"""
TCS BaNCS RestFul API Documentation - MCP Tools
Generated from swagger_2_0 specification
Version: 1.0

Please find the list of API available in TCS BaNCS

Generated at: 2025-06-08T13:34:20.269231
"""

import os
import httpx
import logging
from fastmcp import FastMCP
from typing import Any, Dict, Optional



import asyncio
import json
import re

logger = logging.getLogger(__name__)

# API Configuration
BASE_URL = os.getenv("API_BASE_URL", "https://demoapps.tcsbancs.com/Core")
API_KEY = os.getenv("API_KEY")
TIMEOUT = int(os.getenv("API_TIMEOUT", "30"))




async def make_api_request(
    method: str,
    path: str,
    params: Optional[Dict[str, Any]] = None,
    data: Optional[Dict[str, Any]] = None,
    headers: Optional[Dict[str, str]] = None
) -> Dict[str, Any]:
    """Make authenticated request to API."""
    url = f"{BASE_URL.rstrip('/')}{path}"
    
    
    request_headers = {
        "Content-Type": "application/json",
        "Accept": "application/json"
    }
    
    
    if headers:
        request_headers.update(headers)
    
    async with httpx.AsyncClient(timeout=TIMEOUT) as client:
        try:
            logger.debug(f"API {method} {url}")
            logger.debug(f"Headers: {request_headers}")
            logger.debug(f"Params: {params}")
            logger.debug(f"Data: {data}")
            
            response = await client.request(
                method=method.upper(),
                url=url,
                params=params,
                json=data if data else None,
                headers=request_headers
            )
            
            response.raise_for_status()
            
            # Handle different response types
            content_type = response.headers.get("content-type", "").lower()
            if "application/json" in content_type:
                return response.json()
            else:
                return {"data": response.text, "content_type": content_type}
                
        except httpx.HTTPStatusError as e:
            logger.error(f"API error {e.response.status_code}: {e.response.text}")
            error_detail = {
                "error": True,
                "status_code": e.response.status_code,
                "method": method,
                "url": url,
                "message": "Unknown error"
            }
            
            try:
                error_data = e.response.json()
                error_detail["error_details"] = error_data
                error_detail["message"] = error_data.get("message", error_data.get("error", str(error_data)))
            except:
                error_detail["message"] = e.response.text or str(e)
            
            # Add request details for debugging
            if logger.isEnabledFor(logging.DEBUG):
                error_detail["request"] = {
                    "headers": dict(request_headers),
                    "params": params,
                    "data": data
                }
            
            return error_detail
        except Exception as e:
            logger.error(f"API request failed: {str(e)}")
            return {
                "error": True,
                "message": str(e)
            }


def sanitize_param_name(name: str) -> str:
    """Convert parameter name to Python-friendly format."""
    # Replace spaces and hyphens with underscores
    name = name.replace(' ', '_').replace('-', '_')
    # Convert to lowercase
    name = name.lower()
    # Remove any other special characters
    name = re.sub(r'[^a-z0-9_]', '', name)
    # Ensure it doesn't start with a number
    if name and name[0].isdigit():
        name = f'param_{name}'
    return name


def register_bancs_tools(mcp: FastMCP):
    """Register all API tools with FastMCP server."""
    
    
    
    @mcp.tool()
    async def ambt2020_create_acnt_actv_using_post(
        request_body:Dict[str, Any] ,  # createAccountResource,
        accesstoken: Optional[str] = None,
        channeltype: Optional[int] = None,
        co_relationid: Optional[int] = None,
        initiatingsystem: Optional[str] = None,
        servicemode: Optional[int] = None,
        uuidseqno: Optional[int] = None,
        entity: Optional[str] = None,
        languagecode: Optional[int] = None,
        mu_id: Optional[str] = None,
        referenceid: Optional[str] = None,
        requesthash: Optional[str] = None,
        userid: Optional[int] = None
    ) -> Dict[str, Any]:
        """
        Create Account
        
        Generated from: POST /accountManagement/account
        Source: swagger_2_0
        Operation ID: AMBT2020CreateAcntActvUsingPOST
        
        
        Authentication: Not required
        
        Parameters:
        - request_body: any (required)
          input
        
        
        
        Headers:
        - Accesstoken: string
          Authorization token for identification of the caller
        - ChannelType: integer
          Channel identifier from where the TXN has originated (Internet, Mobile, ATM, Branch Channel )
        - Co-Relationid: integer
          Unique ID for the service invoked, will be set by the TXN system
        - InitiatingSystem: string
          Indicating the initiated system
        - ServiceMode: integer
          Used for branch channel to indicate the type of customer
        - UUIDSeqNo: integer
          UUID Sequence Number
        - entity: string
          entity
        - languageCode: integer
          languageCode
        - mu_id: string
          mu_id
        - referenceId: string
          Place holder for Token based authentication
        - requesthash: string
          Request payload for hash validation
        - userId: integer
          userId
        
        
        """
        
        
        # Prepare request data
        
        # Single body parameter - send directly
        data = request_body if request_body is not None else {}
        
        
        
        # Prepare query parameters
        params = {}
        
        
        # Replace path parameters in URL
        path = "/accountManagement/account"
        
        
        # Prepare headers
        headers = {}
        if accesstoken is not None:
            headers["Accesstoken"] = str(accesstoken)
        if channeltype is not None:
            headers["ChannelType"] = str(channeltype)
        if co_relationid is not None:
            headers["Co-Relationid"] = str(co_relationid)
        if initiatingsystem is not None:
            headers["InitiatingSystem"] = str(initiatingsystem)
        if servicemode is not None:
            headers["ServiceMode"] = str(servicemode)
        if uuidseqno is not None:
            headers["UUIDSeqNo"] = str(uuidseqno)
        if entity is not None:
            headers["entity"] = str(entity)
        if languagecode is not None:
            headers["languageCode"] = str(languagecode)
        if mu_id is not None:
            headers["mu_id"] = str(mu_id)
        if referenceid is not None:
            headers["referenceId"] = str(referenceid)
        if requesthash is not None:
            headers["requesthash"] = str(requesthash)
        if userid is not None:
            headers["userId"] = str(userid)
        
        
        return await make_api_request(
            "POST", 
            path, 
            data=data, 
            params=params if params else None, 
            headers=headers if headers else None
        )
    
    
    
    @mcp.tool()
    async def cbcet0101_fetch_cust_acnts_using_get(
        customerid: Optional[int] = None,
        identifiertype: Optional[int] = None,
        identifiervalue: Optional[str] = None,
        pagenum: Optional[int] = None,
        pagesize: Optional[int] = None,
        accesstoken: Optional[str] = None,
        channeltype: Optional[int] = None,
        co_relationid: Optional[int] = None,
        initiatingsystem: Optional[str] = None,
        servicemode: Optional[int] = None,
        uuidseqno: Optional[int] = None,
        entity: Optional[str] = None,
        languagecode: Optional[int] = None,
        referenceid: Optional[str] = None,
        userid: Optional[int] = None
    ) -> Dict[str, Any]:
        """
        List of Customer Accounts
        
        Generated from: GET /accountManagement/account/CASABalanceList
        Source: swagger_2_0
        Operation ID: CBCET0101FetchCustAcntsUsingGET
        
        
        Authentication: Not required
        
        Parameters:
        - CustomerID: integer
          Customer ID
        - IdentifierType: integer
          Identifier Type
        - IdentifierValue: string
          Identifier Value
        - pageNum: integer
          pageNum
        - pageSize: integer
          pageSize
        
        
        
        Headers:
        - Accesstoken: string
          Authorization token for identification of the caller
        - ChannelType: integer
          Channel identifier from where the TXN has originated (Internet, Mobile, ATM, Branch Channel )
        - Co-Relationid: integer
          Unique ID for the service invoked, will be set by the TXN system
        - InitiatingSystem: string
          Indicating the initiated system
        - ServiceMode: integer
          Used for branch channel to indicate the type of customer
        - UUIDSeqNo: integer
          UUID Sequence Number
        - entity: string
          entity
        - languageCode: integer
          languageCode
        - referenceId: string
          Place holder for Token based authentication
        - userId: integer
          userId
        
        
        """
        
        
        # Prepare query parameters
        params = {}
        if customerid is not None:
            params["CustomerID"] = customerid
            
        if identifiertype is not None:
            params["IdentifierType"] = identifiertype
            
        if identifiervalue is not None:
            params["IdentifierValue"] = identifiervalue
            
        if pagenum is not None:
            params["pageNum"] = pagenum
            
        if pagesize is not None:
            params["pageSize"] = pagesize
            
        
        
        # Replace path parameters in URL
        path = "/accountManagement/account/CASABalanceList"
        
        
        # Prepare headers
        headers = {}
        if accesstoken is not None:
            headers["Accesstoken"] = str(accesstoken)
        if channeltype is not None:
            headers["ChannelType"] = str(channeltype)
        if co_relationid is not None:
            headers["Co-Relationid"] = str(co_relationid)
        if initiatingsystem is not None:
            headers["InitiatingSystem"] = str(initiatingsystem)
        if servicemode is not None:
            headers["ServiceMode"] = str(servicemode)
        if uuidseqno is not None:
            headers["UUIDSeqNo"] = str(uuidseqno)
        if entity is not None:
            headers["entity"] = str(entity)
        if languagecode is not None:
            headers["languageCode"] = str(languagecode)
        if referenceid is not None:
            headers["referenceId"] = str(referenceid)
        if userid is not None:
            headers["userId"] = str(userid)
        
        
        return await make_api_request(
            "GET", 
            path, 
            
            params=params if params else None, 
            headers=headers if headers else None
        )
    
    
    
    @mcp.tool()
    async def amet8290_acnt_bal_statmnt_using_get(
        accountreference: str,
        balancetype: int,
        fromdate: str,
        todate: str,
        closingbalance: Optional[float] = None,
        debitcreditflag: Optional[int] = None,
        fromamount: Optional[float] = None,
        movementamount: Optional[float] = None,
        movementdescription: Optional[str] = None,
        openingbalance: Optional[float] = None,
        pagenum: Optional[int] = None,
        pagesize: Optional[int] = None,
        toamount: Optional[float] = None,
        transactionid: Optional[str] = None,
        transactionpostype: Optional[int] = None,
        transactionsubtype: Optional[int] = None,
        transactiontype: Optional[int] = None,
        accesstoken: Optional[str] = None,
        channeltype: Optional[int] = None,
        co_relationid: Optional[int] = None,
        initiatingsystem: Optional[str] = None,
        servicemode: Optional[int] = None,
        uuidseqno: Optional[int] = None,
        entity: Optional[str] = None,
        languagecode: Optional[int] = None,
        referenceid: Optional[str] = None,
        userid: Optional[int] = None
    ) -> Dict[str, Any]:
        """
        This service fetches CASA Account Transactions
        
        Generated from: GET /accountManagement/account/CASATransactions/{accountReference}
        Source: swagger_2_0
        Operation ID: AMET8290AcntBalStatmntUsingGET
        
        
        Authentication: Not required
        
        Parameters:
        - accountReference: string (required)
          Enter the CASA account reference number
        - balanceType: integer (required)
          BalanceType -  Indicates Type of Balance. 1-Value Date, 2-Transaction Date, 3-Accounting Date
        - closingBalance: number
          Closing Balance(This field is used in case of pagination to pass last record balance)
        - debitCreditFlag: integer
          Debit Credit Flag Indicator 1-> Credit, 2-> Debit (This field is used in case of pagination.)
        - fromAmount: number
          From Amount
        - fromDate: string (required)
          Date from which Statement has to be generated (Date format : YYYYMMDD)
        - movementAmount: number
          Movement Amount (This field is used in case of pagination to pass first/last record Debit/Credit Amount)
        - movementDescription: string
          Movement Description
        - openingBalance: number
          Opening Balance(This field is used in case of pagination to pass first record balance)
        - pageNum: integer
          pageNum
        - pageSize: integer
          pageSize
        - toAmount: number
          To Amount
        - toDate: string (required)
          Date till which Statement has to be generated (Date format : YYYYMMDD)
        - transactionId: string
          Transaction Id
        - transactionPosType: integer
          Transaction Pos Type (Domain name : d_PosTyp , CD value : 5290000, Example Value : 126 - AME, 316 - Cash Block)
        - transactionSubType: integer
          Transaction Sub Type
        - transactionType: integer
          TransactionType - Indicates the type of transcation done. 1-Credit, 2-Debit
        
        
        
        Headers:
        - Accesstoken: string
          Authorization token for identification of the caller
        - ChannelType: integer
          Channel identifier from where the TXN has originated (Internet, Mobile, ATM, Branch Channel )
        - Co-Relationid: integer
          Unique ID for the service invoked, will be set by the TXN system
        - InitiatingSystem: string
          Indicating the initiated system
        - ServiceMode: integer
          Used for branch channel to indicate the type of customer
        - UUIDSeqNo: integer
          UUID Sequence Number
        - entity: string
          entity
        - languageCode: integer
          languageCode
        - referenceId: string
          Place holder for Token based authentication
        - userId: integer
          userId
        
        
        """
        
        
        # Prepare query parameters
        params = {}
        if balancetype is not None:
            params["balanceType"] = balancetype
            
        if closingbalance is not None:
            params["closingBalance"] = closingbalance
            
        if debitcreditflag is not None:
            params["debitCreditFlag"] = debitcreditflag
            
        if fromamount is not None:
            params["fromAmount"] = fromamount
            
        if fromdate is not None:
            params["fromDate"] = fromdate
            
        if movementamount is not None:
            params["movementAmount"] = movementamount
            
        if movementdescription is not None:
            params["movementDescription"] = movementdescription
            
        if openingbalance is not None:
            params["openingBalance"] = openingbalance
            
        if pagenum is not None:
            params["pageNum"] = pagenum
            
        if pagesize is not None:
            params["pageSize"] = pagesize
            
        if toamount is not None:
            params["toAmount"] = toamount
            
        if todate is not None:
            params["toDate"] = todate
            
        if transactionid is not None:
            params["transactionId"] = transactionid
            
        if transactionpostype is not None:
            params["transactionPosType"] = transactionpostype
            
        if transactionsubtype is not None:
            params["transactionSubType"] = transactionsubtype
            
        if transactiontype is not None:
            params["transactionType"] = transactiontype
            
        
        
        # Replace path parameters in URL
        path = "/accountManagement/account/CASATransactions/{accountReference}"
        if accountreference is not None:
            path = path.replace("{accountReference}", str(accountreference))
        
        
        # Prepare headers
        headers = {}
        if accesstoken is not None:
            headers["Accesstoken"] = str(accesstoken)
        if channeltype is not None:
            headers["ChannelType"] = str(channeltype)
        if co_relationid is not None:
            headers["Co-Relationid"] = str(co_relationid)
        if initiatingsystem is not None:
            headers["InitiatingSystem"] = str(initiatingsystem)
        if servicemode is not None:
            headers["ServiceMode"] = str(servicemode)
        if uuidseqno is not None:
            headers["UUIDSeqNo"] = str(uuidseqno)
        if entity is not None:
            headers["entity"] = str(entity)
        if languagecode is not None:
            headers["languageCode"] = str(languagecode)
        if referenceid is not None:
            headers["referenceId"] = str(referenceid)
        if userid is not None:
            headers["userId"] = str(userid)
        
        
        return await make_api_request(
            "GET", 
            path, 
            
            params=params if params else None, 
            headers=headers if headers else None
        )
    
    
    
    @mcp.tool()
    async def amet2021_acnts_bal_statmnt_postusing_post(
        request_body:Dict[str, Any] ,  # accntBalanceStatementResource,
        entity: Optional[str] = None,
        languagecode: Optional[int] = None,
        userid: Optional[int] = None
    ) -> Dict[str, Any]:
        """
        This service used to Fetch Account Balance Statement for multiple accounts
        
        Generated from: POST /accountManagement/account/accountBalanceStatement
        Source: swagger_2_0
        Operation ID: AMET2021AcntsBalStatmnt_POSTUsingPOST
        
        
        Authentication: Not required
        
        Parameters:
        - request_body: any (required)
          input
        
        
        
        Headers:
        - entity: string
          entity
        - languageCode: integer
          languageCode
        - userId: integer
          userId
        
        
        """
        
        
        # Prepare request data
        
        # Single body parameter - send directly
        data = request_body if request_body is not None else {}
        
        
        
        # Prepare query parameters
        params = {}
        
        
        # Replace path parameters in URL
        path = "/accountManagement/account/accountBalanceStatement"
        
        
        # Prepare headers
        headers = {}
        if entity is not None:
            headers["entity"] = str(entity)
        if languagecode is not None:
            headers["languageCode"] = str(languagecode)
        if userid is not None:
            headers["userId"] = str(userid)
        
        
        return await make_api_request(
            "POST", 
            path, 
            data=data, 
            params=params if params else None, 
            headers=headers if headers else None
        )
    
    
    
    @mcp.tool()
    async def ametget_account_count_entrprc_chl_using_get(
        accesstoken: Optional[str] = None,
        channeltype: Optional[int] = None,
        co_relationid: Optional[int] = None,
        initiatingsystem: Optional[str] = None,
        servicemode: Optional[int] = None,
        uuidseqno: Optional[int] = None,
        entity: Optional[str] = None,
        languagecode: Optional[int] = None,
        referenceid: Optional[str] = None,
        userid: Optional[int] = None
    ) -> Dict[str, Any]:
        """
        Fetch Account Count
        
        Generated from: GET /accountManagement/account/accountCount
        Source: swagger_2_0
        Operation ID: AMETGetAccountCountEntrprcChlUsingGET
        
        
        Authentication: Not required
        
        Parameters:
        
        
        
        Headers:
        - Accesstoken: string
          Authorization token for identification of the caller
        - ChannelType: integer
          Channel identifier from where the TXN has originated (Internet, Mobile, ATM, Branch Channel )
        - Co-Relationid: integer
          Unique ID for the service invoked, will be set by the TXN system
        - InitiatingSystem: string
          Indicating the initiated system
        - ServiceMode: integer
          Used for branch channel to indicate the type of customer
        - UUIDSeqNo: integer
          UUID Sequence Number
        - entity: string
          entity
        - languageCode: integer
          languageCode
        - referenceId: string
          Place holder for Token based authentication
        - userId: integer
          userId
        
        
        """
        
        
        # Prepare query parameters
        params = {}
        
        
        # Replace path parameters in URL
        path = "/accountManagement/account/accountCount"
        
        
        # Prepare headers
        headers = {}
        if accesstoken is not None:
            headers["Accesstoken"] = str(accesstoken)
        if channeltype is not None:
            headers["ChannelType"] = str(channeltype)
        if co_relationid is not None:
            headers["Co-Relationid"] = str(co_relationid)
        if initiatingsystem is not None:
            headers["InitiatingSystem"] = str(initiatingsystem)
        if servicemode is not None:
            headers["ServiceMode"] = str(servicemode)
        if uuidseqno is not None:
            headers["UUIDSeqNo"] = str(uuidseqno)
        if entity is not None:
            headers["entity"] = str(entity)
        if languagecode is not None:
            headers["languageCode"] = str(languagecode)
        if referenceid is not None:
            headers["referenceId"] = str(referenceid)
        if userid is not None:
            headers["userId"] = str(userid)
        
        
        return await make_api_request(
            "GET", 
            path, 
            
            params=params if params else None, 
            headers=headers if headers else None
        )
    
    
    
    @mcp.tool()
    async def amet0519_fetch_acnt_dtls_using_get(
        groupid: str,
        currency: Optional[str] = None,
        cusref: Optional[int] = None,
        accountreference: Optional[str] = None,
        extensibilitymap: Optional[str] = None,
        pagenum: Optional[int] = None,
        pagesize: Optional[int] = None,
        accesstoken: Optional[str] = None,
        channeltype: Optional[int] = None,
        co_relationid: Optional[int] = None,
        initiatingsystem: Optional[str] = None,
        servicemode: Optional[int] = None,
        uuidseqno: Optional[int] = None,
        entity: Optional[str] = None,
        languagecode: Optional[int] = None,
        referenceid: Optional[str] = None,
        userid: Optional[int] = None
    ) -> Dict[str, Any]:
        """
        API to fetch Account Number Based on GroupID
        
        Generated from: GET /accountManagement/account/accountDetailsForGroupID
        Source: swagger_2_0
        Operation ID: AMET0519FetchAcntDtlsUsingGET
        
        
        Authentication: Not required
        
        Parameters:
        - Currency: string
          This field is to enter Currency
        - CusRef: integer
          This field is to enter CusRef
        - GroupID: string (required)
          This field is to fetch GroupID
        - accountReference: string
          Account Reference of the Customer
        - extensibilityMap: string
          Custom key - value pair of attributes for extensibility enablement
        - pageNum: integer
          pageNum
        - pageSize: integer
          pageSize
        
        
        
        Headers:
        - Accesstoken: string
          Authorization token for identification of the caller
        - ChannelType: integer
          Channel identifier from where the TXN has originated (Internet, Mobile, ATM, Branch Channel )
        - Co-Relationid: integer
          Unique ID for the service invoked, will be set by the TXN system
        - InitiatingSystem: string
          Indicating the initiated system
        - ServiceMode: integer
          Used for branch channel to indicate the type of customer
        - UUIDSeqNo: integer
          UUID Sequence Number
        - entity: string
          entity
        - languageCode: integer
          languageCode
        - referenceId: string
          Place holder for Token based authentication
        - userId: integer
          userId
        
        
        """
        
        
        # Prepare query parameters
        params = {}
        if currency is not None:
            params["Currency"] = currency
            
        if cusref is not None:
            params["CusRef"] = cusref
            
        if groupid is not None:
            params["GroupID"] = groupid
            
        if accountreference is not None:
            params["accountReference"] = accountreference
            
        if extensibilitymap is not None:
            params["extensibilityMap"] = extensibilitymap
            
        if pagenum is not None:
            params["pageNum"] = pagenum
            
        if pagesize is not None:
            params["pageSize"] = pagesize
            
        
        
        # Replace path parameters in URL
        path = "/accountManagement/account/accountDetailsForGroupID"
        
        
        # Prepare headers
        headers = {}
        if accesstoken is not None:
            headers["Accesstoken"] = str(accesstoken)
        if channeltype is not None:
            headers["ChannelType"] = str(channeltype)
        if co_relationid is not None:
            headers["Co-Relationid"] = str(co_relationid)
        if initiatingsystem is not None:
            headers["InitiatingSystem"] = str(initiatingsystem)
        if servicemode is not None:
            headers["ServiceMode"] = str(servicemode)
        if uuidseqno is not None:
            headers["UUIDSeqNo"] = str(uuidseqno)
        if entity is not None:
            headers["entity"] = str(entity)
        if languagecode is not None:
            headers["languageCode"] = str(languagecode)
        if referenceid is not None:
            headers["referenceId"] = str(referenceid)
        if userid is not None:
            headers["userId"] = str(userid)
        
        
        return await make_api_request(
            "GET", 
            path, 
            
            params=params if params else None, 
            headers=headers if headers else None
        )
    
    
    
    @mcp.tool()
    async def amet2020_get_acnt_details_wrapper_using_get(
        accountreference: str,
        extensibilitymap: Optional[str] = None,
        pagenum: Optional[int] = None,
        pagesize: Optional[int] = None,
        accesstoken: Optional[str] = None,
        channeltype: Optional[int] = None,
        co_relationid: Optional[int] = None,
        initiatingsystem: Optional[str] = None,
        servicemode: Optional[int] = None,
        uuidseqno: Optional[int] = None,
        entity: Optional[str] = None,
        languagecode: Optional[int] = None,
        referenceid: Optional[str] = None,
        userid: Optional[int] = None
    ) -> Dict[str, Any]:
        """
        API to fetch Account Details with Address
        
        Generated from: GET /accountManagement/account/accountDetailsWithAddress/{accountReference}
        Source: swagger_2_0
        Operation ID: AMET2020GetAcntDetails_wrapperUsingGET
        
        
        Authentication: Not required
        
        Parameters:
        - accountReference: string (required)
          Account Reference of the Customer
        - extensibilityMap: string
          Custom key - value pair of attributes for extensibility enablement
        - pageNum: integer
          pageNum
        - pageSize: integer
          pageSize
        
        
        
        Headers:
        - Accesstoken: string
          Authorization token for identification of the caller
        - ChannelType: integer
          Channel identifier from where the TXN has originated (Internet, Mobile, ATM or Branch Channel )
        - Co-Relationid: integer
          Unique ID for the service invoked, will be set by the TXN system
        - InitiatingSystem: string
          Indicating the initiated system
        - ServiceMode: integer
          Used for branch channel to indicate the type of customer
        - UUIDSeqNo: integer
          UUID Sequence Number
        - entity: string
          entity
        - languageCode: integer
          languageCode
        - referenceId: string
          Place holder for Token based authentication
        - userId: integer
          userId
        
        
        """
        
        
        # Prepare query parameters
        params = {}
        if extensibilitymap is not None:
            params["extensibilityMap"] = extensibilitymap
            
        if pagenum is not None:
            params["pageNum"] = pagenum
            
        if pagesize is not None:
            params["pageSize"] = pagesize
            
        
        
        # Replace path parameters in URL
        path = "/accountManagement/account/accountDetailsWithAddress/{accountReference}"
        if accountreference is not None:
            path = path.replace("{accountReference}", str(accountreference))
        
        
        # Prepare headers
        headers = {}
        if accesstoken is not None:
            headers["Accesstoken"] = str(accesstoken)
        if channeltype is not None:
            headers["ChannelType"] = str(channeltype)
        if co_relationid is not None:
            headers["Co-Relationid"] = str(co_relationid)
        if initiatingsystem is not None:
            headers["InitiatingSystem"] = str(initiatingsystem)
        if servicemode is not None:
            headers["ServiceMode"] = str(servicemode)
        if uuidseqno is not None:
            headers["UUIDSeqNo"] = str(uuidseqno)
        if entity is not None:
            headers["entity"] = str(entity)
        if languagecode is not None:
            headers["languageCode"] = str(languagecode)
        if referenceid is not None:
            headers["referenceId"] = str(referenceid)
        if userid is not None:
            headers["userId"] = str(userid)
        
        
        return await make_api_request(
            "GET", 
            path, 
            
            params=params if params else None, 
            headers=headers if headers else None
        )
    
    
    
    @mcp.tool()
    async def cbpetget_account_balance_using_get(
        accountreference: str,
        accesstoken: Optional[str] = None,
        channeltype: Optional[int] = None,
        co_relationid: Optional[int] = None,
        initiatingsystem: Optional[str] = None,
        servicemode: Optional[int] = None,
        uuidseqno: Optional[int] = None,
        entity: Optional[str] = None,
        languagecode: Optional[int] = None,
        referenceid: Optional[str] = None,
        userid: Optional[int] = None
    ) -> Dict[str, Any]:
        """
        Fetch Account Balance Details
        
        Generated from: GET /accountManagement/account/balanceDetails/{accountReference}
        Source: swagger_2_0
        Operation ID: CBPETGetAccountBalanceUsingGET
        
        
        Authentication: Not required
        
        Parameters:
        - accountReference: string (required)
          Enter the Account Reference
        
        
        
        Headers:
        - Accesstoken: string
          Authorization token for identification of the caller
        - ChannelType: integer
          Channel identifier from where the TXN has originated (Internet, Mobile, ATM, Branch Channel )
        - Co-Relationid: integer
          Unique ID for the service invoked, will be set by the TXN system
        - InitiatingSystem: string
          Indicating the initiated system
        - ServiceMode: integer
          Used for branch channel to indicate the type of customer
        - UUIDSeqNo: integer
          UUID Sequence Number
        - entity: string
          entity
        - languageCode: integer
          languageCode
        - referenceId: string
          Place holder for Token based authentication
        - userId: integer
          userId
        
        
        """
        
        
        # Prepare query parameters
        params = {}
        
        
        # Replace path parameters in URL
        path = "/accountManagement/account/balanceDetails/{accountReference}"
        if accountreference is not None:
            path = path.replace("{accountReference}", str(accountreference))
        
        
        # Prepare headers
        headers = {}
        if accesstoken is not None:
            headers["Accesstoken"] = str(accesstoken)
        if channeltype is not None:
            headers["ChannelType"] = str(channeltype)
        if co_relationid is not None:
            headers["Co-Relationid"] = str(co_relationid)
        if initiatingsystem is not None:
            headers["InitiatingSystem"] = str(initiatingsystem)
        if servicemode is not None:
            headers["ServiceMode"] = str(servicemode)
        if uuidseqno is not None:
            headers["UUIDSeqNo"] = str(uuidseqno)
        if entity is not None:
            headers["entity"] = str(entity)
        if languagecode is not None:
            headers["languageCode"] = str(languagecode)
        if referenceid is not None:
            headers["referenceId"] = str(referenceid)
        if userid is not None:
            headers["userId"] = str(userid)
        
        
        return await make_api_request(
            "GET", 
            path, 
            
            params=params if params else None, 
            headers=headers if headers else None
        )
    
    
    
    @mcp.tool()
    async def amet0395_get_acnt_usr_blncs_using_get(
        customerid: int,
        accountcurrency: Optional[str] = None,
        accountreference: Optional[str] = None,
        activecheck: Optional[int] = None,
        groupid: Optional[str] = None,
        balanceondate: Optional[str] = None,
        extensibilitymap: Optional[str] = None,
        pagenum: Optional[int] = None,
        pagesize: Optional[int] = None,
        accesstoken: Optional[str] = None,
        channeltype: Optional[int] = None,
        co_relationid: Optional[int] = None,
        initiatingsystem: Optional[str] = None,
        servicemode: Optional[int] = None,
        uuidseqno: Optional[int] = None,
        entity: Optional[str] = None,
        languagecode: Optional[int] = None,
        referenceid: Optional[str] = None,
        userid: Optional[int] = None
    ) -> Dict[str, Any]:
        """
        Fetch Account Balance List
        
        Generated from: GET /accountManagement/account/balanceList
        Source: swagger_2_0
        Operation ID: AMET0395GetAcntUsrBlncsUsingGET
        
        
        Authentication: Not required
        
        Parameters:
        - AccountCurrency: string
          Account Currency (Domain Name: d_CurrCode / 3 character ISO currency code) Eg : MXN, EUR, USD, INR
        - AccountReference: string
          Account Reference Provided to Customer
        - ActiveCheck: integer
          Flag to check status of Account
        - CustomerID: integer (required)
          Customer ID
        - GroupID: string
          This Field is for GroupID
        - balanceOnDate: string
          Date upto which current balance needs to be checked
        - extensibilityMap: string
          Custom key - value pair of attributes for extensibility enablement
        - pageNum: integer
          pageNum
        - pageSize: integer
          pageSize
        
        
        
        Headers:
        - Accesstoken: string
          Authorization token for identification of the caller
        - ChannelType: integer
          Channel identifier from where the TXN has originated (Internet, Mobile, ATM, Branch Channel )
        - Co-Relationid: integer
          Unique ID for the service invoked, will be set by the TXN system
        - InitiatingSystem: string
          Indicating the initiated system
        - ServiceMode: integer
          Used for branch channel to indicate the type of customer
        - UUIDSeqNo: integer
          UUID Sequence Number
        - entity: string
          entity
        - languageCode: integer
          languageCode
        - referenceId: string
          Place holder for Token based authentication
        - userId: integer
          userId
        
        
        """
        
        
        # Prepare query parameters
        params = {}
        if accountcurrency is not None:
            params["AccountCurrency"] = accountcurrency
            
        if accountreference is not None:
            params["AccountReference"] = accountreference
            
        if activecheck is not None:
            params["ActiveCheck"] = activecheck
            
        if customerid is not None:
            params["CustomerID"] = customerid
            
        if groupid is not None:
            params["GroupID"] = groupid
            
        if balanceondate is not None:
            params["balanceOnDate"] = balanceondate
            
        if extensibilitymap is not None:
            params["extensibilityMap"] = extensibilitymap
            
        if pagenum is not None:
            params["pageNum"] = pagenum
            
        if pagesize is not None:
            params["pageSize"] = pagesize
            
        
        
        # Replace path parameters in URL
        path = "/accountManagement/account/balanceList"
        
        
        # Prepare headers
        headers = {}
        if accesstoken is not None:
            headers["Accesstoken"] = str(accesstoken)
        if channeltype is not None:
            headers["ChannelType"] = str(channeltype)
        if co_relationid is not None:
            headers["Co-Relationid"] = str(co_relationid)
        if initiatingsystem is not None:
            headers["InitiatingSystem"] = str(initiatingsystem)
        if servicemode is not None:
            headers["ServiceMode"] = str(servicemode)
        if uuidseqno is not None:
            headers["UUIDSeqNo"] = str(uuidseqno)
        if entity is not None:
            headers["entity"] = str(entity)
        if languagecode is not None:
            headers["languageCode"] = str(languagecode)
        if referenceid is not None:
            headers["referenceId"] = str(referenceid)
        if userid is not None:
            headers["userId"] = str(userid)
        
        
        return await make_api_request(
            "GET", 
            path, 
            
            params=params if params else None, 
            headers=headers if headers else None
        )
    
    
    
    @mcp.tool()
    async def amet0117_ftch_blck_lst_using_get(
        accountreference: str,
        pagenum: Optional[int] = None,
        pagesize: Optional[int] = None,
        accesstoken: Optional[str] = None,
        channeltype: Optional[int] = None,
        co_relationid: Optional[int] = None,
        initiatingsystem: Optional[str] = None,
        servicemode: Optional[int] = None,
        uuidseqno: Optional[int] = None,
        entity: Optional[str] = None,
        languagecode: Optional[int] = None,
        referenceid: Optional[str] = None,
        userid: Optional[int] = None
    ) -> Dict[str, Any]:
        """
        Fetch Account Block List
        
        Generated from: GET /accountManagement/account/blockList/{accountReference}
        Source: swagger_2_0
        Operation ID: AMET0117FtchBlckLstUsingGET
        
        
        Authentication: Not required
        
        Parameters:
        - accountReference: string (required)
          Enter the Account Reference
        - pageNum: integer
          pageNum
        - pageSize: integer
          pageSize
        
        
        
        Headers:
        - Accesstoken: string
          Authorization token for identification of the caller
        - ChannelType: integer
          Channel identifier from where the TXN has originated (Internet, Mobile, ATM, Branch Channel )
        - Co-Relationid: integer
          Unique ID for the service invoked, will be set by the TXN system
        - InitiatingSystem: string
          Indicating the initiated system
        - ServiceMode: integer
          Used for branch channel to indicate the type of customer
        - UUIDSeqNo: integer
          UUID Sequence Number
        - entity: string
          entity
        - languageCode: integer
          languageCode
        - referenceId: string
          Place holder for Token based authentication
        - userId: integer
          userId
        
        
        """
        
        
        # Prepare query parameters
        params = {}
        if pagenum is not None:
            params["pageNum"] = pagenum
            
        if pagesize is not None:
            params["pageSize"] = pagesize
            
        
        
        # Replace path parameters in URL
        path = "/accountManagement/account/blockList/{accountReference}"
        if accountreference is not None:
            path = path.replace("{accountReference}", str(accountreference))
        
        
        # Prepare headers
        headers = {}
        if accesstoken is not None:
            headers["Accesstoken"] = str(accesstoken)
        if channeltype is not None:
            headers["ChannelType"] = str(channeltype)
        if co_relationid is not None:
            headers["Co-Relationid"] = str(co_relationid)
        if initiatingsystem is not None:
            headers["InitiatingSystem"] = str(initiatingsystem)
        if servicemode is not None:
            headers["ServiceMode"] = str(servicemode)
        if uuidseqno is not None:
            headers["UUIDSeqNo"] = str(uuidseqno)
        if entity is not None:
            headers["entity"] = str(entity)
        if languagecode is not None:
            headers["languageCode"] = str(languagecode)
        if referenceid is not None:
            headers["referenceId"] = str(referenceid)
        if userid is not None:
            headers["userId"] = str(userid)
        
        
        return await make_api_request(
            "GET", 
            path, 
            
            params=params if params else None, 
            headers=headers if headers else None
        )
    
    
    
    @mcp.tool()
    async def ambtcrt_cash_block_wrapper_using_post(
        request_body:Dict[str, Any] ,  # createCashBlockResource,
        accesstoken: Optional[str] = None,
        channeltype: Optional[int] = None,
        co_relationid: Optional[int] = None,
        initiatingsystem: Optional[str] = None,
        servicemode: Optional[int] = None,
        uuidseqno: Optional[str] = None,
        entity: Optional[str] = None,
        languagecode: Optional[int] = None,
        referenceid: Optional[str] = None,
        requesthash: Optional[str] = None,
        userid: Optional[int] = None
    ) -> Dict[str, Any]:
        """
        Create Cash Block
        
        Generated from: POST /accountManagement/account/cashBlock
        Source: swagger_2_0
        Operation ID: AMBTCrtCashBlockWrapperUsingPOST
        
        
        Authentication: Not required
        
        Parameters:
        - request_body: any (required)
          input
        
        
        
        Headers:
        - Accesstoken: string
          Authorization token for identification of the caller
        - ChannelType: integer
          Channel identifier from where the TXN has originated (Internet, Mobile, ATM, Branch Channel )
        - Co-Relationid: integer
          Unique ID for the service invoked, will be set by the TXN system
        - InitiatingSystem: string
          Indicating the initiated system
        - ServiceMode: integer
          Used for branch channel to indicate the type of customer
        - UUIDSeqNo: string
          UUID Sequence Number
        - entity: string
          entity
        - languageCode: integer
          languageCode
        - referenceId: string
          Place holder for Token based authentication
        - requesthash: string
          Request payload for hash validation
        - userId: integer
          userId
        
        
        """
        
        
        # Prepare request data
        
        # Single body parameter - send directly
        data = request_body if request_body is not None else {}
        
        
        
        # Prepare query parameters
        params = {}
        
        
        # Replace path parameters in URL
        path = "/accountManagement/account/cashBlock"
        
        
        # Prepare headers
        headers = {}
        if accesstoken is not None:
            headers["Accesstoken"] = str(accesstoken)
        if channeltype is not None:
            headers["ChannelType"] = str(channeltype)
        if co_relationid is not None:
            headers["Co-Relationid"] = str(co_relationid)
        if initiatingsystem is not None:
            headers["InitiatingSystem"] = str(initiatingsystem)
        if servicemode is not None:
            headers["ServiceMode"] = str(servicemode)
        if uuidseqno is not None:
            headers["UUIDSeqNo"] = str(uuidseqno)
        if entity is not None:
            headers["entity"] = str(entity)
        if languagecode is not None:
            headers["languageCode"] = str(languagecode)
        if referenceid is not None:
            headers["referenceId"] = str(referenceid)
        if requesthash is not None:
            headers["requesthash"] = str(requesthash)
        if userid is not None:
            headers["userId"] = str(userid)
        
        
        return await make_api_request(
            "POST", 
            path, 
            data=data, 
            params=params if params else None, 
            headers=headers if headers else None
        )
    
    
    
    @mcp.tool()
    async def ambtcancel_cash_block_wrapper_using_delete(
        cashblockid: int,
        accesstoken: Optional[str] = None,
        channeltype: Optional[int] = None,
        co_relationid: Optional[int] = None,
        initiatingsystem: Optional[str] = None,
        servicemode: Optional[int] = None,
        uuidseqno: Optional[int] = None,
        entity: Optional[str] = None,
        languagecode: Optional[int] = None,
        referenceid: Optional[str] = None,
        requesthash: Optional[str] = None,
        userid: Optional[int] = None
    ) -> Dict[str, Any]:
        """
        Cancel Cash Block
        
        Generated from: DELETE /accountManagement/account/cashBlock/{cashBlockId}/cancel
        Source: swagger_2_0
        Operation ID: AMBTCancelCashBlockWrapperUsingDELETE
        
        
        Authentication: Not required
        
        Parameters:
        - cashBlockId: integer (required)
          Enter the cash block ID
        
        
        
        Headers:
        - Accesstoken: string
          Authorization token for identification of the caller
        - ChannelType: integer
          Channel identifier from where the TXN has originated (Internet, Mobile, ATM, Branch Channel )
        - Co-Relationid: integer
          Unique ID for the service invoked, will be set by the TXN system
        - InitiatingSystem: string
          Indicating the initiated system
        - ServiceMode: integer
          Used for branch channel to indicate the type of customer
        - UUIDSeqNo: integer
          UUID Sequence Number
        - entity: string
          entity
        - languageCode: integer
          languageCode
        - referenceId: string
          Place holder for Token based authentication
        - requesthash: string
          Request payload for hash validation
        - userId: integer
          userId
        
        
        """
        
        
        # Prepare query parameters
        params = {}
        
        
        # Replace path parameters in URL
        path = "/accountManagement/account/cashBlock/{cashBlockId}/cancel"
        if cashblockid is not None:
            path = path.replace("{cashBlockId}", str(cashblockid))
        
        
        # Prepare headers
        headers = {}
        if accesstoken is not None:
            headers["Accesstoken"] = str(accesstoken)
        if channeltype is not None:
            headers["ChannelType"] = str(channeltype)
        if co_relationid is not None:
            headers["Co-Relationid"] = str(co_relationid)
        if initiatingsystem is not None:
            headers["InitiatingSystem"] = str(initiatingsystem)
        if servicemode is not None:
            headers["ServiceMode"] = str(servicemode)
        if uuidseqno is not None:
            headers["UUIDSeqNo"] = str(uuidseqno)
        if entity is not None:
            headers["entity"] = str(entity)
        if languagecode is not None:
            headers["languageCode"] = str(languagecode)
        if referenceid is not None:
            headers["referenceId"] = str(referenceid)
        if requesthash is not None:
            headers["requesthash"] = str(requesthash)
        if userid is not None:
            headers["userId"] = str(userid)
        
        
        return await make_api_request(
            "DELETE", 
            path, 
            
            params=params if params else None, 
            headers=headers if headers else None
        )
    
    
    
    @mcp.tool()
    async def ambt0119_upd_cash_blck_intf_using_put(
        cashblockid: int,
        request_body:Dict[str, Any] ,  # cashBlocksAmendResource,
        accesstoken: Optional[str] = None,
        channeltype: Optional[int] = None,
        co_relationid: Optional[int] = None,
        initiatingsystem: Optional[str] = None,
        servicemode: Optional[int] = None,
        uuidseqno: Optional[str] = None,
        entity: Optional[str] = None,
        languagecode: Optional[int] = None,
        referenceid: Optional[str] = None,
        requesthash: Optional[str] = None,
        userid: Optional[int] = None
    ) -> Dict[str, Any]:
        """
        Modify of Cash Block
        
        Generated from: PUT /accountManagement/account/cashblocks/{cashBlockId}/update
        Source: swagger_2_0
        Operation ID: AMBT0119UpdCashBlckIntfUsingPUT
        
        
        Authentication: Not required
        
        Parameters:
        - cashBlockId: integer (required)
          cash block reference
        - request_body: any (required)
          input
        
        
        
        Headers:
        - Accesstoken: string
          Authorization token for identification of the caller
        - ChannelType: integer
          Channel identifier from where the TXN has originated (Internet, Mobile, ATM, Branch Channel )
        - Co-Relationid: integer
          Unique ID for the service invoked, will be set by the TXN system
        - InitiatingSystem: string
          Indicating the initiated system
        - ServiceMode: integer
          Used for branch channel to indicate the type of customer
        - UUIDSeqNo: string
          UUID Sequence Number
        - entity: string
          entity
        - languageCode: integer
          languageCode
        - referenceId: string
          Place holder for Token based authentication
        - requesthash: string
          Request payload for hash validation
        - userId: integer
          userId
        
        
        """
        
        
        # Prepare request data
        
        # Single body parameter - send directly
        data = request_body if request_body is not None else {}
        
        
        
        # Prepare query parameters
        params = {}
        
        
        # Replace path parameters in URL
        path = "/accountManagement/account/cashblocks/{cashBlockId}/update"
        if cashblockid is not None:
            path = path.replace("{cashBlockId}", str(cashblockid))
        
        
        # Prepare headers
        headers = {}
        if accesstoken is not None:
            headers["Accesstoken"] = str(accesstoken)
        if channeltype is not None:
            headers["ChannelType"] = str(channeltype)
        if co_relationid is not None:
            headers["Co-Relationid"] = str(co_relationid)
        if initiatingsystem is not None:
            headers["InitiatingSystem"] = str(initiatingsystem)
        if servicemode is not None:
            headers["ServiceMode"] = str(servicemode)
        if uuidseqno is not None:
            headers["UUIDSeqNo"] = str(uuidseqno)
        if entity is not None:
            headers["entity"] = str(entity)
        if languagecode is not None:
            headers["languageCode"] = str(languagecode)
        if referenceid is not None:
            headers["referenceId"] = str(referenceid)
        if requesthash is not None:
            headers["requesthash"] = str(requesthash)
        if userid is not None:
            headers["userId"] = str(userid)
        
        
        return await make_api_request(
            "PUT", 
            path, 
            data=data, 
            params=params if params else None, 
            headers=headers if headers else None
        )
    
    
    
    @mcp.tool()
    async def rstbtcreate_acnt_actv_postusing_post(
        request_body:Dict[str, Any] ,  # accountCreateResource,
        accesstoken: Optional[str] = None,
        channeltype: Optional[int] = None,
        co_relationid: Optional[int] = None,
        initiatingsystem: Optional[str] = None,
        servicemode: Optional[int] = None,
        uuidseqno: Optional[int] = None,
        entity: Optional[str] = None,
        languagecode: Optional[int] = None,
        mu_id: Optional[str] = None,
        referenceid: Optional[str] = None,
        requesthash: Optional[str] = None,
        userid: Optional[int] = None
    ) -> Dict[str, Any]:
        """
        Create Account with details
        
        Generated from: POST /accountManagement/account/create
        Source: swagger_2_0
        Operation ID: RSTBTCreateAcntActv_POSTUsingPOST
        
        
        Authentication: Not required
        
        Parameters:
        - request_body: any (required)
          input
        
        
        
        Headers:
        - Accesstoken: string
          Authorization token for identification of the caller
        - ChannelType: integer
          Channel identifier from where the TXN has originated (Internet, Mobile, ATM, Branch Channel )
        - Co-Relationid: integer
          Unique ID for the service invoked, will be set by the TXN system
        - InitiatingSystem: string
          Indicating the initiated system
        - ServiceMode: integer
          Used for branch channel to indicate the type of customer
        - UUIDSeqNo: integer
          UUID Sequence Number
        - entity: string
          entity
        - languageCode: integer
          languageCode
        - mu_id: string
          mu_id
        - referenceId: string
          Place holder for Token based authentication
        - requesthash: string
          Request payload for hash validation
        - userId: integer
          userId
        
        
        """
        
        
        # Prepare request data
        
        # Single body parameter - send directly
        data = request_body if request_body is not None else {}
        
        
        
        # Prepare query parameters
        params = {}
        
        
        # Replace path parameters in URL
        path = "/accountManagement/account/create"
        
        
        # Prepare headers
        headers = {}
        if accesstoken is not None:
            headers["Accesstoken"] = str(accesstoken)
        if channeltype is not None:
            headers["ChannelType"] = str(channeltype)
        if co_relationid is not None:
            headers["Co-Relationid"] = str(co_relationid)
        if initiatingsystem is not None:
            headers["InitiatingSystem"] = str(initiatingsystem)
        if servicemode is not None:
            headers["ServiceMode"] = str(servicemode)
        if uuidseqno is not None:
            headers["UUIDSeqNo"] = str(uuidseqno)
        if entity is not None:
            headers["entity"] = str(entity)
        if languagecode is not None:
            headers["languageCode"] = str(languagecode)
        if mu_id is not None:
            headers["mu_id"] = str(mu_id)
        if referenceid is not None:
            headers["referenceId"] = str(referenceid)
        if requesthash is not None:
            headers["requesthash"] = str(requesthash)
        if userid is not None:
            headers["userId"] = str(userid)
        
        
        return await make_api_request(
            "POST", 
            path, 
            data=data, 
            params=params if params else None, 
            headers=headers if headers else None
        )
    
    
    
    @mcp.tool()
    async def ambt0601_crtn_mdfy_casa_postusing_post(
        request_body:Dict[str, Any] ,  # AMBT0601CrtnMdfyCASA_Resource,
        accesstoken: Optional[str] = None,
        channeltype: Optional[int] = None,
        co_relationid: Optional[int] = None,
        initiatingsystem: Optional[str] = None,
        servicemode: Optional[int] = None,
        uuidseqno: Optional[int] = None,
        entity: Optional[str] = None,
        languagecode: Optional[int] = None,
        referenceid: Optional[str] = None,
        requesthash: Optional[str] = None,
        userid: Optional[int] = None
    ) -> Dict[str, Any]:
        """
        This API services are used to create and modify  account CASA
        
        Generated from: POST /accountManagement/account/createModifyCASA
        Source: swagger_2_0
        Operation ID: AMBT0601CrtnMdfyCASA_POSTUsingPOST
        
        
        Authentication: Not required
        
        Parameters:
        - request_body: any (required)
          input
        
        
        
        Headers:
        - Accesstoken: string
          Authorization token for identification of the caller
        - ChannelType: integer
          Channel identifier from where the TXN has originated (Internet, Mobile, ATM, Branch Channel )
        - Co-Relationid: integer
          Unique ID for the service invoked, will be set by the TXN system
        - InitiatingSystem: string
          Indicating the initiated system
        - ServiceMode: integer
          Used for branch channel to indicate the type of customer
        - UUIDSeqNo: integer
          UUID Sequence Number
        - entity: string
          entity
        - languageCode: integer
          languageCode
        - referenceId: string
          Place holder for Token based authentication
        - requesthash: string
          Request payload for hash validation
        - userId: integer
          userId
        
        
        """
        
        
        # Prepare request data
        
        # Single body parameter - send directly
        data = request_body if request_body is not None else {}
        
        
        
        # Prepare query parameters
        params = {}
        
        
        # Replace path parameters in URL
        path = "/accountManagement/account/createModifyCASA"
        
        
        # Prepare headers
        headers = {}
        if accesstoken is not None:
            headers["Accesstoken"] = str(accesstoken)
        if channeltype is not None:
            headers["ChannelType"] = str(channeltype)
        if co_relationid is not None:
            headers["Co-Relationid"] = str(co_relationid)
        if initiatingsystem is not None:
            headers["InitiatingSystem"] = str(initiatingsystem)
        if servicemode is not None:
            headers["ServiceMode"] = str(servicemode)
        if uuidseqno is not None:
            headers["UUIDSeqNo"] = str(uuidseqno)
        if entity is not None:
            headers["entity"] = str(entity)
        if languagecode is not None:
            headers["languageCode"] = str(languagecode)
        if referenceid is not None:
            headers["referenceId"] = str(referenceid)
        if requesthash is not None:
            headers["requesthash"] = str(requesthash)
        if userid is not None:
            headers["userId"] = str(userid)
        
        
        return await make_api_request(
            "POST", 
            path, 
            data=data, 
            params=params if params else None, 
            headers=headers if headers else None
        )
    
    
    
    @mcp.tool()
    async def ambtcreate_crypto_blk_adrs_postusing_post(
        request_body:Dict[str, Any] ,  # CreateBlockAddress_Resource,
        accesstoken: Optional[str] = None,
        channeltype: Optional[int] = None,
        co_relationid: Optional[int] = None,
        initiatingsystem: Optional[str] = None,
        servicemode: Optional[int] = None,
        uuidseqno: Optional[int] = None,
        entity: Optional[str] = None,
        languagecode: Optional[int] = None,
        referenceid: Optional[str] = None,
        requesthash: Optional[str] = None,
        userid: Optional[int] = None
    ) -> Dict[str, Any]:
        """
        Create Crypto Block Address
        
        Generated from: POST /accountManagement/account/cryptoDetails
        Source: swagger_2_0
        Operation ID: AMBTCreateCryptoBlkAdrs_POSTUsingPOST
        
        
        Authentication: Not required
        
        Parameters:
        - request_body: any (required)
          input
        
        
        
        Headers:
        - Accesstoken: string
          Authorization token for identification of the caller
        - ChannelType: integer
          Channel identifier from where the TXN has originated (Internet, Mobile, ATM, Branch Channel )
        - Co-Relationid: integer
          Unique ID for the service invoked, will be set by the TXN system
        - InitiatingSystem: string
          Indicating the initiated system
        - ServiceMode: integer
          Used for branch channel to indicate the type of customer
        - UUIDSeqNo: integer
          UUID Sequence Number
        - entity: string
          entity
        - languageCode: integer
          languageCode
        - referenceId: string
          Place holder for Token based authentication
        - requesthash: string
          Request payload for hash validation
        - userId: integer
          userId
        
        
        """
        
        
        # Prepare request data
        
        # Single body parameter - send directly
        data = request_body if request_body is not None else {}
        
        
        
        # Prepare query parameters
        params = {}
        
        
        # Replace path parameters in URL
        path = "/accountManagement/account/cryptoDetails"
        
        
        # Prepare headers
        headers = {}
        if accesstoken is not None:
            headers["Accesstoken"] = str(accesstoken)
        if channeltype is not None:
            headers["ChannelType"] = str(channeltype)
        if co_relationid is not None:
            headers["Co-Relationid"] = str(co_relationid)
        if initiatingsystem is not None:
            headers["InitiatingSystem"] = str(initiatingsystem)
        if servicemode is not None:
            headers["ServiceMode"] = str(servicemode)
        if uuidseqno is not None:
            headers["UUIDSeqNo"] = str(uuidseqno)
        if entity is not None:
            headers["entity"] = str(entity)
        if languagecode is not None:
            headers["languageCode"] = str(languagecode)
        if referenceid is not None:
            headers["referenceId"] = str(referenceid)
        if requesthash is not None:
            headers["requesthash"] = str(requesthash)
        if userid is not None:
            headers["userId"] = str(userid)
        
        
        return await make_api_request(
            "POST", 
            path, 
            data=data, 
            params=params if params else None, 
            headers=headers if headers else None
        )
    
    
    
    @mcp.tool()
    async def ambtmodify_crypto_blk_adrs_postusing_post(
        request_body:Dict[str, Any] ,  # ModifyBlockAddress_Resource,
        accesstoken: Optional[str] = None,
        channeltype: Optional[int] = None,
        co_relationid: Optional[int] = None,
        initiatingsystem: Optional[str] = None,
        servicemode: Optional[int] = None,
        uuidseqno: Optional[int] = None,
        entity: Optional[str] = None,
        languagecode: Optional[int] = None,
        referenceid: Optional[str] = None,
        requesthash: Optional[str] = None,
        userid: Optional[int] = None
    ) -> Dict[str, Any]:
        """
        Modify Crypto Block Address
        
        Generated from: POST /accountManagement/account/cryptoDetails/update
        Source: swagger_2_0
        Operation ID: AMBTModifyCryptoBlkAdrs_POSTUsingPOST
        
        
        Authentication: Not required
        
        Parameters:
        - request_body: any (required)
          input
        
        
        
        Headers:
        - Accesstoken: string
          Authorization token for identification of the caller
        - ChannelType: integer
          Channel identifier from where the TXN has originated (Internet, Mobile, ATM, Branch Channel )
        - Co-Relationid: integer
          Unique ID for the service invoked, will be set by the TXN system
        - InitiatingSystem: string
          Indicating the initiated system
        - ServiceMode: integer
          Used for branch channel to indicate the type of customer
        - UUIDSeqNo: integer
          UUID Sequence Number
        - entity: string
          entity
        - languageCode: integer
          languageCode
        - referenceId: string
          Place holder for Token based authentication
        - requesthash: string
          Request payload for hash validation
        - userId: integer
          userId
        
        
        """
        
        
        # Prepare request data
        
        # Single body parameter - send directly
        data = request_body if request_body is not None else {}
        
        
        
        # Prepare query parameters
        params = {}
        
        
        # Replace path parameters in URL
        path = "/accountManagement/account/cryptoDetails/update"
        
        
        # Prepare headers
        headers = {}
        if accesstoken is not None:
            headers["Accesstoken"] = str(accesstoken)
        if channeltype is not None:
            headers["ChannelType"] = str(channeltype)
        if co_relationid is not None:
            headers["Co-Relationid"] = str(co_relationid)
        if initiatingsystem is not None:
            headers["InitiatingSystem"] = str(initiatingsystem)
        if servicemode is not None:
            headers["ServiceMode"] = str(servicemode)
        if uuidseqno is not None:
            headers["UUIDSeqNo"] = str(uuidseqno)
        if entity is not None:
            headers["entity"] = str(entity)
        if languagecode is not None:
            headers["languageCode"] = str(languagecode)
        if referenceid is not None:
            headers["referenceId"] = str(referenceid)
        if requesthash is not None:
            headers["requesthash"] = str(requesthash)
        if userid is not None:
            headers["userId"] = str(userid)
        
        
        return await make_api_request(
            "POST", 
            path, 
            data=data, 
            params=params if params else None, 
            headers=headers if headers else None
        )
    
    
    
    @mcp.tool()
    async def amet2021_dep_acnts_bal_statmnt_postusing_post(
        request_body:Dict[str, Any] ,  # depAccntBalanceStatementResource,
        entity: Optional[str] = None,
        languagecode: Optional[int] = None,
        userid: Optional[int] = None
    ) -> Dict[str, Any]:
        """
        This service used to Fetch Account Balance Statement for multiple deposit accounts
        
        Generated from: POST /accountManagement/account/depositAccountBalanceStatement
        Source: swagger_2_0
        Operation ID: AMET2021DepAcntsBalStatmnt_POSTUsingPOST
        
        
        Authentication: Not required
        
        Parameters:
        - request_body: any (required)
          input
        
        
        
        Headers:
        - entity: string
          entity
        - languageCode: integer
          languageCode
        - userId: integer
          userId
        
        
        """
        
        
        # Prepare request data
        
        # Single body parameter - send directly
        data = request_body if request_body is not None else {}
        
        
        
        # Prepare query parameters
        params = {}
        
        
        # Replace path parameters in URL
        path = "/accountManagement/account/depositAccountBalanceStatement"
        
        
        # Prepare headers
        headers = {}
        if entity is not None:
            headers["entity"] = str(entity)
        if languagecode is not None:
            headers["languageCode"] = str(languagecode)
        if userid is not None:
            headers["userId"] = str(userid)
        
        
        return await make_api_request(
            "POST", 
            path, 
            data=data, 
            params=params if params else None, 
            headers=headers if headers else None
        )
    
    
    
    @mcp.tool()
    async def cbpetget_account_details_using_get(
        accountreference: str,
        accesstoken: Optional[str] = None,
        channeltype: Optional[int] = None,
        co_relationid: Optional[int] = None,
        initiatingsystem: Optional[str] = None,
        servicemode: Optional[int] = None,
        uuidseqno: Optional[int] = None,
        entity: Optional[str] = None,
        languagecode: Optional[int] = None,
        referenceid: Optional[str] = None,
        userid: Optional[int] = None
    ) -> Dict[str, Any]:
        """
        Fetch Account Details
        
        Generated from: GET /accountManagement/account/details/{accountReference}
        Source: swagger_2_0
        Operation ID: CBPETGetAccountDetailsUsingGET
        
        
        Authentication: Not required
        
        Parameters:
        - accountReference: string (required)
          Enter the Account Reference
        
        
        
        Headers:
        - Accesstoken: string
          Authorization token for identification of the caller
        - ChannelType: integer
          Channel identifier from where the TXN has originated (Internet, Mobile, ATM, Branch Channel )
        - Co-Relationid: integer
          Unique ID for the service invoked, will be set by the TXN system
        - InitiatingSystem: string
          Indicating the initiated system
        - ServiceMode: integer
          Used for branch channel to indicate the type of customer
        - UUIDSeqNo: integer
          UUID Sequence Number
        - entity: string
          entity
        - languageCode: integer
          languageCode
        - referenceId: string
          Place holder for Token based authentication
        - userId: integer
          userId
        
        
        """
        
        
        # Prepare query parameters
        params = {}
        
        
        # Replace path parameters in URL
        path = "/accountManagement/account/details/{accountReference}"
        if accountreference is not None:
            path = path.replace("{accountReference}", str(accountreference))
        
        
        # Prepare headers
        headers = {}
        if accesstoken is not None:
            headers["Accesstoken"] = str(accesstoken)
        if channeltype is not None:
            headers["ChannelType"] = str(channeltype)
        if co_relationid is not None:
            headers["Co-Relationid"] = str(co_relationid)
        if initiatingsystem is not None:
            headers["InitiatingSystem"] = str(initiatingsystem)
        if servicemode is not None:
            headers["ServiceMode"] = str(servicemode)
        if uuidseqno is not None:
            headers["UUIDSeqNo"] = str(uuidseqno)
        if entity is not None:
            headers["entity"] = str(entity)
        if languagecode is not None:
            headers["languageCode"] = str(languagecode)
        if referenceid is not None:
            headers["referenceId"] = str(referenceid)
        if userid is not None:
            headers["userId"] = str(userid)
        
        
        return await make_api_request(
            "GET", 
            path, 
            
            params=params if params else None, 
            headers=headers if headers else None
        )
    
    
    
    @mcp.tool()
    async def ametget_account_details_postusing_get(
        accountreference: str,
        pagenum: Optional[int] = None,
        pagesize: Optional[int] = None,
        accesstoken: Optional[str] = None,
        channeltype: Optional[int] = None,
        co_relationid: Optional[int] = None,
        initiatingsystem: Optional[str] = None,
        servicemode: Optional[int] = None,
        uuidseqno: Optional[int] = None,
        entity: Optional[str] = None,
        languagecode: Optional[int] = None,
        referenceid: Optional[str] = None,
        userid: Optional[int] = None
    ) -> Dict[str, Any]:
        """
        Get enterprise account details
        
        Generated from: GET /accountManagement/account/enterpriseaccountdetails
        Source: swagger_2_0
        Operation ID: AMETGetAccountDetails_POSTUsingGET
        
        
        Authentication: Not required
        
        Parameters:
        - AccountReference: string (required)
          This field shows unique reference of the particular Account
        - pageNum: integer
          pageNum
        - pageSize: integer
          pageSize
        
        
        
        Headers:
        - Accesstoken: string
          Authorization Token to validation the caller
        - ChannelType: integer
          Channel identifier from where the TXN has originated (Internet, Mobile, ATM, Branch Channel )
        - Co-Relationid: integer
          Unique ID for the service invoked, will be set by the TXN system
        - InitiatingSystem: string
          Indicating the initiated system
        - ServiceMode: integer
          Used for branch channel to indicate the type of customer
        - UUIDSeqNo: integer
          UUID Sequence Number
        - entity: string
          entity
        - languageCode: integer
          languageCode
        - referenceId: string
          Place holder for Token based authentication
        - userId: integer
          userId
        
        
        """
        
        
        # Prepare query parameters
        params = {}
        if accountreference is not None:
            params["AccountReference"] = accountreference
            
        if pagenum is not None:
            params["pageNum"] = pagenum
            
        if pagesize is not None:
            params["pageSize"] = pagesize
            
        
        
        # Replace path parameters in URL
        path = "/accountManagement/account/enterpriseaccountdetails"
        
        
        # Prepare headers
        headers = {}
        if accesstoken is not None:
            headers["Accesstoken"] = str(accesstoken)
        if channeltype is not None:
            headers["ChannelType"] = str(channeltype)
        if co_relationid is not None:
            headers["Co-Relationid"] = str(co_relationid)
        if initiatingsystem is not None:
            headers["InitiatingSystem"] = str(initiatingsystem)
        if servicemode is not None:
            headers["ServiceMode"] = str(servicemode)
        if uuidseqno is not None:
            headers["UUIDSeqNo"] = str(uuidseqno)
        if entity is not None:
            headers["entity"] = str(entity)
        if languagecode is not None:
            headers["languageCode"] = str(languagecode)
        if referenceid is not None:
            headers["referenceId"] = str(referenceid)
        if userid is not None:
            headers["userId"] = str(userid)
        
        
        return await make_api_request(
            "GET", 
            path, 
            
            params=params if params else None, 
            headers=headers if headers else None
        )
    
    
    
    @mcp.tool()
    async def amet0395_acnt_entrprc_chl_postusing_get(
        accountname: Optional[str] = None,
        accountreference: Optional[str] = None,
        instrumenttype: Optional[int] = None,
        pagenum: Optional[int] = None,
        pagesize: Optional[int] = None,
        accesstoken: Optional[str] = None,
        channeltype: Optional[int] = None,
        co_relationid: Optional[int] = None,
        initiatingsystem: Optional[str] = None,
        servicemode: Optional[int] = None,
        uuidseqno: Optional[int] = None,
        entity: Optional[str] = None,
        languagecode: Optional[int] = None,
        referenceid: Optional[str] = None,
        userid: Optional[int] = None
    ) -> Dict[str, Any]:
        """
        Fetch enterprise account list
        
        Generated from: GET /accountManagement/account/enterpriselist
        Source: swagger_2_0
        Operation ID: AMET0395AcntEntrprcChl_POSTUsingGET
        
        
        Authentication: Not required
        
        Parameters:
        - AccountName: string
          Account Name
        - AccountReference: string
          This field shows unique reference of the particular Account
        - InstrumentType: integer
          This field shows instrument type of the particular Account
        - pageNum: integer
          pageNum
        - pageSize: integer
          pageSize
        
        
        
        Headers:
        - Accesstoken: string
          Authorization Token to validation the caller
        - ChannelType: integer
          Channel identifier from where the TXN has originated (Internet, Mobile, ATM, Branch Channel )
        - Co-Relationid: integer
          Unique ID for the service invoked, will be set by the TXN system
        - InitiatingSystem: string
          Indicating the initiated system
        - ServiceMode: integer
          Used for branch channel to indicate the type of customer
        - UUIDSeqNo: integer
          UUID Sequence Number
        - entity: string
          entity
        - languageCode: integer
          languageCode
        - referenceId: string
          Place holder for Token based authentication
        - userId: integer
          userId
        
        
        """
        
        
        # Prepare query parameters
        params = {}
        if accountname is not None:
            params["AccountName"] = accountname
            
        if accountreference is not None:
            params["AccountReference"] = accountreference
            
        if instrumenttype is not None:
            params["InstrumentType"] = instrumenttype
            
        if pagenum is not None:
            params["pageNum"] = pagenum
            
        if pagesize is not None:
            params["pageSize"] = pagesize
            
        
        
        # Replace path parameters in URL
        path = "/accountManagement/account/enterpriselist"
        
        
        # Prepare headers
        headers = {}
        if accesstoken is not None:
            headers["Accesstoken"] = str(accesstoken)
        if channeltype is not None:
            headers["ChannelType"] = str(channeltype)
        if co_relationid is not None:
            headers["Co-Relationid"] = str(co_relationid)
        if initiatingsystem is not None:
            headers["InitiatingSystem"] = str(initiatingsystem)
        if servicemode is not None:
            headers["ServiceMode"] = str(servicemode)
        if uuidseqno is not None:
            headers["UUIDSeqNo"] = str(uuidseqno)
        if entity is not None:
            headers["entity"] = str(entity)
        if languagecode is not None:
            headers["languageCode"] = str(languagecode)
        if referenceid is not None:
            headers["referenceId"] = str(referenceid)
        if userid is not None:
            headers["userId"] = str(userid)
        
        
        return await make_api_request(
            "GET", 
            path, 
            
            params=params if params else None, 
            headers=headers if headers else None
        )
    
    
    
    @mcp.tool()
    async def amet1704_prd_dtl_entrprcchl_postusing_get(
        customerreference: int,
        instrumenttype: Optional[int] = None,
        pagenum: Optional[int] = None,
        pagesize: Optional[int] = None,
        accesstoken: Optional[str] = None,
        channeltype: Optional[int] = None,
        co_relationid: Optional[int] = None,
        initiatingsystem: Optional[str] = None,
        servicemode: Optional[int] = None,
        uuidseqno: Optional[int] = None,
        entity: Optional[str] = None,
        languagecode: Optional[int] = None,
        referenceid: Optional[str] = None,
        userid: Optional[int] = None
    ) -> Dict[str, Any]:
        """
        Get enterprise product details
        
        Generated from: GET /accountManagement/account/enterpriseproductdetails
        Source: swagger_2_0
        Operation ID: AMET1704PrdDtlEntrprcchl_POSTUsingGET
        
        
        Authentication: Not required
        
        Parameters:
        - CustomerReference: integer (required)
          This field shows unique reference of the particular Account
        - InstrumentType: integer
          Instrument Type
        - pageNum: integer
          pageNum
        - pageSize: integer
          pageSize
        
        
        
        Headers:
        - Accesstoken: string
          Authorization Token to validation the caller
        - ChannelType: integer
          Channel identifier from where the TXN has originated (Internet, Mobile, ATM, Branch Channel )
        - Co-Relationid: integer
          Unique ID for the service invoked, will be set by the TXN system
        - InitiatingSystem: string
          Indicating the initiated system
        - ServiceMode: integer
          Used for branch channel to indicate the type of customer
        - UUIDSeqNo: integer
          UUID Sequence Number
        - entity: string
          entity
        - languageCode: integer
          languageCode
        - referenceId: string
          Place holder for Token based authentication
        - userId: integer
          userId
        
        
        """
        
        
        # Prepare query parameters
        params = {}
        if customerreference is not None:
            params["CustomerReference"] = customerreference
            
        if instrumenttype is not None:
            params["InstrumentType"] = instrumenttype
            
        if pagenum is not None:
            params["pageNum"] = pagenum
            
        if pagesize is not None:
            params["pageSize"] = pagesize
            
        
        
        # Replace path parameters in URL
        path = "/accountManagement/account/enterpriseproductdetails"
        
        
        # Prepare headers
        headers = {}
        if accesstoken is not None:
            headers["Accesstoken"] = str(accesstoken)
        if channeltype is not None:
            headers["ChannelType"] = str(channeltype)
        if co_relationid is not None:
            headers["Co-Relationid"] = str(co_relationid)
        if initiatingsystem is not None:
            headers["InitiatingSystem"] = str(initiatingsystem)
        if servicemode is not None:
            headers["ServiceMode"] = str(servicemode)
        if uuidseqno is not None:
            headers["UUIDSeqNo"] = str(uuidseqno)
        if entity is not None:
            headers["entity"] = str(entity)
        if languagecode is not None:
            headers["languageCode"] = str(languagecode)
        if referenceid is not None:
            headers["referenceId"] = str(referenceid)
        if userid is not None:
            headers["userId"] = str(userid)
        
        
        return await make_api_request(
            "GET", 
            path, 
            
            params=params if params else None, 
            headers=headers if headers else None
        )
    
    
    
    @mcp.tool()
    async def amet1703_get_inst_con_dtls_postusing_get(
        accountreference: str,
        interestcategory: Optional[int] = None,
        pagenum: Optional[int] = None,
        pagesize: Optional[int] = None,
        accesstoken: Optional[str] = None,
        channeltype: Optional[int] = None,
        co_relationid: Optional[int] = None,
        initiatingsystem: Optional[str] = None,
        servicemode: Optional[int] = None,
        uuidseqno: Optional[int] = None,
        entity: Optional[str] = None,
        languagecode: Optional[int] = None,
        referenceid: Optional[str] = None,
        userid: Optional[int] = None
    ) -> Dict[str, Any]:
        """
        Interest Condition Details
        
        Generated from: GET /accountManagement/account/interestCondition
        Source: swagger_2_0
        Operation ID: AMET1703GetInstConDtls_POSTUsingGET
        
        
        Authentication: Not required
        
        Parameters:
        - accountReference: string (required)
          Reference number of account
        - interestCategory: integer
          Interest Category (Eg: 1- Credit, 2- Debit, 5-Penal domain : d_IntrCatg)
        - pageNum: integer
          pageNum
        - pageSize: integer
          pageSize
        
        
        
        Headers:
        - Accesstoken: string
          Authorization token for identification of the caller
        - ChannelType: integer
          Channel identifier from where the TXN has originated (Internet, Mobile, ATM, Branch Channel )
        - Co-Relationid: integer
          Unique ID for the service invoked, will be set by the TXN system
        - InitiatingSystem: string
          Indicating the initiated system
        - ServiceMode: integer
          Used for branch channel to indicate the type of customer
        - UUIDSeqNo: integer
          UUID Sequence Number
        - entity: string
          entity
        - languageCode: integer
          languageCode
        - referenceId: string
          Place holder for Token based authentication
        - userId: integer
          userId
        
        
        """
        
        
        # Prepare query parameters
        params = {}
        if accountreference is not None:
            params["accountReference"] = accountreference
            
        if interestcategory is not None:
            params["interestCategory"] = interestcategory
            
        if pagenum is not None:
            params["pageNum"] = pagenum
            
        if pagesize is not None:
            params["pageSize"] = pagesize
            
        
        
        # Replace path parameters in URL
        path = "/accountManagement/account/interestCondition"
        
        
        # Prepare headers
        headers = {}
        if accesstoken is not None:
            headers["Accesstoken"] = str(accesstoken)
        if channeltype is not None:
            headers["ChannelType"] = str(channeltype)
        if co_relationid is not None:
            headers["Co-Relationid"] = str(co_relationid)
        if initiatingsystem is not None:
            headers["InitiatingSystem"] = str(initiatingsystem)
        if servicemode is not None:
            headers["ServiceMode"] = str(servicemode)
        if uuidseqno is not None:
            headers["UUIDSeqNo"] = str(uuidseqno)
        if entity is not None:
            headers["entity"] = str(entity)
        if languagecode is not None:
            headers["languageCode"] = str(languagecode)
        if referenceid is not None:
            headers["referenceId"] = str(referenceid)
        if userid is not None:
            headers["userId"] = str(userid)
        
        
        return await make_api_request(
            "GET", 
            path, 
            
            params=params if params else None, 
            headers=headers if headers else None
        )
    
    
    
    @mcp.tool()
    async def amet0319_fetch_acnt_lst_using_get(
        accountreference: Optional[str] = None,
        accounttype: Optional[int] = None,
        accountusage: Optional[str] = None,
        balancerequired: Optional[int] = None,
        customerid: Optional[int] = None,
        groupid: Optional[str] = None,
        identifiertype: Optional[int] = None,
        identifiervalue: Optional[str] = None,
        accountsubtype: Optional[int] = None,
        currency: Optional[str] = None,
        extensibilitymap: Optional[str] = None,
        pagenum: Optional[int] = None,
        pagesize: Optional[int] = None,
        portfolioid: Optional[str] = None,
        productid: Optional[int] = None,
        status: Optional[str] = None,
        accesstoken: Optional[str] = None,
        channeltype: Optional[int] = None,
        co_relationid: Optional[int] = None,
        initiatingsystem: Optional[str] = None,
        servicemode: Optional[int] = None,
        uuidseqno: Optional[int] = None,
        entity: Optional[str] = None,
        languagecode: Optional[int] = None,
        referenceid: Optional[str] = None,
        userid: Optional[int] = None
    ) -> Dict[str, Any]:
        """
        Fetch Account List
        
        Generated from: GET /accountManagement/account/list
        Source: swagger_2_0
        Operation ID: AMET0319FetchAcntLstUsingGET
        
        
        Authentication: Not required
        
        Parameters:
        - AccountReference: string
          Enter the AccountReference
        - AccountType: integer
          Enter account type 7-Cash account, 40- Saving account , 48 - Current Account
        - AccountUsage: string
          Enter account usage 7-Nostro 
        - BalanceRequired: integer
          Balance Required Flag 1--- Balance fields will appear
        - CustomerID: integer
          Customer ID
        - GroupId: string
          This is to fetch GroupID
        - IdentifierType: integer
          Identifier Type
        - IdentifierValue: string
          Identifier Value
        - accountSubType: integer
          Enter account type 1 - MMA , 2- DDA , 3 - TIP, 4 - VCL , 5 - OD , 6 - PROCEED
        - currency: string
          Currency code for the Account (Domain Name: d_CurrCode / 3 character ISO currency code) Eg : MXN, EUR, USD, INR
        - extensibilityMap: string
          Custom key - value pair of attributes for extensibility enablement
        - pageNum: integer
          pageNum
        - pageSize: integer
          pageSize
        - portfolioID: string
          Portfolio ID linked to the account.
        - productid: integer
          Product Id
        - status: string
          Account Status (Domain Name: d_AccStat) 1-on hold, 2-active, 3-released, 4-verified
        
        
        
        Headers:
        - Accesstoken: string
          Authorization token for identification of the caller
        - ChannelType: integer
          Channel identifier from where the TXN has originated (Internet, Mobile, ATM, Branch Channel )
        - Co-Relationid: integer
          Unique ID for the service invoked, will be set by the TXN system
        - InitiatingSystem: string
          Indicating the initiated system
        - ServiceMode: integer
          Used for branch channel to indicate the type of customer
        - UUIDSeqNo: integer
          UUID Sequence Number
        - entity: string
          entity
        - languageCode: integer
          languageCode
        - referenceId: string
          Place holder for Token based authentication
        - userId: integer
          userId
        
        
        """
        
        
        # Prepare query parameters
        params = {}
        if accountreference is not None:
            params["AccountReference"] = accountreference
            
        if accounttype is not None:
            params["AccountType"] = accounttype
            
        if accountusage is not None:
            params["AccountUsage"] = accountusage
            
        if balancerequired is not None:
            params["BalanceRequired"] = balancerequired
            
        if customerid is not None:
            params["CustomerID"] = customerid
            
        if groupid is not None:
            params["GroupId"] = groupid
            
        if identifiertype is not None:
            params["IdentifierType"] = identifiertype
            
        if identifiervalue is not None:
            params["IdentifierValue"] = identifiervalue
            
        if accountsubtype is not None:
            params["accountSubType"] = accountsubtype
            
        if currency is not None:
            params["currency"] = currency
            
        if extensibilitymap is not None:
            params["extensibilityMap"] = extensibilitymap
            
        if pagenum is not None:
            params["pageNum"] = pagenum
            
        if pagesize is not None:
            params["pageSize"] = pagesize
            
        if portfolioid is not None:
            params["portfolioID"] = portfolioid
            
        if productid is not None:
            params["productid"] = productid
            
        if status is not None:
            params["status"] = status
            
        
        
        # Replace path parameters in URL
        path = "/accountManagement/account/list"
        
        
        # Prepare headers
        headers = {}
        if accesstoken is not None:
            headers["Accesstoken"] = str(accesstoken)
        if channeltype is not None:
            headers["ChannelType"] = str(channeltype)
        if co_relationid is not None:
            headers["Co-Relationid"] = str(co_relationid)
        if initiatingsystem is not None:
            headers["InitiatingSystem"] = str(initiatingsystem)
        if servicemode is not None:
            headers["ServiceMode"] = str(servicemode)
        if uuidseqno is not None:
            headers["UUIDSeqNo"] = str(uuidseqno)
        if entity is not None:
            headers["entity"] = str(entity)
        if languagecode is not None:
            headers["languageCode"] = str(languagecode)
        if referenceid is not None:
            headers["referenceId"] = str(referenceid)
        if userid is not None:
            headers["userId"] = str(userid)
        
        
        return await make_api_request(
            "GET", 
            path, 
            
            params=params if params else None, 
            headers=headers if headers else None
        )
    
    
    
    @mcp.tool()
    async def amet1084_view_mndate_signtures_getusing_get(
        accountreference: str,
        imagetype: int,
        thresholdamt: float,
        transactiontype: int,
        channeltype: Optional[int] = None,
        co_relationid: Optional[int] = None,
        initiatingsystem: Optional[str] = None,
        servicemode: Optional[int] = None,
        uuidseqno: Optional[int] = None,
        entity: Optional[str] = None,
        languagecode: Optional[int] = None,
        userid: Optional[int] = None
    ) -> Dict[str, Any]:
        """
        API to fetch View Mandate Signatures
        
        Generated from: GET /accountManagement/account/mandateSignaturesDetails
        Source: swagger_2_0
        Operation ID: AMET1084ViewMndateSigntures_GETUsingGET
        
        
        Authentication: Not required
        
        Parameters:
        - AccountReference: string (required)
          Account Reference
        - ImageType: integer (required)
          Image Type
        - ThresholdAmt: number (required)
          Transaction Amount
        - TransactionType: integer (required)
          Transaction Type (42-AllDebits)
        
        
        
        Headers:
        - ChannelType: integer
          Channel identifier from where the TXN has originated (Internet, Mobile, ATM, Branch Channel )
        - Co-Relationid: integer
          Unique ID for the service invoked, will be set by the TXN system
        - InitiatingSystem: string
          Indicating the initiated system
        - ServiceMode: integer
          Used for branch channel to indicate the type of customer
        - UUIDSeqNo: integer
          UUID Sequence Number
        - entity: string
          entity
        - languageCode: integer
          languageCode
        - userId: integer
          userId
        
        
        """
        
        
        # Prepare query parameters
        params = {}
        if accountreference is not None:
            params["AccountReference"] = accountreference
            
        if imagetype is not None:
            params["ImageType"] = imagetype
            
        if thresholdamt is not None:
            params["ThresholdAmt"] = thresholdamt
            
        if transactiontype is not None:
            params["TransactionType"] = transactiontype
            
        
        
        # Replace path parameters in URL
        path = "/accountManagement/account/mandateSignaturesDetails"
        
        
        # Prepare headers
        headers = {}
        if channeltype is not None:
            headers["ChannelType"] = str(channeltype)
        if co_relationid is not None:
            headers["Co-Relationid"] = str(co_relationid)
        if initiatingsystem is not None:
            headers["InitiatingSystem"] = str(initiatingsystem)
        if servicemode is not None:
            headers["ServiceMode"] = str(servicemode)
        if uuidseqno is not None:
            headers["UUIDSeqNo"] = str(uuidseqno)
        if entity is not None:
            headers["entity"] = str(entity)
        if languagecode is not None:
            headers["languageCode"] = str(languagecode)
        if userid is not None:
            headers["userId"] = str(userid)
        
        
        return await make_api_request(
            "GET", 
            path, 
            
            params=params if params else None, 
            headers=headers if headers else None
        )
    
    
    
    @mcp.tool()
    async def amet2022_get_migrated_data_using_get(
        referencetype: int,
        newreferencenumber: Optional[str] = None,
        oldreferencenumber: Optional[str] = None,
        oldsystemid: Optional[int] = None,
        accesstoken: Optional[str] = None,
        channeltype: Optional[int] = None,
        co_relationid: Optional[int] = None,
        initiatingsystem: Optional[str] = None,
        servicemode: Optional[int] = None,
        uuidseqno: Optional[int] = None,
        entity: Optional[str] = None,
        languagecode: Optional[int] = None,
        referenceid: Optional[str] = None,
        userid: Optional[int] = None
    ) -> Dict[str, Any]:
        """
        API to fetch Migrated Data
        
        Generated from: GET /accountManagement/account/migrateddatasearch
        Source: swagger_2_0
        Operation ID: AMET2022GetMigratedDataUsingGET
        
        
        Authentication: Not required
        
        Parameters:
        - newReferenceNumber: string
          This field is to enter New Reference Number
        - oldReferenceNumber: string
          This field is to enter Old Reference Number
        - oldSystemID: integer
          This field is to select Old System ID (CBS)
        - referenceType: integer (required)
          This field is to select Reference Type (Eg: 1-CIF, 2-Demand Account, 3-Term Deposit Account, 4-Loan Account domain: d_ReferenceType)
        
        
        
        Headers:
        - Accesstoken: string
          Authorization token for identification of the caller
        - ChannelType: integer
          Channel identifier from where the TXN has originated (Internet, Mobile, ATM, Branch Channel )
        - Co-Relationid: integer
          Unique ID for the service invoked, will be set by the TXN system
        - InitiatingSystem: string
          Indicating the initiated system
        - ServiceMode: integer
          Used for branch channel to indicate the type of customer
        - UUIDSeqNo: integer
          UUID Sequence Number
        - entity: string
          entity
        - languageCode: integer
          languageCode
        - referenceId: string
          Place holder for Token based authentication
        - userId: integer
          userId
        
        
        """
        
        
        # Prepare query parameters
        params = {}
        if newreferencenumber is not None:
            params["newReferenceNumber"] = newreferencenumber
            
        if oldreferencenumber is not None:
            params["oldReferenceNumber"] = oldreferencenumber
            
        if oldsystemid is not None:
            params["oldSystemID"] = oldsystemid
            
        if referencetype is not None:
            params["referenceType"] = referencetype
            
        
        
        # Replace path parameters in URL
        path = "/accountManagement/account/migrateddatasearch"
        
        
        # Prepare headers
        headers = {}
        if accesstoken is not None:
            headers["Accesstoken"] = str(accesstoken)
        if channeltype is not None:
            headers["ChannelType"] = str(channeltype)
        if co_relationid is not None:
            headers["Co-Relationid"] = str(co_relationid)
        if initiatingsystem is not None:
            headers["InitiatingSystem"] = str(initiatingsystem)
        if servicemode is not None:
            headers["ServiceMode"] = str(servicemode)
        if uuidseqno is not None:
            headers["UUIDSeqNo"] = str(uuidseqno)
        if entity is not None:
            headers["entity"] = str(entity)
        if languagecode is not None:
            headers["languageCode"] = str(languagecode)
        if referenceid is not None:
            headers["referenceId"] = str(referenceid)
        if userid is not None:
            headers["userId"] = str(userid)
        
        
        return await make_api_request(
            "GET", 
            path, 
            
            params=params if params else None, 
            headers=headers if headers else None
        )
    
    
    
    @mcp.tool()
    async def rstbtmodify_acnt_actv_putusing_put(
        request_body:Dict[str, Any] ,  # AccountModifyResource,
        accesstoken: Optional[str] = None,
        channeltype: Optional[int] = None,
        co_relationid: Optional[int] = None,
        initiatingsystem: Optional[str] = None,
        servicemode: Optional[int] = None,
        uuidseqno: Optional[int] = None,
        entity: Optional[str] = None,
        languagecode: Optional[int] = None,
        mu_id: Optional[str] = None,
        referenceid: Optional[str] = None,
        requesthash: Optional[str] = None,
        userid: Optional[int] = None
    ) -> Dict[str, Any]:
        """
        Modify Account Details
        
        Generated from: PUT /accountManagement/account/modify
        Source: swagger_2_0
        Operation ID: RSTBTModifyAcntActv_PUTUsingPUT
        
        
        Authentication: Not required
        
        Parameters:
        - request_body: any (required)
          input
        
        
        
        Headers:
        - Accesstoken: string
          Authorization token for identification of the caller
        - ChannelType: integer
          Channel identifier from where the TXN has originated (Internet, Mobile, ATM, Branch Channel )
        - Co-Relationid: integer
          Unique ID for the service invoked, will be set by the TXN system
        - InitiatingSystem: string
          Indicating the initiated system
        - ServiceMode: integer
          Used for branch channel to indicate the type of customer
        - UUIDSeqNo: integer
          UUID Sequence Number
        - entity: string
          entity
        - languageCode: integer
          languageCode
        - mu_id: string
          mu_id
        - referenceId: string
          Place holder for Token based authentication
        - requesthash: string
          Request payload for hash validation
        - userId: integer
          userId
        
        
        """
        
        
        # Prepare request data
        
        # Single body parameter - send directly
        data = request_body if request_body is not None else {}
        
        
        
        # Prepare query parameters
        params = {}
        
        
        # Replace path parameters in URL
        path = "/accountManagement/account/modify"
        
        
        # Prepare headers
        headers = {}
        if accesstoken is not None:
            headers["Accesstoken"] = str(accesstoken)
        if channeltype is not None:
            headers["ChannelType"] = str(channeltype)
        if co_relationid is not None:
            headers["Co-Relationid"] = str(co_relationid)
        if initiatingsystem is not None:
            headers["InitiatingSystem"] = str(initiatingsystem)
        if servicemode is not None:
            headers["ServiceMode"] = str(servicemode)
        if uuidseqno is not None:
            headers["UUIDSeqNo"] = str(uuidseqno)
        if entity is not None:
            headers["entity"] = str(entity)
        if languagecode is not None:
            headers["languageCode"] = str(languagecode)
        if mu_id is not None:
            headers["mu_id"] = str(mu_id)
        if referenceid is not None:
            headers["referenceId"] = str(referenceid)
        if requesthash is not None:
            headers["requesthash"] = str(requesthash)
        if userid is not None:
            headers["userId"] = str(userid)
        
        
        return await make_api_request(
            "PUT", 
            path, 
            data=data, 
            params=params if params else None, 
            headers=headers if headers else None
        )
    
    
    
    @mcp.tool()
    async def cbpetget_account_product_using_get(
        accountreference: str,
        pagenum: Optional[int] = None,
        pagesize: Optional[int] = None,
        accesstoken: Optional[str] = None,
        channeltype: Optional[int] = None,
        co_relationid: Optional[int] = None,
        initiatingsystem: Optional[str] = None,
        servicemode: Optional[int] = None,
        uuidseqno: Optional[int] = None,
        entity: Optional[str] = None,
        languagecode: Optional[int] = None,
        referenceid: Optional[str] = None,
        userid: Optional[int] = None
    ) -> Dict[str, Any]:
        """
        Fetch Account Product
        
        Generated from: GET /accountManagement/account/product/{accountReference}
        Source: swagger_2_0
        Operation ID: CBPETGetAccountProductUsingGET
        
        
        Authentication: Not required
        
        Parameters:
        - accountReference: string (required)
          Enter the Account Reference
        - pageNum: integer
          pageNum
        - pageSize: integer
          pageSize
        
        
        
        Headers:
        - Accesstoken: string
          Authorization token for identification of the caller
        - ChannelType: integer
          Channel identifier from where the TXN has originated (Internet, Mobile, ATM, Branch Channel )
        - Co-Relationid: integer
          Unique ID for the service invoked, will be set by the TXN system
        - InitiatingSystem: string
          Indicating the initiated system
        - ServiceMode: integer
          Used for branch channel to indicate the type of customer
        - UUIDSeqNo: integer
          UUID Sequence Number
        - entity: string
          entity
        - languageCode: integer
          languageCode
        - referenceId: string
          Place holder for Token based authentication
        - userId: integer
          userId
        
        
        """
        
        
        # Prepare query parameters
        params = {}
        if pagenum is not None:
            params["pageNum"] = pagenum
            
        if pagesize is not None:
            params["pageSize"] = pagesize
            
        
        
        # Replace path parameters in URL
        path = "/accountManagement/account/product/{accountReference}"
        if accountreference is not None:
            path = path.replace("{accountReference}", str(accountreference))
        
        
        # Prepare headers
        headers = {}
        if accesstoken is not None:
            headers["Accesstoken"] = str(accesstoken)
        if channeltype is not None:
            headers["ChannelType"] = str(channeltype)
        if co_relationid is not None:
            headers["Co-Relationid"] = str(co_relationid)
        if initiatingsystem is not None:
            headers["InitiatingSystem"] = str(initiatingsystem)
        if servicemode is not None:
            headers["ServiceMode"] = str(servicemode)
        if uuidseqno is not None:
            headers["UUIDSeqNo"] = str(uuidseqno)
        if entity is not None:
            headers["entity"] = str(entity)
        if languagecode is not None:
            headers["languageCode"] = str(languagecode)
        if referenceid is not None:
            headers["referenceId"] = str(referenceid)
        if userid is not None:
            headers["userId"] = str(userid)
        
        
        return await make_api_request(
            "GET", 
            path, 
            
            params=params if params else None, 
            headers=headers if headers else None
        )
    
    
    
    @mcp.tool()
    async def cbcbt2021_prodct_switch_using_post(
        request_body:Dict[str, Any] ,  # ProdctSwitchResource,
        accesstoken: Optional[str] = None,
        channeltype: Optional[int] = None,
        co_relationid: Optional[int] = None,
        initiatingsystem: Optional[str] = None,
        servicemode: Optional[int] = None,
        uuidseqno: Optional[int] = None,
        entity: Optional[str] = None,
        languagecode: Optional[int] = None,
        referenceid: Optional[str] = None,
        requesthash: Optional[str] = None,
        userid: Optional[int] = None
    ) -> Dict[str, Any]:
        """
        Product Switch Wrapper
        
        Generated from: POST /accountManagement/account/productswitch
        Source: swagger_2_0
        Operation ID: CBCBT2021ProdctSwitchUsingPOST
        
        
        Authentication: Not required
        
        Parameters:
        - request_body: any (required)
          input
        
        
        
        Headers:
        - Accesstoken: string
          Authorization Token to validation the caller
        - ChannelType: integer
          Channel identifier from where the TXN has originated (Internet, Mobile, ATM, Branch Channel )
        - Co-Relationid: integer
          Unique ID for the service invoked, will be set by the TXN system
        - InitiatingSystem: string
          Indicating the initiated system
        - ServiceMode: integer
          Used for branch channel to indicate the type of customer
        - UUIDSeqNo: integer
          UUID Sequence Number
        - entity: string
          entity
        - languageCode: integer
          languageCode
        - referenceId: string
          Place holder forToken based authetication
        - requesthash: string
          Request payload for hash validation
        - userId: integer
          userId
        
        
        """
        
        
        # Prepare request data
        
        # Single body parameter - send directly
        data = request_body if request_body is not None else {}
        
        
        
        # Prepare query parameters
        params = {}
        
        
        # Replace path parameters in URL
        path = "/accountManagement/account/productswitch"
        
        
        # Prepare headers
        headers = {}
        if accesstoken is not None:
            headers["Accesstoken"] = str(accesstoken)
        if channeltype is not None:
            headers["ChannelType"] = str(channeltype)
        if co_relationid is not None:
            headers["Co-Relationid"] = str(co_relationid)
        if initiatingsystem is not None:
            headers["InitiatingSystem"] = str(initiatingsystem)
        if servicemode is not None:
            headers["ServiceMode"] = str(servicemode)
        if uuidseqno is not None:
            headers["UUIDSeqNo"] = str(uuidseqno)
        if entity is not None:
            headers["entity"] = str(entity)
        if languagecode is not None:
            headers["languageCode"] = str(languagecode)
        if referenceid is not None:
            headers["referenceId"] = str(referenceid)
        if requesthash is not None:
            headers["requesthash"] = str(requesthash)
        if userid is not None:
            headers["userId"] = str(userid)
        
        
        return await make_api_request(
            "POST", 
            path, 
            data=data, 
            params=params if params else None, 
            headers=headers if headers else None
        )
    
    
    
    @mcp.tool()
    async def ambt8011_gen_resr_req1_using_post(
        request_body:Dict[str, Any] ,  # accountReservationResource,
        channeltype: Optional[int] = None,
        co_relationid: Optional[int] = None,
        initiatingsystem: Optional[str] = None,
        servicemode: Optional[int] = None,
        uuidseqno: Optional[int] = None,
        entity: Optional[str] = None,
        languagecode: Optional[int] = None,
        userid: Optional[int] = None
    ) -> Dict[str, Any]:
        """
        API To Create Account Reservation Request for CASA and Term Deposit
        
        Generated from: POST /accountManagement/account/reservationRequest
        Source: swagger_2_0
        Operation ID: AMBT8011GenResrReq1UsingPOST
        
        
        Authentication: Not required
        
        Parameters:
        - request_body: any (required)
          input
        
        
        
        Headers:
        - ChannelType: integer
          Channel identifier from where the TXN has originated (Internet, Mobile, ATM, Branch Channel )
        - Co-Relationid: integer
          Unique ID for the service invoked, will be set by the TXN system
        - InitiatingSystem: string
          Indicating the initiated system
        - ServiceMode: integer
          Used for branch channel to indicate the type of customer
        - UUIDSeqNo: integer
          UUID Sequence Number
        - entity: string
          entity
        - languageCode: integer
          languageCode
        - userId: integer
          userId
        
        
        """
        
        
        # Prepare request data
        
        # Single body parameter - send directly
        data = request_body if request_body is not None else {}
        
        
        
        # Prepare query parameters
        params = {}
        
        
        # Replace path parameters in URL
        path = "/accountManagement/account/reservationRequest"
        
        
        # Prepare headers
        headers = {}
        if channeltype is not None:
            headers["ChannelType"] = str(channeltype)
        if co_relationid is not None:
            headers["Co-Relationid"] = str(co_relationid)
        if initiatingsystem is not None:
            headers["InitiatingSystem"] = str(initiatingsystem)
        if servicemode is not None:
            headers["ServiceMode"] = str(servicemode)
        if uuidseqno is not None:
            headers["UUIDSeqNo"] = str(uuidseqno)
        if entity is not None:
            headers["entity"] = str(entity)
        if languagecode is not None:
            headers["languageCode"] = str(languagecode)
        if userid is not None:
            headers["userId"] = str(userid)
        
        
        return await make_api_request(
            "POST", 
            path, 
            data=data, 
            params=params if params else None, 
            headers=headers if headers else None
        )
    
    
    
    @mcp.tool()
    async def brbtrequest_acnt_statmnt_using_post(
        request_body:Dict[str, Any] ,  # AccountStatementReportRequest_Resource,
        accesstoken: Optional[str] = None,
        channeltype: Optional[int] = None,
        co_relationid: Optional[int] = None,
        initiatingsystem: Optional[str] = None,
        servicemode: Optional[int] = None,
        uuidseqno: Optional[int] = None,
        entity: Optional[str] = None,
        languagecode: Optional[int] = None,
        referenceid: Optional[str] = None,
        requesthash: Optional[str] = None,
        userid: Optional[int] = None
    ) -> Dict[str, Any]:
        """
        This API makes a request for Account Statement Report
        
        Generated from: POST /accountManagement/account/statementReport
        Source: swagger_2_0
        Operation ID: BRBTRequestAcntStatmntUsingPOST
        
        
        Authentication: Not required
        
        Parameters:
        - request_body: any (required)
          input
        
        
        
        Headers:
        - Accesstoken: string
          Authorization token for identification of the caller
        - ChannelType: integer
          Channel identifier from where the TXN has originated (Internet, Mobile, ATM, Branch Channel )
        - Co-Relationid: integer
          Unique ID for the service invoked, will be set by the TXN system
        - InitiatingSystem: string
          Indicating the initiated system
        - ServiceMode: integer
          Used for branch channel to indicate the type of customer
        - UUIDSeqNo: integer
          UUID Sequence Number
        - entity: string
          entity
        - languageCode: integer
          languageCode
        - referenceId: string
          Place holder for Token based authentication
        - requesthash: string
          Request payload for hash validation
        - userId: integer
          userId
        
        
        """
        
        
        # Prepare request data
        
        # Single body parameter - send directly
        data = request_body if request_body is not None else {}
        
        
        
        # Prepare query parameters
        params = {}
        
        
        # Replace path parameters in URL
        path = "/accountManagement/account/statementReport"
        
        
        # Prepare headers
        headers = {}
        if accesstoken is not None:
            headers["Accesstoken"] = str(accesstoken)
        if channeltype is not None:
            headers["ChannelType"] = str(channeltype)
        if co_relationid is not None:
            headers["Co-Relationid"] = str(co_relationid)
        if initiatingsystem is not None:
            headers["InitiatingSystem"] = str(initiatingsystem)
        if servicemode is not None:
            headers["ServiceMode"] = str(servicemode)
        if uuidseqno is not None:
            headers["UUIDSeqNo"] = str(uuidseqno)
        if entity is not None:
            headers["entity"] = str(entity)
        if languagecode is not None:
            headers["languageCode"] = str(languagecode)
        if referenceid is not None:
            headers["referenceId"] = str(referenceid)
        if requesthash is not None:
            headers["requesthash"] = str(requesthash)
        if userid is not None:
            headers["userId"] = str(userid)
        
        
        return await make_api_request(
            "POST", 
            path, 
            data=data, 
            params=params if params else None, 
            headers=headers if headers else None
        )
    
    
    
    @mcp.tool()
    async def cbcet2001_calc_rngbal_using_get(
        accountreference: str,
        customerid: Optional[int] = None,
        extensibilitymap: Optional[str] = None,
        fromamount: Optional[float] = None,
        fromdate: Optional[str] = None,
        movementdescription: Optional[str] = None,
        pagenum: Optional[int] = None,
        pagesize: Optional[int] = None,
        toamount: Optional[float] = None,
        todate: Optional[str] = None,
        transactionaccounttype: Optional[int] = None,
        transactionid: Optional[str] = None,
        transactiontype: Optional[int] = None,
        accesstoken: Optional[str] = None,
        channeltype: Optional[int] = None,
        co_relationid: Optional[int] = None,
        initiatingsystem: Optional[str] = None,
        servicemode: Optional[int] = None,
        uuidseqno: Optional[int] = None,
        entity: Optional[str] = None,
        languagecode: Optional[int] = None,
        referenceid: Optional[str] = None,
        userid: Optional[int] = None
    ) -> Dict[str, Any]:
        """
        Fetch Transaction History
        
        Generated from: GET /accountManagement/account/transactionHistory/{accountReference}
        Source: swagger_2_0
        Operation ID: CBCET2001CalcRNGBalUsingGET
        
        
        Authentication: Not required
        
        Parameters:
        - accountReference: string (required)
          Enter the Account Reference
        - customerId: integer
          Enter the Customer Reference for whom transactions to be fetched(Applicable for Joint Accounts)
        - extensibilityMap: string
          Custom key - value pair of attributes for extensibility enablement
        - fromAmount: number
          Enter the From amount of the transaction
        - fromDate: string
          Enter the From Date(format:YYYYMMDD)
        - movementDescription: string
          Movement Description
        - pageNum: integer
          pageNum
        - pageSize: integer
          pageSize
        - toAmount: number
          enter the To amount of the transaction
        - toDate: string
          Enter the To Date(format:YYYYMMDD)
        - transactionAccountType: integer
          Enter the transaction account type in the transaction (Domain Name: d_CrDrFlg) Eg : 1-Credit, 2-Debit
        - transactionId: string
          Transaction Id
        - transactionType: integer
          Enter the transaction type of the transaction (Domain Name: d_PosTyp) Eg : 1 - OnHold, 117 - Invoice Application, 126 - AME, 1369 - DownPayment
        
        
        
        Headers:
        - Accesstoken: string
          Authorization token for identification of the caller
        - ChannelType: integer
          Channel identifier from where the TXN has originated (Internet, Mobile, ATM, Branch Channel )
        - Co-Relationid: integer
          Unique ID for the service invoked, will be set by the TXN system
        - InitiatingSystem: string
          Indicating the initiated system
        - ServiceMode: integer
          Used for branch channel to indicate the type of customer
        - UUIDSeqNo: integer
          UUID Sequence Number
        - entity: string
          entity
        - languageCode: integer
          languageCode
        - referenceId: string
          Place holder for Token based authentication
        - userId: integer
          userId
        
        
        """
        
        
        # Prepare query parameters
        params = {}
        if customerid is not None:
            params["customerId"] = customerid
            
        if extensibilitymap is not None:
            params["extensibilityMap"] = extensibilitymap
            
        if fromamount is not None:
            params["fromAmount"] = fromamount
            
        if fromdate is not None:
            params["fromDate"] = fromdate
            
        if movementdescription is not None:
            params["movementDescription"] = movementdescription
            
        if pagenum is not None:
            params["pageNum"] = pagenum
            
        if pagesize is not None:
            params["pageSize"] = pagesize
            
        if toamount is not None:
            params["toAmount"] = toamount
            
        if todate is not None:
            params["toDate"] = todate
            
        if transactionaccounttype is not None:
            params["transactionAccountType"] = transactionaccounttype
            
        if transactionid is not None:
            params["transactionId"] = transactionid
            
        if transactiontype is not None:
            params["transactionType"] = transactiontype
            
        
        
        # Replace path parameters in URL
        path = "/accountManagement/account/transactionHistory/{accountReference}"
        if accountreference is not None:
            path = path.replace("{accountReference}", str(accountreference))
        
        
        # Prepare headers
        headers = {}
        if accesstoken is not None:
            headers["Accesstoken"] = str(accesstoken)
        if channeltype is not None:
            headers["ChannelType"] = str(channeltype)
        if co_relationid is not None:
            headers["Co-Relationid"] = str(co_relationid)
        if initiatingsystem is not None:
            headers["InitiatingSystem"] = str(initiatingsystem)
        if servicemode is not None:
            headers["ServiceMode"] = str(servicemode)
        if uuidseqno is not None:
            headers["UUIDSeqNo"] = str(uuidseqno)
        if entity is not None:
            headers["entity"] = str(entity)
        if languagecode is not None:
            headers["languageCode"] = str(languagecode)
        if referenceid is not None:
            headers["referenceId"] = str(referenceid)
        if userid is not None:
            headers["userId"] = str(userid)
        
        
        return await make_api_request(
            "GET", 
            path, 
            
            params=params if params else None, 
            headers=headers if headers else None
        )
    
    
    
    @mcp.tool()
    async def cbpetgettransactions_using_get(
        accountreference: str,
        accesstoken: Optional[str] = None,
        channeltype: Optional[int] = None,
        co_relationid: Optional[int] = None,
        initiatingsystem: Optional[str] = None,
        servicemode: Optional[int] = None,
        uuidseqno: Optional[int] = None,
        entity: Optional[str] = None,
        languagecode: Optional[int] = None,
        referenceid: Optional[str] = None,
        userid: Optional[int] = None
    ) -> Dict[str, Any]:
        """
        Fetch Account Transactions
        
        Generated from: GET /accountManagement/account/transactions/{accountReference}
        Source: swagger_2_0
        Operation ID: CBPETGettransactionsUsingGET
        
        
        Authentication: Not required
        
        Parameters:
        - accountReference: string (required)
          Enter the Account Reference
        
        
        
        Headers:
        - Accesstoken: string
          Authorization token for identification of the caller
        - ChannelType: integer
          Channel identifier from where the TXN has originated (Internet, Mobile, ATM, Branch Channel )
        - Co-Relationid: integer
          Unique ID for the service invoked, will be set by the TXN system
        - InitiatingSystem: string
          Indicating the initiated system
        - ServiceMode: integer
          Used for branch channel to indicate the type of customer
        - UUIDSeqNo: integer
          UUID Sequence Number
        - entity: string
          entity
        - languageCode: integer
          languageCode
        - referenceId: string
          Place holder for Token based authentication
        - userId: integer
          userId
        
        
        """
        
        
        # Prepare query parameters
        params = {}
        
        
        # Replace path parameters in URL
        path = "/accountManagement/account/transactions/{accountReference}"
        if accountreference is not None:
            path = path.replace("{accountReference}", str(accountreference))
        
        
        # Prepare headers
        headers = {}
        if accesstoken is not None:
            headers["Accesstoken"] = str(accesstoken)
        if channeltype is not None:
            headers["ChannelType"] = str(channeltype)
        if co_relationid is not None:
            headers["Co-Relationid"] = str(co_relationid)
        if initiatingsystem is not None:
            headers["InitiatingSystem"] = str(initiatingsystem)
        if servicemode is not None:
            headers["ServiceMode"] = str(servicemode)
        if uuidseqno is not None:
            headers["UUIDSeqNo"] = str(uuidseqno)
        if entity is not None:
            headers["entity"] = str(entity)
        if languagecode is not None:
            headers["languageCode"] = str(languagecode)
        if referenceid is not None:
            headers["referenceId"] = str(referenceid)
        if userid is not None:
            headers["userId"] = str(userid)
        
        
        return await make_api_request(
            "GET", 
            path, 
            
            params=params if params else None, 
            headers=headers if headers else None
        )
    
    
    
    @mcp.tool()
    async def rstetview_acnt_actv_postusing_get(
        accountreference: str,
        pagenum: Optional[int] = None,
        pagesize: Optional[int] = None,
        accesstoken: Optional[str] = None,
        channeltype: Optional[int] = None,
        co_relationid: Optional[int] = None,
        initiatingsystem: Optional[str] = None,
        servicemode: Optional[int] = None,
        uuidseqno: Optional[int] = None,
        entity: Optional[str] = None,
        languagecode: Optional[int] = None,
        referenceid: Optional[str] = None,
        userid: Optional[int] = None
    ) -> Dict[str, Any]:
        """
        View Account Details
        
        Generated from: GET /accountManagement/account/view
        Source: swagger_2_0
        Operation ID: RSTETViewAcntActv_POSTUsingGET
        
        
        Authentication: Not required
        
        Parameters:
        - accountReference: string (required)
          Reference Number generated for account based on the configured scheme
        - pageNum: integer
          pageNum
        - pageSize: integer
          pageSize
        
        
        
        Headers:
        - Accesstoken: string
          Authorization token for identification of the caller
        - ChannelType: integer
          Channel identifier from where the TXN has originated (Internet, Mobile, ATM, Branch Channel )
        - Co-Relationid: integer
          Unique ID for the service invoked, will be set by the TXN system
        - InitiatingSystem: string
          Indicating the initiated system
        - ServiceMode: integer
          Used for branch channel to indicate the type of customer
        - UUIDSeqNo: integer
          UUID Sequence Number
        - entity: string
          entity
        - languageCode: integer
          languageCode
        - referenceId: string
          Place holder for Token based authentication
        - userId: integer
          userId
        
        
        """
        
        
        # Prepare query parameters
        params = {}
        if accountreference is not None:
            params["accountReference"] = accountreference
            
        if pagenum is not None:
            params["pageNum"] = pagenum
            
        if pagesize is not None:
            params["pageSize"] = pagesize
            
        
        
        # Replace path parameters in URL
        path = "/accountManagement/account/view"
        
        
        # Prepare headers
        headers = {}
        if accesstoken is not None:
            headers["Accesstoken"] = str(accesstoken)
        if channeltype is not None:
            headers["ChannelType"] = str(channeltype)
        if co_relationid is not None:
            headers["Co-Relationid"] = str(co_relationid)
        if initiatingsystem is not None:
            headers["InitiatingSystem"] = str(initiatingsystem)
        if servicemode is not None:
            headers["ServiceMode"] = str(servicemode)
        if uuidseqno is not None:
            headers["UUIDSeqNo"] = str(uuidseqno)
        if entity is not None:
            headers["entity"] = str(entity)
        if languagecode is not None:
            headers["languageCode"] = str(languagecode)
        if referenceid is not None:
            headers["referenceId"] = str(referenceid)
        if userid is not None:
            headers["userId"] = str(userid)
        
        
        return await make_api_request(
            "GET", 
            path, 
            
            params=params if params else None, 
            headers=headers if headers else None
        )
    
    
    
    @mcp.tool()
    async def ambtauthorize_crypto_blk_adrs_postusing_post(
        accountreference: str,
        accesstoken: Optional[str] = None,
        channeltype: Optional[int] = None,
        co_relationid: Optional[int] = None,
        initiatingsystem: Optional[str] = None,
        servicemode: Optional[int] = None,
        uuidseqno: Optional[int] = None,
        entity: Optional[str] = None,
        languagecode: Optional[int] = None,
        referenceid: Optional[str] = None,
        requesthash: Optional[str] = None,
        userid: Optional[int] = None
    ) -> Dict[str, Any]:
        """
        Authorize Crypto Block Address
        
        Generated from: POST /accountManagement/account/{accountReference}/cryptoDetails/authorize
        Source: swagger_2_0
        Operation ID: AMBTAuthorizeCryptoBlkAdrs_POSTUsingPOST
        
        
        Authentication: Not required
        
        Parameters:
        - accountReference: string (required)
          BBAN Number of Account for which Crypto Details has to be Authorized
        
        
        
        Headers:
        - Accesstoken: string
          Authorization token for identification of the caller
        - ChannelType: integer
          Channel identifier from where the TXN has originated (Internet, Mobile, ATM, Branch Channel )
        - Co-Relationid: integer
          Unique ID for the service invoked, will be set by the TXN system
        - InitiatingSystem: string
          Indicating the initiated system
        - ServiceMode: integer
          Used for branch channel to indicate the type of customer
        - UUIDSeqNo: integer
          UUID Sequence Number
        - entity: string
          entity
        - languageCode: integer
          languageCode
        - referenceId: string
          Place holder for Token based authentication
        - requesthash: string
          Request payload for hash validation
        - userId: integer
          userId
        
        
        """
        
        
        # Prepare query parameters
        params = {}
        
        
        # Replace path parameters in URL
        path = "/accountManagement/account/{accountReference}/cryptoDetails/authorize"
        if accountreference is not None:
            path = path.replace("{accountReference}", str(accountreference))
        
        
        # Prepare headers
        headers = {}
        if accesstoken is not None:
            headers["Accesstoken"] = str(accesstoken)
        if channeltype is not None:
            headers["ChannelType"] = str(channeltype)
        if co_relationid is not None:
            headers["Co-Relationid"] = str(co_relationid)
        if initiatingsystem is not None:
            headers["InitiatingSystem"] = str(initiatingsystem)
        if servicemode is not None:
            headers["ServiceMode"] = str(servicemode)
        if uuidseqno is not None:
            headers["UUIDSeqNo"] = str(uuidseqno)
        if entity is not None:
            headers["entity"] = str(entity)
        if languagecode is not None:
            headers["languageCode"] = str(languagecode)
        if referenceid is not None:
            headers["referenceId"] = str(referenceid)
        if requesthash is not None:
            headers["requesthash"] = str(requesthash)
        if userid is not None:
            headers["userId"] = str(userid)
        
        
        return await make_api_request(
            "POST", 
            path, 
            
            params=params if params else None, 
            headers=headers if headers else None
        )
    
    
    
    @mcp.tool()
    async def ambtreject_crypto_blk_adrs_postusing_post(
        accountreference: str,
        accesstoken: Optional[str] = None,
        channeltype: Optional[int] = None,
        co_relationid: Optional[int] = None,
        initiatingsystem: Optional[str] = None,
        servicemode: Optional[int] = None,
        uuidseqno: Optional[int] = None,
        entity: Optional[str] = None,
        languagecode: Optional[int] = None,
        referenceid: Optional[str] = None,
        requesthash: Optional[str] = None,
        userid: Optional[int] = None
    ) -> Dict[str, Any]:
        """
        Reject Crypto Block Address
        
        Generated from: POST /accountManagement/account/{accountReference}/cryptoDetails/reject
        Source: swagger_2_0
        Operation ID: AMBTRejectCryptoBlkAdrs_POSTUsingPOST
        
        
        Authentication: Not required
        
        Parameters:
        - accountReference: string (required)
          BBAN Number of Account for which Crypto Details has to be Authorized
        
        
        
        Headers:
        - Accesstoken: string
          Authorization token for identification of the caller
        - ChannelType: integer
          Channel identifier from where the TXN has originated (Internet, Mobile, ATM, Branch Channel )
        - Co-Relationid: integer
          Unique ID for the service invoked, will be set by the TXN system
        - InitiatingSystem: string
          Indicating the initiated system
        - ServiceMode: integer
          Used for branch channel to indicate the type of customer
        - UUIDSeqNo: integer
          UUID Sequence Number
        - entity: string
          entity
        - languageCode: integer
          languageCode
        - referenceId: string
          Place holder for Token based authentication
        - requesthash: string
          Request payload for hash validation
        - userId: integer
          userId
        
        
        """
        
        
        # Prepare query parameters
        params = {}
        
        
        # Replace path parameters in URL
        path = "/accountManagement/account/{accountReference}/cryptoDetails/reject"
        if accountreference is not None:
            path = path.replace("{accountReference}", str(accountreference))
        
        
        # Prepare headers
        headers = {}
        if accesstoken is not None:
            headers["Accesstoken"] = str(accesstoken)
        if channeltype is not None:
            headers["ChannelType"] = str(channeltype)
        if co_relationid is not None:
            headers["Co-Relationid"] = str(co_relationid)
        if initiatingsystem is not None:
            headers["InitiatingSystem"] = str(initiatingsystem)
        if servicemode is not None:
            headers["ServiceMode"] = str(servicemode)
        if uuidseqno is not None:
            headers["UUIDSeqNo"] = str(uuidseqno)
        if entity is not None:
            headers["entity"] = str(entity)
        if languagecode is not None:
            headers["languageCode"] = str(languagecode)
        if referenceid is not None:
            headers["referenceId"] = str(referenceid)
        if requesthash is not None:
            headers["requesthash"] = str(requesthash)
        if userid is not None:
            headers["userId"] = str(userid)
        
        
        return await make_api_request(
            "POST", 
            path, 
            
            params=params if params else None, 
            headers=headers if headers else None
        )
    
    
    
    @mcp.tool()
    async def ambt2021_modfy_acnt_name_using_put(
        accountname: str,
        accountreference: str,
        accesstoken: Optional[str] = None,
        channeltype: Optional[int] = None,
        co_relationid: Optional[int] = None,
        initiatingsystem: Optional[str] = None,
        servicemode: Optional[int] = None,
        uuidseqno: Optional[int] = None,
        entity: Optional[str] = None,
        languagecode: Optional[int] = None,
        referenceid: Optional[str] = None,
        userid: Optional[int] = None
    ) -> Dict[str, Any]:
        """
        Modify account name
        
        Generated from: PUT /accountManagement/account/{accountReference}/{accountName}/name
        Source: swagger_2_0
        Operation ID: AMBT2021ModfyAcntNameUsingPUT
        
        
        Authentication: Not required
        
        Parameters:
        - accountName: string (required)
          Name to replace existing account name [Max Length :- 70 character]
        - accountReference: string (required)
          Account reference number
        
        
        
        Headers:
        - Accesstoken: string
          Authorization Token to validation the caller
        - ChannelType: integer
          Channel identifier from where the TXN has originated (Internet, Mobile, ATM, Branch Channel )
        - Co-Relationid: integer
          Unique ID for the service invoked, will be set by the TXN system
        - InitiatingSystem: string
          Indicating the initiated system
        - ServiceMode: integer
          Used for branch channel to indicate the type of customer
        - UUIDSeqNo: integer
          UUID Sequence Number
        - entity: string
          entity
        - languageCode: integer
          languageCode
        - referenceId: string
          Place holder for Token based authentication
        - userId: integer
          userId
        
        
        """
        
        
        # Prepare query parameters
        params = {}
        
        
        # Replace path parameters in URL
        path = "/accountManagement/account/{accountReference}/{accountName}/name"
        if accountname is not None:
            path = path.replace("{accountName}", str(accountname))
        if accountreference is not None:
            path = path.replace("{accountReference}", str(accountreference))
        
        
        # Prepare headers
        headers = {}
        if accesstoken is not None:
            headers["Accesstoken"] = str(accesstoken)
        if channeltype is not None:
            headers["ChannelType"] = str(channeltype)
        if co_relationid is not None:
            headers["Co-Relationid"] = str(co_relationid)
        if initiatingsystem is not None:
            headers["InitiatingSystem"] = str(initiatingsystem)
        if servicemode is not None:
            headers["ServiceMode"] = str(servicemode)
        if uuidseqno is not None:
            headers["UUIDSeqNo"] = str(uuidseqno)
        if entity is not None:
            headers["entity"] = str(entity)
        if languagecode is not None:
            headers["languageCode"] = str(languagecode)
        if referenceid is not None:
            headers["referenceId"] = str(referenceid)
        if userid is not None:
            headers["userId"] = str(userid)
        
        
        return await make_api_request(
            "PUT", 
            path, 
            
            params=params if params else None, 
            headers=headers if headers else None
        )
    
    
    
    @mcp.tool()
    async def rstbt2010_acnt_clsr_rls_postusing_post(
        request_body:Dict[str, Any] ,  # acntClsrRlsResource,
        accesstoken: Optional[str] = None,
        channeltype: Optional[int] = None,
        co_relationid: Optional[int] = None,
        initiatingsystem: Optional[str] = None,
        servicemode: Optional[int] = None,
        uuidseqno: Optional[int] = None,
        entity: Optional[str] = None,
        languagecode: Optional[int] = None,
        referenceid: Optional[str] = None,
        userid: Optional[int] = None
    ) -> Dict[str, Any]:
        """
        This API is used to close account before activation
        
        Generated from: POST /accountManagement/accountClosureBeforeActivation
        Source: swagger_2_0
        Operation ID: RSTBT2010AcntClsrRls_POSTUsingPOST
        
        
        Authentication: Not required
        
        Parameters:
        - request_body: any (required)
          input
        
        
        
        Headers:
        - Accesstoken: string
          Authorization token for identification of the caller
        - ChannelType: integer
          Channel identifier from where the TXN has originated (Internet, Mobile, ATM, Branch Channel )
        - Co-Relationid: integer
          Unique ID for the service invoked, will be set by the TXN system
        - InitiatingSystem: string
          Indicating the initiated system
        - ServiceMode: integer
          Used for branch channel to indicate the type of customer
        - UUIDSeqNo: integer
          UUID Sequence Number
        - entity: string
          entity
        - languageCode: integer
          languageCode
        - referenceId: string
          Place holder for Token based authentication
        - userId: integer
          userId
        
        
        """
        
        
        # Prepare request data
        
        # Single body parameter - send directly
        data = request_body if request_body is not None else {}
        
        
        
        # Prepare query parameters
        params = {}
        
        
        # Replace path parameters in URL
        path = "/accountManagement/accountClosureBeforeActivation"
        
        
        # Prepare headers
        headers = {}
        if accesstoken is not None:
            headers["Accesstoken"] = str(accesstoken)
        if channeltype is not None:
            headers["ChannelType"] = str(channeltype)
        if co_relationid is not None:
            headers["Co-Relationid"] = str(co_relationid)
        if initiatingsystem is not None:
            headers["InitiatingSystem"] = str(initiatingsystem)
        if servicemode is not None:
            headers["ServiceMode"] = str(servicemode)
        if uuidseqno is not None:
            headers["UUIDSeqNo"] = str(uuidseqno)
        if entity is not None:
            headers["entity"] = str(entity)
        if languagecode is not None:
            headers["languageCode"] = str(languagecode)
        if referenceid is not None:
            headers["referenceId"] = str(referenceid)
        if userid is not None:
            headers["userId"] = str(userid)
        
        
        return await make_api_request(
            "POST", 
            path, 
            data=data, 
            params=params if params else None, 
            headers=headers if headers else None
        )
    
    
    
    @mcp.tool()
    async def amto5202_crt_acnt_cls_released_postusing_post(
        accountreference: str,
        request_body:Dict[str, Any] ,  # AccountCloserOrderDetailsRequest,
        accesstoken: Optional[str] = None,
        channeltype: Optional[int] = None,
        co_relationid: Optional[int] = None,
        initiatingsystem: Optional[str] = None,
        servicemode: Optional[int] = None,
        uuidseqno: Optional[int] = None,
        entity: Optional[str] = None,
        languagecode: Optional[int] = None,
        referenceid: Optional[str] = None,
        userid: Optional[int] = None
    ) -> Dict[str, Any]:
        """
        Account Closure Initiation
        
        Generated from: POST /accountManagement/accountClosureInitiation/{accountReference}
        Source: swagger_2_0
        Operation ID: AMTO5202CrtAcntClsReleased_POSTUsingPOST
        
        
        Authentication: Not required
        
        Parameters:
        - accountReference: string (required)
          Account Reference
        - request_body: any (required)
          input
        
        
        
        Headers:
        - Accesstoken: string
          Authorization token for identification of the caller
        - ChannelType: integer
          Channel identifier from where the TXN has originated (Internet, Mobile, ATM, Branch Channel )
        - Co-Relationid: integer
          Unique ID for the service invoked, will be set by the TXN system
        - InitiatingSystem: string
          Indicating the initiated system
        - ServiceMode: integer
          Used for branch channel to indicate the type of customer
        - UUIDSeqNo: integer
          UUID Sequence Number
        - entity: string
          entity
        - languageCode: integer
          languageCode
        - referenceId: string
          Place holder for Token based authentication
        - userId: integer
          userId
        
        
        """
        
        
        # Prepare request data
        
        # Single body parameter - send directly
        data = request_body if request_body is not None else {}
        
        
        
        # Prepare query parameters
        params = {}
        
        
        # Replace path parameters in URL
        path = "/accountManagement/accountClosureInitiation/{accountReference}"
        if accountreference is not None:
            path = path.replace("{accountReference}", str(accountreference))
        
        
        # Prepare headers
        headers = {}
        if accesstoken is not None:
            headers["Accesstoken"] = str(accesstoken)
        if channeltype is not None:
            headers["ChannelType"] = str(channeltype)
        if co_relationid is not None:
            headers["Co-Relationid"] = str(co_relationid)
        if initiatingsystem is not None:
            headers["InitiatingSystem"] = str(initiatingsystem)
        if servicemode is not None:
            headers["ServiceMode"] = str(servicemode)
        if uuidseqno is not None:
            headers["UUIDSeqNo"] = str(uuidseqno)
        if entity is not None:
            headers["entity"] = str(entity)
        if languagecode is not None:
            headers["languageCode"] = str(languagecode)
        if referenceid is not None:
            headers["referenceId"] = str(referenceid)
        if userid is not None:
            headers["userId"] = str(userid)
        
        
        return await make_api_request(
            "POST", 
            path, 
            data=data, 
            params=params if params else None, 
            headers=headers if headers else None
        )
    
    
    
    @mcp.tool()
    async def amto5201_validate_acnt_cls_dtls_postusing_get(
        accountreference: str,
        provisionalclosingoption: int,
        losscertificateamount: Optional[float] = None,
        provisionalclosingbalance: Optional[float] = None,
        substitutionaccountreference: Optional[str] = None,
        tentativeclosingdate: Optional[str] = None,
        accesstoken: Optional[str] = None,
        channeltype: Optional[int] = None,
        co_relationid: Optional[int] = None,
        initiatingsystem: Optional[str] = None,
        servicemode: Optional[int] = None,
        uuidseqno: Optional[int] = None,
        entity: Optional[str] = None,
        languagecode: Optional[int] = None,
        referenceid: Optional[str] = None,
        userid: Optional[int] = None
    ) -> Dict[str, Any]:
        """
        Account Closure validation
        
        Generated from: GET /accountManagement/accountClosureValidation/{accountReference}
        Source: swagger_2_0
        Operation ID: AMTO5201ValidateAcntClsDtls_POSTUsingGET
        
        
        Authentication: Not required
        
        Parameters:
        - accountReference: string (required)
          Account Reference
        - lossCertificateAmount: number
          Loss Certificate Amount
        - provisionalClosingBalance: number
          Provisional Closing Balance
        - provisionalClosingOption: integer (required)
          Provisional Closing Option(d_ProvClosingoption)Example :-  1-Giro Domestic Post, 2-Within Bank, 3-Cash Payout of Internal Origin,4-Giro International
        - substitutionAccountReference: string
          Substitution Account Reference
        - tentativeClosingDate: string
          Tentative Closing Date (Date format : YYYYMMDD)
        
        
        
        Headers:
        - Accesstoken: string
          Authorization token for identification of the caller
        - ChannelType: integer
          Channel identifier from where the TXN has originated (Internet, Mobile, ATM, Branch Channel )
        - Co-Relationid: integer
          Unique ID for the service invoked, will be set by the TXN system
        - InitiatingSystem: string
          Indicating the initiated system
        - ServiceMode: integer
          Used for branch channel to indicate the type of customer
        - UUIDSeqNo: integer
          UUID Sequence Number
        - entity: string
          entity
        - languageCode: integer
          languageCode
        - referenceId: string
          Place holder for Token based authentication
        - userId: integer
          userId
        
        
        """
        
        
        # Prepare query parameters
        params = {}
        if losscertificateamount is not None:
            params["lossCertificateAmount"] = losscertificateamount
            
        if provisionalclosingbalance is not None:
            params["provisionalClosingBalance"] = provisionalclosingbalance
            
        if provisionalclosingoption is not None:
            params["provisionalClosingOption"] = provisionalclosingoption
            
        if substitutionaccountreference is not None:
            params["substitutionAccountReference"] = substitutionaccountreference
            
        if tentativeclosingdate is not None:
            params["tentativeClosingDate"] = tentativeclosingdate
            
        
        
        # Replace path parameters in URL
        path = "/accountManagement/accountClosureValidation/{accountReference}"
        if accountreference is not None:
            path = path.replace("{accountReference}", str(accountreference))
        
        
        # Prepare headers
        headers = {}
        if accesstoken is not None:
            headers["Accesstoken"] = str(accesstoken)
        if channeltype is not None:
            headers["ChannelType"] = str(channeltype)
        if co_relationid is not None:
            headers["Co-Relationid"] = str(co_relationid)
        if initiatingsystem is not None:
            headers["InitiatingSystem"] = str(initiatingsystem)
        if servicemode is not None:
            headers["ServiceMode"] = str(servicemode)
        if uuidseqno is not None:
            headers["UUIDSeqNo"] = str(uuidseqno)
        if entity is not None:
            headers["entity"] = str(entity)
        if languagecode is not None:
            headers["languageCode"] = str(languagecode)
        if referenceid is not None:
            headers["referenceId"] = str(referenceid)
        if userid is not None:
            headers["userId"] = str(userid)
        
        
        return await make_api_request(
            "GET", 
            path, 
            
            params=params if params else None, 
            headers=headers if headers else None
        )
    
    
    
    @mcp.tool()
    async def amet8290_acnt_dtls_reln_postusing_get(
        accountreference: str,
        accesstoken: Optional[str] = None,
        channeltype: Optional[int] = None,
        co_relationid: Optional[int] = None,
        initiatingsystem: Optional[str] = None,
        servicemode: Optional[int] = None,
        uuidseqno: Optional[int] = None,
        entity: Optional[str] = None,
        languagecode: Optional[int] = None,
        referenceid: Optional[str] = None,
        userid: Optional[int] = None
    ) -> Dict[str, Any]:
        """
        Get Account Relations
        
        Generated from: GET /accountManagement/accountDetailsRelation/{accountReference}
        Source: swagger_2_0
        Operation ID: AMET8290AcntDtlsReln_POSTUsingGET
        
        
        Authentication: Not required
        
        Parameters:
        - accountReference: string (required)
          Unique Reference for the Account
        
        
        
        Headers:
        - Accesstoken: string
          Authorization Token to validation the caller
        - ChannelType: integer
          Channel identifier from where the TXN has originated (Internet, Mobile, ATM, Branch Channel )
        - Co-Relationid: integer
          Unique ID for the service invoked, will be set by the TXN system
        - InitiatingSystem: string
          Indicating the initiated system
        - ServiceMode: integer
          Used for branch channel to indicate the type of customer
        - UUIDSeqNo: integer
          UUID Sequence Number
        - entity: string
          entity
        - languageCode: integer
          languageCode
        - referenceId: string
          Place holder for Token based authentication
        - userId: integer
          userId
        
        
        """
        
        
        # Prepare query parameters
        params = {}
        
        
        # Replace path parameters in URL
        path = "/accountManagement/accountDetailsRelation/{accountReference}"
        if accountreference is not None:
            path = path.replace("{accountReference}", str(accountreference))
        
        
        # Prepare headers
        headers = {}
        if accesstoken is not None:
            headers["Accesstoken"] = str(accesstoken)
        if channeltype is not None:
            headers["ChannelType"] = str(channeltype)
        if co_relationid is not None:
            headers["Co-Relationid"] = str(co_relationid)
        if initiatingsystem is not None:
            headers["InitiatingSystem"] = str(initiatingsystem)
        if servicemode is not None:
            headers["ServiceMode"] = str(servicemode)
        if uuidseqno is not None:
            headers["UUIDSeqNo"] = str(uuidseqno)
        if entity is not None:
            headers["entity"] = str(entity)
        if languagecode is not None:
            headers["languageCode"] = str(languagecode)
        if referenceid is not None:
            headers["referenceId"] = str(referenceid)
        if userid is not None:
            headers["userId"] = str(userid)
        
        
        return await make_api_request(
            "GET", 
            path, 
            
            params=params if params else None, 
            headers=headers if headers else None
        )
    
    
    
    @mcp.tool()
    async def cbcbt1084_opn_rsrvd_iban_postusing_post(
        request_body:Dict[str, Any] ,  # OpenReservedIBAN_Resource,
        channeltype: Optional[int] = None,
        co_relationid: Optional[int] = None,
        initiatingsystem: Optional[str] = None,
        servicemode: Optional[int] = None,
        uuidseqno: Optional[int] = None,
        entity: Optional[str] = None,
        languagecode: Optional[int] = None,
        userid: Optional[int] = None
    ) -> Dict[str, Any]:
        """
        Account Opening by Reserved IBAN
        
        Generated from: POST /accountManagement/accountManagement/account/OpenReservedIBAN
        Source: swagger_2_0
        Operation ID: CBCBT1084OpnRsrvdIBAN_POSTUsingPOST
        
        
        Authentication: Not required
        
        Parameters:
        - request_body: any (required)
          input
        
        
        
        Headers:
        - ChannelType: integer
          Channel identifier from where the TXN has originated (Internet, Mobile, ATM, Branch Channel )
        - Co-Relationid: integer
          Unique ID for the service invoked, will be set by the TXN system
        - InitiatingSystem: string
          Indicating the initiated system
        - ServiceMode: integer
          Used for branch channel to indicate the type of customer
        - UUIDSeqNo: integer
          UUID Sequence Number
        - entity: string
          entity
        - languageCode: integer
          languageCode
        - userId: integer
          userId
        
        
        """
        
        
        # Prepare request data
        
        # Single body parameter - send directly
        data = request_body if request_body is not None else {}
        
        
        
        # Prepare query parameters
        params = {}
        
        
        # Replace path parameters in URL
        path = "/accountManagement/accountManagement/account/OpenReservedIBAN"
        
        
        # Prepare headers
        headers = {}
        if channeltype is not None:
            headers["ChannelType"] = str(channeltype)
        if co_relationid is not None:
            headers["Co-Relationid"] = str(co_relationid)
        if initiatingsystem is not None:
            headers["InitiatingSystem"] = str(initiatingsystem)
        if servicemode is not None:
            headers["ServiceMode"] = str(servicemode)
        if uuidseqno is not None:
            headers["UUIDSeqNo"] = str(uuidseqno)
        if entity is not None:
            headers["entity"] = str(entity)
        if languagecode is not None:
            headers["languageCode"] = str(languagecode)
        if userid is not None:
            headers["userId"] = str(userid)
        
        
        return await make_api_request(
            "POST", 
            path, 
            data=data, 
            params=params if params else None, 
            headers=headers if headers else None
        )
    
    
    
    @mcp.tool()
    async def fietget_prdt_intrst_rates_getusing_get(
        instrumentid: int,
        extensibilitymap: Optional[str] = None,
        channeltype: Optional[int] = None,
        co_relationid: Optional[int] = None,
        initiatingsystem: Optional[str] = None,
        servicemode: Optional[int] = None,
        uuidseqno: Optional[int] = None,
        entity: Optional[str] = None,
        languagecode: Optional[int] = None,
        userid: Optional[int] = None
    ) -> Dict[str, Any]:
        """
        API to fetch Product Interest Rate
        
        Generated from: GET /accountManagement/accountManagement/account/ProductInterestRate
        Source: swagger_2_0
        Operation ID: FIETGetPrdtIntrstRates_GETUsingGET
        
        
        Authentication: Not required
        
        Parameters:
        - InstrumentId: integer (required)
          Instrument Id
        - extensibilityMap: string
          Custom key - value pair of attributes for extensibility enablement
        
        
        
        Headers:
        - ChannelType: integer
          Channel identifier from where the TXN has originated (Internet, Mobile, ATM, Branch Channel )
        - Co-Relationid: integer
          Unique ID for the service invoked, will be set by the TXN system
        - InitiatingSystem: string
          Indicating the initiated system
        - ServiceMode: integer
          Used for branch channel to indicate the type of customer
        - UUIDSeqNo: integer
          UUID Sequence Number
        - entity: string
          entity
        - languageCode: integer
          languageCode
        - userId: integer
          userId
        
        
        """
        
        
        # Prepare query parameters
        params = {}
        if instrumentid is not None:
            params["InstrumentId"] = instrumentid
            
        if extensibilitymap is not None:
            params["extensibilityMap"] = extensibilitymap
            
        
        
        # Replace path parameters in URL
        path = "/accountManagement/accountManagement/account/ProductInterestRate"
        
        
        # Prepare headers
        headers = {}
        if channeltype is not None:
            headers["ChannelType"] = str(channeltype)
        if co_relationid is not None:
            headers["Co-Relationid"] = str(co_relationid)
        if initiatingsystem is not None:
            headers["InitiatingSystem"] = str(initiatingsystem)
        if servicemode is not None:
            headers["ServiceMode"] = str(servicemode)
        if uuidseqno is not None:
            headers["UUIDSeqNo"] = str(uuidseqno)
        if entity is not None:
            headers["entity"] = str(entity)
        if languagecode is not None:
            headers["languageCode"] = str(languagecode)
        if userid is not None:
            headers["userId"] = str(userid)
        
        
        return await make_api_request(
            "GET", 
            path, 
            
            params=params if params else None, 
            headers=headers if headers else None
        )
    
    
    
    @mcp.tool()
    async def fiet3207_get_prdt_list_getusing_get(
        channeltype: Optional[int] = None,
        co_relationid: Optional[int] = None,
        initiatingsystem: Optional[str] = None,
        servicemode: Optional[int] = None,
        uuidseqno: Optional[int] = None,
        entity: Optional[str] = None,
        languagecode: Optional[int] = None,
        userid: Optional[int] = None
    ) -> Dict[str, Any]:
        """
        API to fetch Product List
        
        Generated from: GET /accountManagement/accountManagement/account/ProductList
        Source: swagger_2_0
        Operation ID: FIET3207GetPrdtList_GETUsingGET
        
        
        Authentication: Not required
        
        Parameters:
        
        
        
        Headers:
        - ChannelType: integer
          Channel identifier from where the TXN has originated (Internet, Mobile, ATM, Branch Channel )
        - Co-Relationid: integer
          Unique ID for the service invoked, will be set by the TXN system
        - InitiatingSystem: string
          Indicating the initiated system
        - ServiceMode: integer
          Used for branch channel to indicate the type of customer
        - UUIDSeqNo: integer
          UUID Sequence Number
        - entity: string
          entity
        - languageCode: integer
          languageCode
        - userId: integer
          userId
        
        
        """
        
        
        # Prepare query parameters
        params = {}
        
        
        # Replace path parameters in URL
        path = "/accountManagement/accountManagement/account/ProductList"
        
        
        # Prepare headers
        headers = {}
        if channeltype is not None:
            headers["ChannelType"] = str(channeltype)
        if co_relationid is not None:
            headers["Co-Relationid"] = str(co_relationid)
        if initiatingsystem is not None:
            headers["InitiatingSystem"] = str(initiatingsystem)
        if servicemode is not None:
            headers["ServiceMode"] = str(servicemode)
        if uuidseqno is not None:
            headers["UUIDSeqNo"] = str(uuidseqno)
        if entity is not None:
            headers["entity"] = str(entity)
        if languagecode is not None:
            headers["languageCode"] = str(languagecode)
        if userid is not None:
            headers["userId"] = str(userid)
        
        
        return await make_api_request(
            "GET", 
            path, 
            
            params=params if params else None, 
            headers=headers if headers else None
        )
    
    
    
    @mcp.tool()
    async def amet0316_get_acnt_dtls_w_postusing_get(
        accountreference: str,
        groupid: Optional[str] = None,
        accesstoken: Optional[str] = None,
        channeltype: Optional[int] = None,
        co_relationid: Optional[int] = None,
        initiatingsystem: Optional[str] = None,
        servicemode: Optional[int] = None,
        uuidseqno: Optional[int] = None,
        entity: Optional[str] = None,
        languagecode: Optional[int] = None,
        referenceid: Optional[str] = None,
        requesthash: Optional[str] = None,
        userid: Optional[int] = None
    ) -> Dict[str, Any]:
        """
        Account Additional Details
        
        Generated from: GET /accountManagement/accountManagement/account/accountRelations/{accountReference}
        Source: swagger_2_0
        Operation ID: AMET0316GetAcntDtlsW_POSTUsingGET
        
        
        Authentication: Not required
        
        Parameters:
        - GroupID: string
          This field is to fetch GroupID
        - accountReference: string (required)
          Reference Number generated for account based on the configured scheme
        
        
        
        Headers:
        - Accesstoken: string
          Authorization token for identification of the caller
        - ChannelType: integer
          Channel identifier from where the TXN has originated (Internet, Mobile, ATM, Branch Channel )
        - Co-Relationid: integer
          Unique ID for the service invoked, will be set by the TXN system
        - InitiatingSystem: string
          Indicating the initiated system
        - ServiceMode: integer
          Used for branch channel to indicate the type of customer
        - UUIDSeqNo: integer
          UUID Sequence Number
        - entity: string
          entity
        - languageCode: integer
          languageCode
        - referenceId: string
          Place holder for Token based authentication
        - requesthash: string
          Request payload for hash validation
        - userId: integer
          userId
        
        
        """
        
        
        # Prepare query parameters
        params = {}
        if groupid is not None:
            params["GroupID"] = groupid
            
        
        
        # Replace path parameters in URL
        path = "/accountManagement/accountManagement/account/accountRelations/{accountReference}"
        if accountreference is not None:
            path = path.replace("{accountReference}", str(accountreference))
        
        
        # Prepare headers
        headers = {}
        if accesstoken is not None:
            headers["Accesstoken"] = str(accesstoken)
        if channeltype is not None:
            headers["ChannelType"] = str(channeltype)
        if co_relationid is not None:
            headers["Co-Relationid"] = str(co_relationid)
        if initiatingsystem is not None:
            headers["InitiatingSystem"] = str(initiatingsystem)
        if servicemode is not None:
            headers["ServiceMode"] = str(servicemode)
        if uuidseqno is not None:
            headers["UUIDSeqNo"] = str(uuidseqno)
        if entity is not None:
            headers["entity"] = str(entity)
        if languagecode is not None:
            headers["languageCode"] = str(languagecode)
        if referenceid is not None:
            headers["referenceId"] = str(referenceid)
        if requesthash is not None:
            headers["requesthash"] = str(requesthash)
        if userid is not None:
            headers["userId"] = str(userid)
        
        
        return await make_api_request(
            "GET", 
            path, 
            
            params=params if params else None, 
            headers=headers if headers else None
        )
    
    
    
    @mcp.tool()
    async def amet0807_view_mandate_matrix_postusing_get(
        accountreference: str,
        pagenum: Optional[int] = None,
        pagesize: Optional[int] = None,
        channeltype: Optional[int] = None,
        co_relationid: Optional[int] = None,
        initiatingsystem: Optional[str] = None,
        servicemode: Optional[int] = None,
        uuidseqno: Optional[int] = None,
        entity: Optional[str] = None,
        languagecode: Optional[int] = None,
        userid: Optional[int] = None
    ) -> Dict[str, Any]:
        """
        List Mandate Matrix Details
        
        Generated from: GET /accountManagement/accountManagement/account/mandateMatrix/{accountReference}
        Source: swagger_2_0
        Operation ID: AMET0807ViewMandateMatrix_POSTUsingGET
        
        
        Authentication: Not required
        
        Parameters:
        - accountReference: string (required)
          Reference Number generated for account based on the configured scheme
        - pageNum: integer
          pageNum
        - pageSize: integer
          pageSize
        
        
        
        Headers:
        - ChannelType: integer
          Channel identifier from where the TXN has originated (Internet, Mobile, ATM, Branch Channel )
        - Co-Relationid: integer
          Unique ID for the service invoked, will be set by the TXN system
        - InitiatingSystem: string
          Indicating the initiated system
        - ServiceMode: integer
          Used for branch channel to indicate the type of customer
        - UUIDSeqNo: integer
          UUID Sequence Number
        - entity: string
          entity
        - languageCode: integer
          languageCode
        - userId: integer
          userId
        
        
        """
        
        
        # Prepare query parameters
        params = {}
        if pagenum is not None:
            params["pageNum"] = pagenum
            
        if pagesize is not None:
            params["pageSize"] = pagesize
            
        
        
        # Replace path parameters in URL
        path = "/accountManagement/accountManagement/account/mandateMatrix/{accountReference}"
        if accountreference is not None:
            path = path.replace("{accountReference}", str(accountreference))
        
        
        # Prepare headers
        headers = {}
        if channeltype is not None:
            headers["ChannelType"] = str(channeltype)
        if co_relationid is not None:
            headers["Co-Relationid"] = str(co_relationid)
        if initiatingsystem is not None:
            headers["InitiatingSystem"] = str(initiatingsystem)
        if servicemode is not None:
            headers["ServiceMode"] = str(servicemode)
        if uuidseqno is not None:
            headers["UUIDSeqNo"] = str(uuidseqno)
        if entity is not None:
            headers["entity"] = str(entity)
        if languagecode is not None:
            headers["languageCode"] = str(languagecode)
        if userid is not None:
            headers["userId"] = str(userid)
        
        
        return await make_api_request(
            "GET", 
            path, 
            
            params=params if params else None, 
            headers=headers if headers else None
        )
    
    
    
    @mcp.tool()
    async def rstbtaccount_re_activation_using_put(
        request_body:Dict[str, Any] ,  # accountReActivationResource,
        accesstoken: Optional[str] = None,
        channeltype: Optional[int] = None,
        co_relationid: Optional[int] = None,
        initiatingsystem: Optional[str] = None,
        servicemode: Optional[int] = None,
        uuidseqno: Optional[int] = None,
        entity: Optional[str] = None,
        languagecode: Optional[int] = None,
        referenceid: Optional[str] = None,
        userid: Optional[int] = None
    ) -> Dict[str, Any]:
        """
        Account re-activation after customer attains majority
        
        Generated from: PUT /accountManagement/accountReActivation
        Source: swagger_2_0
        Operation ID: RSTBTAccountReActivationUsingPUT
        
        
        Authentication: Not required
        
        Parameters:
        - request_body: any (required)
          input
        
        
        
        Headers:
        - Accesstoken: string
          Authorization Token to validation the caller
        - ChannelType: integer
          Channel identifier from where the TXN has originated (Internet, Mobile, ATM, Branch Channel )
        - Co-Relationid: integer
          Unique ID for the service invoked, will be set by the TXN system
        - InitiatingSystem: string
          Indicating the initiated system
        - ServiceMode: integer
          Used for branch channel to indicate the type of customer
        - UUIDSeqNo: integer
          UUID Sequence Number
        - entity: string
          entity
        - languageCode: integer
          languageCode
        - referenceId: string
          Place holder for Token based authentication
        - userId: integer
          userId
        
        
        """
        
        
        # Prepare request data
        
        # Single body parameter - send directly
        data = request_body if request_body is not None else {}
        
        
        
        # Prepare query parameters
        params = {}
        
        
        # Replace path parameters in URL
        path = "/accountManagement/accountReActivation"
        
        
        # Prepare headers
        headers = {}
        if accesstoken is not None:
            headers["Accesstoken"] = str(accesstoken)
        if channeltype is not None:
            headers["ChannelType"] = str(channeltype)
        if co_relationid is not None:
            headers["Co-Relationid"] = str(co_relationid)
        if initiatingsystem is not None:
            headers["InitiatingSystem"] = str(initiatingsystem)
        if servicemode is not None:
            headers["ServiceMode"] = str(servicemode)
        if uuidseqno is not None:
            headers["UUIDSeqNo"] = str(uuidseqno)
        if entity is not None:
            headers["entity"] = str(entity)
        if languagecode is not None:
            headers["languageCode"] = str(languagecode)
        if referenceid is not None:
            headers["referenceId"] = str(referenceid)
        if userid is not None:
            headers["userId"] = str(userid)
        
        
        return await make_api_request(
            "PUT", 
            path, 
            data=data, 
            params=params if params else None, 
            headers=headers if headers else None
        )
    
    
    
    @mcp.tool()
    async def brbt0404_auth_std_set_ins_postusing_put(
        request_body:Dict[str, Any] ,  # authSSIResource,
        accesstoken: Optional[str] = None,
        channeltype: Optional[int] = None,
        co_relationid: Optional[int] = None,
        entity: Optional[str] = None,
        initiatingsystem: Optional[str] = None,
        languagecode: Optional[int] = None,
        referenceid: Optional[str] = None,
        servicemode: Optional[int] = None,
        userid: Optional[int] = None,
        uuidseqno: Optional[int] = None
    ) -> Dict[str, Any]:
        """
        Authorization of Standard Settlement Instruction on Account
        
        Generated from: PUT /accountManagement/accountSSI/authSSI
        Source: swagger_2_0
        Operation ID: BRBT0404AuthStdSetIns_POSTUsingPUT
        
        
        Authentication: Not required
        
        Parameters:
        - request_body: any (required)
          input
        
        
        
        Headers:
        - Accesstoken: string
          Authorization Token to validation the caller
        - ChannelType: integer
          Channel identifier from where the TXN has originated (Internet, Mobile, ATM, Branch Channel )
        - co-Relationid: integer
          Unique ID for the service invoked, will be set by the TXN system
        - entity: string
          entity
        - initiatingSystem: string
          Indicating the initiated system
        - languageCode: integer
          languageCode
        - referenceId: string
          Place holder for Token based authentication
        - serviceMode: integer
          Used for branch channel to indicate the type of customer
        - userId: integer
          userId
        - uuidSeqNo: integer
          UUID Sequence Number
        
        
        """
        
        
        # Prepare request data
        
        # Single body parameter - send directly
        data = request_body if request_body is not None else {}
        
        
        
        # Prepare query parameters
        params = {}
        
        
        # Replace path parameters in URL
        path = "/accountManagement/accountSSI/authSSI"
        
        
        # Prepare headers
        headers = {}
        if accesstoken is not None:
            headers["Accesstoken"] = str(accesstoken)
        if channeltype is not None:
            headers["ChannelType"] = str(channeltype)
        if co_relationid is not None:
            headers["co-Relationid"] = str(co_relationid)
        if entity is not None:
            headers["entity"] = str(entity)
        if initiatingsystem is not None:
            headers["initiatingSystem"] = str(initiatingsystem)
        if languagecode is not None:
            headers["languageCode"] = str(languagecode)
        if referenceid is not None:
            headers["referenceId"] = str(referenceid)
        if servicemode is not None:
            headers["serviceMode"] = str(servicemode)
        if userid is not None:
            headers["userId"] = str(userid)
        if uuidseqno is not None:
            headers["uuidSeqNo"] = str(uuidseqno)
        
        
        return await make_api_request(
            "PUT", 
            path, 
            data=data, 
            params=params if params else None, 
            headers=headers if headers else None
        )
    
    
    
    @mcp.tool()
    async def brbt0401_crt_std_set_ins_postusing_post(
        request_body:Dict[str, Any] ,  # accountSSIResource,
        accesstoken: Optional[str] = None,
        channeltype: Optional[int] = None,
        co_relationid: Optional[int] = None,
        initiatingsystem: Optional[str] = None,
        servicemode: Optional[int] = None,
        uuidseqno: Optional[int] = None,
        entity: Optional[str] = None,
        languagecode: Optional[int] = None,
        referenceid: Optional[str] = None,
        requesthash: Optional[str] = None,
        userid: Optional[int] = None
    ) -> Dict[str, Any]:
        """
        Creation of Standard Settlement Instruction on Account
        
        Generated from: POST /accountManagement/accountSSI/createSSI
        Source: swagger_2_0
        Operation ID: BRBT0401CrtStdSetIns_POSTUsingPOST
        
        
        Authentication: Not required
        
        Parameters:
        - request_body: any (required)
          input
        
        
        
        Headers:
        - Accesstoken: string
          Authorization token for identification of the caller
        - ChannelType: integer
          Channel identifier from where the TXN has originated (Internet, Mobile, ATM, Branch Channel )
        - Co-Relationid: integer
          Unique ID for the service invoked, will be set by the TXN system
        - InitiatingSystem: string
          Indicating the initiated system
        - ServiceMode: integer
          Used for branch channel to indicate the type of customer
        - UUIDSeqNo: integer
          UUID Sequence Number
        - entity: string
          entity
        - languageCode: integer
          languageCode
        - referenceId: string
          Place holder for Token based authentication
        - requesthash: string
          Request payload for hash validation
        - userId: integer
          userId
        
        
        """
        
        
        # Prepare request data
        
        # Single body parameter - send directly
        data = request_body if request_body is not None else {}
        
        
        
        # Prepare query parameters
        params = {}
        
        
        # Replace path parameters in URL
        path = "/accountManagement/accountSSI/createSSI"
        
        
        # Prepare headers
        headers = {}
        if accesstoken is not None:
            headers["Accesstoken"] = str(accesstoken)
        if channeltype is not None:
            headers["ChannelType"] = str(channeltype)
        if co_relationid is not None:
            headers["Co-Relationid"] = str(co_relationid)
        if initiatingsystem is not None:
            headers["InitiatingSystem"] = str(initiatingsystem)
        if servicemode is not None:
            headers["ServiceMode"] = str(servicemode)
        if uuidseqno is not None:
            headers["UUIDSeqNo"] = str(uuidseqno)
        if entity is not None:
            headers["entity"] = str(entity)
        if languagecode is not None:
            headers["languageCode"] = str(languagecode)
        if referenceid is not None:
            headers["referenceId"] = str(referenceid)
        if requesthash is not None:
            headers["requesthash"] = str(requesthash)
        if userid is not None:
            headers["userId"] = str(userid)
        
        
        return await make_api_request(
            "POST", 
            path, 
            data=data, 
            params=params if params else None, 
            headers=headers if headers else None
        )
    
    
    
    @mcp.tool()
    async def brbt0403_del_std_set_ins_postusing_delete(
        request_body:Dict[str, Any] ,  # deleteSSIResource,
        accesstoken: Optional[str] = None,
        channeltype: Optional[int] = None,
        co_relationid: Optional[int] = None,
        initiatingsystem: Optional[str] = None,
        servicemode: Optional[int] = None,
        uuidseqno: Optional[int] = None,
        entity: Optional[str] = None,
        languagecode: Optional[int] = None,
        referenceid: Optional[str] = None,
        requesthash: Optional[str] = None,
        userid: Optional[int] = None
    ) -> Dict[str, Any]:
        """
        Deletion of Standard Settlement Instruction on Account
        
        Generated from: DELETE /accountManagement/accountSSI/deleteSSI
        Source: swagger_2_0
        Operation ID: BRBT0403DelStdSetIns_POSTUsingDELETE
        
        
        Authentication: Not required
        
        Parameters:
        - request_body: any (required)
          input
        
        
        
        Headers:
        - Accesstoken: string
          Authorization token for identification of the caller
        - ChannelType: integer
          Channel identifier from where the TXN has originated (Internet, Mobile, ATM, Branch Channel )
        - Co-Relationid: integer
          Unique ID for the service invoked, will be set by the TXN system
        - InitiatingSystem: string
          Indicating the initiated system
        - ServiceMode: integer
          Used for branch channel to indicate the type of customer
        - UUIDSeqNo: integer
          UUID Sequence Number
        - entity: string
          entity
        - languageCode: integer
          languageCode
        - referenceId: string
          Place holder for Token based authentication
        - requesthash: string
          Request payload for hash validation
        - userId: integer
          userId
        
        
        """
        
        
        # Prepare request data
        
        # Single body parameter - send directly
        data = request_body if request_body is not None else {}
        
        
        
        # Prepare query parameters
        params = {}
        
        
        # Replace path parameters in URL
        path = "/accountManagement/accountSSI/deleteSSI"
        
        
        # Prepare headers
        headers = {}
        if accesstoken is not None:
            headers["Accesstoken"] = str(accesstoken)
        if channeltype is not None:
            headers["ChannelType"] = str(channeltype)
        if co_relationid is not None:
            headers["Co-Relationid"] = str(co_relationid)
        if initiatingsystem is not None:
            headers["InitiatingSystem"] = str(initiatingsystem)
        if servicemode is not None:
            headers["ServiceMode"] = str(servicemode)
        if uuidseqno is not None:
            headers["UUIDSeqNo"] = str(uuidseqno)
        if entity is not None:
            headers["entity"] = str(entity)
        if languagecode is not None:
            headers["languageCode"] = str(languagecode)
        if referenceid is not None:
            headers["referenceId"] = str(referenceid)
        if requesthash is not None:
            headers["requesthash"] = str(requesthash)
        if userid is not None:
            headers["userId"] = str(userid)
        
        
        return await make_api_request(
            "DELETE", 
            path, 
            data=data, 
            params=params if params else None, 
            headers=headers if headers else None
        )
    
    
    
    @mcp.tool()
    async def brbt0402_mod_std_set_ins_postusing_put(
        request_body:Dict[str, Any] ,  # modifySSIResource,
        accesstoken: Optional[str] = None,
        channeltype: Optional[int] = None,
        co_relationid: Optional[int] = None,
        initiatingsystem: Optional[str] = None,
        servicemode: Optional[int] = None,
        uuidseqno: Optional[int] = None,
        entity: Optional[str] = None,
        languagecode: Optional[int] = None,
        referenceid: Optional[str] = None,
        requesthash: Optional[str] = None,
        userid: Optional[int] = None
    ) -> Dict[str, Any]:
        """
        Modification of Standard Settlement Instruction on Account
        
        Generated from: PUT /accountManagement/accountSSI/modifySSI
        Source: swagger_2_0
        Operation ID: BRBT0402ModStdSetIns_POSTUsingPUT
        
        
        Authentication: Not required
        
        Parameters:
        - request_body: any (required)
          input
        
        
        
        Headers:
        - Accesstoken: string
          Authorization token for identification of the caller
        - ChannelType: integer
          Channel identifier from where the TXN has originated (Internet, Mobile, ATM, Branch Channel )
        - Co-Relationid: integer
          Unique ID for the service invoked, will be set by the TXN system
        - InitiatingSystem: string
          Indicating the initiated system
        - ServiceMode: integer
          Used for branch channel to indicate the type of customer
        - UUIDSeqNo: integer
          UUID Sequence Number
        - entity: string
          entity
        - languageCode: integer
          languageCode
        - referenceId: string
          Place holder for Token based authentication
        - requesthash: string
          Request payload for hash validation
        - userId: integer
          userId
        
        
        """
        
        
        # Prepare request data
        
        # Single body parameter - send directly
        data = request_body if request_body is not None else {}
        
        
        
        # Prepare query parameters
        params = {}
        
        
        # Replace path parameters in URL
        path = "/accountManagement/accountSSI/modifySSI"
        
        
        # Prepare headers
        headers = {}
        if accesstoken is not None:
            headers["Accesstoken"] = str(accesstoken)
        if channeltype is not None:
            headers["ChannelType"] = str(channeltype)
        if co_relationid is not None:
            headers["Co-Relationid"] = str(co_relationid)
        if initiatingsystem is not None:
            headers["InitiatingSystem"] = str(initiatingsystem)
        if servicemode is not None:
            headers["ServiceMode"] = str(servicemode)
        if uuidseqno is not None:
            headers["UUIDSeqNo"] = str(uuidseqno)
        if entity is not None:
            headers["entity"] = str(entity)
        if languagecode is not None:
            headers["languageCode"] = str(languagecode)
        if referenceid is not None:
            headers["referenceId"] = str(referenceid)
        if requesthash is not None:
            headers["requesthash"] = str(requesthash)
        if userid is not None:
            headers["userId"] = str(userid)
        
        
        return await make_api_request(
            "PUT", 
            path, 
            data=data, 
            params=params if params else None, 
            headers=headers if headers else None
        )
    
    
    
    @mcp.tool()
    async def amet2021_fetch_acnt_statistic_using_get(
        accountreference: Optional[str] = None,
        customerreference: Optional[int] = None,
        period: Optional[int] = None,
        accesstoken: Optional[str] = None,
        channeltype: Optional[int] = None,
        co_relationid: Optional[int] = None,
        initiatingsystem: Optional[str] = None,
        servicemode: Optional[int] = None,
        uuidseqno: Optional[int] = None,
        entity: Optional[str] = None,
        languagecode: Optional[int] = None,
        referenceid: Optional[str] = None,
        requesthash: Optional[str] = None,
        userid: Optional[int] = None
    ) -> Dict[str, Any]:
        """
        To Fetch Total Cr and Dr Txns in a Customer Account
        
        Generated from: GET /accountManagement/accountStatistic
        Source: swagger_2_0
        Operation ID: AMET2021FetchAcntStatisticUsingGET
        
        
        Authentication: Not required
        
        Parameters:
        - accountReference: string
          Account Reference
        - customerReference: integer
          Customer Reference
        - period: integer
          period (in month upto 12)
        
        
        
        Headers:
        - Accesstoken: string
          Authorization Token to validation the caller
        - ChannelType: integer
          Channel identifier from where the TXN has originated (Internet, Mobile, ATM, Branch Channel )
        - Co-Relationid: integer
          Unique ID for the service invoked, will be set by the TXN system
        - InitiatingSystem: string
          Indicating the initiated system
        - ServiceMode: integer
          Used for branch channel to indicate the type of customer
        - UUIDSeqNo: integer
          UUID Sequence Number
        - entity: string
          entity
        - languageCode: integer
          languageCode
        - referenceId: string
          Place holder for Token based authentication
        - requesthash: string
          Request payload for hash validation
        - userId: integer
          userId
        
        
        """
        
        
        # Prepare query parameters
        params = {}
        if accountreference is not None:
            params["accountReference"] = accountreference
            
        if customerreference is not None:
            params["customerReference"] = customerreference
            
        if period is not None:
            params["period"] = period
            
        
        
        # Replace path parameters in URL
        path = "/accountManagement/accountStatistic"
        
        
        # Prepare headers
        headers = {}
        if accesstoken is not None:
            headers["Accesstoken"] = str(accesstoken)
        if channeltype is not None:
            headers["ChannelType"] = str(channeltype)
        if co_relationid is not None:
            headers["Co-Relationid"] = str(co_relationid)
        if initiatingsystem is not None:
            headers["InitiatingSystem"] = str(initiatingsystem)
        if servicemode is not None:
            headers["ServiceMode"] = str(servicemode)
        if uuidseqno is not None:
            headers["UUIDSeqNo"] = str(uuidseqno)
        if entity is not None:
            headers["entity"] = str(entity)
        if languagecode is not None:
            headers["languageCode"] = str(languagecode)
        if referenceid is not None:
            headers["referenceId"] = str(referenceid)
        if requesthash is not None:
            headers["requesthash"] = str(requesthash)
        if userid is not None:
            headers["userId"] = str(userid)
        
        
        return await make_api_request(
            "GET", 
            path, 
            
            params=params if params else None, 
            headers=headers if headers else None
        )
    
    
    
    @mcp.tool()
    async def amet2026_lst_acnt_txn_cndtn_postusing_post(
        accountreference: str,
        accesstoken: Optional[str] = None,
        channeltype: Optional[int] = None,
        co_relationid: Optional[int] = None,
        initiatingsystem: Optional[str] = None,
        servicemode: Optional[int] = None,
        uuidseqno: Optional[int] = None,
        entity: Optional[str] = None,
        languagecode: Optional[int] = None,
        referenceid: Optional[str] = None,
        userid: Optional[int] = None
    ) -> Dict[str, Any]:
        """
        API to publish the account transaction conditions based on account number
        
        Generated from: POST /accountManagement/accountTransactionConditions/{accountReference}
        Source: swagger_2_0
        Operation ID: AMET2026LstAcntTxnCndtn_POSTUsingPOST
        
        
        Authentication: Not required
        
        Parameters:
        - accountReference: string (required)
          Enter the Account Reference
        
        
        
        Headers:
        - Accesstoken: string
          Authorization token for identification of the caller
        - ChannelType: integer
          Channel identifier from where the TXN has originated (Internet, Mobile, ATM, Branch Channel )
        - Co-Relationid: integer
          Unique ID for the service invoked, will be set by the TXN system
        - InitiatingSystem: string
          Indicating the initiated system
        - ServiceMode: integer
          Used for branch channel to indicate the type of customer
        - UUIDSeqNo: integer
          UUID Sequence Number
        - entity: string
          entity
        - languageCode: integer
          languageCode
        - referenceId: string
          Place holder for Token based authentication
        - userId: integer
          userId
        
        
        """
        
        
        # Prepare query parameters
        params = {}
        
        
        # Replace path parameters in URL
        path = "/accountManagement/accountTransactionConditions/{accountReference}"
        if accountreference is not None:
            path = path.replace("{accountReference}", str(accountreference))
        
        
        # Prepare headers
        headers = {}
        if accesstoken is not None:
            headers["Accesstoken"] = str(accesstoken)
        if channeltype is not None:
            headers["ChannelType"] = str(channeltype)
        if co_relationid is not None:
            headers["Co-Relationid"] = str(co_relationid)
        if initiatingsystem is not None:
            headers["InitiatingSystem"] = str(initiatingsystem)
        if servicemode is not None:
            headers["ServiceMode"] = str(servicemode)
        if uuidseqno is not None:
            headers["UUIDSeqNo"] = str(uuidseqno)
        if entity is not None:
            headers["entity"] = str(entity)
        if languagecode is not None:
            headers["languageCode"] = str(languagecode)
        if referenceid is not None:
            headers["referenceId"] = str(referenceid)
        if userid is not None:
            headers["userId"] = str(userid)
        
        
        return await make_api_request(
            "POST", 
            path, 
            
            params=params if params else None, 
            headers=headers if headers else None
        )
    
    
    
    @mcp.tool()
    async def amtc0700_validate_acnt_postusing_get(
        accountreference: str,
        accountcurrency: Optional[str] = None,
        accesstoken: Optional[str] = None,
        channeltype: Optional[int] = None,
        co_relationid: Optional[int] = None,
        initiatingsystem: Optional[str] = None,
        servicemode: Optional[int] = None,
        uuidseqno: Optional[int] = None,
        entity: Optional[str] = None,
        languagecode: Optional[int] = None,
        referenceid: Optional[str] = None,
        userid: Optional[int] = None
    ) -> Dict[str, Any]:
        """
        Account Validation
        
        Generated from: GET /accountManagement/accountValidation
        Source: swagger_2_0
        Operation ID: AMTC0700ValidateAcnt_POSTUsingGET
        
        
        Authentication: Not required
        
        Parameters:
        - accountCurrency: string
          AccountCurrency
        - accountReference: string (required)
          AccountReference
        
        
        
        Headers:
        - Accesstoken: string
          Authorization token for identification of the caller
        - ChannelType: integer
          Channel identifier from where the TXN has originated (Internet, Mobile, ATM, Branch Channel )
        - Co-Relationid: integer
          Unique ID for the service invoked, will be set by the TXN system
        - InitiatingSystem: string
          Indicating the initiated system
        - ServiceMode: integer
          Used for branch channel to indicate the type of customer
        - UUIDSeqNo: integer
          UUID Sequence Number
        - entity: string
          entity
        - languageCode: integer
          languageCode
        - referenceId: string
          Place holder for Token based authentication
        - userId: integer
          userId
        
        
        """
        
        
        # Prepare query parameters
        params = {}
        if accountcurrency is not None:
            params["accountCurrency"] = accountcurrency
            
        if accountreference is not None:
            params["accountReference"] = accountreference
            
        
        
        # Replace path parameters in URL
        path = "/accountManagement/accountValidation"
        
        
        # Prepare headers
        headers = {}
        if accesstoken is not None:
            headers["Accesstoken"] = str(accesstoken)
        if channeltype is not None:
            headers["ChannelType"] = str(channeltype)
        if co_relationid is not None:
            headers["Co-Relationid"] = str(co_relationid)
        if initiatingsystem is not None:
            headers["InitiatingSystem"] = str(initiatingsystem)
        if servicemode is not None:
            headers["ServiceMode"] = str(servicemode)
        if uuidseqno is not None:
            headers["UUIDSeqNo"] = str(uuidseqno)
        if entity is not None:
            headers["entity"] = str(entity)
        if languagecode is not None:
            headers["languageCode"] = str(languagecode)
        if referenceid is not None:
            headers["referenceId"] = str(referenceid)
        if userid is not None:
            headers["userId"] = str(userid)
        
        
        return await make_api_request(
            "GET", 
            path, 
            
            params=params if params else None, 
            headers=headers if headers else None
        )
    
    
    
    @mcp.tool()
    async def ambtcrt_mdfy_casasweep_wrapper_postusing_post(
        request_body:Dict[str, Any] ,  # createCasaSweepResource,
        accesstoken: Optional[str] = None,
        channeltype: Optional[int] = None,
        co_relationid: Optional[int] = None,
        initiatingsystem: Optional[str] = None,
        servicemode: Optional[int] = None,
        uuidseqno: Optional[int] = None,
        entity: Optional[str] = None,
        languagecode: Optional[int] = None,
        referenceid: Optional[str] = None,
        requesthash: Optional[str] = None,
        userid: Optional[int] = None
    ) -> Dict[str, Any]:
        """
        Create/Modify CASA Sweep Details
        
        Generated from: POST /accountManagement/casaSweep
        Source: swagger_2_0
        Operation ID: AMBTCrtMdfyCASAsweepWrapper_POSTUsingPOST
        
        
        Authentication: Not required
        
        Parameters:
        - request_body: any (required)
          input
        
        
        
        Headers:
        - Accesstoken: string
          Authorization token for identification of the caller
        - ChannelType: integer
          Channel identifier from where the TXN has originated (Internet, Mobile, ATM, Branch Channel )
        - Co-Relationid: integer
          Unique ID for the service invoked, will be set by the TXN system
        - InitiatingSystem: string
          Indicating the initiated system
        - ServiceMode: integer
          Used for branch channel to indicate the type of customer
        - UUIDSeqNo: integer
          UUID Sequence Number
        - entity: string
          entity
        - languageCode: integer
          languageCode
        - referenceId: string
          Place holder for Token based authentication
        - requesthash: string
          Request payload for hash validation
        - userId: integer
          userId
        
        
        """
        
        
        # Prepare request data
        
        # Single body parameter - send directly
        data = request_body if request_body is not None else {}
        
        
        
        # Prepare query parameters
        params = {}
        
        
        # Replace path parameters in URL
        path = "/accountManagement/casaSweep"
        
        
        # Prepare headers
        headers = {}
        if accesstoken is not None:
            headers["Accesstoken"] = str(accesstoken)
        if channeltype is not None:
            headers["ChannelType"] = str(channeltype)
        if co_relationid is not None:
            headers["Co-Relationid"] = str(co_relationid)
        if initiatingsystem is not None:
            headers["InitiatingSystem"] = str(initiatingsystem)
        if servicemode is not None:
            headers["ServiceMode"] = str(servicemode)
        if uuidseqno is not None:
            headers["UUIDSeqNo"] = str(uuidseqno)
        if entity is not None:
            headers["entity"] = str(entity)
        if languagecode is not None:
            headers["languageCode"] = str(languagecode)
        if referenceid is not None:
            headers["referenceId"] = str(referenceid)
        if requesthash is not None:
            headers["requesthash"] = str(requesthash)
        if userid is not None:
            headers["userId"] = str(userid)
        
        
        return await make_api_request(
            "POST", 
            path, 
            data=data, 
            params=params if params else None, 
            headers=headers if headers else None
        )
    
    
    
    @mcp.tool()
    async def ambtdelete_casasweep_postusing_post(
        request_body:Dict[str, Any] ,  # deleteCasaSweepResource,
        accesstoken: Optional[str] = None,
        channeltype: Optional[int] = None,
        co_relationid: Optional[int] = None,
        initiatingsystem: Optional[str] = None,
        servicemode: Optional[int] = None,
        uuidseqno: Optional[int] = None,
        entity: Optional[str] = None,
        languagecode: Optional[int] = None,
        referenceid: Optional[str] = None,
        requesthash: Optional[str] = None,
        userid: Optional[int] = None
    ) -> Dict[str, Any]:
        """
        Delete CASA Sweep Details
        
        Generated from: POST /accountManagement/casaSweep/delete
        Source: swagger_2_0
        Operation ID: AMBTDeleteCASASweep_POSTUsingPOST
        
        
        Authentication: Not required
        
        Parameters:
        - request_body: any (required)
          input
        
        
        
        Headers:
        - Accesstoken: string
          Authorization token for identification of the caller
        - ChannelType: integer
          Channel identifier from where the TXN has originated (Internet, Mobile, ATM, Branch Channel )
        - Co-Relationid: integer
          Unique ID for the service invoked, will be set by the TXN system
        - InitiatingSystem: string
          Indicating the initiated system
        - ServiceMode: integer
          Used for branch channel to indicate the type of customer
        - UUIDSeqNo: integer
          UUID Sequence Number
        - entity: string
          entity
        - languageCode: integer
          languageCode
        - referenceId: string
          Place holder for Token based authentication
        - requesthash: string
          Request payload for hash validation
        - userId: integer
          userId
        
        
        """
        
        
        # Prepare request data
        
        # Single body parameter - send directly
        data = request_body if request_body is not None else {}
        
        
        
        # Prepare query parameters
        params = {}
        
        
        # Replace path parameters in URL
        path = "/accountManagement/casaSweep/delete"
        
        
        # Prepare headers
        headers = {}
        if accesstoken is not None:
            headers["Accesstoken"] = str(accesstoken)
        if channeltype is not None:
            headers["ChannelType"] = str(channeltype)
        if co_relationid is not None:
            headers["Co-Relationid"] = str(co_relationid)
        if initiatingsystem is not None:
            headers["InitiatingSystem"] = str(initiatingsystem)
        if servicemode is not None:
            headers["ServiceMode"] = str(servicemode)
        if uuidseqno is not None:
            headers["UUIDSeqNo"] = str(uuidseqno)
        if entity is not None:
            headers["entity"] = str(entity)
        if languagecode is not None:
            headers["languageCode"] = str(languagecode)
        if referenceid is not None:
            headers["referenceId"] = str(referenceid)
        if requesthash is not None:
            headers["requesthash"] = str(requesthash)
        if userid is not None:
            headers["userId"] = str(userid)
        
        
        return await make_api_request(
            "POST", 
            path, 
            data=data, 
            params=params if params else None, 
            headers=headers if headers else None
        )
    
    
    
    @mcp.tool()
    async def amet0604_fetch_casausing_get(
        accountreference: str,
        pagenum: Optional[int] = None,
        pagesize: Optional[int] = None,
        accesstoken: Optional[str] = None,
        channeltype: Optional[int] = None,
        co_relationid: Optional[int] = None,
        initiatingsystem: Optional[str] = None,
        servicemode: Optional[int] = None,
        uuidseqno: Optional[int] = None,
        entity: Optional[str] = None,
        languagecode: Optional[int] = None,
        referenceid: Optional[str] = None,
        userid: Optional[int] = None
    ) -> Dict[str, Any]:
        """
        Fetch CASA Sweep Details
        
        Generated from: GET /accountManagement/casaSweep/{accountReference}
        Source: swagger_2_0
        Operation ID: AMET0604FetchCASAUsingGET
        
        
        Authentication: Not required
        
        Parameters:
        - accountReference: string (required)
          Account Reference
        - pageNum: integer
          pageNum
        - pageSize: integer
          pageSize
        
        
        
        Headers:
        - Accesstoken: string
          Authorization token for identification of the caller
        - ChannelType: integer
          Channel identifier from where the TXN has originated (Internet, Mobile, ATM, Branch Channel )
        - Co-Relationid: integer
          Unique ID for the service invoked, will be set by the TXN system
        - InitiatingSystem: string
          Indicating the initiated system
        - ServiceMode: integer
          Used for branch channel to indicate the type of customer
        - UUIDSeqNo: integer
          UUID Sequence Number
        - entity: string
          entity
        - languageCode: integer
          languageCode
        - referenceId: string
          Place holder for Token based authentication
        - userId: integer
          userId
        
        
        """
        
        
        # Prepare query parameters
        params = {}
        if pagenum is not None:
            params["pageNum"] = pagenum
            
        if pagesize is not None:
            params["pageSize"] = pagesize
            
        
        
        # Replace path parameters in URL
        path = "/accountManagement/casaSweep/{accountReference}"
        if accountreference is not None:
            path = path.replace("{accountReference}", str(accountreference))
        
        
        # Prepare headers
        headers = {}
        if accesstoken is not None:
            headers["Accesstoken"] = str(accesstoken)
        if channeltype is not None:
            headers["ChannelType"] = str(channeltype)
        if co_relationid is not None:
            headers["Co-Relationid"] = str(co_relationid)
        if initiatingsystem is not None:
            headers["InitiatingSystem"] = str(initiatingsystem)
        if servicemode is not None:
            headers["ServiceMode"] = str(servicemode)
        if uuidseqno is not None:
            headers["UUIDSeqNo"] = str(uuidseqno)
        if entity is not None:
            headers["entity"] = str(entity)
        if languagecode is not None:
            headers["languageCode"] = str(languagecode)
        if referenceid is not None:
            headers["referenceId"] = str(referenceid)
        if userid is not None:
            headers["userId"] = str(userid)
        
        
        return await make_api_request(
            "GET", 
            path, 
            
            params=params if params else None, 
            headers=headers if headers else None
        )
    
    
    
    @mcp.tool()
    async def ambt2018_acnt_clsr_rvrs_auth_postusing_post(
        request_body:Dict[str, Any] ,  # accountClosureReversalAuthorisationRequest,
        accesstoken: Optional[str] = None,
        channeltype: Optional[int] = None,
        co_relationid: Optional[int] = None,
        initiatingsystem: Optional[str] = None,
        servicemode: Optional[int] = None,
        uuidseqno: Optional[int] = None,
        entity: Optional[str] = None,
        languagecode: Optional[int] = None,
        referenceid: Optional[str] = None,
        requesthash: Optional[str] = None,
        userid: Optional[int] = None
    ) -> Dict[str, Any]:
        """
        Account closure reversal authorisation
        
        Generated from: POST /accountManagement/closure/reversal/authorise
        Source: swagger_2_0
        Operation ID: AMBT2018AcntClsrRvrsAuth_POSTUsingPOST
        
        
        Authentication: Not required
        
        Parameters:
        - request_body: any (required)
          input
        
        
        
        Headers:
        - Accesstoken: string
          Authorization token for identification of the caller
        - ChannelType: integer
          Channel identifier from where the TXN has originated (Internet, Mobile, ATM, Branch Channel )
        - Co-Relationid: integer
          Unique ID for the service invoked, will be set by the TXN system
        - InitiatingSystem: string
          Indicating the initiated system
        - ServiceMode: integer
          Used for branch channel to indicate the type of customer
        - UUIDSeqNo: integer
          UUID Sequence Number
        - entity: string
          entity
        - languageCode: integer
          languageCode
        - referenceId: string
          Place holder for Token based authentication
        - requesthash: string
          Request payload for hash validation
        - userId: integer
          userId
        
        
        """
        
        
        # Prepare request data
        
        # Single body parameter - send directly
        data = request_body if request_body is not None else {}
        
        
        
        # Prepare query parameters
        params = {}
        
        
        # Replace path parameters in URL
        path = "/accountManagement/closure/reversal/authorise"
        
        
        # Prepare headers
        headers = {}
        if accesstoken is not None:
            headers["Accesstoken"] = str(accesstoken)
        if channeltype is not None:
            headers["ChannelType"] = str(channeltype)
        if co_relationid is not None:
            headers["Co-Relationid"] = str(co_relationid)
        if initiatingsystem is not None:
            headers["InitiatingSystem"] = str(initiatingsystem)
        if servicemode is not None:
            headers["ServiceMode"] = str(servicemode)
        if uuidseqno is not None:
            headers["UUIDSeqNo"] = str(uuidseqno)
        if entity is not None:
            headers["entity"] = str(entity)
        if languagecode is not None:
            headers["languageCode"] = str(languagecode)
        if referenceid is not None:
            headers["referenceId"] = str(referenceid)
        if requesthash is not None:
            headers["requesthash"] = str(requesthash)
        if userid is not None:
            headers["userId"] = str(userid)
        
        
        return await make_api_request(
            "POST", 
            path, 
            data=data, 
            params=params if params else None, 
            headers=headers if headers else None
        )
    
    
    
    @mcp.tool()
    async def ambt2018_acnt_clsr_rvrsl_init_postusing_post(
        request_body:Dict[str, Any] ,  # accountClosureReversalInitiationRequest,
        accesstoken: Optional[str] = None,
        channeltype: Optional[int] = None,
        co_relationid: Optional[int] = None,
        initiatingsystem: Optional[str] = None,
        servicemode: Optional[int] = None,
        uuidseqno: Optional[int] = None,
        entity: Optional[str] = None,
        languagecode: Optional[int] = None,
        referenceid: Optional[str] = None,
        requesthash: Optional[str] = None,
        userid: Optional[int] = None
    ) -> Dict[str, Any]:
        """
        Account closure reversal initiation
        
        Generated from: POST /accountManagement/closure/reversal/init
        Source: swagger_2_0
        Operation ID: AMBT2018AcntClsrRvrslInit_POSTUsingPOST
        
        
        Authentication: Not required
        
        Parameters:
        - request_body: any (required)
          input
        
        
        
        Headers:
        - Accesstoken: string
          Authorization token for identification of the caller
        - ChannelType: integer
          Channel identifier from where the TXN has originated (Internet, Mobile, ATM, Branch Channel )
        - Co-Relationid: integer
          Unique ID for the service invoked, will be set by the TXN system
        - InitiatingSystem: string
          Indicating the initiated system
        - ServiceMode: integer
          Used for branch channel to indicate the type of customer
        - UUIDSeqNo: integer
          UUID Sequence Number
        - entity: string
          entity
        - languageCode: integer
          languageCode
        - referenceId: string
          Place holder for Token based authentication
        - requesthash: string
          Request payload for hash validation
        - userId: integer
          userId
        
        
        """
        
        
        # Prepare request data
        
        # Single body parameter - send directly
        data = request_body if request_body is not None else {}
        
        
        
        # Prepare query parameters
        params = {}
        
        
        # Replace path parameters in URL
        path = "/accountManagement/closure/reversal/init"
        
        
        # Prepare headers
        headers = {}
        if accesstoken is not None:
            headers["Accesstoken"] = str(accesstoken)
        if channeltype is not None:
            headers["ChannelType"] = str(channeltype)
        if co_relationid is not None:
            headers["Co-Relationid"] = str(co_relationid)
        if initiatingsystem is not None:
            headers["InitiatingSystem"] = str(initiatingsystem)
        if servicemode is not None:
            headers["ServiceMode"] = str(servicemode)
        if uuidseqno is not None:
            headers["UUIDSeqNo"] = str(uuidseqno)
        if entity is not None:
            headers["entity"] = str(entity)
        if languagecode is not None:
            headers["languageCode"] = str(languagecode)
        if referenceid is not None:
            headers["referenceId"] = str(referenceid)
        if requesthash is not None:
            headers["requesthash"] = str(requesthash)
        if userid is not None:
            headers["userId"] = str(userid)
        
        
        return await make_api_request(
            "POST", 
            path, 
            data=data, 
            params=params if params else None, 
            headers=headers if headers else None
        )
    
    
    
    @mcp.tool()
    async def rstbt2020_create_acnt_actvwth_relations_using_post(
        request_body:Dict[str, Any] ,  # createAcntActvwthRelationsResource,
        accesstoken: Optional[str] = None,
        channeltype: Optional[int] = None,
        co_relationid: Optional[int] = None,
        initiatingsystem: Optional[str] = None,
        servicemode: Optional[int] = None,
        uuidseqno: Optional[int] = None,
        entity: Optional[str] = None,
        languagecode: Optional[int] = None,
        referenceid: Optional[str] = None,
        requesthash: Optional[str] = None,
        userid: Optional[int] = None
    ) -> Dict[str, Any]:
        """
        This API is used create account with Relations
        
        Generated from: POST /accountManagement/createAccountwthRelations
        Source: swagger_2_0
        Operation ID: RSTBT2020CreateAcntActvwthRelationsUsingPOST
        
        
        Authentication: Not required
        
        Parameters:
        - request_body: any (required)
          input
        
        
        
        Headers:
        - Accesstoken: string
          Authorization token for identification of the caller
        - ChannelType: integer
          Channel identifier from where the TXN has originated (Internet, Mobile, ATM, Branch Channel )
        - Co-Relationid: integer
          Unique ID for the service invoked, will be set by the TXN system
        - InitiatingSystem: string
          Indicating the initiated system
        - ServiceMode: integer
          Used for branch channel to indicate the type of customer
        - UUIDSeqNo: integer
          UUID Sequence Number
        - entity: string
          entity
        - languageCode: integer
          languageCode
        - referenceId: string
          Place holder for Token based authentication
        - requesthash: string
          Request payload for hash validation
        - userId: integer
          userId
        
        
        """
        
        
        # Prepare request data
        
        # Single body parameter - send directly
        data = request_body if request_body is not None else {}
        
        
        
        # Prepare query parameters
        params = {}
        
        
        # Replace path parameters in URL
        path = "/accountManagement/createAccountwthRelations"
        
        
        # Prepare headers
        headers = {}
        if accesstoken is not None:
            headers["Accesstoken"] = str(accesstoken)
        if channeltype is not None:
            headers["ChannelType"] = str(channeltype)
        if co_relationid is not None:
            headers["Co-Relationid"] = str(co_relationid)
        if initiatingsystem is not None:
            headers["InitiatingSystem"] = str(initiatingsystem)
        if servicemode is not None:
            headers["ServiceMode"] = str(servicemode)
        if uuidseqno is not None:
            headers["UUIDSeqNo"] = str(uuidseqno)
        if entity is not None:
            headers["entity"] = str(entity)
        if languagecode is not None:
            headers["languageCode"] = str(languagecode)
        if referenceid is not None:
            headers["referenceId"] = str(referenceid)
        if requesthash is not None:
            headers["requesthash"] = str(requesthash)
        if userid is not None:
            headers["userId"] = str(userid)
        
        
        return await make_api_request(
            "POST", 
            path, 
            data=data, 
            params=params if params else None, 
            headers=headers if headers else None
        )
    
    
    
    @mcp.tool()
    async def rstbt2010_crt_mdf_nominee_using_post(
        request_body:Dict[str, Any] ,  # CrtMdfNomineeResource,
        accesstoken: Optional[str] = None,
        channeltype: Optional[int] = None,
        co_relationid: Optional[int] = None,
        initiatingsystem: Optional[str] = None,
        servicemode: Optional[int] = None,
        uuidseqno: Optional[int] = None,
        entity: Optional[str] = None,
        languagecode: Optional[int] = None,
        referenceid: Optional[str] = None,
        requesthash: Optional[str] = None,
        userid: Optional[int] = None
    ) -> Dict[str, Any]:
        """
        Create/Modify/Cancel Nominee At Account Level
        
        Generated from: POST /accountManagement/createNominee
        Source: swagger_2_0
        Operation ID: RSTBT2010CrtMdfNomineeUsingPOST
        
        
        Authentication: Not required
        
        Parameters:
        - request_body: any (required)
          input
        
        
        
        Headers:
        - Accesstoken: string
          Authorization Token to validation the caller
        - ChannelType: integer
          Channel identifier from where the TXN has originated (Internet, Mobile, ATM, Branch Channel )
        - Co-Relationid: integer
          Unique ID for the service invoked, will be set by the TXN system
        - InitiatingSystem: string
          Indicating the initiated system
        - ServiceMode: integer
          Used for branch channel to indicate the type of customer
        - UUIDSeqNo: integer
          UUID Sequence Number
        - entity: string
          entity
        - languageCode: integer
          languageCode
        - referenceId: string
          Place holder forToken based authetication
        - requesthash: string
          Request payload for hash validation
        - userId: integer
          userId
        
        
        """
        
        
        # Prepare request data
        
        # Single body parameter - send directly
        data = request_body if request_body is not None else {}
        
        
        
        # Prepare query parameters
        params = {}
        
        
        # Replace path parameters in URL
        path = "/accountManagement/createNominee"
        
        
        # Prepare headers
        headers = {}
        if accesstoken is not None:
            headers["Accesstoken"] = str(accesstoken)
        if channeltype is not None:
            headers["ChannelType"] = str(channeltype)
        if co_relationid is not None:
            headers["Co-Relationid"] = str(co_relationid)
        if initiatingsystem is not None:
            headers["InitiatingSystem"] = str(initiatingsystem)
        if servicemode is not None:
            headers["ServiceMode"] = str(servicemode)
        if uuidseqno is not None:
            headers["UUIDSeqNo"] = str(uuidseqno)
        if entity is not None:
            headers["entity"] = str(entity)
        if languagecode is not None:
            headers["languageCode"] = str(languagecode)
        if referenceid is not None:
            headers["referenceId"] = str(referenceid)
        if requesthash is not None:
            headers["requesthash"] = str(requesthash)
        if userid is not None:
            headers["userId"] = str(userid)
        
        
        return await make_api_request(
            "POST", 
            path, 
            data=data, 
            params=params if params else None, 
            headers=headers if headers else None
        )
    
    
    
    @mcp.tool()
    async def depet0203_get_deal_lst_postusing_get(
        customerref: Optional[int] = None,
        customerreference: Optional[str] = None,
        accountreference: Optional[str] = None,
        instrumentid: Optional[int] = None,
        instrumentreference: Optional[str] = None,
        pagenum: Optional[int] = None,
        pagesize: Optional[int] = None,
        entity: Optional[str] = None,
        languagecode: Optional[int] = None,
        userid: Optional[int] = None
    ) -> Dict[str, Any]:
        """
        This service fetches deposite Accounts
        
        Generated from: GET /accountManagement/fecthDepositList
        Source: swagger_2_0
        Operation ID: DEPET0203GetDealLst_POSTUsingGET
        
        
        Authentication: Not required
        
        Parameters:
        - CustomerRef: integer
          enter the range flag for CustomerID(2 for equals)
        - CustomerReference: string
          Enter the Customer ID
        - accountReference: string
          Enter the account reference number
        - instrumentID: integer
          Enter the range for instrument ID
        - instrumentReference: string
          Enter the instrument ID
        - pageNum: integer
          pageNum
        - pageSize: integer
          pageSize
        
        
        
        Headers:
        - entity: string
          entity
        - languageCode: integer
          languageCode
        - userId: integer
          userId
        
        
        """
        
        
        # Prepare query parameters
        params = {}
        if customerref is not None:
            params["CustomerRef"] = customerref
            
        if customerreference is not None:
            params["CustomerReference"] = customerreference
            
        if accountreference is not None:
            params["accountReference"] = accountreference
            
        if instrumentid is not None:
            params["instrumentID"] = instrumentid
            
        if instrumentreference is not None:
            params["instrumentReference"] = instrumentreference
            
        if pagenum is not None:
            params["pageNum"] = pagenum
            
        if pagesize is not None:
            params["pageSize"] = pagesize
            
        
        
        # Replace path parameters in URL
        path = "/accountManagement/fecthDepositList"
        
        
        # Prepare headers
        headers = {}
        if entity is not None:
            headers["entity"] = str(entity)
        if languagecode is not None:
            headers["languageCode"] = str(languagecode)
        if userid is not None:
            headers["userId"] = str(userid)
        
        
        return await make_api_request(
            "GET", 
            path, 
            
            params=params if params else None, 
            headers=headers if headers else None
        )
    
    
    
    @mcp.tool()
    async def amet2021_fetch_crd_txns_postusing_get(
        cardnumber: Optional[str] = None,
        fromdate: Optional[str] = None,
        maskedcardnumber: Optional[str] = None,
        pagenum: Optional[int] = None,
        pagesize: Optional[int] = None,
        todate: Optional[str] = None,
        accesstoken: Optional[str] = None,
        channeltype: Optional[int] = None,
        co_relationid: Optional[int] = None,
        initiatingsystem: Optional[str] = None,
        servicemode: Optional[int] = None,
        uuidseqno: Optional[int] = None,
        entity: Optional[str] = None,
        languagecode: Optional[int] = None,
        referenceid: Optional[str] = None,
        userid: Optional[int] = None
    ) -> Dict[str, Any]:
        """
        Fetch Card Transactions
        
        Generated from: GET /accountManagement/fetchCardtxns
        Source: swagger_2_0
        Operation ID: AMET2021FetchCrdTxns_POSTUsingGET
        
        
        Authentication: Not required
        
        Parameters:
        - cardNumber: string
          Card Number
        - fromDate: string
          From Date (format : YYYYMMDD)
        - maskedCardNumber: string
          Masked Card Number
        - pageNum: integer
          pageNum
        - pageSize: integer
          pageSize
        - toDate: string
          To Date (format : YYYYMMDD)
        
        
        
        Headers:
        - Accesstoken: string
          Authorization Token to validation the caller
        - ChannelType: integer
          Channel identifier from where the TXN has originated (Internet, Mobile, ATM, Branch Channel )
        - Co-Relationid: integer
          Unique ID for the service invoked, will be set by the TXN system
        - InitiatingSystem: string
          Indicating the initiated system
        - ServiceMode: integer
          Used for branch channel to indicate the type of customer
        - UUIDSeqNo: integer
          UUID Sequence Number
        - entity: string
          entity
        - languageCode: integer
          languageCode
        - referenceId: string
          Place holder for Token based authentication
        - userId: integer
          userId
        
        
        """
        
        
        # Prepare query parameters
        params = {}
        if cardnumber is not None:
            params["cardNumber"] = cardnumber
            
        if fromdate is not None:
            params["fromDate"] = fromdate
            
        if maskedcardnumber is not None:
            params["maskedCardNumber"] = maskedcardnumber
            
        if pagenum is not None:
            params["pageNum"] = pagenum
            
        if pagesize is not None:
            params["pageSize"] = pagesize
            
        if todate is not None:
            params["toDate"] = todate
            
        
        
        # Replace path parameters in URL
        path = "/accountManagement/fetchCardtxns"
        
        
        # Prepare headers
        headers = {}
        if accesstoken is not None:
            headers["Accesstoken"] = str(accesstoken)
        if channeltype is not None:
            headers["ChannelType"] = str(channeltype)
        if co_relationid is not None:
            headers["Co-Relationid"] = str(co_relationid)
        if initiatingsystem is not None:
            headers["InitiatingSystem"] = str(initiatingsystem)
        if servicemode is not None:
            headers["ServiceMode"] = str(servicemode)
        if uuidseqno is not None:
            headers["UUIDSeqNo"] = str(uuidseqno)
        if entity is not None:
            headers["entity"] = str(entity)
        if languagecode is not None:
            headers["languageCode"] = str(languagecode)
        if referenceid is not None:
            headers["referenceId"] = str(referenceid)
        if userid is not None:
            headers["userId"] = str(userid)
        
        
        return await make_api_request(
            "GET", 
            path, 
            
            params=params if params else None, 
            headers=headers if headers else None
        )
    
    
    
    @mcp.tool()
    async def amet2022_ftch_intrst_dtls_getusing_get(
        accountreference: str,
        fromdate: str,
        todate: str,
        accesstoken: Optional[str] = None,
        channeltype: Optional[int] = None,
        co_relationid: Optional[int] = None,
        initiatingsystem: Optional[str] = None,
        servicemode: Optional[int] = None,
        uuidseqno: Optional[int] = None,
        entity: Optional[str] = None,
        languagecode: Optional[int] = None,
        referenceid: Optional[str] = None,
        requesthash: Optional[str] = None,
        userid: Optional[int] = None
    ) -> Dict[str, Any]:
        """
        This API is used to fetch Interest Amounts
        
        Generated from: GET /accountManagement/interestDetails/fetch
        Source: swagger_2_0
        Operation ID: AMET2022FtchIntrstDtls_GETUsingGET
        
        
        Authentication: Not required
        
        Parameters:
        - accountReference: string (required)
          Acount Reference
        - fromDate: string (required)
          interest Fetch from date yyyymmdd
        - toDate: string (required)
          interest Fetch To date yyyymmdd
        
        
        
        Headers:
        - Accesstoken: string
          Authorization token for identification of the caller
        - ChannelType: integer
          Channel identifier from where the TXN has originated (Internet, Mobile, ATM, Branch Channel )
        - Co-Relationid: integer
          Unique ID for the service invoked, will be set by the TXN system
        - InitiatingSystem: string
          Indicating the initiated system
        - ServiceMode: integer
          Used for branch channel to indicate the type of customer
        - UUIDSeqNo: integer
          UUID Sequence Number
        - entity: string
          entity
        - languageCode: integer
          languageCode
        - referenceId: string
          Place holder for Token based authentication
        - requesthash: string
          Request payload for hash validation
        - userId: integer
          userId
        
        
        """
        
        
        # Prepare query parameters
        params = {}
        if accountreference is not None:
            params["accountReference"] = accountreference
            
        if fromdate is not None:
            params["fromDate"] = fromdate
            
        if todate is not None:
            params["toDate"] = todate
            
        
        
        # Replace path parameters in URL
        path = "/accountManagement/interestDetails/fetch"
        
        
        # Prepare headers
        headers = {}
        if accesstoken is not None:
            headers["Accesstoken"] = str(accesstoken)
        if channeltype is not None:
            headers["ChannelType"] = str(channeltype)
        if co_relationid is not None:
            headers["Co-Relationid"] = str(co_relationid)
        if initiatingsystem is not None:
            headers["InitiatingSystem"] = str(initiatingsystem)
        if servicemode is not None:
            headers["ServiceMode"] = str(servicemode)
        if uuidseqno is not None:
            headers["UUIDSeqNo"] = str(uuidseqno)
        if entity is not None:
            headers["entity"] = str(entity)
        if languagecode is not None:
            headers["languageCode"] = str(languagecode)
        if referenceid is not None:
            headers["referenceId"] = str(referenceid)
        if requesthash is not None:
            headers["requesthash"] = str(requesthash)
        if userid is not None:
            headers["userId"] = str(userid)
        
        
        return await make_api_request(
            "GET", 
            path, 
            
            params=params if params else None, 
            headers=headers if headers else None
        )
    
    
    
    @mcp.tool()
    async def amet5211_fetch_prvsnl_clsr_dtls_postusing_get(
        accountreference: str,
        # accountreference: str,
        accesstoken: Optional[str] = None,
        channeltype: Optional[int] = None,
        co_relationid: Optional[int] = None,
        initiatingsystem: Optional[str] = None,
        servicemode: Optional[int] = None,
        uuidseqno: Optional[int] = None,
        entity: Optional[str] = None,
        languagecode: Optional[int] = None,
        referenceid: Optional[str] = None,
        userid: Optional[int] = None
    ) -> Dict[str, Any]:
        """
        Fetch Provision Closing Balance
        
        Generated from: GET /accountManagement/provisionalClosingBalance/{accountReference} 
        Source: swagger_2_0
        Operation ID: AMET5211FetchPrvsnlClsrDtls_POSTUsingGET
        
        
        Authentication: Not required
        
        Parameters:
        - accountReference: string (required)
          Account Reference
        - accountReference: string (required)
          Path parameter accountReference
        
        
        
        Headers:
        - Accesstoken: string
          Authorization token for identification of the caller
        - ChannelType: integer
          Channel identifier from where the TXN has originated (Internet, Mobile, ATM, Branch Channel )
        - Co-Relationid: integer
          Unique ID for the service invoked, will be set by the TXN system
        - InitiatingSystem: string
          Indicating the initiated system
        - ServiceMode: integer
          Used for branch channel to indicate the type of customer
        - UUIDSeqNo: integer
          UUID Sequence Number
        - entity: string
          entity
        - languageCode: integer
          languageCode
        - referenceId: string
          Place holder for Token based authentication
        - userId: integer
          userId
        
        
        """
        
        
        # Prepare query parameters
        params = {}
        if accountreference is not None:
            params["accountReference"] = accountreference
            
        
        
        # Replace path parameters in URL
        path = "/accountManagement/provisionalClosingBalance/{accountReference} "
        if accountreference is not None:
            path = path.replace("{accountReference}", str(accountreference))
        
        
        # Prepare headers
        headers = {}
        if accesstoken is not None:
            headers["Accesstoken"] = str(accesstoken)
        if channeltype is not None:
            headers["ChannelType"] = str(channeltype)
        if co_relationid is not None:
            headers["Co-Relationid"] = str(co_relationid)
        if initiatingsystem is not None:
            headers["InitiatingSystem"] = str(initiatingsystem)
        if servicemode is not None:
            headers["ServiceMode"] = str(servicemode)
        if uuidseqno is not None:
            headers["UUIDSeqNo"] = str(uuidseqno)
        if entity is not None:
            headers["entity"] = str(entity)
        if languagecode is not None:
            headers["languageCode"] = str(languagecode)
        if referenceid is not None:
            headers["referenceId"] = str(referenceid)
        if userid is not None:
            headers["userId"] = str(userid)
        
        
        return await make_api_request(
            "GET", 
            path, 
            
            params=params if params else None, 
            headers=headers if headers else None
        )
    
    
    
    @mcp.tool()
    async def ambtcrt_tdsweep_wrapper_postusing_post(
        request_body:Dict[str, Any] ,  # createTdSweepResource,
        accesstoken: Optional[str] = None,
        channeltype: Optional[int] = None,
        co_relationid: Optional[int] = None,
        initiatingsystem: Optional[str] = None,
        servicemode: Optional[int] = None,
        uuidseqno: Optional[int] = None,
        entity: Optional[str] = None,
        languagecode: Optional[int] = None,
        referenceid: Optional[str] = None,
        requesthash: Optional[str] = None,
        userid: Optional[int] = None
    ) -> Dict[str, Any]:
        """
        Create TD Sweep Details
        
        Generated from: POST /accountManagement/tdSweep
        Source: swagger_2_0
        Operation ID: AMBTCrtTDSweepWrapper_POSTUsingPOST
        
        
        Authentication: Not required
        
        Parameters:
        - request_body: any (required)
          input
        
        
        
        Headers:
        - Accesstoken: string
          Authorization token for identification of the caller
        - ChannelType: integer
          Channel identifier from where the TXN has originated (Internet, Mobile, ATM, Branch Channel )
        - Co-Relationid: integer
          Unique ID for the service invoked, will be set by the TXN system
        - InitiatingSystem: string
          Indicating the initiated system
        - ServiceMode: integer
          Used for branch channel to indicate the type of customer
        - UUIDSeqNo: integer
          UUID Sequence Number
        - entity: string
          entity
        - languageCode: integer
          languageCode
        - referenceId: string
          Place holder for Token based authentication
        - requesthash: string
          Request payload for hash validation
        - userId: integer
          userId
        
        
        """
        
        
        # Prepare request data
        
        # Single body parameter - send directly
        data = request_body if request_body is not None else {}
        
        
        
        # Prepare query parameters
        params = {}
        
        
        # Replace path parameters in URL
        path = "/accountManagement/tdSweep"
        
        
        # Prepare headers
        headers = {}
        if accesstoken is not None:
            headers["Accesstoken"] = str(accesstoken)
        if channeltype is not None:
            headers["ChannelType"] = str(channeltype)
        if co_relationid is not None:
            headers["Co-Relationid"] = str(co_relationid)
        if initiatingsystem is not None:
            headers["InitiatingSystem"] = str(initiatingsystem)
        if servicemode is not None:
            headers["ServiceMode"] = str(servicemode)
        if uuidseqno is not None:
            headers["UUIDSeqNo"] = str(uuidseqno)
        if entity is not None:
            headers["entity"] = str(entity)
        if languagecode is not None:
            headers["languageCode"] = str(languagecode)
        if referenceid is not None:
            headers["referenceId"] = str(referenceid)
        if requesthash is not None:
            headers["requesthash"] = str(requesthash)
        if userid is not None:
            headers["userId"] = str(userid)
        
        
        return await make_api_request(
            "POST", 
            path, 
            data=data, 
            params=params if params else None, 
            headers=headers if headers else None
        )
    
    
    
    @mcp.tool()
    async def ambtdelete_tdsweep_postusing_post(
        request_body:Dict[str, Any] ,  # deleteTdSweepResource,
        accesstoken: Optional[str] = None,
        channeltype: Optional[int] = None,
        co_relationid: Optional[int] = None,
        initiatingsystem: Optional[str] = None,
        servicemode: Optional[int] = None,
        uuidseqno: Optional[int] = None,
        entity: Optional[str] = None,
        languagecode: Optional[int] = None,
        referenceid: Optional[str] = None,
        requesthash: Optional[str] = None,
        userid: Optional[int] = None
    ) -> Dict[str, Any]:
        """
        Delete Td Sweep Details
        
        Generated from: POST /accountManagement/tdSweep/delete
        Source: swagger_2_0
        Operation ID: AMBTDeleteTDSweep_POSTUsingPOST
        
        
        Authentication: Not required
        
        Parameters:
        - request_body: any (required)
          input
        
        
        
        Headers:
        - Accesstoken: string
          Authorization token for identification of the caller
        - ChannelType: integer
          Channel identifier from where the TXN has originated (Internet, Mobile, ATM, Branch Channel )
        - Co-Relationid: integer
          Unique ID for the service invoked, will be set by the TXN system
        - InitiatingSystem: string
          Indicating the initiated system
        - ServiceMode: integer
          Used for branch channel to indicate the type of customer
        - UUIDSeqNo: integer
          UUID Sequence Number
        - entity: string
          entity
        - languageCode: integer
          languageCode
        - referenceId: string
          Place holder for Token based authentication
        - requesthash: string
          Request payload for hash validation
        - userId: integer
          userId
        
        
        """
        
        
        # Prepare request data
        
        # Single body parameter - send directly
        data = request_body if request_body is not None else {}
        
        
        
        # Prepare query parameters
        params = {}
        
        
        # Replace path parameters in URL
        path = "/accountManagement/tdSweep/delete"
        
        
        # Prepare headers
        headers = {}
        if accesstoken is not None:
            headers["Accesstoken"] = str(accesstoken)
        if channeltype is not None:
            headers["ChannelType"] = str(channeltype)
        if co_relationid is not None:
            headers["Co-Relationid"] = str(co_relationid)
        if initiatingsystem is not None:
            headers["InitiatingSystem"] = str(initiatingsystem)
        if servicemode is not None:
            headers["ServiceMode"] = str(servicemode)
        if uuidseqno is not None:
            headers["UUIDSeqNo"] = str(uuidseqno)
        if entity is not None:
            headers["entity"] = str(entity)
        if languagecode is not None:
            headers["languageCode"] = str(languagecode)
        if referenceid is not None:
            headers["referenceId"] = str(referenceid)
        if requesthash is not None:
            headers["requesthash"] = str(requesthash)
        if userid is not None:
            headers["userId"] = str(userid)
        
        
        return await make_api_request(
            "POST", 
            path, 
            data=data, 
            params=params if params else None, 
            headers=headers if headers else None
        )
    
    
    
    @mcp.tool()
    async def ambtdelete_auth_rej_td_postusing_post(
        request_body:Dict[str, Any] ,  # deleteAuthRejTD_Resource,
        accesstoken: Optional[str] = None,
        channeltype: Optional[int] = None,
        co_relationid: Optional[int] = None,
        initiatingsystem: Optional[str] = None,
        servicemode: Optional[int] = None,
        uuidseqno: Optional[int] = None,
        entity: Optional[str] = None,
        languagecode: Optional[int] = None,
        referenceid: Optional[str] = None,
        requesthash: Optional[str] = None,
        userid: Optional[int] = None
    ) -> Dict[str, Any]:
        """
        Authorize/Reject of Delete Td Sweep Details
        
        Generated from: POST /accountManagement/tdSweep/deleteAuthReject
        Source: swagger_2_0
        Operation ID: AMBTDeleteAuthRejTD_POSTUsingPOST
        
        
        Authentication: Not required
        
        Parameters:
        - request_body: any (required)
          input
        
        
        
        Headers:
        - Accesstoken: string
          Authorization token for identification of the caller
        - ChannelType: integer
          Channel identifier from where the TXN has originated (Internet, Mobile, ATM, Branch Channel )
        - Co-Relationid: integer
          Unique ID for the service invoked, will be set by the TXN system
        - InitiatingSystem: string
          Indicating the initiated system
        - ServiceMode: integer
          Used for branch channel to indicate the type of customer
        - UUIDSeqNo: integer
          UUID Sequence Number
        - entity: string
          entity
        - languageCode: integer
          languageCode
        - referenceId: string
          Place holder for Token based authentication
        - requesthash: string
          Request payload for hash validation
        - userId: integer
          userId
        
        
        """
        
        
        # Prepare request data
        
        # Single body parameter - send directly
        data = request_body if request_body is not None else {}
        
        
        
        # Prepare query parameters
        params = {}
        
        
        # Replace path parameters in URL
        path = "/accountManagement/tdSweep/deleteAuthReject"
        
        
        # Prepare headers
        headers = {}
        if accesstoken is not None:
            headers["Accesstoken"] = str(accesstoken)
        if channeltype is not None:
            headers["ChannelType"] = str(channeltype)
        if co_relationid is not None:
            headers["Co-Relationid"] = str(co_relationid)
        if initiatingsystem is not None:
            headers["InitiatingSystem"] = str(initiatingsystem)
        if servicemode is not None:
            headers["ServiceMode"] = str(servicemode)
        if uuidseqno is not None:
            headers["UUIDSeqNo"] = str(uuidseqno)
        if entity is not None:
            headers["entity"] = str(entity)
        if languagecode is not None:
            headers["languageCode"] = str(languagecode)
        if referenceid is not None:
            headers["referenceId"] = str(referenceid)
        if requesthash is not None:
            headers["requesthash"] = str(requesthash)
        if userid is not None:
            headers["userId"] = str(userid)
        
        
        return await make_api_request(
            "POST", 
            path, 
            data=data, 
            params=params if params else None, 
            headers=headers if headers else None
        )
    
    
    
    @mcp.tool()
    async def amet0303_tdsweep_postusing_get(
        accountreference: str,
        accesstoken: Optional[str] = None,
        channeltype: Optional[int] = None,
        co_relationid: Optional[int] = None,
        initiatingsystem: Optional[str] = None,
        servicemode: Optional[int] = None,
        uuidseqno: Optional[int] = None,
        entity: Optional[str] = None,
        languagecode: Optional[int] = None,
        referenceid: Optional[str] = None,
        userid: Optional[int] = None
    ) -> Dict[str, Any]:
        """
        Fetch TD Sweep Details
        
        Generated from: GET /accountManagement/tdSweep/{accountReference}
        Source: swagger_2_0
        Operation ID: AMET0303TDSweep_POSTUsingGET
        
        
        Authentication: Not required
        
        Parameters:
        - accountReference: string (required)
          Account Reference
        
        
        
        Headers:
        - Accesstoken: string
          Authorization token for identification of the caller
        - ChannelType: integer
          Channel identifier from where the TXN has originated (Internet, Mobile, ATM, Branch Channel )
        - Co-Relationid: integer
          Unique ID for the service invoked, will be set by the TXN system
        - InitiatingSystem: string
          Indicating the initiated system
        - ServiceMode: integer
          Used for branch channel to indicate the type of customer
        - UUIDSeqNo: integer
          UUID Sequence Number
        - entity: string
          entity
        - languageCode: integer
          languageCode
        - referenceId: string
          Place holder for Token based authentication
        - userId: integer
          userId
        
        
        """
        
        
        # Prepare query parameters
        params = {}
        
        
        # Replace path parameters in URL
        path = "/accountManagement/tdSweep/{accountReference}"
        if accountreference is not None:
            path = path.replace("{accountReference}", str(accountreference))
        
        
        # Prepare headers
        headers = {}
        if accesstoken is not None:
            headers["Accesstoken"] = str(accesstoken)
        if channeltype is not None:
            headers["ChannelType"] = str(channeltype)
        if co_relationid is not None:
            headers["Co-Relationid"] = str(co_relationid)
        if initiatingsystem is not None:
            headers["InitiatingSystem"] = str(initiatingsystem)
        if servicemode is not None:
            headers["ServiceMode"] = str(servicemode)
        if uuidseqno is not None:
            headers["UUIDSeqNo"] = str(uuidseqno)
        if entity is not None:
            headers["entity"] = str(entity)
        if languagecode is not None:
            headers["languageCode"] = str(languagecode)
        if referenceid is not None:
            headers["referenceId"] = str(referenceid)
        if userid is not None:
            headers["userId"] = str(userid)
        
        
        return await make_api_request(
            "GET", 
            path, 
            
            params=params if params else None, 
            headers=headers if headers else None
        )
    
    
    
    @mcp.tool()
    async def ambt2507_crt_txns_lmt_postusing_post(
        request_body:Dict[str, Any] ,  # limitUpdateResource,
        accesstoken: Optional[str] = None,
        channeltype: Optional[int] = None,
        co_relationid: Optional[int] = None,
        initiatingsystem: Optional[str] = None,
        servicemode: Optional[int] = None,
        uuidseqno: Optional[int] = None,
        entity: Optional[str] = None,
        languagecode: Optional[int] = None,
        referenceid: Optional[str] = None,
        requesthash: Optional[str] = None,
        userid: Optional[int] = None
    ) -> Dict[str, Any]:
        """
        API used for updating Global limit
        
        Generated from: POST /accountManagement/updateTransactionGlobalLimit
        Source: swagger_2_0
        Operation ID: AMBT2507CrtTxnsLmt_POSTUsingPOST
        
        
        Authentication: Not required
        
        Parameters:
        - request_body: any (required)
          input
        
        
        
        Headers:
        - Accesstoken: string
          Authorization Token to validation the caller
        - ChannelType: integer
          Channel identifier from where the TXN has originated (Internet, Mobile, ATM, Branch Channel )
        - Co-Relationid: integer
          Unique ID for the service invoked, will be set by the TXN system
        - InitiatingSystem: string
          Indicating the initiated system
        - ServiceMode: integer
          Used for branch channel to indicate the type of customer
        - UUIDSeqNo: integer
          UUID Sequence Number
        - entity: string
          entity
        - languageCode: integer
          languageCode
        - referenceId: string
          Place holder for Token based authentication
        - requesthash: string
          Request payload for hash validation
        - userId: integer
          userId
        
        
        """
        
        
        # Prepare request data
        
        # Single body parameter - send directly
        data = request_body if request_body is not None else {}
        
        
        
        # Prepare query parameters
        params = {}
        
        
        # Replace path parameters in URL
        path = "/accountManagement/updateTransactionGlobalLimit"
        
        
        # Prepare headers
        headers = {}
        if accesstoken is not None:
            headers["Accesstoken"] = str(accesstoken)
        if channeltype is not None:
            headers["ChannelType"] = str(channeltype)
        if co_relationid is not None:
            headers["Co-Relationid"] = str(co_relationid)
        if initiatingsystem is not None:
            headers["InitiatingSystem"] = str(initiatingsystem)
        if servicemode is not None:
            headers["ServiceMode"] = str(servicemode)
        if uuidseqno is not None:
            headers["UUIDSeqNo"] = str(uuidseqno)
        if entity is not None:
            headers["entity"] = str(entity)
        if languagecode is not None:
            headers["languageCode"] = str(languagecode)
        if referenceid is not None:
            headers["referenceId"] = str(referenceid)
        if requesthash is not None:
            headers["requesthash"] = str(requesthash)
        if userid is not None:
            headers["userId"] = str(userid)
        
        
        return await make_api_request(
            "POST", 
            path, 
            data=data, 
            params=params if params else None, 
            headers=headers if headers else None
        )
    
    
    
    @mcp.tool()
    async def ambtcncl_wntc_wrapper_postusing_put(
        request_body:Dict[str, Any] ,  # cancelWithDrawalNoticeWrapper_Resource,
        accesstoken: Optional[str] = None,
        channeltype: Optional[int] = None,
        co_relationid: Optional[int] = None,
        initiatingsystem: Optional[str] = None,
        servicemode: Optional[int] = None,
        uuidseqno: Optional[int] = None,
        entity: Optional[str] = None,
        languagecode: Optional[int] = None,
        userid: Optional[int] = None
    ) -> Dict[str, Any]:
        """
        Cancel withDrawal notice
        
        Generated from: PUT /accountManagement/withDrawalNotice/Cancel
        Source: swagger_2_0
        Operation ID: AMBTCnclWNtcWrapper_POSTUsingPUT
        
        
        Authentication: Not required
        
        Parameters:
        - request_body: any (required)
          input
        
        
        
        Headers:
        - Accesstoken: string
          Authorization Token to validation the caller
        - ChannelType: integer
          Channel identifier from where the TXN has originated (Internet, Mobile, ATM, Branch Channel )
        - Co-Relationid: integer
          Unique ID for the service invoked, will be set by the TXN system
        - InitiatingSystem: string
          Indicating the initiated system
        - ServiceMode: integer
          Used for branch channel to indicate the type of customer
        - UUIDSeqNo: integer
          UUID Sequence Number
        - entity: string
          entity
        - languageCode: integer
          languageCode
        - userId: integer
          userId
        
        
        """
        
        
        # Prepare request data
        
        # Single body parameter - send directly
        data = request_body if request_body is not None else {}
        
        
        
        # Prepare query parameters
        params = {}
        
        
        # Replace path parameters in URL
        path = "/accountManagement/withDrawalNotice/Cancel"
        
        
        # Prepare headers
        headers = {}
        if accesstoken is not None:
            headers["Accesstoken"] = str(accesstoken)
        if channeltype is not None:
            headers["ChannelType"] = str(channeltype)
        if co_relationid is not None:
            headers["Co-Relationid"] = str(co_relationid)
        if initiatingsystem is not None:
            headers["InitiatingSystem"] = str(initiatingsystem)
        if servicemode is not None:
            headers["ServiceMode"] = str(servicemode)
        if uuidseqno is not None:
            headers["UUIDSeqNo"] = str(uuidseqno)
        if entity is not None:
            headers["entity"] = str(entity)
        if languagecode is not None:
            headers["languageCode"] = str(languagecode)
        if userid is not None:
            headers["userId"] = str(userid)
        
        
        return await make_api_request(
            "PUT", 
            path, 
            data=data, 
            params=params if params else None, 
            headers=headers if headers else None
        )
    
    
    
    @mcp.tool()
    async def amet0212_ftch_ntc_lst_getusing_get(
        accountreference: str,
        leveltype: str,
        accesstoken: Optional[str] = None,
        channeltype: Optional[int] = None,
        co_relationid: Optional[int] = None,
        initiatingsystem: Optional[str] = None,
        servicemode: Optional[int] = None,
        uuidseqno: Optional[int] = None,
        entity: Optional[str] = None,
        languagecode: Optional[int] = None,
        userid: Optional[int] = None
    ) -> Dict[str, Any]:
        """
        WithDrawal notice List
        
        Generated from: GET /accountManagement/withDrawalNotice/list
        Source: swagger_2_0
        Operation ID: AMET0212FtchNtcLst_GETUsingGET
        
        
        Authentication: Not required
        
        Parameters:
        - accountReference: string (required)
          Notice deposit account reference
        - levelType: string (required)
          level type (2 - account)
        
        
        
        Headers:
        - Accesstoken: string
          Authorization Token to validation the caller
        - ChannelType: integer
          Channel identifier from where the TXN has originated (Internet, Mobile, ATM, Branch Channel )
        - Co-Relationid: integer
          Unique ID for the service invoked, will be set by the TXN system
        - InitiatingSystem: string
          Indicating the initiated system
        - ServiceMode: integer
          Used for branch channel to indicate the type of customer
        - UUIDSeqNo: integer
          UUID Sequence Number
        - entity: string
          entity
        - languageCode: integer
          languageCode
        - userId: integer
          userId
        
        
        """
        
        
        # Prepare query parameters
        params = {}
        if accountreference is not None:
            params["accountReference"] = accountreference
            
        if leveltype is not None:
            params["levelType"] = leveltype
            
        
        
        # Replace path parameters in URL
        path = "/accountManagement/withDrawalNotice/list"
        
        
        # Prepare headers
        headers = {}
        if accesstoken is not None:
            headers["Accesstoken"] = str(accesstoken)
        if channeltype is not None:
            headers["ChannelType"] = str(channeltype)
        if co_relationid is not None:
            headers["Co-Relationid"] = str(co_relationid)
        if initiatingsystem is not None:
            headers["InitiatingSystem"] = str(initiatingsystem)
        if servicemode is not None:
            headers["ServiceMode"] = str(servicemode)
        if uuidseqno is not None:
            headers["UUIDSeqNo"] = str(uuidseqno)
        if entity is not None:
            headers["entity"] = str(entity)
        if languagecode is not None:
            headers["languageCode"] = str(languagecode)
        if userid is not None:
            headers["userId"] = str(userid)
        
        
        return await make_api_request(
            "GET", 
            path, 
            
            params=params if params else None, 
            headers=headers if headers else None
        )
    
    
    
    @mcp.tool()
    async def amet0210_get_wntc_dtls_getusing_get(
        withdrawalnoticenumber: int,
        accesstoken: Optional[str] = None,
        channeltype: Optional[int] = None,
        co_relationid: Optional[int] = None,
        initiatingsystem: Optional[str] = None,
        servicemode: Optional[int] = None,
        uuidseqno: Optional[int] = None,
        entity: Optional[str] = None,
        languagecode: Optional[int] = None,
        userid: Optional[int] = None
    ) -> Dict[str, Any]:
        """
        View withDrawal notice
        
        Generated from: GET /accountManagement/withdrawalNotice/view
        Source: swagger_2_0
        Operation ID: AMET0210GetWNtcDtls_GETUsingGET
        
        
        Authentication: Not required
        
        Parameters:
        - withdrawalNoticeNumber: integer (required)
          Unique Reference generated after creation of withdrawal notice
        
        
        
        Headers:
        - Accesstoken: string
          Authorization Token to validation the caller
        - ChannelType: integer
          Channel identifier from where the TXN has originated (Internet, Mobile, ATM, Branch Channel )
        - Co-Relationid: integer
          Unique ID for the service invoked, will be set by the TXN system
        - InitiatingSystem: string
          Indicating the initiated system
        - ServiceMode: integer
          Used for branch channel to indicate the type of customer
        - UUIDSeqNo: integer
          UUID Sequence Number
        - entity: string
          entity
        - languageCode: integer
          languageCode
        - userId: integer
          userId
        
        
        """
        
        
        # Prepare query parameters
        params = {}
        if withdrawalnoticenumber is not None:
            params["withdrawalNoticeNumber"] = withdrawalnoticenumber
            
        
        
        # Replace path parameters in URL
        path = "/accountManagement/withdrawalNotice/view"
        
        
        # Prepare headers
        headers = {}
        if accesstoken is not None:
            headers["Accesstoken"] = str(accesstoken)
        if channeltype is not None:
            headers["ChannelType"] = str(channeltype)
        if co_relationid is not None:
            headers["Co-Relationid"] = str(co_relationid)
        if initiatingsystem is not None:
            headers["InitiatingSystem"] = str(initiatingsystem)
        if servicemode is not None:
            headers["ServiceMode"] = str(servicemode)
        if uuidseqno is not None:
            headers["UUIDSeqNo"] = str(uuidseqno)
        if entity is not None:
            headers["entity"] = str(entity)
        if languagecode is not None:
            headers["languageCode"] = str(languagecode)
        if userid is not None:
            headers["userId"] = str(userid)
        
        
        return await make_api_request(
            "GET", 
            path, 
            
            params=params if params else None, 
            headers=headers if headers else None
        )
    
    
    
    @mcp.tool()
    async def aibt1924_authorise_fixed_asset_dtls_postusing_post(
        request_body:Dict[str, Any] ,  # authoriseFixedAssetDtlsResource,
        accesstoken: Optional[str] = None,
        channeltype: Optional[int] = None,
        co_relationid: Optional[int] = None,
        initiatingsystem: Optional[str] = None,
        servicemode: Optional[int] = None,
        uuidseqno: Optional[int] = None,
        entity: Optional[str] = None,
        languagecode: Optional[int] = None,
        userid: Optional[int] = None
    ) -> Dict[str, Any]:
        """
        Authorise Fixed Asset Details
        
        Generated from: POST /assetInformation/authorise/fixedassetdetails
        Source: swagger_2_0
        Operation ID: AIBT1924AuthoriseFixedAssetDtls_POSTUsingPOST
        
        
        Authentication: Not required
        
        Parameters:
        - request_body: any (required)
          input
        
        
        
        Headers:
        - Accesstoken: string
          Authorization Token to validation the caller
        - ChannelType: integer
          Channel identifier from where the TXN has originated (Internet, Mobile, ATM, Branch Channel )
        - Co-Relationid: integer
          Unique ID for the service invoked, will be set by the TXN system
        - InitiatingSystem: string
          Indicating the initiated system
        - ServiceMode: integer
          Used for branch channel to indicate the type of customer
        - UUIDSeqNo: integer
          UUID Sequence Number
        - entity: string
          entity
        - languageCode: integer
          languageCode
        - userId: integer
          userId
        
        
        """
        
        
        # Prepare request data
        
        # Single body parameter - send directly
        data = request_body if request_body is not None else {}
        
        
        
        # Prepare query parameters
        params = {}
        
        
        # Replace path parameters in URL
        path = "/assetInformation/authorise/fixedassetdetails"
        
        
        # Prepare headers
        headers = {}
        if accesstoken is not None:
            headers["Accesstoken"] = str(accesstoken)
        if channeltype is not None:
            headers["ChannelType"] = str(channeltype)
        if co_relationid is not None:
            headers["Co-Relationid"] = str(co_relationid)
        if initiatingsystem is not None:
            headers["InitiatingSystem"] = str(initiatingsystem)
        if servicemode is not None:
            headers["ServiceMode"] = str(servicemode)
        if uuidseqno is not None:
            headers["UUIDSeqNo"] = str(uuidseqno)
        if entity is not None:
            headers["entity"] = str(entity)
        if languagecode is not None:
            headers["languageCode"] = str(languagecode)
        if userid is not None:
            headers["userId"] = str(userid)
        
        
        return await make_api_request(
            "POST", 
            path, 
            data=data, 
            params=params if params else None, 
            headers=headers if headers else None
        )
    
    
    
    @mcp.tool()
    async def aiet1921_fetch_fixed_asset_dtls_getusing_get(
        assetsubtype: Optional[int] = None,
        assettype: Optional[int] = None,
        fixedassetstatus: Optional[int] = None,
        fixedassetsubstatus: Optional[int] = None,
        location: Optional[int] = None,
        locationbranch: Optional[int] = None,
        locationdepartment: Optional[int] = None,
        pagenum: Optional[int] = None,
        pagesize: Optional[int] = None,
        purchasedatefrom: Optional[str] = None,
        purchasedateto: Optional[str] = None,
        urnnumber: Optional[str] = None,
        accesstoken: Optional[str] = None,
        channeltype: Optional[int] = None,
        co_relationid: Optional[int] = None,
        initiatingsystem: Optional[str] = None,
        servicemode: Optional[int] = None,
        uuidseqno: Optional[int] = None,
        entity: Optional[str] = None,
        languagecode: Optional[int] = None,
        userid: Optional[int] = None
    ) -> Dict[str, Any]:
        """
        fetch Fixed Asset Details
        
        Generated from: GET /assetInformation/fetch/fixedAssetDetails
        Source: swagger_2_0
        Operation ID: AIET1921FetchFixedAssetDtls_GETUsingGET
        
        
        Authentication: Not required
        
        Parameters:
        - assetSubType: integer
          assetSubType
        - assetType: integer
          assetType
        - fixedAssetStatus: integer
          fixedAssetStatus
        - fixedAssetSubStatus: integer
          fixedAssetSubStatus
        - location: integer
          location
        - locationBranch: integer
          locationBranch
        - locationDepartment: integer
          locationDepartment
        - pageNum: integer
          pageNum
        - pageSize: integer
          pageSize
        - purchaseDateFrom: string
          purchaseDateFrom
        - purchaseDateTo: string
          purchaseDateTo
        - urnNumber: string
          FA_URN
        
        
        
        Headers:
        - Accesstoken: string
          Authorization token for identification of the caller
        - ChannelType: integer
          Channel identifier from where the TXN has originated (Internet, Mobile, ATM, Branch Channel )
        - Co-Relationid: integer
          Unique ID for the service invoked, will be set by the TXN system
        - InitiatingSystem: string
          Indicating the initiated system
        - ServiceMode: integer
          Used for branch channel to indicate the type of customer
        - UUIDSeqNo: integer
          UUID Sequence Number
        - entity: string
          entity
        - languageCode: integer
          languageCode
        - userId: integer
          userId
        
        
        """
        
        
        # Prepare query parameters
        params = {}
        if assetsubtype is not None:
            params["assetSubType"] = assetsubtype
            
        if assettype is not None:
            params["assetType"] = assettype
            
        if fixedassetstatus is not None:
            params["fixedAssetStatus"] = fixedassetstatus
            
        if fixedassetsubstatus is not None:
            params["fixedAssetSubStatus"] = fixedassetsubstatus
            
        if location is not None:
            params["location"] = location
            
        if locationbranch is not None:
            params["locationBranch"] = locationbranch
            
        if locationdepartment is not None:
            params["locationDepartment"] = locationdepartment
            
        if pagenum is not None:
            params["pageNum"] = pagenum
            
        if pagesize is not None:
            params["pageSize"] = pagesize
            
        if purchasedatefrom is not None:
            params["purchaseDateFrom"] = purchasedatefrom
            
        if purchasedateto is not None:
            params["purchaseDateTo"] = purchasedateto
            
        if urnnumber is not None:
            params["urnNumber"] = urnnumber
            
        
        
        # Replace path parameters in URL
        path = "/assetInformation/fetch/fixedAssetDetails"
        
        
        # Prepare headers
        headers = {}
        if accesstoken is not None:
            headers["Accesstoken"] = str(accesstoken)
        if channeltype is not None:
            headers["ChannelType"] = str(channeltype)
        if co_relationid is not None:
            headers["Co-Relationid"] = str(co_relationid)
        if initiatingsystem is not None:
            headers["InitiatingSystem"] = str(initiatingsystem)
        if servicemode is not None:
            headers["ServiceMode"] = str(servicemode)
        if uuidseqno is not None:
            headers["UUIDSeqNo"] = str(uuidseqno)
        if entity is not None:
            headers["entity"] = str(entity)
        if languagecode is not None:
            headers["languageCode"] = str(languagecode)
        if userid is not None:
            headers["userId"] = str(userid)
        
        
        return await make_api_request(
            "GET", 
            path, 
            
            params=params if params else None, 
            headers=headers if headers else None
        )
    
    
    
    @mcp.tool()
    async def aibt1922_create_fixed_asset_dtls_postusing_post(
        request_body:Dict[str, Any] ,  # createFixedAssetDtlsResource,
        accesstoken: Optional[str] = None,
        channeltype: Optional[int] = None,
        co_relationid: Optional[int] = None,
        initiatingsystem: Optional[str] = None,
        servicemode: Optional[int] = None,
        uuidseqno: Optional[int] = None,
        entity: Optional[str] = None,
        languagecode: Optional[int] = None,
        userid: Optional[int] = None
    ) -> Dict[str, Any]:
        """
        Create Fixed Asset
        
        Generated from: POST /assetInformation/fixedAsset/create
        Source: swagger_2_0
        Operation ID: AIBT1922CreateFixedAssetDtls_POSTUsingPOST
        
        
        Authentication: Not required
        
        Parameters:
        - request_body: any (required)
          input
        
        
        
        Headers:
        - Accesstoken: string
          Authorization Token to validation the caller
        - ChannelType: integer
          Channel identifier from where the TXN has originated (Internet, Mobile, ATM, Branch Channel )
        - Co-Relationid: integer
          Unique ID for the service invoked, will be set by the TXN system
        - InitiatingSystem: string
          Indicating the initiated system
        - ServiceMode: integer
          Used for branch channel to indicate the type of customer
        - UUIDSeqNo: integer
          UUID Sequence Number
        - entity: string
          entity
        - languageCode: integer
          languageCode
        - userId: integer
          userId
        
        
        """
        
        
        # Prepare request data
        
        # Single body parameter - send directly
        data = request_body if request_body is not None else {}
        
        
        
        # Prepare query parameters
        params = {}
        
        
        # Replace path parameters in URL
        path = "/assetInformation/fixedAsset/create"
        
        
        # Prepare headers
        headers = {}
        if accesstoken is not None:
            headers["Accesstoken"] = str(accesstoken)
        if channeltype is not None:
            headers["ChannelType"] = str(channeltype)
        if co_relationid is not None:
            headers["Co-Relationid"] = str(co_relationid)
        if initiatingsystem is not None:
            headers["InitiatingSystem"] = str(initiatingsystem)
        if servicemode is not None:
            headers["ServiceMode"] = str(servicemode)
        if uuidseqno is not None:
            headers["UUIDSeqNo"] = str(uuidseqno)
        if entity is not None:
            headers["entity"] = str(entity)
        if languagecode is not None:
            headers["languageCode"] = str(languagecode)
        if userid is not None:
            headers["userId"] = str(userid)
        
        
        return await make_api_request(
            "POST", 
            path, 
            data=data, 
            params=params if params else None, 
            headers=headers if headers else None
        )
    
    
    
    @mcp.tool()
    async def aiet1922_get_fixed_asset_dtls_postusing_get(
        faurnnumber: str,
        accesstoken: Optional[str] = None,
        channeltype: Optional[int] = None,
        co_relationid: Optional[int] = None,
        initiatingsystem: Optional[str] = None,
        servicemode: Optional[int] = None,
        uuidseqno: Optional[int] = None,
        entity: Optional[str] = None,
        languagecode: Optional[int] = None,
        userid: Optional[int] = None
    ) -> Dict[str, Any]:
        """
        get Fixed Asset
        
        Generated from: GET /assetInformation/get/FixedAsset
        Source: swagger_2_0
        Operation ID: AIET1922GetFixedAssetDtls_POSTUsingGET
        
        
        Authentication: Not required
        
        Parameters:
        - faUrnNumber: string (required)
          FA_URN
        
        
        
        Headers:
        - Accesstoken: string
          Authorization token for identification of the caller
        - ChannelType: integer
          Channel identifier from where the TXN has originated (Internet, Mobile, ATM, Branch Channel )
        - Co-Relationid: integer
          Unique ID for the service invoked, will be set by the TXN system
        - InitiatingSystem: string
          Indicating the initiated system
        - ServiceMode: integer
          Used for branch channel to indicate the type of customer
        - UUIDSeqNo: integer
          UUID Sequence Number
        - entity: string
          entity
        - languageCode: integer
          languageCode
        - userId: integer
          userId
        
        
        """
        
        
        # Prepare query parameters
        params = {}
        if faurnnumber is not None:
            params["faUrnNumber"] = faurnnumber
            
        
        
        # Replace path parameters in URL
        path = "/assetInformation/get/FixedAsset"
        
        
        # Prepare headers
        headers = {}
        if accesstoken is not None:
            headers["Accesstoken"] = str(accesstoken)
        if channeltype is not None:
            headers["ChannelType"] = str(channeltype)
        if co_relationid is not None:
            headers["Co-Relationid"] = str(co_relationid)
        if initiatingsystem is not None:
            headers["InitiatingSystem"] = str(initiatingsystem)
        if servicemode is not None:
            headers["ServiceMode"] = str(servicemode)
        if uuidseqno is not None:
            headers["UUIDSeqNo"] = str(uuidseqno)
        if entity is not None:
            headers["entity"] = str(entity)
        if languagecode is not None:
            headers["languageCode"] = str(languagecode)
        if userid is not None:
            headers["userId"] = str(userid)
        
        
        return await make_api_request(
            "GET", 
            path, 
            
            params=params if params else None, 
            headers=headers if headers else None
        )
    
    
    
    @mcp.tool()
    async def aiet1930_fetch_fixed_asset_tag_dtls_getusing_get(
        faurnnumber: str,
        pagenum: Optional[int] = None,
        pagesize: Optional[int] = None,
        accesstoken: Optional[str] = None,
        channeltype: Optional[int] = None,
        co_relationid: Optional[int] = None,
        initiatingsystem: Optional[str] = None,
        servicemode: Optional[int] = None,
        uuidseqno: Optional[int] = None,
        entity: Optional[str] = None,
        languagecode: Optional[int] = None,
        userid: Optional[int] = None
    ) -> Dict[str, Any]:
        """
        Get Fixed Asset Tag Details
        
        Generated from: GET /assetInformation/get/FixedAssetTagDetail
        Source: swagger_2_0
        Operation ID: AIET1930FetchFixedAssetTagDtls_GETUsingGET
        
        
        Authentication: Not required
        
        Parameters:
        - faUrnNumber: string (required)
          FA_URN
        - pageNum: integer
          pageNum
        - pageSize: integer
          pageSize
        
        
        
        Headers:
        - Accesstoken: string
          Authorization token for identification of the caller
        - ChannelType: integer
          Channel identifier from where the TXN has originated (Internet, Mobile, ATM, Branch Channel )
        - Co-Relationid: integer
          Unique ID for the service invoked, will be set by the TXN system
        - InitiatingSystem: string
          Indicating the initiated system
        - ServiceMode: integer
          Used for branch channel to indicate the type of customer
        - UUIDSeqNo: integer
          UUID Sequence Number
        - entity: string
          entity
        - languageCode: integer
          languageCode
        - userId: integer
          userId
        
        
        """
        
        
        # Prepare query parameters
        params = {}
        if faurnnumber is not None:
            params["faUrnNumber"] = faurnnumber
            
        if pagenum is not None:
            params["pageNum"] = pagenum
            
        if pagesize is not None:
            params["pageSize"] = pagesize
            
        
        
        # Replace path parameters in URL
        path = "/assetInformation/get/FixedAssetTagDetail"
        
        
        # Prepare headers
        headers = {}
        if accesstoken is not None:
            headers["Accesstoken"] = str(accesstoken)
        if channeltype is not None:
            headers["ChannelType"] = str(channeltype)
        if co_relationid is not None:
            headers["Co-Relationid"] = str(co_relationid)
        if initiatingsystem is not None:
            headers["InitiatingSystem"] = str(initiatingsystem)
        if servicemode is not None:
            headers["ServiceMode"] = str(servicemode)
        if uuidseqno is not None:
            headers["UUIDSeqNo"] = str(uuidseqno)
        if entity is not None:
            headers["entity"] = str(entity)
        if languagecode is not None:
            headers["languageCode"] = str(languagecode)
        if userid is not None:
            headers["userId"] = str(userid)
        
        
        return await make_api_request(
            "GET", 
            path, 
            
            params=params if params else None, 
            headers=headers if headers else None
        )
    
    
    
    @mcp.tool()
    async def aibt1931_update_tag_release_postusing_post(
        request_body:Dict[str, Any] ,  # updateFixedAssetTagDtlsResource,
        accesstoken: Optional[str] = None,
        channeltype: Optional[int] = None,
        co_relationid: Optional[int] = None,
        initiatingsystem: Optional[str] = None,
        servicemode: Optional[int] = None,
        uuidseqno: Optional[int] = None,
        entity: Optional[str] = None,
        languagecode: Optional[int] = None,
        userid: Optional[int] = None
    ) -> Dict[str, Any]:
        """
        update Fixed Asset Tag Details
        
        Generated from: POST /assetInformation/modify/FixedAssetTagDetail
        Source: swagger_2_0
        Operation ID: AIBT1931UpdateTagRelease_POSTUsingPOST
        
        
        Authentication: Not required
        
        Parameters:
        - request_body: any (required)
          input
        
        
        
        Headers:
        - Accesstoken: string
          Authorization token for identification of the caller
        - ChannelType: integer
          Channel identifier from where the TXN has originated (Internet, Mobile, ATM, Branch Channel )
        - Co-Relationid: integer
          Unique ID for the service invoked, will be set by the TXN system
        - InitiatingSystem: string
          Indicating the initiated system
        - ServiceMode: integer
          Used for branch channel to indicate the type of customer
        - UUIDSeqNo: integer
          UUID Sequence Number
        - entity: string
          entity
        - languageCode: integer
          languageCode
        - userId: integer
          userId
        
        
        """
        
        
        # Prepare request data
        
        # Single body parameter - send directly
        data = request_body if request_body is not None else {}
        
        
        
        # Prepare query parameters
        params = {}
        
        
        # Replace path parameters in URL
        path = "/assetInformation/modify/FixedAssetTagDetail"
        
        
        # Prepare headers
        headers = {}
        if accesstoken is not None:
            headers["Accesstoken"] = str(accesstoken)
        if channeltype is not None:
            headers["ChannelType"] = str(channeltype)
        if co_relationid is not None:
            headers["Co-Relationid"] = str(co_relationid)
        if initiatingsystem is not None:
            headers["InitiatingSystem"] = str(initiatingsystem)
        if servicemode is not None:
            headers["ServiceMode"] = str(servicemode)
        if uuidseqno is not None:
            headers["UUIDSeqNo"] = str(uuidseqno)
        if entity is not None:
            headers["entity"] = str(entity)
        if languagecode is not None:
            headers["languageCode"] = str(languagecode)
        if userid is not None:
            headers["userId"] = str(userid)
        
        
        return await make_api_request(
            "POST", 
            path, 
            data=data, 
            params=params if params else None, 
            headers=headers if headers else None
        )
    
    
    
    @mcp.tool()
    async def aibt1923_modify_fixed_asset_dtls_postusing_post(
        request_body:Dict[str, Any] ,  # modifyFixedAssetDtlsResource,
        accesstoken: Optional[str] = None,
        channeltype: Optional[int] = None,
        co_relationid: Optional[int] = None,
        initiatingsystem: Optional[str] = None,
        servicemode: Optional[int] = None,
        uuidseqno: Optional[int] = None,
        entity: Optional[str] = None,
        languagecode: Optional[int] = None,
        userid: Optional[int] = None
    ) -> Dict[str, Any]:
        """
        Modify Fixed Asset Details
        
        Generated from: POST /assetInformation/modify/fixedassetdtls
        Source: swagger_2_0
        Operation ID: AIBT1923ModifyFixedAssetDtls_POSTUsingPOST
        
        
        Authentication: Not required
        
        Parameters:
        - request_body: any (required)
          input
        
        
        
        Headers:
        - Accesstoken: string
          Authorization Token to validation the caller
        - ChannelType: integer
          Channel identifier from where the TXN has originated (Internet, Mobile, ATM, Branch Channel )
        - Co-Relationid: integer
          Unique ID for the service invoked, will be set by the TXN system
        - InitiatingSystem: string
          Indicating the initiated system
        - ServiceMode: integer
          Used for branch channel to indicate the type of customer
        - UUIDSeqNo: integer
          UUID Sequence Number
        - entity: string
          entity
        - languageCode: integer
          languageCode
        - userId: integer
          userId
        
        
        """
        
        
        # Prepare request data
        
        # Single body parameter - send directly
        data = request_body if request_body is not None else {}
        
        
        
        # Prepare query parameters
        params = {}
        
        
        # Replace path parameters in URL
        path = "/assetInformation/modify/fixedassetdtls"
        
        
        # Prepare headers
        headers = {}
        if accesstoken is not None:
            headers["Accesstoken"] = str(accesstoken)
        if channeltype is not None:
            headers["ChannelType"] = str(channeltype)
        if co_relationid is not None:
            headers["Co-Relationid"] = str(co_relationid)
        if initiatingsystem is not None:
            headers["InitiatingSystem"] = str(initiatingsystem)
        if servicemode is not None:
            headers["ServiceMode"] = str(servicemode)
        if uuidseqno is not None:
            headers["UUIDSeqNo"] = str(uuidseqno)
        if entity is not None:
            headers["entity"] = str(entity)
        if languagecode is not None:
            headers["languageCode"] = str(languagecode)
        if userid is not None:
            headers["userId"] = str(userid)
        
        
        return await make_api_request(
            "POST", 
            path, 
            data=data, 
            params=params if params else None, 
            headers=headers if headers else None
        )
    
    
    
    @mcp.tool()
    async def bset0805_ftch_actv_entity_lst_postusing_get(
        bankname: Optional[str] = None,
        timezonedescription: Optional[int] = None,
        pagenum: Optional[int] = None,
        pagesize: Optional[int] = None,
        accesstoken: Optional[str] = None,
        channeltype: Optional[int] = None,
        co_relationid: Optional[int] = None,
        initiatingsystem: Optional[str] = None,
        servicemode: Optional[int] = None,
        uuidseqno: Optional[int] = None,
        languagecode: Optional[int] = None,
        referenceid: Optional[str] = None,
        userid: Optional[int] = None
    ) -> Dict[str, Any]:
        """
        Fetches active bank details
        
        Generated from: GET /bankstructure/bank/OperationUnit/entityList
        Source: swagger_2_0
        Operation ID: BSET0805FtchActvEntityLst_POSTUsingGET
        
        
        Authentication: Not required
        
        Parameters:
        - BankName: string
          Name of the Bank
        - TimeZoneDescription: integer
          Description of the selected Time Zone
        - pageNum: integer
          pageNum
        - pageSize: integer
          pageSize
        
        
        
        Headers:
        - Accesstoken: string
          Authorization token for identification of the caller
        - ChannelType: integer
          Channel identifier from where the Transaction has originated (Internet, Mobile, ATM, Branch Channel )
        - Co-Relationid: integer
          Unique ID for the service invoked, will be set by the Transaction system
        - InitiatingSystem: string
          Indicating the initiated system
        - ServiceMode: integer
          Used for branch channel to indicate the type of customer
        - UUIDSeqNo: integer
          UUID Sequence Number
        - languageCode: integer
          languageCode
        - referenceId: string
          Place holder for Token based authentication
        - userId: integer
          userId
        
        
        """
        
        
        # Prepare query parameters
        params = {}
        if bankname is not None:
            params["BankName"] = bankname
            
        if timezonedescription is not None:
            params["TimeZoneDescription"] = timezonedescription
            
        if pagenum is not None:
            params["pageNum"] = pagenum
            
        if pagesize is not None:
            params["pageSize"] = pagesize
            
        
        
        # Replace path parameters in URL
        path = "/bankstructure/bank/OperationUnit/entityList"
        
        
        # Prepare headers
        headers = {}
        if accesstoken is not None:
            headers["Accesstoken"] = str(accesstoken)
        if channeltype is not None:
            headers["ChannelType"] = str(channeltype)
        if co_relationid is not None:
            headers["Co-Relationid"] = str(co_relationid)
        if initiatingsystem is not None:
            headers["InitiatingSystem"] = str(initiatingsystem)
        if servicemode is not None:
            headers["ServiceMode"] = str(servicemode)
        if uuidseqno is not None:
            headers["UUIDSeqNo"] = str(uuidseqno)
        if languagecode is not None:
            headers["languageCode"] = str(languagecode)
        if referenceid is not None:
            headers["referenceId"] = str(referenceid)
        if userid is not None:
            headers["userId"] = str(userid)
        
        
        return await make_api_request(
            "GET", 
            path, 
            
            params=params if params else None, 
            headers=headers if headers else None
        )
    
    
    
    @mcp.tool()
    async def bset0802_ftch_actv_banks_postusing_get(
        pagenum: Optional[int] = None,
        pagesize: Optional[int] = None,
        accesstoken: Optional[str] = None,
        channeltype: Optional[int] = None,
        co_relationid: Optional[int] = None,
        initiatingsystem: Optional[str] = None,
        servicemode: Optional[int] = None,
        uuidseqno: Optional[int] = None,
        languagecode: Optional[int] = None,
        referenceid: Optional[str] = None,
        userid: Optional[int] = None
    ) -> Dict[str, Any]:
        """
        Fetches all active banks
        
        Generated from: GET /bankstructure/bank/activeBankList
        Source: swagger_2_0
        Operation ID: BSET0802FtchActvBanks_POSTUsingGET
        
        
        Authentication: Not required
        
        Parameters:
        - pageNum: integer
          pageNum
        - pageSize: integer
          pageSize
        
        
        
        Headers:
        - Accesstoken: string
          Authorization token for identification of the caller
        - ChannelType: integer
          Channel identifier from where the Transaction has originated (Internet, Mobile, ATM, Branch Channel )
        - Co-Relationid: integer
          Unique ID for the service invoked, will be set by the Transaction system
        - InitiatingSystem: string
          Indicating the initiated system
        - ServiceMode: integer
          Used for branch channel to indicate the type of customer
        - UUIDSeqNo: integer
          UUID Sequence Number
        - languageCode: integer
          languageCode
        - referenceId: string
          Place holder for Token based authentication
        - userId: integer
          userId
        
        
        """
        
        
        # Prepare query parameters
        params = {}
        if pagenum is not None:
            params["pageNum"] = pagenum
            
        if pagesize is not None:
            params["pageSize"] = pagesize
            
        
        
        # Replace path parameters in URL
        path = "/bankstructure/bank/activeBankList"
        
        
        # Prepare headers
        headers = {}
        if accesstoken is not None:
            headers["Accesstoken"] = str(accesstoken)
        if channeltype is not None:
            headers["ChannelType"] = str(channeltype)
        if co_relationid is not None:
            headers["Co-Relationid"] = str(co_relationid)
        if initiatingsystem is not None:
            headers["InitiatingSystem"] = str(initiatingsystem)
        if servicemode is not None:
            headers["ServiceMode"] = str(servicemode)
        if uuidseqno is not None:
            headers["UUIDSeqNo"] = str(uuidseqno)
        if languagecode is not None:
            headers["languageCode"] = str(languagecode)
        if referenceid is not None:
            headers["referenceId"] = str(referenceid)
        if userid is not None:
            headers["userId"] = str(userid)
        
        
        return await make_api_request(
            "GET", 
            path, 
            
            params=params if params else None, 
            headers=headers if headers else None
        )
    
    
    
    @mcp.tool()
    async def cbcet4392_get_prnt_mufrom_muhrchy_using_get(
        branchid: Optional[str] = None,
        pagenum: Optional[int] = None,
        pagesize: Optional[int] = None,
        purpose: Optional[str] = None,
        channeltype: Optional[int] = None,
        co_relationid: Optional[int] = None,
        entity: Optional[str] = None,
        initiatingsystem: Optional[str] = None,
        languagecode: Optional[int] = None,
        mu_id: Optional[str] = None,
        servicemode: Optional[int] = None,
        userid: Optional[int] = None,
        uuidseqno: Optional[int] = None
    ) -> Dict[str, Any]:
        """
        Fetches Parent Branch from Branch Hierarchy
        
        Generated from: GET /bankstructure/bank/fetchParentBranch
        Source: swagger_2_0
        Operation ID: CBCET4392GetPrntMUFromMUHrchyUsingGET
        
        
        Authentication: Not required
        
        Parameters:
        - branchId: string
          Branch id
        - pageNum: integer
          pageNum
        - pageSize: integer
          pageSize
        - purpose: string
          Purpose
        
        
        
        Headers:
        - ChannelType: integer
          Channel identifier from where the TXN has originated (Internet, Mobile, ATM, Branch Channel )
        - co-Relationid: integer
          Unique ID for the service invoked, will be set by the TXN system
        - entity: string
          entity
        - initiatingSystem: string
          Indicating the initiated system
        - languageCode: integer
          languageCode
        - mu_Id: string
          Used to indicate the Branch Id of user
        - serviceMode: integer
          Used for branch channel to indicate the type of customer
        - userId: integer
          userId
        - uuidSeqNo: integer
          UUID Sequence Number
        
        
        """
        
        
        # Prepare query parameters
        params = {}
        if branchid is not None:
            params["branchId"] = branchid
            
        if pagenum is not None:
            params["pageNum"] = pagenum
            
        if pagesize is not None:
            params["pageSize"] = pagesize
            
        if purpose is not None:
            params["purpose"] = purpose
            
        
        
        # Replace path parameters in URL
        path = "/bankstructure/bank/fetchParentBranch"
        
        
        # Prepare headers
        headers = {}
        if channeltype is not None:
            headers["ChannelType"] = str(channeltype)
        if co_relationid is not None:
            headers["co-Relationid"] = str(co_relationid)
        if entity is not None:
            headers["entity"] = str(entity)
        if initiatingsystem is not None:
            headers["initiatingSystem"] = str(initiatingsystem)
        if languagecode is not None:
            headers["languageCode"] = str(languagecode)
        if mu_id is not None:
            headers["mu_Id"] = str(mu_id)
        if servicemode is not None:
            headers["serviceMode"] = str(servicemode)
        if userid is not None:
            headers["userId"] = str(userid)
        if uuidseqno is not None:
            headers["uuidSeqNo"] = str(uuidseqno)
        
        
        return await make_api_request(
            "GET", 
            path, 
            
            params=params if params else None, 
            headers=headers if headers else None
        )
    
    
    
    @mcp.tool()
    async def bset0804_ftch_bank_lst_postusing_get(
        entity: Optional[str] = None,
        status: Optional[str] = None,
        pagenum: Optional[int] = None,
        pagesize: Optional[int] = None,
        accesstoken: Optional[str] = None,
        channeltype: Optional[int] = None,
        co_relationid: Optional[int] = None,
        initiatingsystem: Optional[str] = None,
        servicemode: Optional[int] = None,
        uuidseqno: Optional[int] = None,
        languagecode: Optional[int] = None,
        userid: Optional[int] = None
    ) -> Dict[str, Any]:
        """
        Fetches banks present in the system.
        
        Generated from: GET /bankstructure/bank/list
        Source: swagger_2_0
        Operation ID: BSET0804FtchBankLst_POSTUsingGET
        
        
        Authentication: Not required
        
        Parameters:
        - Entity: string
          This Field shows Operational Unit  Like GPRDT, GBANK etc
        - Status: string
          This field shows status of Banks to be fetched(1-Entered,2-Active,3-Pending Closure,4-Closed,5-Reject,6-Pending Authorize)
        - pageNum: integer
          pageNum
        - pageSize: integer
          pageSize
        
        
        
        Headers:
        - Accesstoken: string
          Authorization token for identification of the caller
        - ChannelType: integer
          Channel identifier from where the Transaction has originated (Internet, Mobile, ATM, Branch Channel )
        - Co-Relationid: integer
          Unique ID for the service invoked, will be set by the Transaction system
        - InitiatingSystem: string
          Indicating the initiated system
        - ServiceMode: integer
          Used for branch channel to indicate the type of customer
        - UUIDSeqNo: integer
          UUID Sequence Number
        - languageCode: integer
          languageCode
        - userId: integer
          userId
        
        
        """
        
        
        # Prepare query parameters
        params = {}
        if entity is not None:
            params["Entity"] = entity
            
        if status is not None:
            params["Status"] = status
            
        if pagenum is not None:
            params["pageNum"] = pagenum
            
        if pagesize is not None:
            params["pageSize"] = pagesize
            
        
        
        # Replace path parameters in URL
        path = "/bankstructure/bank/list"
        
        
        # Prepare headers
        headers = {}
        if accesstoken is not None:
            headers["Accesstoken"] = str(accesstoken)
        if channeltype is not None:
            headers["ChannelType"] = str(channeltype)
        if co_relationid is not None:
            headers["Co-Relationid"] = str(co_relationid)
        if initiatingsystem is not None:
            headers["InitiatingSystem"] = str(initiatingsystem)
        if servicemode is not None:
            headers["ServiceMode"] = str(servicemode)
        if uuidseqno is not None:
            headers["UUIDSeqNo"] = str(uuidseqno)
        if languagecode is not None:
            headers["languageCode"] = str(languagecode)
        if userid is not None:
            headers["userId"] = str(userid)
        
        
        return await make_api_request(
            "GET", 
            path, 
            
            params=params if params else None, 
            headers=headers if headers else None
        )
    
    
    
    @mcp.tool()
    async def bset0103_ftch_actv_ous_postusing_get(
        pagenum: Optional[int] = None,
        pagesize: Optional[int] = None,
        accesstoken: Optional[str] = None,
        channeltype: Optional[int] = None,
        co_relationid: Optional[int] = None,
        initiatingsystem: Optional[str] = None,
        servicemode: Optional[int] = None,
        uuidseqno: Optional[int] = None,
        languagecode: Optional[int] = None,
        referenceid: Optional[str] = None,
        userid: Optional[int] = None
    ) -> Dict[str, Any]:
        """
        Fetches active Operational Units
        
        Generated from: GET /bankstructure/operationalUnit/activeEntityList
        Source: swagger_2_0
        Operation ID: BSET0103FtchActvOUs_POSTUsingGET
        
        
        Authentication: Not required
        
        Parameters:
        - pageNum: integer
          pageNum
        - pageSize: integer
          pageSize
        
        
        
        Headers:
        - Accesstoken: string
          Authorization token for identification of the caller
        - ChannelType: integer
          Channel identifier from where the Transaction has originated (Internet, Mobile, ATM, Branch Channel )
        - Co-Relationid: integer
          Unique ID for the service invoked, will be set by the Transaction system
        - InitiatingSystem: string
          Indicating the initiated system
        - ServiceMode: integer
          Used for branch channel to indicate the type of customer
        - UUIDSeqNo: integer
          UUID Sequence Number
        - languageCode: integer
          languageCode
        - referenceId: string
          Place holder for Token based authentication
        - userId: integer
          userId
        
        
        """
        
        
        # Prepare query parameters
        params = {}
        if pagenum is not None:
            params["pageNum"] = pagenum
            
        if pagesize is not None:
            params["pageSize"] = pagesize
            
        
        
        # Replace path parameters in URL
        path = "/bankstructure/operationalUnit/activeEntityList"
        
        
        # Prepare headers
        headers = {}
        if accesstoken is not None:
            headers["Accesstoken"] = str(accesstoken)
        if channeltype is not None:
            headers["ChannelType"] = str(channeltype)
        if co_relationid is not None:
            headers["Co-Relationid"] = str(co_relationid)
        if initiatingsystem is not None:
            headers["InitiatingSystem"] = str(initiatingsystem)
        if servicemode is not None:
            headers["ServiceMode"] = str(servicemode)
        if uuidseqno is not None:
            headers["UUIDSeqNo"] = str(uuidseqno)
        if languagecode is not None:
            headers["languageCode"] = str(languagecode)
        if referenceid is not None:
            headers["referenceId"] = str(referenceid)
        if userid is not None:
            headers["userId"] = str(userid)
        
        
        return await make_api_request(
            "GET", 
            path, 
            
            params=params if params else None, 
            headers=headers if headers else None
        )
    
    
    
    @mcp.tool()
    async def bset0105_ftch_oulst_postusing_get(
        bankreference: Optional[str] = None,
        operationalunit: Optional[str] = None,
        status: Optional[str] = None,
        timezone: Optional[str] = None,
        pagenum: Optional[int] = None,
        pagesize: Optional[int] = None,
        accesstoken: Optional[str] = None,
        channeltype: Optional[int] = None,
        co_relationid: Optional[int] = None,
        initiatingsystem: Optional[str] = None,
        servicemode: Optional[int] = None,
        uuidseqno: Optional[int] = None,
        languagecode: Optional[int] = None,
        userid: Optional[int] = None
    ) -> Dict[str, Any]:
        """
        Fetches operational units present in the system based on specific search criteria
        
        Generated from: GET /bankstructure/operationalUnit/entityList
        Source: swagger_2_0
        Operation ID: BSET0105FtchOULst_POSTUsingGET
        
        
        Authentication: Not required
        
        Parameters:
        - BankReference: string
          This Field shows Bank Operational Unit  Like GPRDT, GBANK etc.
        - OperationalUnit: string
          Operational Unit  field denotes the Entity for which records has to be fetched
        - Status: string
          This field shows status of Banks to be fetched(1-Entered,3-Active,5-Pending Closure,6-Closed,7-Reject)
        - TimeZone: string
          This field shows Time Zone Id for Time Zones like(1-Central European Time,10-Indian Standard Time)
        - pageNum: integer
          pageNum
        - pageSize: integer
          pageSize
        
        
        
        Headers:
        - Accesstoken: string
          Authorization token for identification of the caller
        - ChannelType: integer
          Channel identifier from where the Transaction has originated (Internet, Mobile, ATM, Branch Channel )
        - Co-Relationid: integer
          Unique ID for the service invoked, will be set by the Transaction system
        - InitiatingSystem: string
          Indicating the initiated system
        - ServiceMode: integer
          Used for branch channel to indicate the type of customer
        - UUIDSeqNo: integer
          UUID Sequence Number
        - languageCode: integer
          languageCode
        - userId: integer
          userId
        
        
        """
        
        
        # Prepare query parameters
        params = {}
        if bankreference is not None:
            params["BankReference"] = bankreference
            
        if operationalunit is not None:
            params["OperationalUnit"] = operationalunit
            
        if status is not None:
            params["Status"] = status
            
        if timezone is not None:
            params["TimeZone"] = timezone
            
        if pagenum is not None:
            params["pageNum"] = pagenum
            
        if pagesize is not None:
            params["pageSize"] = pagesize
            
        
        
        # Replace path parameters in URL
        path = "/bankstructure/operationalUnit/entityList"
        
        
        # Prepare headers
        headers = {}
        if accesstoken is not None:
            headers["Accesstoken"] = str(accesstoken)
        if channeltype is not None:
            headers["ChannelType"] = str(channeltype)
        if co_relationid is not None:
            headers["Co-Relationid"] = str(co_relationid)
        if initiatingsystem is not None:
            headers["InitiatingSystem"] = str(initiatingsystem)
        if servicemode is not None:
            headers["ServiceMode"] = str(servicemode)
        if uuidseqno is not None:
            headers["UUIDSeqNo"] = str(uuidseqno)
        if languagecode is not None:
            headers["languageCode"] = str(languagecode)
        if userid is not None:
            headers["userId"] = str(userid)
        
        
        return await make_api_request(
            "GET", 
            path, 
            
            params=params if params else None, 
            headers=headers if headers else None
        )
    
    
    
    @mcp.tool()
    async def crbt1808_createt_invoice_cltrl_using_post(
        request_body:Dict[str, Any] ,  # createInvoiceCollateralResource,
        accesstoken: Optional[str] = None,
        channeltype: Optional[int] = None,
        co_relationid: Optional[int] = None,
        initiatingsystem: Optional[str] = None,
        servicemode: Optional[int] = None,
        uuidseqno: Optional[int] = None,
        entity: Optional[str] = None,
        languagecode: Optional[int] = None,
        referenceid: Optional[str] = None,
        requesthash: Optional[str] = None,
        userid: Optional[int] = None
    ) -> Dict[str, Any]:
        """
        Creation of Agreement Of Proceed Type of Collateral
        
        Generated from: POST /collateral/agreementOfProceed
        Source: swagger_2_0
        Operation ID: CRBT1808CreatetInvoiceCltrlUsingPOST
        
        
        Authentication: Not required
        
        Parameters:
        - request_body: any (required)
          input
        
        
        
        Headers:
        - Accesstoken: string
          Authorization token for identification of the caller
        - ChannelType: integer
          Channel identifier from where the TXN has originated (Internet, Mobile, ATM, Branch Channel )
        - Co-Relationid: integer
          Unique ID for the service invoked, will be set by the TXN system
        - InitiatingSystem: string
          Indicating the initiated system
        - ServiceMode: integer
          Used for branch channel to indicate the type of customer
        - UUIDSeqNo: integer
          UUID Sequence Number
        - entity: string
          entity
        - languageCode: integer
          languageCode
        - referenceId: string
          Place holder for Token based authentication
        - requesthash: string
          Request payload for hash validation
        - userId: integer
          userId
        
        
        """
        
        
        # Prepare request data
        
        # Single body parameter - send directly
        data = request_body if request_body is not None else {}
        
        
        
        # Prepare query parameters
        params = {}
        
        
        # Replace path parameters in URL
        path = "/collateral/agreementOfProceed"
        
        
        # Prepare headers
        headers = {}
        if accesstoken is not None:
            headers["Accesstoken"] = str(accesstoken)
        if channeltype is not None:
            headers["ChannelType"] = str(channeltype)
        if co_relationid is not None:
            headers["Co-Relationid"] = str(co_relationid)
        if initiatingsystem is not None:
            headers["InitiatingSystem"] = str(initiatingsystem)
        if servicemode is not None:
            headers["ServiceMode"] = str(servicemode)
        if uuidseqno is not None:
            headers["UUIDSeqNo"] = str(uuidseqno)
        if entity is not None:
            headers["entity"] = str(entity)
        if languagecode is not None:
            headers["languageCode"] = str(languagecode)
        if referenceid is not None:
            headers["referenceId"] = str(referenceid)
        if requesthash is not None:
            headers["requesthash"] = str(requesthash)
        if userid is not None:
            headers["userId"] = str(userid)
        
        
        return await make_api_request(
            "POST", 
            path, 
            data=data, 
            params=params if params else None, 
            headers=headers if headers else None
        )
    
    
    
    @mcp.tool()
    async def cret1808_fetch_invoice_cltrl_using_get(
        collateralreference: int,
        accesstoken: Optional[str] = None,
        channeltype: Optional[int] = None,
        co_relationid: Optional[int] = None,
        initiatingsystem: Optional[str] = None,
        servicemode: Optional[int] = None,
        uuidseqno: Optional[int] = None,
        entity: Optional[str] = None,
        languagecode: Optional[int] = None,
        referenceid: Optional[str] = None,
        requesthash: Optional[str] = None,
        userid: Optional[int] = None
    ) -> Dict[str, Any]:
        """
        Fetch Details of Agreement of Proceed Collateral
        
        Generated from: GET /collateral/agreementOfProceed/{collateralReference}
        Source: swagger_2_0
        Operation ID: CRET1808FetchInvoiceCltrlUsingGET
        
        
        Authentication: Not required
        
        Parameters:
        - collateralReference: integer (required)
          System generated unique reference of collateral
        
        
        
        Headers:
        - Accesstoken: string
          Authorization token for identification of the caller
        - ChannelType: integer
          Channel identifier from where the TXN has originated (Internet, Mobile, ATM, Branch Channel )
        - Co-Relationid: integer
          Unique ID for the service invoked, will be set by the TXN system
        - InitiatingSystem: string
          Indicating the initiated system
        - ServiceMode: integer
          Used for branch channel to indicate the type of customer
        - UUIDSeqNo: integer
          UUID Sequence Number
        - entity: string
          entity
        - languageCode: integer
          languageCode
        - referenceId: string
          Place holder for Token based authentication
        - requesthash: string
          Request payload for hash validation
        - userId: integer
          userId
        
        
        """
        
        
        # Prepare query parameters
        params = {}
        
        
        # Replace path parameters in URL
        path = "/collateral/agreementOfProceed/{collateralReference}"
        if collateralreference is not None:
            path = path.replace("{collateralReference}", str(collateralreference))
        
        
        # Prepare headers
        headers = {}
        if accesstoken is not None:
            headers["Accesstoken"] = str(accesstoken)
        if channeltype is not None:
            headers["ChannelType"] = str(channeltype)
        if co_relationid is not None:
            headers["Co-Relationid"] = str(co_relationid)
        if initiatingsystem is not None:
            headers["InitiatingSystem"] = str(initiatingsystem)
        if servicemode is not None:
            headers["ServiceMode"] = str(servicemode)
        if uuidseqno is not None:
            headers["UUIDSeqNo"] = str(uuidseqno)
        if entity is not None:
            headers["entity"] = str(entity)
        if languagecode is not None:
            headers["languageCode"] = str(languagecode)
        if referenceid is not None:
            headers["referenceId"] = str(referenceid)
        if requesthash is not None:
            headers["requesthash"] = str(requesthash)
        if userid is not None:
            headers["userId"] = str(userid)
        
        
        return await make_api_request(
            "GET", 
            path, 
            
            params=params if params else None, 
            headers=headers if headers else None
        )
    
    
    
    @mcp.tool()
    async def crbt0101_asgnmnt_of_proceed_modification_wrapper_using_put(
        collateralreference: int,
        request_body:Dict[str, Any] ,  # assignmentOfProceedModificationWrapperResource,
        accesstoken: Optional[str] = None,
        channeltype: Optional[int] = None,
        co_relationid: Optional[int] = None,
        initiatingsystem: Optional[str] = None,
        servicemode: Optional[int] = None,
        uuidseqno: Optional[int] = None,
        entity: Optional[str] = None,
        languagecode: Optional[int] = None,
        referenceid: Optional[str] = None,
        requesthash: Optional[str] = None,
        userid: Optional[int] = None
    ) -> Dict[str, Any]:
        """
        Assignment of Proceed Collateral Modification
        
        Generated from: PUT /collateral/agreementOfProceed/{collateralReference}
        Source: swagger_2_0
        Operation ID: CRBT0101AsgnmntOfProceedModificationWrapperUsingPUT
        
        
        Authentication: Not required
        
        Parameters:
        - collateralReference: integer (required)
          System generated Collateral Unique Reference
        - request_body: any (required)
          input
        
        
        
        Headers:
        - Accesstoken: string
          Authorization token for identification of the caller
        - ChannelType: integer
          Channel identifier from where the TXN has originated (Internet, Mobile, ATM, Branch Channel )
        - Co-Relationid: integer
          Unique ID for the service invoked, will be set by the TXN system
        - InitiatingSystem: string
          Indicating the initiated system
        - ServiceMode: integer
          Used for branch channel to indicate the type of customer
        - UUIDSeqNo: integer
          UUID Sequence Number
        - entity: string
          entity
        - languageCode: integer
          languageCode
        - referenceId: string
          Place holder for Token based authentication
        - requesthash: string
          Request payload for hash validation
        - userId: integer
          userId
        
        
        """
        
        
        # Prepare request data
        
        # Single body parameter - send directly
        data = request_body if request_body is not None else {}
        
        
        
        # Prepare query parameters
        params = {}
        
        
        # Replace path parameters in URL
        path = "/collateral/agreementOfProceed/{collateralReference}"
        if collateralreference is not None:
            path = path.replace("{collateralReference}", str(collateralreference))
        
        
        # Prepare headers
        headers = {}
        if accesstoken is not None:
            headers["Accesstoken"] = str(accesstoken)
        if channeltype is not None:
            headers["ChannelType"] = str(channeltype)
        if co_relationid is not None:
            headers["Co-Relationid"] = str(co_relationid)
        if initiatingsystem is not None:
            headers["InitiatingSystem"] = str(initiatingsystem)
        if servicemode is not None:
            headers["ServiceMode"] = str(servicemode)
        if uuidseqno is not None:
            headers["UUIDSeqNo"] = str(uuidseqno)
        if entity is not None:
            headers["entity"] = str(entity)
        if languagecode is not None:
            headers["languageCode"] = str(languagecode)
        if referenceid is not None:
            headers["referenceId"] = str(referenceid)
        if requesthash is not None:
            headers["requesthash"] = str(requesthash)
        if userid is not None:
            headers["userId"] = str(userid)
        
        
        return await make_api_request(
            "PUT", 
            path, 
            data=data, 
            params=params if params else None, 
            headers=headers if headers else None
        )
    
    
    
    @mcp.tool()
    async def crbt1995_create_bank_dep_cltrl_using_post(
        request_body:Dict[str, Any] ,  # bankDepositCollateralResource,
        accesstoken: Optional[str] = None,
        channeltype: Optional[int] = None,
        co_relationid: Optional[int] = None,
        initiatingsystem: Optional[str] = None,
        servicemode: Optional[int] = None,
        uuidseqno: Optional[int] = None,
        entity: Optional[str] = None,
        languagecode: Optional[int] = None,
        referenceid: Optional[str] = None,
        requesthash: Optional[str] = None,
        userid: Optional[int] = None
    ) -> Dict[str, Any]:
        """
        Creation of Bank deposit collateral
        
        Generated from: POST /collateral/bankDeposit
        Source: swagger_2_0
        Operation ID: CRBT1995CreateBankDepCltrlUsingPOST
        
        
        Authentication: Not required
        
        Parameters:
        - request_body: any (required)
          input
        
        
        
        Headers:
        - Accesstoken: string
          Authorization token for identification of the caller
        - ChannelType: integer
          Channel identifier from where the TXN has originated (Internet, Mobile, ATM, Branch Channel)
        - Co-Relationid: integer
          Unique ID for the service invoked, will be set by the TXN system
        - InitiatingSystem: string
          Indicating the initiated system
        - ServiceMode: integer
          Used for branch channel to indicate the type of customer
        - UUIDSeqNo: integer
          UUID Sequence Number
        - entity: string
          entity
        - languageCode: integer
          languageCode
        - referenceId: string
          Place holder for Token based authentication
        - requesthash: string
          Request payload for hash validation
        - userId: integer
          userId
        
        
        """
        
        
        # Prepare request data
        
        # Single body parameter - send directly
        data = request_body if request_body is not None else {}
        
        
        
        # Prepare query parameters
        params = {}
        
        
        # Replace path parameters in URL
        path = "/collateral/bankDeposit"
        
        
        # Prepare headers
        headers = {}
        if accesstoken is not None:
            headers["Accesstoken"] = str(accesstoken)
        if channeltype is not None:
            headers["ChannelType"] = str(channeltype)
        if co_relationid is not None:
            headers["Co-Relationid"] = str(co_relationid)
        if initiatingsystem is not None:
            headers["InitiatingSystem"] = str(initiatingsystem)
        if servicemode is not None:
            headers["ServiceMode"] = str(servicemode)
        if uuidseqno is not None:
            headers["UUIDSeqNo"] = str(uuidseqno)
        if entity is not None:
            headers["entity"] = str(entity)
        if languagecode is not None:
            headers["languageCode"] = str(languagecode)
        if referenceid is not None:
            headers["referenceId"] = str(referenceid)
        if requesthash is not None:
            headers["requesthash"] = str(requesthash)
        if userid is not None:
            headers["userId"] = str(userid)
        
        
        return await make_api_request(
            "POST", 
            path, 
            data=data, 
            params=params if params else None, 
            headers=headers if headers else None
        )
    
    
    
    @mcp.tool()
    async def crbt0101_cltrl_bank_dep_modification_wrapper_using_put(
        collateralreference: int,
        request_body:Dict[str, Any] ,  # collateralBankDepositModifyResource,
        accesstoken: Optional[str] = None,
        channeltype: Optional[int] = None,
        co_relationid: Optional[int] = None,
        initiatingsystem: Optional[str] = None,
        servicemode: Optional[int] = None,
        uuidseqno: Optional[int] = None,
        entity: Optional[str] = None,
        languagecode: Optional[int] = None,
        referenceid: Optional[str] = None,
        requesthash: Optional[str] = None,
        userid: Optional[int] = None
    ) -> Dict[str, Any]:
        """
        Bank Deposit Collateral Modification
        
        Generated from: PUT /collateral/bankDeposit/{collateralReference}
        Source: swagger_2_0
        Operation ID: CRBT0101CltrlBankDepModificationWrapperUsingPUT
        
        
        Authentication: Not required
        
        Parameters:
        - collateralReference: integer (required)
          System generated Collateral Unique Reference
        - request_body: any (required)
          input
        
        
        
        Headers:
        - Accesstoken: string
          Authorization token for identification of the caller
        - ChannelType: integer
          Channel identifier from where the TXN has originated (Internet, Mobile, ATM, Branch Channel )
        - Co-Relationid: integer
          Unique ID for the service invoked, will be set by the TXN system
        - InitiatingSystem: string
          Indicating the initiated system
        - ServiceMode: integer
          Used for branch channel to indicate the type of customer
        - UUIDSeqNo: integer
          UUID Sequence Number
        - entity: string
          entity
        - languageCode: integer
          languageCode
        - referenceId: string
          Place holder for Token based authentication
        - requesthash: string
          Request payload for hash validation
        - userId: integer
          userId
        
        
        """
        
        
        # Prepare request data
        
        # Single body parameter - send directly
        data = request_body if request_body is not None else {}
        
        
        
        # Prepare query parameters
        params = {}
        
        
        # Replace path parameters in URL
        path = "/collateral/bankDeposit/{collateralReference}"
        if collateralreference is not None:
            path = path.replace("{collateralReference}", str(collateralreference))
        
        
        # Prepare headers
        headers = {}
        if accesstoken is not None:
            headers["Accesstoken"] = str(accesstoken)
        if channeltype is not None:
            headers["ChannelType"] = str(channeltype)
        if co_relationid is not None:
            headers["Co-Relationid"] = str(co_relationid)
        if initiatingsystem is not None:
            headers["InitiatingSystem"] = str(initiatingsystem)
        if servicemode is not None:
            headers["ServiceMode"] = str(servicemode)
        if uuidseqno is not None:
            headers["UUIDSeqNo"] = str(uuidseqno)
        if entity is not None:
            headers["entity"] = str(entity)
        if languagecode is not None:
            headers["languageCode"] = str(languagecode)
        if referenceid is not None:
            headers["referenceId"] = str(referenceid)
        if requesthash is not None:
            headers["requesthash"] = str(requesthash)
        if userid is not None:
            headers["userId"] = str(userid)
        
        
        return await make_api_request(
            "PUT", 
            path, 
            data=data, 
            params=params if params else None, 
            headers=headers if headers else None
        )
    
    
    
    @mcp.tool()
    async def cret1995_fetch_bank_dep_cltrl_postusing_get(
        collateralreference: int,
        accesstoken: Optional[str] = None,
        channeltype: Optional[int] = None,
        co_relationid: Optional[int] = None,
        initiatingsystem: Optional[str] = None,
        servicemode: Optional[int] = None,
        uuidseqno: Optional[int] = None,
        entity: Optional[str] = None,
        languagecode: Optional[int] = None,
        referenceid: Optional[str] = None,
        userid: Optional[int] = None
    ) -> Dict[str, Any]:
        """
        View details of bank deposit collateral
        
        Generated from: GET /collateral/collateral/bankdeposit/{collateralReference}
        Source: swagger_2_0
        Operation ID: CRET1995FetchBankDepCltrl_POSTUsingGET
        
        
        Authentication: Not required
        
        Parameters:
        - collateralReference: integer (required)
          System generated unique reference of collateral
        
        
        
        Headers:
        - Accesstoken: string
          Authorization token for identification of the caller
        - ChannelType: integer
          Channel identifier from where the TXN has originated (Internet, Mobile, ATM, Branch Channel )
        - Co-Relationid: integer
          Unique ID for the service invoked, will be set by the TXN system
        - InitiatingSystem: string
          Indicating the initiated system
        - ServiceMode: integer
          Used for branch channel to indicate the type of customer
        - UUIDSeqNo: integer
          UUID Sequence Number
        - entity: string
          entity
        - languageCode: integer
          languageCode
        - referenceId: string
          Place holder for Token based authentication
        - userId: integer
          userId
        
        
        """
        
        
        # Prepare query parameters
        params = {}
        
        
        # Replace path parameters in URL
        path = "/collateral/collateral/bankdeposit/{collateralReference}"
        if collateralreference is not None:
            path = path.replace("{collateralReference}", str(collateralreference))
        
        
        # Prepare headers
        headers = {}
        if accesstoken is not None:
            headers["Accesstoken"] = str(accesstoken)
        if channeltype is not None:
            headers["ChannelType"] = str(channeltype)
        if co_relationid is not None:
            headers["Co-Relationid"] = str(co_relationid)
        if initiatingsystem is not None:
            headers["InitiatingSystem"] = str(initiatingsystem)
        if servicemode is not None:
            headers["ServiceMode"] = str(servicemode)
        if uuidseqno is not None:
            headers["UUIDSeqNo"] = str(uuidseqno)
        if entity is not None:
            headers["entity"] = str(entity)
        if languagecode is not None:
            headers["languageCode"] = str(languagecode)
        if referenceid is not None:
            headers["referenceId"] = str(referenceid)
        if userid is not None:
            headers["userId"] = str(userid)
        
        
        return await make_api_request(
            "GET", 
            path, 
            
            params=params if params else None, 
            headers=headers if headers else None
        )
    
    
    
    @mcp.tool()
    async def crbt1870_release_cltrl_on_hold_using_post(
        request_body:Dict[str, Any] ,  # CollateralDischargeRequest,
        accesstoken: Optional[str] = None,
        channeltype: Optional[int] = None,
        co_relationid: Optional[int] = None,
        initiatingsystem: Optional[str] = None,
        servicemode: Optional[int] = None,
        uuidseqno: Optional[int] = None,
        entity: Optional[str] = None,
        languagecode: Optional[int] = None,
        referenceid: Optional[str] = None,
        requesthash: Optional[str] = None,
        userid: Optional[int] = None
    ) -> Dict[str, Any]:
        """
        discharge of collaterals
        
        Generated from: POST /collateral/collateralDischarge
        Source: swagger_2_0
        Operation ID: CRBT1870ReleaseCltrlOnHoldUsingPOST
        
        
        Authentication: Not required
        
        Parameters:
        - request_body: any (required)
          input
        
        
        
        Headers:
        - Accesstoken: string
          Authorization token for identification of the caller
        - ChannelType: integer
          Channel identifier from where the TXN has originated (Internet, Mobile, ATM, Branch Channel )
        - Co-Relationid: integer
          Unique ID for the service invoked, will be set by the TXN system
        - InitiatingSystem: string
          Indicating the initiated system
        - ServiceMode: integer
          Used for branch channel to indicate the type of customer
        - UUIDSeqNo: integer
          UUID Sequence Number
        - entity: string
          entity
        - languageCode: integer
          languageCode
        - referenceId: string
          Place holder for Token based authentication
        - requesthash: string
          Request payload for hash validation
        - userId: integer
          userId
        
        
        """
        
        
        # Prepare request data
        
        # Single body parameter - send directly
        data = request_body if request_body is not None else {}
        
        
        
        # Prepare query parameters
        params = {}
        
        
        # Replace path parameters in URL
        path = "/collateral/collateralDischarge"
        
        
        # Prepare headers
        headers = {}
        if accesstoken is not None:
            headers["Accesstoken"] = str(accesstoken)
        if channeltype is not None:
            headers["ChannelType"] = str(channeltype)
        if co_relationid is not None:
            headers["Co-Relationid"] = str(co_relationid)
        if initiatingsystem is not None:
            headers["InitiatingSystem"] = str(initiatingsystem)
        if servicemode is not None:
            headers["ServiceMode"] = str(servicemode)
        if uuidseqno is not None:
            headers["UUIDSeqNo"] = str(uuidseqno)
        if entity is not None:
            headers["entity"] = str(entity)
        if languagecode is not None:
            headers["languageCode"] = str(languagecode)
        if referenceid is not None:
            headers["referenceId"] = str(referenceid)
        if requesthash is not None:
            headers["requesthash"] = str(requesthash)
        if userid is not None:
            headers["userId"] = str(userid)
        
        
        return await make_api_request(
            "POST", 
            path, 
            data=data, 
            params=params if params else None, 
            headers=headers if headers else None
        )
    
    
    
    @mcp.tool()
    async def crbt1864_create_coll_link_using_post(
        request_body:Dict[str, Any] ,  # createCollateralLinkResource,
        accesstoken: Optional[str] = None,
        channeltype: Optional[int] = None,
        co_relationid: Optional[int] = None,
        initiatingsystem: Optional[str] = None,
        servicemode: Optional[int] = None,
        uuidseqno: Optional[int] = None,
        entity: Optional[str] = None,
        languagecode: Optional[int] = None,
        referenceid: Optional[str] = None,
        requesthash: Optional[str] = None,
        userid: Optional[int] = None
    ) -> Dict[str, Any]:
        """
        Creation of a collateral Link
        
        Generated from: POST /collateral/collateralLink
        Source: swagger_2_0
        Operation ID: CRBT1864CreateCollLinkUsingPOST
        
        
        Authentication: Not required
        
        Parameters:
        - request_body: any (required)
          input
        
        
        
        Headers:
        - Accesstoken: string
          Authorization token for identification of the caller
        - ChannelType: integer
          Channel identifier from where the TXN has originated (Internet, Mobile, ATM, Branch Channel )
        - Co-Relationid: integer
          Unique ID for the service invoked, will be set by the TXN system
        - InitiatingSystem: string
          Indicating the initiated system
        - ServiceMode: integer
          Used for branch channel to indicate the type of customer
        - UUIDSeqNo: integer
          UUID Sequence Number
        - entity: string
          entity
        - languageCode: integer
          languageCode
        - referenceId: string
          Place holder for Token based authentication
        - requesthash: string
          Request payload for hash validation
        - userId: integer
          userId
        
        
        """
        
        
        # Prepare request data
        
        # Single body parameter - send directly
        data = request_body if request_body is not None else {}
        
        
        
        # Prepare query parameters
        params = {}
        
        
        # Replace path parameters in URL
        path = "/collateral/collateralLink"
        
        
        # Prepare headers
        headers = {}
        if accesstoken is not None:
            headers["Accesstoken"] = str(accesstoken)
        if channeltype is not None:
            headers["ChannelType"] = str(channeltype)
        if co_relationid is not None:
            headers["Co-Relationid"] = str(co_relationid)
        if initiatingsystem is not None:
            headers["InitiatingSystem"] = str(initiatingsystem)
        if servicemode is not None:
            headers["ServiceMode"] = str(servicemode)
        if uuidseqno is not None:
            headers["UUIDSeqNo"] = str(uuidseqno)
        if entity is not None:
            headers["entity"] = str(entity)
        if languagecode is not None:
            headers["languageCode"] = str(languagecode)
        if referenceid is not None:
            headers["referenceId"] = str(referenceid)
        if requesthash is not None:
            headers["requesthash"] = str(requesthash)
        if userid is not None:
            headers["userId"] = str(userid)
        
        
        return await make_api_request(
            "POST", 
            path, 
            data=data, 
            params=params if params else None, 
            headers=headers if headers else None
        )
    
    
    
    @mcp.tool()
    async def crbt2022_create_other_cltrl_postusing_post(
        request_body:Dict[str, Any] ,  # CLTRL_MASTER_CRBT2022CreateOtherCltrl_Resource,
        accesstoken: Optional[str] = None,
        channeltype: Optional[int] = None,
        co_relationid: Optional[int] = None,
        initiatingsystem: Optional[str] = None,
        servicemode: Optional[int] = None,
        uuidseqno: Optional[int] = None,
        entity: Optional[str] = None,
        languagecode: Optional[int] = None,
        referenceid: Optional[str] = None,
        requesthash: Optional[str] = None,
        userid: Optional[int] = None
    ) -> Dict[str, Any]:
        """
        Create Other Colateral
        
        Generated from: POST /collateral/crbt2022createothercltrl
        Source: swagger_2_0
        Operation ID: CRBT2022CreateOtherCltrl_POSTUsingPOST
        
        
        Authentication: Not required
        
        Parameters:
        - request_body: any (required)
          input
        
        
        
        Headers:
        - Accesstoken: string
          Authorization token for identification of the caller
        - ChannelType: integer
          Channel identifier from where the TXN has originated (Internet, Mobile, ATM, Branch Channel )
        - Co-Relationid: integer
          Unique ID for the service invoked, will be set by the TXN system
        - InitiatingSystem: string
          Indicating the initiated system
        - ServiceMode: integer
          Used for branch channel to indicate the type of customer
        - UUIDSeqNo: integer
          UUID Sequence Number
        - entity: string
          entity
        - languageCode: integer
          languageCode
        - referenceId: string
          Place holder for Token based authentication
        - requesthash: string
          Request payload for hash validation
        - userId: integer
          userId
        
        
        """
        
        
        # Prepare request data
        
        # Single body parameter - send directly
        data = request_body if request_body is not None else {}
        
        
        
        # Prepare query parameters
        params = {}
        
        
        # Replace path parameters in URL
        path = "/collateral/crbt2022createothercltrl"
        
        
        # Prepare headers
        headers = {}
        if accesstoken is not None:
            headers["Accesstoken"] = str(accesstoken)
        if channeltype is not None:
            headers["ChannelType"] = str(channeltype)
        if co_relationid is not None:
            headers["Co-Relationid"] = str(co_relationid)
        if initiatingsystem is not None:
            headers["InitiatingSystem"] = str(initiatingsystem)
        if servicemode is not None:
            headers["ServiceMode"] = str(servicemode)
        if uuidseqno is not None:
            headers["UUIDSeqNo"] = str(uuidseqno)
        if entity is not None:
            headers["entity"] = str(entity)
        if languagecode is not None:
            headers["languageCode"] = str(languagecode)
        if referenceid is not None:
            headers["referenceId"] = str(referenceid)
        if requesthash is not None:
            headers["requesthash"] = str(requesthash)
        if userid is not None:
            headers["userId"] = str(userid)
        
        
        return await make_api_request(
            "POST", 
            path, 
            data=data, 
            params=params if params else None, 
            headers=headers if headers else None
        )
    
    
    
    @mcp.tool()
    async def crbt1800_create_cltrl_prprty_adtnl_dtls_postusing_post(
        request_body:Dict[str, Any] ,  # collateralAdditionalDetailsCreationResource,
        accesstoken: Optional[str] = None,
        channeltype: Optional[int] = None,
        co_relationid: Optional[int] = None,
        initiatingsystem: Optional[str] = None,
        servicemode: Optional[int] = None,
        uuidseqno: Optional[int] = None,
        entity: Optional[str] = None,
        languagecode: Optional[int] = None,
        referenceid: Optional[str] = None,
        requesthash: Optional[str] = None,
        userid: Optional[int] = None
    ) -> Dict[str, Any]:
        """
        create collateral property additional details
        
        Generated from: POST /collateral/createCollateralAdditionalDetails
        Source: swagger_2_0
        Operation ID: CRBT1800CreateCltrlPrprtyAdtnlDtls_POSTUsingPOST
        
        
        Authentication: Not required
        
        Parameters:
        - request_body: any (required)
          input
        
        
        
        Headers:
        - Accesstoken: string
          Authorization token for identification of the caller
        - ChannelType: integer
          Channel identifier from where the TXN has originated (Internet, Mobile, ATM, Branch Channel )
        - Co-Relationid: integer
          Unique ID for the service invoked, will be set by the TXN system
        - InitiatingSystem: string
          Indicating the initiated system
        - ServiceMode: integer
          Used for branch channel to indicate the type of customer
        - UUIDSeqNo: integer
          UUID Sequence Number
        - entity: string
          entity
        - languageCode: integer
          languageCode
        - referenceId: string
          Place holder for Token based authentication
        - requesthash: string
          Request payload for hash validation
        - userId: integer
          userId
        
        
        """
        
        
        # Prepare request data
        
        # Single body parameter - send directly
        data = request_body if request_body is not None else {}
        
        
        
        # Prepare query parameters
        params = {}
        
        
        # Replace path parameters in URL
        path = "/collateral/createCollateralAdditionalDetails"
        
        
        # Prepare headers
        headers = {}
        if accesstoken is not None:
            headers["Accesstoken"] = str(accesstoken)
        if channeltype is not None:
            headers["ChannelType"] = str(channeltype)
        if co_relationid is not None:
            headers["Co-Relationid"] = str(co_relationid)
        if initiatingsystem is not None:
            headers["InitiatingSystem"] = str(initiatingsystem)
        if servicemode is not None:
            headers["ServiceMode"] = str(servicemode)
        if uuidseqno is not None:
            headers["UUIDSeqNo"] = str(uuidseqno)
        if entity is not None:
            headers["entity"] = str(entity)
        if languagecode is not None:
            headers["languageCode"] = str(languagecode)
        if referenceid is not None:
            headers["referenceId"] = str(referenceid)
        if requesthash is not None:
            headers["requesthash"] = str(requesthash)
        if userid is not None:
            headers["userId"] = str(userid)
        
        
        return await make_api_request(
            "POST", 
            path, 
            data=data, 
            params=params if params else None, 
            headers=headers if headers else None
        )
    
    
    
    @mcp.tool()
    async def cret1864_fetch_coll_link_postusing_post(
        request_body:Dict[str, Any] ,  # CLTRL_MASTER_CRET1864FetchCollLink_Resource
    ) -> Dict[str, Any]:
        """
        CRET1864FetchCollLink
        
        Generated from: POST /collateral/cret1864fetchcolllink
        Source: swagger_2_0
        Operation ID: CRET1864FetchCollLink_POSTUsingPOST
        
        
        Authentication: Not required
        
        Parameters:
        - request_body: any (required)
          input
        
        
        
        """
        
        
        # Prepare request data
        
        # Single body parameter - send directly
        data = request_body if request_body is not None else {}
        
        
        
        # Prepare query parameters
        params = {}
        
        
        # Replace path parameters in URL
        path = "/collateral/cret1864fetchcolllink"
        
        
        # Prepare headers
        headers = {}
        
        
        return await make_api_request(
            "POST", 
            path, 
            data=data, 
            params=params if params else None, 
            headers=headers if headers else None
        )
    
    
    
    @mcp.tool()
    async def crbt1815_create_grnte_cltrl_using_post(
        request_body:Dict[str, Any] ,  # createGuaranteeCollateralResource,
        accesstoken: Optional[str] = None,
        channeltype: Optional[int] = None,
        co_relationid: Optional[int] = None,
        initiatingsystem: Optional[str] = None,
        servicemode: Optional[int] = None,
        uuidseqno: Optional[int] = None,
        entity: Optional[str] = None,
        languagecode: Optional[int] = None,
        referenceid: Optional[str] = None,
        requesthash: Optional[str] = None,
        userid: Optional[int] = None
    ) -> Dict[str, Any]:
        """
        Create Guarantee Collateral
        
        Generated from: POST /collateral/guarantee
        Source: swagger_2_0
        Operation ID: CRBT1815CreateGrnteCltrlUsingPOST
        
        
        Authentication: Not required
        
        Parameters:
        - request_body: any (required)
          input
        
        
        
        Headers:
        - Accesstoken: string
          Authorization token for identification of the caller
        - ChannelType: integer
          Channel identifier from where the TXN has originated (Internet, Mobile, ATM, Branch Channel )
        - Co-Relationid: integer
          Unique ID for the service invoked, will be set by the TXN system
        - InitiatingSystem: string
          Indicating the initiated system
        - ServiceMode: integer
          Used for branch channel to indicate the type of customer
        - UUIDSeqNo: integer
          UUID Sequence Number
        - entity: string
          entity
        - languageCode: integer
          languageCode
        - referenceId: string
          Place holder for Token based authentication
        - requesthash: string
          Request payload for hash validation
        - userId: integer
          userId
        
        
        """
        
        
        # Prepare request data
        
        # Single body parameter - send directly
        data = request_body if request_body is not None else {}
        
        
        
        # Prepare query parameters
        params = {}
        
        
        # Replace path parameters in URL
        path = "/collateral/guarantee"
        
        
        # Prepare headers
        headers = {}
        if accesstoken is not None:
            headers["Accesstoken"] = str(accesstoken)
        if channeltype is not None:
            headers["ChannelType"] = str(channeltype)
        if co_relationid is not None:
            headers["Co-Relationid"] = str(co_relationid)
        if initiatingsystem is not None:
            headers["InitiatingSystem"] = str(initiatingsystem)
        if servicemode is not None:
            headers["ServiceMode"] = str(servicemode)
        if uuidseqno is not None:
            headers["UUIDSeqNo"] = str(uuidseqno)
        if entity is not None:
            headers["entity"] = str(entity)
        if languagecode is not None:
            headers["languageCode"] = str(languagecode)
        if referenceid is not None:
            headers["referenceId"] = str(referenceid)
        if requesthash is not None:
            headers["requesthash"] = str(requesthash)
        if userid is not None:
            headers["userId"] = str(userid)
        
        
        return await make_api_request(
            "POST", 
            path, 
            data=data, 
            params=params if params else None, 
            headers=headers if headers else None
        )
    
    
    
    @mcp.tool()
    async def crbt0101_guarantee_modification_wrapper_using_put(
        request_body:Dict[str, Any] ,  # modifyCollateralGuaranteeResource,
        accesstoken: Optional[str] = None,
        channeltype: Optional[int] = None,
        co_relationid: Optional[int] = None,
        initiatingsystem: Optional[str] = None,
        servicemode: Optional[int] = None,
        uuidseqno: Optional[int] = None,
        entity: Optional[str] = None,
        languagecode: Optional[int] = None,
        referenceid: Optional[str] = None,
        requesthash: Optional[str] = None,
        userid: Optional[int] = None
    ) -> Dict[str, Any]:
        """
        Guarantee Collateral Modification
        
        Generated from: PUT /collateral/guarantee
        Source: swagger_2_0
        Operation ID: CRBT0101GuaranteeModificationWrapperUsingPUT
        
        
        Authentication: Not required
        
        Parameters:
        - request_body: any (required)
          input
        
        
        
        Headers:
        - Accesstoken: string
          Authorization token for identification of the caller
        - ChannelType: integer
          Channel identifier from where the TXN has originated (Internet, Mobile, ATM, Branch Channel )
        - Co-Relationid: integer
          Unique ID for the service invoked, will be set by the TXN system
        - InitiatingSystem: string
          Indicating the initiated system
        - ServiceMode: integer
          Used for branch channel to indicate the type of customer
        - UUIDSeqNo: integer
          UUID Sequence Number
        - entity: string
          entity
        - languageCode: integer
          languageCode
        - referenceId: string
          Place holder for Token based authentication
        - requesthash: string
          Request payload for hash validation
        - userId: integer
          userId
        
        
        """
        
        
        # Prepare request data
        
        # Single body parameter - send directly
        data = request_body if request_body is not None else {}
        
        
        
        # Prepare query parameters
        params = {}
        
        
        # Replace path parameters in URL
        path = "/collateral/guarantee"
        
        
        # Prepare headers
        headers = {}
        if accesstoken is not None:
            headers["Accesstoken"] = str(accesstoken)
        if channeltype is not None:
            headers["ChannelType"] = str(channeltype)
        if co_relationid is not None:
            headers["Co-Relationid"] = str(co_relationid)
        if initiatingsystem is not None:
            headers["InitiatingSystem"] = str(initiatingsystem)
        if servicemode is not None:
            headers["ServiceMode"] = str(servicemode)
        if uuidseqno is not None:
            headers["UUIDSeqNo"] = str(uuidseqno)
        if entity is not None:
            headers["entity"] = str(entity)
        if languagecode is not None:
            headers["languageCode"] = str(languagecode)
        if referenceid is not None:
            headers["referenceId"] = str(referenceid)
        if requesthash is not None:
            headers["requesthash"] = str(requesthash)
        if userid is not None:
            headers["userId"] = str(userid)
        
        
        return await make_api_request(
            "PUT", 
            path, 
            data=data, 
            params=params if params else None, 
            headers=headers if headers else None
        )
    
    
    
    @mcp.tool()
    async def cret1815_view_grnte_cltrl_using_get(
        collateralreference: int,
        accesstoken: Optional[str] = None,
        channeltype: Optional[int] = None,
        co_relationid: Optional[int] = None,
        initiatingsystem: Optional[str] = None,
        servicemode: Optional[int] = None,
        uuidseqno: Optional[int] = None,
        entity: Optional[str] = None,
        languagecode: Optional[int] = None,
        referenceid: Optional[str] = None,
        requesthash: Optional[str] = None,
        userid: Optional[int] = None
    ) -> Dict[str, Any]:
        """
        View Guarantee Collateral Details
        
        Generated from: GET /collateral/guarantee/{collateralReference}
        Source: swagger_2_0
        Operation ID: CRET1815ViewGrnteCltrlUsingGET
        
        
        Authentication: Not required
        
        Parameters:
        - collateralReference: integer (required)
          System generated unique reference of collateral
        
        
        
        Headers:
        - Accesstoken: string
          Authorization token for identification of the caller
        - ChannelType: integer
          Channel identifier from where the TXN has originated (Internet, Mobile, ATM, Branch Channel )
        - Co-Relationid: integer
          Unique ID for the service invoked, will be set by the TXN system
        - InitiatingSystem: string
          Indicating the initiated system
        - ServiceMode: integer
          Used for branch channel to indicate the type of customer
        - UUIDSeqNo: integer
          UUID Sequence Number
        - entity: string
          entity
        - languageCode: integer
          languageCode
        - referenceId: string
          Place holder for Token based authentication
        - requesthash: string
          Request payload for hash validation
        - userId: integer
          userId
        
        
        """
        
        
        # Prepare query parameters
        params = {}
        
        
        # Replace path parameters in URL
        path = "/collateral/guarantee/{collateralReference}"
        if collateralreference is not None:
            path = path.replace("{collateralReference}", str(collateralreference))
        
        
        # Prepare headers
        headers = {}
        if accesstoken is not None:
            headers["Accesstoken"] = str(accesstoken)
        if channeltype is not None:
            headers["ChannelType"] = str(channeltype)
        if co_relationid is not None:
            headers["Co-Relationid"] = str(co_relationid)
        if initiatingsystem is not None:
            headers["InitiatingSystem"] = str(initiatingsystem)
        if servicemode is not None:
            headers["ServiceMode"] = str(servicemode)
        if uuidseqno is not None:
            headers["UUIDSeqNo"] = str(uuidseqno)
        if entity is not None:
            headers["entity"] = str(entity)
        if languagecode is not None:
            headers["languageCode"] = str(languagecode)
        if referenceid is not None:
            headers["referenceId"] = str(referenceid)
        if requesthash is not None:
            headers["requesthash"] = str(requesthash)
        if userid is not None:
            headers["userId"] = str(userid)
        
        
        return await make_api_request(
            "GET", 
            path, 
            
            params=params if params else None, 
            headers=headers if headers else None
        )
    
    
    
    @mcp.tool()
    async def crbt2019_create_insrnc_cltrl_postusing_post(
        request_body:Dict[str, Any] ,  # collateralInsuranceAndValueDocCreateResource,
        entity: Optional[str] = None,
        languagecode: Optional[int] = None
    ) -> Dict[str, Any]:
        """
        Create Insurance Collatarel
        
        Generated from: POST /collateral/insuranceAndValueDoc
        Source: swagger_2_0
        Operation ID: CRBT2019CreateInsrncCltrlPOSTUsingPOST
        
        
        Authentication: Not required
        
        Parameters:
        - request_body: any (required)
          input
        
        
        
        Headers:
        - entity: string
          entity
        - languageCode: integer
          languageCode
        
        
        """
        
        
        # Prepare request data
        
        # Single body parameter - send directly
        data = request_body if request_body is not None else {}
        
        
        
        # Prepare query parameters
        params = {}
        
        
        # Replace path parameters in URL
        path = "/collateral/insuranceAndValueDoc"
        
        
        # Prepare headers
        headers = {}
        if entity is not None:
            headers["entity"] = str(entity)
        if languagecode is not None:
            headers["languageCode"] = str(languagecode)
        
        
        return await make_api_request(
            "POST", 
            path, 
            data=data, 
            params=params if params else None, 
            headers=headers if headers else None
        )
    
    
    
    @mcp.tool()
    async def cret2019_fetch_insrnc_cltrl_using_get(
        collateralreference: int,
        accesstoken: Optional[str] = None,
        channeltype: Optional[int] = None,
        co_relationid: Optional[int] = None,
        initiatingsystem: Optional[str] = None,
        servicemode: Optional[int] = None,
        uuidseqno: Optional[int] = None,
        entity: Optional[str] = None,
        languagecode: Optional[int] = None,
        referenceid: Optional[str] = None,
        requesthash: Optional[str] = None,
        userid: Optional[int] = None
    ) -> Dict[str, Any]:
        """
        Collateral Insurance View
        
        Generated from: GET /collateral/insuranceAndValueDoc/{collateralReference}
        Source: swagger_2_0
        Operation ID: CRET2019FetchInsrncCltrlUsingGET
        
        
        Authentication: Not required
        
        Parameters:
        - collateralReference: integer (required)
          System generated unique reference of collateral
        
        
        
        Headers:
        - Accesstoken: string
          Authorization token for identification of the caller
        - ChannelType: integer
          Channel identifier from where the TXN has originated (Internet, Mobile, ATM, Branch Channel )
        - Co-Relationid: integer
          Unique ID for the service invoked, will be set by the TXN system
        - InitiatingSystem: string
          Indicating the initiated system
        - ServiceMode: integer
          Used for branch channel to indicate the type of customer
        - UUIDSeqNo: integer
          UUID Sequence Number
        - entity: string
          entity
        - languageCode: integer
          languageCode
        - referenceId: string
          Place holder for Token based authentication
        - requesthash: string
          Request payload for hash validation
        - userId: integer
          userId
        
        
        """
        
        
        # Prepare query parameters
        params = {}
        
        
        # Replace path parameters in URL
        path = "/collateral/insuranceAndValueDoc/{collateralReference}"
        if collateralreference is not None:
            path = path.replace("{collateralReference}", str(collateralreference))
        
        
        # Prepare headers
        headers = {}
        if accesstoken is not None:
            headers["Accesstoken"] = str(accesstoken)
        if channeltype is not None:
            headers["ChannelType"] = str(channeltype)
        if co_relationid is not None:
            headers["Co-Relationid"] = str(co_relationid)
        if initiatingsystem is not None:
            headers["InitiatingSystem"] = str(initiatingsystem)
        if servicemode is not None:
            headers["ServiceMode"] = str(servicemode)
        if uuidseqno is not None:
            headers["UUIDSeqNo"] = str(uuidseqno)
        if entity is not None:
            headers["entity"] = str(entity)
        if languagecode is not None:
            headers["languageCode"] = str(languagecode)
        if referenceid is not None:
            headers["referenceId"] = str(referenceid)
        if requesthash is not None:
            headers["requesthash"] = str(requesthash)
        if userid is not None:
            headers["userId"] = str(userid)
        
        
        return await make_api_request(
            "GET", 
            path, 
            
            params=params if params else None, 
            headers=headers if headers else None
        )
    
    
    
    @mcp.tool()
    async def crbt0101_insrnc_value_doc_modification_wrapper_postusing_put(
        collateralreference: int,
        request_body:Dict[str, Any] ,  # collateralInsuranceAndValueDocModifyResource,
        entity: Optional[str] = None,
        languagecode: Optional[int] = None,
        runmode: Optional[int] = None,
        userid: Optional[int] = None
    ) -> Dict[str, Any]:
        """
        Insurance And Value Doc Collateral Modification
        
        Generated from: PUT /collateral/insuranceAndValueDoc/{collateralReference}
        Source: swagger_2_0
        Operation ID: CRBT0101InsrncValueDocModificationWrapperPOSTUsingPUT
        
        
        Authentication: Not required
        
        Parameters:
        - collateralReference: integer (required)
          System generated Collateral Unique Reference
        - request_body: any (required)
          input
        
        
        
        Headers:
        - entity: string
          entity
        - languageCode: integer
          languageCode
        - runMode: integer
          runMode
        - userId: integer
          userId
        
        
        """
        
        
        # Prepare request data
        
        # Single body parameter - send directly
        data = request_body if request_body is not None else {}
        
        
        
        # Prepare query parameters
        params = {}
        
        
        # Replace path parameters in URL
        path = "/collateral/insuranceAndValueDoc/{collateralReference}"
        if collateralreference is not None:
            path = path.replace("{collateralReference}", str(collateralreference))
        
        
        # Prepare headers
        headers = {}
        if entity is not None:
            headers["entity"] = str(entity)
        if languagecode is not None:
            headers["languageCode"] = str(languagecode)
        if runmode is not None:
            headers["runMode"] = str(runmode)
        if userid is not None:
            headers["userId"] = str(userid)
        
        
        return await make_api_request(
            "PUT", 
            path, 
            data=data, 
            params=params if params else None, 
            headers=headers if headers else None
        )
    
    
    
    @mcp.tool()
    async def cret1803_fetch_cltrl_mrtr_lst_using_get(
        businessstatus: str,
        collateralgroup: Optional[int] = None,
        collateralreference: Optional[int] = None,
        collateralsubgroup: Optional[int] = None,
        collateraltype: Optional[int] = None,
        customerreference: Optional[int] = None,
        pagenum: Optional[int] = None,
        pagesize: Optional[int] = None,
        accesstoken: Optional[str] = None,
        channeltype: Optional[int] = None,
        co_relationid: Optional[int] = None,
        initiatingsystem: Optional[str] = None,
        servicemode: Optional[int] = None,
        uuidseqno: Optional[int] = None,
        entity: Optional[str] = None,
        languagecode: Optional[int] = None,
        referenceid: Optional[str] = None,
        userid: Optional[int] = None
    ) -> Dict[str, Any]:
        """
        View Collateral List
        
        Generated from: GET /collateral/list
        Source: swagger_2_0
        Operation ID: CRET1803FetchCltrlMrtrLstUsingGET
        
        
        Authentication: Not required
        
        Parameters:
        - BusinessStatus: string (required)
          Status of the Collateral : 1 - Active , 2 - Inactive .More Collateral Status refer d_Status
        - CollateralGroup: integer
          Collateral Group - a combination of collateral group and sub-group which can be configured per collateral type : 2-Invoice and Receivables,10-Shares and bonds,11-Villa,12-Vacation home,13-Vehicle and Heavy Machinery . More Collateral Group refer d_CollateralGrp
        - CollateralReference: integer
          System generated Collateral Unique Reference
        - CollateralSubGroup: integer
          Collateral sub group : 1-All,22-TENANT_OWNED,24-RENTAL_ESTATE,25-OFFICE_ESTATE . More Collateral Subgroup refer d_CollateralSubGrp
        - CollateralType: integer
          Collateral Type - The various types of collateral templates supported in system: 12-Shares and Bonds,13-Invoice and Receivables,14-Land and Immovable Property,15-Vehicle and Heavy Machinery. More Collateral Type refer d_CollateralType
        - CustomerReference: integer
          Internal Identifier of the customer who is the owner of the collateral
        - pageNum: integer
          pageNum
        - pageSize: integer
          pageSize
        
        
        
        Headers:
        - Accesstoken: string
          Authorization token for identification of the caller
        - ChannelType: integer
          Channel identifier from where the TXN has originated (Internet, Mobile, ATM, Branch Channel )
        - Co-Relationid: integer
          Unique ID for the service invoked, will be set by the TXN system
        - InitiatingSystem: string
          Indicating the initiated system
        - ServiceMode: integer
          Used for branch channel to indicate the type of customer
        - UUIDSeqNo: integer
          UUID Sequence Number
        - entity: string
          entity
        - languageCode: integer
          languageCode
        - referenceId: string
          Place holder for Token based authentication
        - userId: integer
          userId
        
        
        """
        
        
        # Prepare query parameters
        params = {}
        if businessstatus is not None:
            params["BusinessStatus"] = businessstatus
            
        if collateralgroup is not None:
            params["CollateralGroup"] = collateralgroup
            
        if collateralreference is not None:
            params["CollateralReference"] = collateralreference
            
        if collateralsubgroup is not None:
            params["CollateralSubGroup"] = collateralsubgroup
            
        if collateraltype is not None:
            params["CollateralType"] = collateraltype
            
        if customerreference is not None:
            params["CustomerReference"] = customerreference
            
        if pagenum is not None:
            params["pageNum"] = pagenum
            
        if pagesize is not None:
            params["pageSize"] = pagesize
            
        
        
        # Replace path parameters in URL
        path = "/collateral/list"
        
        
        # Prepare headers
        headers = {}
        if accesstoken is not None:
            headers["Accesstoken"] = str(accesstoken)
        if channeltype is not None:
            headers["ChannelType"] = str(channeltype)
        if co_relationid is not None:
            headers["Co-Relationid"] = str(co_relationid)
        if initiatingsystem is not None:
            headers["InitiatingSystem"] = str(initiatingsystem)
        if servicemode is not None:
            headers["ServiceMode"] = str(servicemode)
        if uuidseqno is not None:
            headers["UUIDSeqNo"] = str(uuidseqno)
        if entity is not None:
            headers["entity"] = str(entity)
        if languagecode is not None:
            headers["languageCode"] = str(languagecode)
        if referenceid is not None:
            headers["referenceId"] = str(referenceid)
        if userid is not None:
            headers["userId"] = str(userid)
        
        
        return await make_api_request(
            "GET", 
            path, 
            
            params=params if params else None, 
            headers=headers if headers else None
        )
    
    
    
    @mcp.tool()
    async def cret1802_fetch_prprty_mortgage_deeds_cltrl_wrapper_using_get(
        collateralreference: int,
        accesstoken: Optional[str] = None,
        channeltype: Optional[int] = None,
        co_relationid: Optional[int] = None,
        initiatingsystem: Optional[str] = None,
        servicemode: Optional[int] = None,
        uuidseqno: Optional[int] = None,
        entity: Optional[str] = None,
        languagecode: Optional[int] = None,
        referenceid: Optional[str] = None,
        requesthash: Optional[str] = None,
        userid: Optional[int] = None
    ) -> Dict[str, Any]:
        """
        Fetch Details of Land And immovable property Collateral
        
        Generated from: GET /collateral/realEstate/{collateralReference}
        Source: swagger_2_0
        Operation ID: CRET1802FetchPrprtyMortgageDeedsCltrlWrapperUsingGET
        
        
        Authentication: Not required
        
        Parameters:
        - collateralReference: integer (required)
          Collateral Id Generated
        
        
        
        Headers:
        - Accesstoken: string
          Authorization token for identification of the caller
        - ChannelType: integer
          Channel identifier from where the TXN has originated (Internet, Mobile, ATM, Branch Channel )
        - Co-Relationid: integer
          Unique ID for the service invoked, will be set by the TXN system
        - InitiatingSystem: string
          Indicating the initiated system
        - ServiceMode: integer
          Used for branch channel to indicate the type of customer
        - UUIDSeqNo: integer
          UUID Sequence Number
        - entity: string
          entity
        - languageCode: integer
          languageCode
        - referenceId: string
          Place holder for Token based authentication
        - requesthash: string
          Request payload for hash validation
        - userId: integer
          userId
        
        
        """
        
        
        # Prepare query parameters
        params = {}
        
        
        # Replace path parameters in URL
        path = "/collateral/realEstate/{collateralReference}"
        if collateralreference is not None:
            path = path.replace("{collateralReference}", str(collateralreference))
        
        
        # Prepare headers
        headers = {}
        if accesstoken is not None:
            headers["Accesstoken"] = str(accesstoken)
        if channeltype is not None:
            headers["ChannelType"] = str(channeltype)
        if co_relationid is not None:
            headers["Co-Relationid"] = str(co_relationid)
        if initiatingsystem is not None:
            headers["InitiatingSystem"] = str(initiatingsystem)
        if servicemode is not None:
            headers["ServiceMode"] = str(servicemode)
        if uuidseqno is not None:
            headers["UUIDSeqNo"] = str(uuidseqno)
        if entity is not None:
            headers["entity"] = str(entity)
        if languagecode is not None:
            headers["languageCode"] = str(languagecode)
        if referenceid is not None:
            headers["referenceId"] = str(referenceid)
        if requesthash is not None:
            headers["requesthash"] = str(requesthash)
        if userid is not None:
            headers["userId"] = str(userid)
        
        
        return await make_api_request(
            "GET", 
            path, 
            
            params=params if params else None, 
            headers=headers if headers else None
        )
    
    
    
    @mcp.tool()
    async def crbt1809_create_vhcl_cltrl_postusing_post(
        request_body:Dict[str, Any] ,  # createVhclCltrlResource,
        accesstoken: Optional[str] = None,
        channeltype: Optional[int] = None,
        co_relationid: Optional[int] = None,
        initiatingsystem: Optional[str] = None,
        servicemode: Optional[int] = None,
        uuidseqno: Optional[int] = None,
        entity: Optional[str] = None,
        languagecode: Optional[int] = None,
        referenceid: Optional[str] = None,
        requesthash: Optional[str] = None,
        userid: Optional[int] = None
    ) -> Dict[str, Any]:
        """
        Creation of Vehicle and Heavy Machinery Collateral
        
        Generated from: POST /collateral/vehicleAndHeavyMachinery
        Source: swagger_2_0
        Operation ID: CRBT1809CreateVhclCltrlPOSTUsingPOST
        
        
        Authentication: Not required
        
        Parameters:
        - request_body: any (required)
          input
        
        
        
        Headers:
        - Accesstoken: string
          Authorization token for identification of the caller
        - ChannelType: integer
          Channel identifier from where the TXN has originated (Internet, Mobile, ATM, Branch Channel )
        - Co-Relationid: integer
          Unique ID for the service invoked, will be set by the TXN system
        - InitiatingSystem: string
          Indicating the initiated system
        - ServiceMode: integer
          Used for branch channel to indicate the type of customer
        - UUIDSeqNo: integer
          UUID Sequence Number
        - entity: string
          entity
        - languageCode: integer
          languageCode
        - referenceId: string
          Place holder for Token based authentication
        - requesthash: string
          Request payload for hash validation
        - userId: integer
          userId
        
        
        """
        
        
        # Prepare request data
        
        # Single body parameter - send directly
        data = request_body if request_body is not None else {}
        
        
        
        # Prepare query parameters
        params = {}
        
        
        # Replace path parameters in URL
        path = "/collateral/vehicleAndHeavyMachinery"
        
        
        # Prepare headers
        headers = {}
        if accesstoken is not None:
            headers["Accesstoken"] = str(accesstoken)
        if channeltype is not None:
            headers["ChannelType"] = str(channeltype)
        if co_relationid is not None:
            headers["Co-Relationid"] = str(co_relationid)
        if initiatingsystem is not None:
            headers["InitiatingSystem"] = str(initiatingsystem)
        if servicemode is not None:
            headers["ServiceMode"] = str(servicemode)
        if uuidseqno is not None:
            headers["UUIDSeqNo"] = str(uuidseqno)
        if entity is not None:
            headers["entity"] = str(entity)
        if languagecode is not None:
            headers["languageCode"] = str(languagecode)
        if referenceid is not None:
            headers["referenceId"] = str(referenceid)
        if requesthash is not None:
            headers["requesthash"] = str(requesthash)
        if userid is not None:
            headers["userId"] = str(userid)
        
        
        return await make_api_request(
            "POST", 
            path, 
            data=data, 
            params=params if params else None, 
            headers=headers if headers else None
        )
    
    
    
    @mcp.tool()
    async def cret1809_fetch_vehicle_cltrl_dtls_getusing_get(
        collateralreference: int,
        accesstoken: Optional[str] = None,
        channeltype: Optional[int] = None,
        co_relationid: Optional[int] = None,
        initiatingsystem: Optional[str] = None,
        servicemode: Optional[int] = None,
        uuidseqno: Optional[int] = None,
        entity: Optional[str] = None,
        languagecode: Optional[int] = None,
        referenceid: Optional[str] = None,
        requesthash: Optional[str] = None,
        userid: Optional[int] = None
    ) -> Dict[str, Any]:
        """
        Fetch Details of  Vehicle and Heavy  Machinary Collateral
        
        Generated from: GET /collateral/vehicleAndHeavyMachinery/{collateralReference}
        Source: swagger_2_0
        Operation ID: CRET1809FetchVehicleCltrlDtlsGETUsingGET
        
        
        Authentication: Not required
        
        Parameters:
        - collateralReference: integer (required)
          System generated unique reference of collateral
        
        
        
        Headers:
        - Accesstoken: string
          Authorization token for identification of the caller
        - ChannelType: integer
          Channel identifier from where the TXN has originated (Internet, Mobile, ATM, Branch Channel )
        - Co-Relationid: integer
          Unique ID for the service invoked, will be set by the TXN system
        - InitiatingSystem: string
          Indicating the initiated system
        - ServiceMode: integer
          Used for branch channel to indicate the type of customer
        - UUIDSeqNo: integer
          UUID Sequence Number
        - entity: string
          entity
        - languageCode: integer
          languageCode
        - referenceId: string
          Place holder for Token based authentication
        - requesthash: string
          Request payload for hash validation
        - userId: integer
          userId
        
        
        """
        
        
        # Prepare query parameters
        params = {}
        
        
        # Replace path parameters in URL
        path = "/collateral/vehicleAndHeavyMachinery/{collateralReference}"
        if collateralreference is not None:
            path = path.replace("{collateralReference}", str(collateralreference))
        
        
        # Prepare headers
        headers = {}
        if accesstoken is not None:
            headers["Accesstoken"] = str(accesstoken)
        if channeltype is not None:
            headers["ChannelType"] = str(channeltype)
        if co_relationid is not None:
            headers["Co-Relationid"] = str(co_relationid)
        if initiatingsystem is not None:
            headers["InitiatingSystem"] = str(initiatingsystem)
        if servicemode is not None:
            headers["ServiceMode"] = str(servicemode)
        if uuidseqno is not None:
            headers["UUIDSeqNo"] = str(uuidseqno)
        if entity is not None:
            headers["entity"] = str(entity)
        if languagecode is not None:
            headers["languageCode"] = str(languagecode)
        if referenceid is not None:
            headers["referenceId"] = str(referenceid)
        if requesthash is not None:
            headers["requesthash"] = str(requesthash)
        if userid is not None:
            headers["userId"] = str(userid)
        
        
        return await make_api_request(
            "GET", 
            path, 
            
            params=params if params else None, 
            headers=headers if headers else None
        )
    
    
    
    @mcp.tool()
    async def crbt0101_veh_and_heavy_machinery_modification_wrapper_postusing_put(
        collateralreference: int,
        request_body:Dict[str, Any] ,  # vehAndHeavyMachineryModificationWrapperResource,
        accesstoken: Optional[str] = None,
        channeltype: Optional[int] = None,
        co_relationid: Optional[int] = None,
        initiatingsystem: Optional[str] = None,
        servicemode: Optional[int] = None,
        uuidseqno: Optional[int] = None,
        entity: Optional[str] = None,
        languagecode: Optional[int] = None,
        referenceid: Optional[str] = None,
        requesthash: Optional[str] = None,
        userid: Optional[int] = None
    ) -> Dict[str, Any]:
        """
        Modification of Vehicle And Heavy Machinery collateral
        
        Generated from: PUT /collateral/vehicleAndHeavyMachinery/{collateralReference}
        Source: swagger_2_0
        Operation ID: CRBT0101VehAndHeavyMachineryModificationWrapperPOSTUsingPUT
        
        
        Authentication: Not required
        
        Parameters:
        - collateralReference: integer (required)
          System generated Collateral Unique Reference
        - request_body: any (required)
          input
        
        
        
        Headers:
        - Accesstoken: string
          Authorization token for identification of the caller
        - ChannelType: integer
          Channel identifier from where the TXN has originated (Internet, Mobile, ATM, Branch Channel )
        - Co-Relationid: integer
          Unique ID for the service invoked, will be set by the TXN system
        - InitiatingSystem: string
          Indicating the initiated system
        - ServiceMode: integer
          Used for branch channel to indicate the type of customer
        - UUIDSeqNo: integer
          UUID Sequence Number
        - entity: string
          entity
        - languageCode: integer
          languageCode
        - referenceId: string
          Place holder for Token based authentication
        - requesthash: string
          Request payload for hash validation
        - userId: integer
          userId
        
        
        """
        
        
        # Prepare request data
        
        # Single body parameter - send directly
        data = request_body if request_body is not None else {}
        
        
        
        # Prepare query parameters
        params = {}
        
        
        # Replace path parameters in URL
        path = "/collateral/vehicleAndHeavyMachinery/{collateralReference}"
        if collateralreference is not None:
            path = path.replace("{collateralReference}", str(collateralreference))
        
        
        # Prepare headers
        headers = {}
        if accesstoken is not None:
            headers["Accesstoken"] = str(accesstoken)
        if channeltype is not None:
            headers["ChannelType"] = str(channeltype)
        if co_relationid is not None:
            headers["Co-Relationid"] = str(co_relationid)
        if initiatingsystem is not None:
            headers["InitiatingSystem"] = str(initiatingsystem)
        if servicemode is not None:
            headers["ServiceMode"] = str(servicemode)
        if uuidseqno is not None:
            headers["UUIDSeqNo"] = str(uuidseqno)
        if entity is not None:
            headers["entity"] = str(entity)
        if languagecode is not None:
            headers["languageCode"] = str(languagecode)
        if referenceid is not None:
            headers["referenceId"] = str(referenceid)
        if requesthash is not None:
            headers["requesthash"] = str(requesthash)
        if userid is not None:
            headers["userId"] = str(userid)
        
        
        return await make_api_request(
            "PUT", 
            path, 
            data=data, 
            params=params if params else None, 
            headers=headers if headers else None
        )
    
    
    
    @mcp.tool()
    async def crbt1995_auth_bank_dep_cltrl_postusing_post(
        request_body:Dict[str, Any] ,  # CLTRL_MASTER_CRBT1995AuthBankDepCltrl_Resource
    ) -> Dict[str, Any]:
        """
        CRBT1995AuthBankDepCltrl
        
        Generated from: POST /crbt1995authbankdepcltrl
        Source: swagger_2_0
        Operation ID: CRBT1995AuthBankDepCltrl_POSTUsingPOST
        
        
        Authentication: Not required
        
        Parameters:
        - request_body: any (required)
          input
        
        
        
        """
        
        
        # Prepare request data
        
        # Single body parameter - send directly
        data = request_body if request_body is not None else {}
        
        
        
        # Prepare query parameters
        params = {}
        
        
        # Replace path parameters in URL
        path = "/crbt1995authbankdepcltrl"
        
        
        # Prepare headers
        headers = {}
        
        
        return await make_api_request(
            "POST", 
            path, 
            data=data, 
            params=params if params else None, 
            headers=headers if headers else None
        )
    
    
    
    @mcp.tool()
    async def ambt2021_crypto_adrs_maint_postusing_post(
        request_body:Dict[str, Any] ,  # cryptoBlockAddressMaintainanceResource,
        accesstoken: Optional[str] = None,
        channeltype: Optional[int] = None,
        co_relationid: Optional[int] = None,
        initiatingsystem: Optional[str] = None,
        servicemode: Optional[int] = None,
        uuidseqno: Optional[int] = None,
        entity: Optional[str] = None,
        referenceid: Optional[str] = None,
        requesthash: Optional[str] = None
    ) -> Dict[str, Any]:
        """
        Maintainance of Crypto Block Address
        
        Generated from: POST /crypto/account/cryptoDetails/maintainance
        Source: swagger_2_0
        Operation ID: AMBT2021CryptoAdrsMaint_POSTUsingPOST
        
        
        Authentication: Not required
        
        Parameters:
        - request_body: any (required)
          input
        
        
        
        Headers:
        - Accesstoken: string
          Authorization token for identification of the caller
        - ChannelType: integer
          Channel identifier from where the TXN has originated (Internet, Mobile, ATM, Branch Channel )
        - Co-Relationid: integer
          Unique ID for the service invoked, will be set by the TXN system
        - InitiatingSystem: string
          Indicating the initiated system
        - ServiceMode: integer
          Used for branch channel to indicate the type of customer
        - UUIDSeqNo: integer
          UUID Sequence Number
        - entity: string
          entity
        - referenceId: string
          Place holder for Token based authentication
        - requesthash: string
          Request payload for hash validation
        
        
        """
        
        
        # Prepare request data
        
        # Single body parameter - send directly
        data = request_body if request_body is not None else {}
        
        
        
        # Prepare query parameters
        params = {}
        
        
        # Replace path parameters in URL
        path = "/crypto/account/cryptoDetails/maintainance"
        
        
        # Prepare headers
        headers = {}
        if accesstoken is not None:
            headers["Accesstoken"] = str(accesstoken)
        if channeltype is not None:
            headers["ChannelType"] = str(channeltype)
        if co_relationid is not None:
            headers["Co-Relationid"] = str(co_relationid)
        if initiatingsystem is not None:
            headers["InitiatingSystem"] = str(initiatingsystem)
        if servicemode is not None:
            headers["ServiceMode"] = str(servicemode)
        if uuidseqno is not None:
            headers["UUIDSeqNo"] = str(uuidseqno)
        if entity is not None:
            headers["entity"] = str(entity)
        if referenceid is not None:
            headers["referenceId"] = str(referenceid)
        if requesthash is not None:
            headers["requesthash"] = str(requesthash)
        
        
        return await make_api_request(
            "POST", 
            path, 
            data=data, 
            params=params if params else None, 
            headers=headers if headers else None
        )
    
    
    
    @mcp.tool()
    async def ametget_crypto_block_address_postusing_get(
        accountreference: str,
        customerreference: int,
        currency: Optional[str] = None,
        status: Optional[int] = None,
        validfrom: Optional[str] = None,
        validtill: Optional[str] = None,
        pagenum: Optional[int] = None,
        pagesize: Optional[int] = None,
        accesstoken: Optional[str] = None,
        channeltype: Optional[int] = None,
        co_relationid: Optional[int] = None,
        initiatingsystem: Optional[str] = None,
        servicemode: Optional[int] = None,
        uuidseqno: Optional[int] = None,
        authorization: Optional[str] = None,
        entity: Optional[str] = None,
        languagecode: Optional[int] = None,
        referenceid: Optional[str] = None,
        userid: Optional[int] = None
    ) -> Dict[str, Any]:
        """
        Fetch Crypto Block Address
        
        Generated from: GET /crypto/account/{accountReference}/cryptoDetails
        Source: swagger_2_0
        Operation ID: AMETGetCryptoBlockAddress_POSTUsingGET
        
        
        Authentication: Not required
        
        Parameters:
        - Currency: string
          Currency of blockchain address created
        - Status: integer
          This Field denotes the WorkFlow Status of the Crypto Master created by User 2-Active,3-Released,6-Rejected,11-ActModPendAuth(Domain Name: d_AccStat)
        - ValidFrom: string
          Date on which Account has been opened (Date Format : yyyyMMdd)
        - ValidTill: string
          Date till which related Block Chain Address is valid. Once the date crosses Current Application Date,Same Block Address should be reflected in history Tab.(Date Format : yyyyMMdd)
        - accountReference: string (required)
          BBAN Number of Account for which Crypto Details has to be fetched
        - customerReference: integer (required)
          Customer Reference of the Account for which Crypto Details has to be fetched
        - pageNum: integer
          pageNum
        - pageSize: integer
          pageSize
        
        
        
        Headers:
        - Accesstoken: string
          Authorization token for identification of the caller
        - ChannelType: integer
          Channel identifier from where the TXN has originated (Internet, Mobile, ATM, Branch Channel )
        - Co-Relationid: integer
          Unique ID for the service invoked, will be set by the TXN system
        - InitiatingSystem: string
          Indicating the initiated system
        - ServiceMode: integer
          Used for branch channel to indicate the type of customer
        - UUIDSeqNo: integer
          UUID Sequence Number
        - authorization: string
          Authorization Token to validation the caller
        - entity: string
          entity
        - languageCode: integer
          languageCode
        - referenceId: string
          Identified reference field for authorization
        - userId: integer
          userId
        
        
        """
        
        
        # Prepare query parameters
        params = {}
        if currency is not None:
            params["Currency"] = currency
            
        if status is not None:
            params["Status"] = status
            
        if validfrom is not None:
            params["ValidFrom"] = validfrom
            
        if validtill is not None:
            params["ValidTill"] = validtill
            
        if pagenum is not None:
            params["pageNum"] = pagenum
            
        if pagesize is not None:
            params["pageSize"] = pagesize
            
        
        
        # Replace path parameters in URL
        path = "/crypto/account/{accountReference}/cryptoDetails"
        if accountreference is not None:
            path = path.replace("{accountReference}", str(accountreference))
        if customerreference is not None:
            path = path.replace("{customerReference}", str(customerreference))
        
        
        # Prepare headers
        headers = {}
        if accesstoken is not None:
            headers["Accesstoken"] = str(accesstoken)
        if channeltype is not None:
            headers["ChannelType"] = str(channeltype)
        if co_relationid is not None:
            headers["Co-Relationid"] = str(co_relationid)
        if initiatingsystem is not None:
            headers["InitiatingSystem"] = str(initiatingsystem)
        if servicemode is not None:
            headers["ServiceMode"] = str(servicemode)
        if uuidseqno is not None:
            headers["UUIDSeqNo"] = str(uuidseqno)
        if authorization is not None:
            headers["authorization"] = str(authorization)
        if entity is not None:
            headers["entity"] = str(entity)
        if languagecode is not None:
            headers["languageCode"] = str(languagecode)
        if referenceid is not None:
            headers["referenceId"] = str(referenceid)
        if userid is not None:
            headers["userId"] = str(userid)
        
        
        return await make_api_request(
            "GET", 
            path, 
            
            params=params if params else None, 
            headers=headers if headers else None
        )
    
    
    
    @mcp.tool()
    async def ameet2022_fetch_customer_holdings_postusing_get(
        customerreference: int,
        holdingtype: int,
        pagenum: Optional[int] = None,
        pagesize: Optional[int] = None,
        accesstoken: Optional[str] = None,
        channeltype: Optional[int] = None,
        co_relationid: Optional[int] = None,
        initiatingsystem: Optional[str] = None,
        servicemode: Optional[int] = None,
        uuidseqno: Optional[int] = None,
        entity: Optional[str] = None,
        languagecode: Optional[int] = None,
        referenceid: Optional[str] = None,
        userid: Optional[int] = None
    ) -> Dict[str, Any]:
        """
        Fetch Customer Holdings
        
        Generated from: GET /crypto/customer/holdings
        Source: swagger_2_0
        Operation ID: AMEET2022FetchCustomerHoldings_POSTUsingGET
        
        
        Authentication: Not required
        
        Parameters:
        - CustomerReference: integer (required)
          This field displays Customer Reference
        - HoldingType: integer (required)
          This field displays Holding Type 1- Crypto 2- Fiat
        - pageNum: integer
          pageNum
        - pageSize: integer
          pageSize
        
        
        
        Headers:
        - Accesstoken: string
          Authorization token for identification of the caller
        - ChannelType: integer
          Channel identifier from where the transaction has originated (Internet, Mobile, ATM, Branch Channel )
        - Co-Relationid: integer
          Unique ID for the service invoked, will be set by the transaction system
        - InitiatingSystem: string
          Indicating the initiated system
        - ServiceMode: integer
          Used for branch channel to indicate the type of customer
        - UUIDSeqNo: integer
          UUID Sequence Number
        - entity: string
          entity
        - languageCode: integer
          languageCode
        - referenceId: string
          Place holder for Token based authentication
        - userId: integer
          userId
        
        
        """
        
        
        # Prepare query parameters
        params = {}
        if customerreference is not None:
            params["CustomerReference"] = customerreference
            
        if holdingtype is not None:
            params["HoldingType"] = holdingtype
            
        if pagenum is not None:
            params["pageNum"] = pagenum
            
        if pagesize is not None:
            params["pageSize"] = pagesize
            
        
        
        # Replace path parameters in URL
        path = "/crypto/customer/holdings"
        
        
        # Prepare headers
        headers = {}
        if accesstoken is not None:
            headers["Accesstoken"] = str(accesstoken)
        if channeltype is not None:
            headers["ChannelType"] = str(channeltype)
        if co_relationid is not None:
            headers["Co-Relationid"] = str(co_relationid)
        if initiatingsystem is not None:
            headers["InitiatingSystem"] = str(initiatingsystem)
        if servicemode is not None:
            headers["ServiceMode"] = str(servicemode)
        if uuidseqno is not None:
            headers["UUIDSeqNo"] = str(uuidseqno)
        if entity is not None:
            headers["entity"] = str(entity)
        if languagecode is not None:
            headers["languageCode"] = str(languagecode)
        if referenceid is not None:
            headers["referenceId"] = str(referenceid)
        if userid is not None:
            headers["userId"] = str(userid)
        
        
        return await make_api_request(
            "GET", 
            path, 
            
            params=params if params else None, 
            headers=headers if headers else None
        )
    
    
    
    @mcp.tool()
    async def ameetfetch_all_currencies_postusing_get(
        pagenum: Optional[int] = None,
        pagesize: Optional[int] = None,
        accesstoken: Optional[str] = None,
        channeltype: Optional[int] = None,
        co_relationid: Optional[int] = None,
        initiatingsystem: Optional[str] = None,
        servicemode: Optional[int] = None,
        uuidseqno: Optional[int] = None,
        entity: Optional[str] = None,
        languagecode: Optional[int] = None,
        referenceid: Optional[str] = None,
        userid: Optional[int] = None
    ) -> Dict[str, Any]:
        """
        Fetch All Currency Details
        
        Generated from: GET /crypto/fetchAllCurrencyDetails
        Source: swagger_2_0
        Operation ID: AMEETFetchAllCurrencies_POSTUsingGET
        
        
        Authentication: Not required
        
        Parameters:
        - pageNum: integer
          pageNum
        - pageSize: integer
          pageSize
        
        
        
        Headers:
        - Accesstoken: string
          Authorization token for identification of the caller
        - ChannelType: integer
          Channel identifier from where the transaction has originated (Internet, Mobile, ATM, Branch Channel )
        - Co-Relationid: integer
          Unique ID for the service invoked, will be set by the transaction system
        - InitiatingSystem: string
          Indicating the initiated system
        - ServiceMode: integer
          Used for branch channel to indicate the type of customer
        - UUIDSeqNo: integer
          UUID Sequence Number
        - entity: string
          entity
        - languageCode: integer
          languageCode
        - referenceId: string
          Place holder for Token based authentication
        - userId: integer
          userId
        
        
        """
        
        
        # Prepare query parameters
        params = {}
        if pagenum is not None:
            params["pageNum"] = pagenum
            
        if pagesize is not None:
            params["pageSize"] = pagesize
            
        
        
        # Replace path parameters in URL
        path = "/crypto/fetchAllCurrencyDetails"
        
        
        # Prepare headers
        headers = {}
        if accesstoken is not None:
            headers["Accesstoken"] = str(accesstoken)
        if channeltype is not None:
            headers["ChannelType"] = str(channeltype)
        if co_relationid is not None:
            headers["Co-Relationid"] = str(co_relationid)
        if initiatingsystem is not None:
            headers["InitiatingSystem"] = str(initiatingsystem)
        if servicemode is not None:
            headers["ServiceMode"] = str(servicemode)
        if uuidseqno is not None:
            headers["UUIDSeqNo"] = str(uuidseqno)
        if entity is not None:
            headers["entity"] = str(entity)
        if languagecode is not None:
            headers["languageCode"] = str(languagecode)
        if referenceid is not None:
            headers["referenceId"] = str(referenceid)
        if userid is not None:
            headers["userId"] = str(userid)
        
        
        return await make_api_request(
            "GET", 
            path, 
            
            params=params if params else None, 
            headers=headers if headers else None
        )
    
    
    
    @mcp.tool()
    async def ameetfetch_lending_currencies_postusing_get(
        pagenum: Optional[int] = None,
        pagesize: Optional[int] = None,
        accesstoken: Optional[str] = None,
        channeltype: Optional[int] = None,
        co_relationid: Optional[int] = None,
        initiatingsystem: Optional[str] = None,
        servicemode: Optional[int] = None,
        uuidseqno: Optional[int] = None,
        entity: Optional[str] = None,
        languagecode: Optional[int] = None,
        referenceid: Optional[str] = None,
        userid: Optional[int] = None
    ) -> Dict[str, Any]:
        """
        Fetch Currencies in which loans can be granted
        
        Generated from: GET /crypto/fetchAllLendingCurrencies
        Source: swagger_2_0
        Operation ID: AMEETFetchLendingCurrencies_POSTUsingGET
        
        
        Authentication: Not required
        
        Parameters:
        - pageNum: integer
          pageNum
        - pageSize: integer
          pageSize
        
        
        
        Headers:
        - Accesstoken: string
          Authorization token for identification of the caller
        - ChannelType: integer
          Channel identifier from where the transaction has originated (Internet, Mobile, ATM, Branch Channel )
        - Co-Relationid: integer
          Unique ID for the service invoked, will be set by the transaction system
        - InitiatingSystem: string
          Indicating the initiated system
        - ServiceMode: integer
          Used for branch channel to indicate the type of customer
        - UUIDSeqNo: integer
          UUID Sequence Number
        - entity: string
          entity
        - languageCode: integer
          languageCode
        - referenceId: string
          Place holder for Token based authentication
        - userId: integer
          userId
        
        
        """
        
        
        # Prepare query parameters
        params = {}
        if pagenum is not None:
            params["pageNum"] = pagenum
            
        if pagesize is not None:
            params["pageSize"] = pagesize
            
        
        
        # Replace path parameters in URL
        path = "/crypto/fetchAllLendingCurrencies"
        
        
        # Prepare headers
        headers = {}
        if accesstoken is not None:
            headers["Accesstoken"] = str(accesstoken)
        if channeltype is not None:
            headers["ChannelType"] = str(channeltype)
        if co_relationid is not None:
            headers["Co-Relationid"] = str(co_relationid)
        if initiatingsystem is not None:
            headers["InitiatingSystem"] = str(initiatingsystem)
        if servicemode is not None:
            headers["ServiceMode"] = str(servicemode)
        if uuidseqno is not None:
            headers["UUIDSeqNo"] = str(uuidseqno)
        if entity is not None:
            headers["entity"] = str(entity)
        if languagecode is not None:
            headers["languageCode"] = str(languagecode)
        if referenceid is not None:
            headers["referenceId"] = str(referenceid)
        if userid is not None:
            headers["userId"] = str(userid)
        
        
        return await make_api_request(
            "GET", 
            path, 
            
            params=params if params else None, 
            headers=headers if headers else None
        )
    
    
    
    @mcp.tool()
    async def faet2022_fetch_crypto_bal_postusing_get(
        accountreference: Optional[str] = None,
        blanacetype: Optional[int] = None,
        blockchainadress: Optional[str] = None,
        accesstoken: Optional[str] = None,
        channeltype: Optional[int] = None,
        co_relationid: Optional[int] = None,
        initiatingsystem: Optional[str] = None,
        servicemode: Optional[int] = None,
        uuidseqno: Optional[int] = None,
        entity: Optional[str] = None,
        referenceid: Optional[str] = None,
        requesthash: Optional[str] = None,
        userid: Optional[int] = None
    ) -> Dict[str, Any]:
        """
        Fetch Crypto Balance
        
        Generated from: GET /crypto/fetchCryptoBalance
        Source: swagger_2_0
        Operation ID: FAET2022FetchCryptoBal_POSTUsingGET
        
        
        Authentication: Not required
        
        Parameters:
        - AccountReference: string
          Account Number of the Account. It can be IBAN or BBAN for Cash Account and Reference Account Number for Internal Account
        - blanaceType: integer
          Balance Type like 1 - Book Dated Balance ( Sum of Movements Amount ), 13 - Current Balance ( Sum of Movements Amount - Active Cash Blocks or Fund Hold ), 4 - Available Balance ( Sum of Movements Amount and Overdraft Limit Amount - Active Cash Blocks or Fund Hold) . Default will be Available Balance when No value for Balance Type is received in the Input
        - blockChainAdress: string
          BlockChain Address for the Account
        
        
        
        Headers:
        - Accesstoken: string
          Authorization token for identification of the caller
        - ChannelType: integer
          Channel from where the transaction has originated (Internet, Mobile, ATM, Branch Channel )
        - Co-Relationid: integer
          Unique ID for the service invoked, will be set by the TXN system
        - InitiatingSystem: string
          Indicating the initiated system
        - ServiceMode: integer
          Used for branch channel to indicate the type of customer
        - UUIDSeqNo: integer
          UUID Sequence Number
        - entity: string
          entity
        - referenceId: string
          Place holder for Token based authentication
        - requesthash: string
          Request payload for hash validation
        - userId: integer
          userId
        
        
        """
        
        
        # Prepare query parameters
        params = {}
        if accountreference is not None:
            params["AccountReference"] = accountreference
            
        if blanacetype is not None:
            params["blanaceType"] = blanacetype
            
        if blockchainadress is not None:
            params["blockChainAdress"] = blockchainadress
            
        
        
        # Replace path parameters in URL
        path = "/crypto/fetchCryptoBalance"
        
        
        # Prepare headers
        headers = {}
        if accesstoken is not None:
            headers["Accesstoken"] = str(accesstoken)
        if channeltype is not None:
            headers["ChannelType"] = str(channeltype)
        if co_relationid is not None:
            headers["Co-Relationid"] = str(co_relationid)
        if initiatingsystem is not None:
            headers["InitiatingSystem"] = str(initiatingsystem)
        if servicemode is not None:
            headers["ServiceMode"] = str(servicemode)
        if uuidseqno is not None:
            headers["UUIDSeqNo"] = str(uuidseqno)
        if entity is not None:
            headers["entity"] = str(entity)
        if referenceid is not None:
            headers["referenceId"] = str(referenceid)
        if requesthash is not None:
            headers["requesthash"] = str(requesthash)
        if userid is not None:
            headers["userId"] = str(userid)
        
        
        return await make_api_request(
            "GET", 
            path, 
            
            params=params if params else None, 
            headers=headers if headers else None
        )
    
    
    
    @mcp.tool()
    async def ameetfetch_lending_currency_details_postusing_get(
        currencycodenumber: int,
        pagenum: Optional[int] = None,
        pagesize: Optional[int] = None,
        accesstoken: Optional[str] = None,
        channeltype: Optional[int] = None,
        co_relationid: Optional[int] = None,
        initiatingsystem: Optional[str] = None,
        servicemode: Optional[int] = None,
        uuidseqno: Optional[int] = None,
        entity: Optional[str] = None,
        languagecode: Optional[int] = None,
        referenceid: Optional[str] = None,
        userid: Optional[int] = None
    ) -> Dict[str, Any]:
        """
        Fetch Currency Details based on Currency Code Number
        
        Generated from: GET /crypto/fetchCurrencyDetail/currencyCodeNumber
        Source: swagger_2_0
        Operation ID: AMEETFetchLendingCurrencyDetails_POSTUsingGET
        
        
        Authentication: Not required
        
        Parameters:
        - currencyCodeNumber: integer (required)
          This field displays Currency Code Number.
        - pageNum: integer
          pageNum
        - pageSize: integer
          pageSize
        
        
        
        Headers:
        - Accesstoken: string
          Authorization token for identification of the caller
        - ChannelType: integer
          Channel identifier from where the transaction has originated (Internet, Mobile, ATM, Branch Channel )
        - Co-Relationid: integer
          Unique ID for the service invoked, will be set by the transaction system
        - InitiatingSystem: string
          Indicating the initiated system
        - ServiceMode: integer
          Used for branch channel to indicate the type of customer
        - UUIDSeqNo: integer
          UUID Sequence Number
        - entity: string
          entity
        - languageCode: integer
          languageCode
        - referenceId: string
          Place holder for Token based authentication
        - userId: integer
          userId
        
        
        """
        
        
        # Prepare query parameters
        params = {}
        if currencycodenumber is not None:
            params["currencyCodeNumber"] = currencycodenumber
            
        if pagenum is not None:
            params["pageNum"] = pagenum
            
        if pagesize is not None:
            params["pageSize"] = pagesize
            
        
        
        # Replace path parameters in URL
        path = "/crypto/fetchCurrencyDetail/currencyCodeNumber"
        
        
        # Prepare headers
        headers = {}
        if accesstoken is not None:
            headers["Accesstoken"] = str(accesstoken)
        if channeltype is not None:
            headers["ChannelType"] = str(channeltype)
        if co_relationid is not None:
            headers["Co-Relationid"] = str(co_relationid)
        if initiatingsystem is not None:
            headers["InitiatingSystem"] = str(initiatingsystem)
        if servicemode is not None:
            headers["ServiceMode"] = str(servicemode)
        if uuidseqno is not None:
            headers["UUIDSeqNo"] = str(uuidseqno)
        if entity is not None:
            headers["entity"] = str(entity)
        if languagecode is not None:
            headers["languageCode"] = str(languagecode)
        if referenceid is not None:
            headers["referenceId"] = str(referenceid)
        if userid is not None:
            headers["userId"] = str(userid)
        
        
        return await make_api_request(
            "GET", 
            path, 
            
            params=params if params else None, 
            headers=headers if headers else None
        )
    
    
    
    @mcp.tool()
    async def amebtauth_rebal_setup_using_put(
        request_body:Dict[str, Any] ,  # authoriseRebalanceSetupResource,
        accesstoken: Optional[str] = None,
        channeltype: Optional[int] = None,
        co_relationid: Optional[int] = None,
        initiatingsystem: Optional[str] = None,
        servicemode: Optional[int] = None,
        uuidseqno: Optional[int] = None,
        entity: Optional[str] = None,
        languagecode: Optional[int] = None,
        referenceid: Optional[str] = None,
        userid: Optional[int] = None
    ) -> Dict[str, Any]:
        """
        Authorise Rebalance Setup
        
        Generated from: PUT /crypto/rebalance/authorise
        Source: swagger_2_0
        Operation ID: AMEBTAuthRebalSetupUsingPUT
        
        
        Authentication: Not required
        
        Parameters:
        - request_body: any (required)
          input
        
        
        
        Headers:
        - Accesstoken: string
          Authorization token for identification of the caller
        - ChannelType: integer
          Channel identifier from where the TXN has originated (Internet, Mobile, ATM, Branch Channel )
        - Co-Relationid: integer
          Unique ID for the service invoked, will be set by the TXN system
        - InitiatingSystem: string
          Indicating the initiated system
        - ServiceMode: integer
          Used for branch channel to indicate the type of customer
        - UUIDSeqNo: integer
          UUID Sequence Number
        - entity: string
          entity
        - languageCode: integer
          languageCode
        - referenceId: string
          Place holder for Token based authentication
        - userId: integer
          userId
        
        
        """
        
        
        # Prepare request data
        
        # Single body parameter - send directly
        data = request_body if request_body is not None else {}
        
        
        
        # Prepare query parameters
        params = {}
        
        
        # Replace path parameters in URL
        path = "/crypto/rebalance/authorise"
        
        
        # Prepare headers
        headers = {}
        if accesstoken is not None:
            headers["Accesstoken"] = str(accesstoken)
        if channeltype is not None:
            headers["ChannelType"] = str(channeltype)
        if co_relationid is not None:
            headers["Co-Relationid"] = str(co_relationid)
        if initiatingsystem is not None:
            headers["InitiatingSystem"] = str(initiatingsystem)
        if servicemode is not None:
            headers["ServiceMode"] = str(servicemode)
        if uuidseqno is not None:
            headers["UUIDSeqNo"] = str(uuidseqno)
        if entity is not None:
            headers["entity"] = str(entity)
        if languagecode is not None:
            headers["languageCode"] = str(languagecode)
        if referenceid is not None:
            headers["referenceId"] = str(referenceid)
        if userid is not None:
            headers["userId"] = str(userid)
        
        
        return await make_api_request(
            "PUT", 
            path, 
            data=data, 
            params=params if params else None, 
            headers=headers if headers else None
        )
    
    
    
    @mcp.tool()
    async def ameetfetch_rebal_setup_list_using_get(
        currency: Optional[str] = None,
        internalaccount: Optional[str] = None,
        pagenum: Optional[int] = None,
        pagesize: Optional[int] = None,
        rebalsetupid: Optional[int] = None,
        status: Optional[int] = None,
        accesstoken: Optional[str] = None,
        channeltype: Optional[int] = None,
        co_relationid: Optional[int] = None,
        initiatingsystem: Optional[str] = None,
        servicemode: Optional[int] = None,
        uuidseqno: Optional[int] = None,
        entity: Optional[str] = None,
        languagecode: Optional[int] = None,
        referenceid: Optional[str] = None,
        userid: Optional[int] = None
    ) -> Dict[str, Any]:
        """
        Fetch Rebalance Setup List
        
        Generated from: GET /crypto/rebalance/list
        Source: swagger_2_0
        Operation ID: AMEETFetchRebalSetupListUsingGET
        
        
        Authentication: Not required
        
        Parameters:
        - currency: string
          Currency of the rebalancing Account. ISO currency codes USD,EUR,INR,ILS(Domain Name: d_CurrCode)
        - internalAccount: string
          Internal Account
        - pageNum: integer
          pageNum
        - pageSize: integer
          pageSize
        - rebalSetupId: integer
          Rebalance Sequence ID
        - status: integer
          Rebalance Status 1-Active,7-OnHold,15-MPndgAuth,64-Deleted (Domain Name: d_Status)
        
        
        
        Headers:
        - Accesstoken: string
          Authorization token for identification of the caller
        - ChannelType: integer
          Channel identifier from where the TXN has originated (Internet, Mobile, ATM, Branch Channel )
        - Co-Relationid: integer
          Unique ID for the service invoked, will be set by the TXN system
        - InitiatingSystem: string
          Indicating the initiated system
        - ServiceMode: integer
          Used for branch channel to indicate the type of customer
        - UUIDSeqNo: integer
          UUID Sequence Number
        - entity: string
          entity
        - languageCode: integer
          languageCode
        - referenceId: string
          Place holder for Token based authentication
        - userId: integer
          userId
        
        
        """
        
        
        # Prepare query parameters
        params = {}
        if currency is not None:
            params["currency"] = currency
            
        if internalaccount is not None:
            params["internalAccount"] = internalaccount
            
        if pagenum is not None:
            params["pageNum"] = pagenum
            
        if pagesize is not None:
            params["pageSize"] = pagesize
            
        if rebalsetupid is not None:
            params["rebalSetupId"] = rebalsetupid
            
        if status is not None:
            params["status"] = status
            
        
        
        # Replace path parameters in URL
        path = "/crypto/rebalance/list"
        
        
        # Prepare headers
        headers = {}
        if accesstoken is not None:
            headers["Accesstoken"] = str(accesstoken)
        if channeltype is not None:
            headers["ChannelType"] = str(channeltype)
        if co_relationid is not None:
            headers["Co-Relationid"] = str(co_relationid)
        if initiatingsystem is not None:
            headers["InitiatingSystem"] = str(initiatingsystem)
        if servicemode is not None:
            headers["ServiceMode"] = str(servicemode)
        if uuidseqno is not None:
            headers["UUIDSeqNo"] = str(uuidseqno)
        if entity is not None:
            headers["entity"] = str(entity)
        if languagecode is not None:
            headers["languageCode"] = str(languagecode)
        if referenceid is not None:
            headers["referenceId"] = str(referenceid)
        if userid is not None:
            headers["userId"] = str(userid)
        
        
        return await make_api_request(
            "GET", 
            path, 
            
            params=params if params else None, 
            headers=headers if headers else None
        )
    
    
    
    @mcp.tool()
    async def amebtdelete_rebal_setup_using_delete(
        rebalsetupid: int,
        currency: Optional[str] = None,
        internalaccount: Optional[str] = None,
        accesstoken: Optional[str] = None,
        channeltype: Optional[int] = None,
        co_relationid: Optional[int] = None,
        initiatingsystem: Optional[str] = None,
        servicemode: Optional[int] = None,
        uuidseqno: Optional[int] = None,
        entity: Optional[str] = None,
        languagecode: Optional[int] = None,
        referenceid: Optional[str] = None,
        userid: Optional[int] = None
    ) -> Dict[str, Any]:
        """
        Delete Rebalance Setup
        
        Generated from: DELETE /crypto/rebalance/{rebalSetupId}
        Source: swagger_2_0
        Operation ID: AMEBTDeleteRebalSetupUsingDELETE
        
        
        Authentication: Not required
        
        Parameters:
        - currency: string
          Currency of the rebalancing Account. ISO currency codes USD,EUR,INR,ILS(Domain Name: d_CurrCode)
        - internalAccount: string
          Internal Account
        - rebalSetupId: integer (required)
          Rebalance Sequence ID
        
        
        
        Headers:
        - Accesstoken: string
          Authorization token for identification of the caller
        - ChannelType: integer
          Channel identifier from where the TXN has originated (Internet, Mobile, ATM, Branch Channel )
        - Co-Relationid: integer
          Unique ID for the service invoked, will be set by the TXN system
        - InitiatingSystem: string
          Indicating the initiated system
        - ServiceMode: integer
          Used for branch channel to indicate the type of customer
        - UUIDSeqNo: integer
          UUID Sequence Number
        - entity: string
          entity
        - languageCode: integer
          languageCode
        - referenceId: string
          Place holder for Token based authentication
        - userId: integer
          userId
        
        
        """
        
        
        # Prepare query parameters
        params = {}
        if currency is not None:
            params["currency"] = currency
            
        if internalaccount is not None:
            params["internalAccount"] = internalaccount
            
        
        
        # Replace path parameters in URL
        path = "/crypto/rebalance/{rebalSetupId}"
        if rebalsetupid is not None:
            path = path.replace("{rebalSetupId}", str(rebalsetupid))
        
        
        # Prepare headers
        headers = {}
        if accesstoken is not None:
            headers["Accesstoken"] = str(accesstoken)
        if channeltype is not None:
            headers["ChannelType"] = str(channeltype)
        if co_relationid is not None:
            headers["Co-Relationid"] = str(co_relationid)
        if initiatingsystem is not None:
            headers["InitiatingSystem"] = str(initiatingsystem)
        if servicemode is not None:
            headers["ServiceMode"] = str(servicemode)
        if uuidseqno is not None:
            headers["UUIDSeqNo"] = str(uuidseqno)
        if entity is not None:
            headers["entity"] = str(entity)
        if languagecode is not None:
            headers["languageCode"] = str(languagecode)
        if referenceid is not None:
            headers["referenceId"] = str(referenceid)
        if userid is not None:
            headers["userId"] = str(userid)
        
        
        return await make_api_request(
            "DELETE", 
            path, 
            
            params=params if params else None, 
            headers=headers if headers else None
        )
    
    
    
    @mcp.tool()
    async def ameetview_rebal_setup_getusing_get(
        rebalsetupid: int,
        currency: Optional[str] = None,
        rebalanceinternalacc: Optional[str] = None,
        accesstoken: Optional[str] = None,
        channeltype: Optional[int] = None,
        co_relationid: Optional[int] = None,
        initiatingsystem: Optional[str] = None,
        servicemode: Optional[int] = None,
        uuidseqno: Optional[int] = None,
        entity: Optional[str] = None,
        languagecode: Optional[int] = None,
        referenceid: Optional[str] = None,
        userid: Optional[int] = None
    ) -> Dict[str, Any]:
        """
        View Internal Account Rebalance Setup
        
        Generated from: GET /crypto/rebalanceInternalAccSetup/{rebalSetupId}
        Source: swagger_2_0
        Operation ID: AMEETViewRebalSetup_GETUsingGET
        
        
        Authentication: Not required
        
        Parameters:
        - currency: string
          currency
        - rebalSetupId: integer (required)
          Rebalance Sequence ID
        - rebalanceInternalAcc: string
          Internal Rebalacing Account
        
        
        
        Headers:
        - Accesstoken: string
          Authorization token for identification of the caller
        - ChannelType: integer
          Channel identifier from where the TXN has originated (Internet, Mobile, ATM, Branch Channel )
        - Co-Relationid: integer
          Unique ID for the service invoked, will be set by the TXN system
        - InitiatingSystem: string
          Indicating the initiated system
        - ServiceMode: integer
          Used for branch channel to indicate the type of customer
        - UUIDSeqNo: integer
          UUID Sequence Number
        - entity: string
          entity
        - languageCode: integer
          languageCode
        - referenceId: string
          Place holder for Token based authentication
        - userId: integer
          userId
        
        
        """
        
        
        # Prepare query parameters
        params = {}
        if currency is not None:
            params["currency"] = currency
            
        if rebalanceinternalacc is not None:
            params["rebalanceInternalAcc"] = rebalanceinternalacc
            
        
        
        # Replace path parameters in URL
        path = "/crypto/rebalanceInternalAccSetup/{rebalSetupId}"
        if rebalsetupid is not None:
            path = path.replace("{rebalSetupId}", str(rebalsetupid))
        
        
        # Prepare headers
        headers = {}
        if accesstoken is not None:
            headers["Accesstoken"] = str(accesstoken)
        if channeltype is not None:
            headers["ChannelType"] = str(channeltype)
        if co_relationid is not None:
            headers["Co-Relationid"] = str(co_relationid)
        if initiatingsystem is not None:
            headers["InitiatingSystem"] = str(initiatingsystem)
        if servicemode is not None:
            headers["ServiceMode"] = str(servicemode)
        if uuidseqno is not None:
            headers["UUIDSeqNo"] = str(uuidseqno)
        if entity is not None:
            headers["entity"] = str(entity)
        if languagecode is not None:
            headers["languageCode"] = str(languagecode)
        if referenceid is not None:
            headers["referenceId"] = str(referenceid)
        if userid is not None:
            headers["userId"] = str(userid)
        
        
        return await make_api_request(
            "GET", 
            path, 
            
            params=params if params else None, 
            headers=headers if headers else None
        )
    
    
    
    @mcp.tool()
    async def amebtcreate_rebal_setup_using_post(
        request_body:Dict[str, Any] ,  # createRebalanceSetupResource,
        accesstoken: Optional[str] = None,
        channeltype: Optional[int] = None,
        co_relationid: Optional[int] = None,
        initiatingsystem: Optional[str] = None,
        servicemode: Optional[int] = None,
        uuidseqno: Optional[int] = None,
        entity: Optional[str] = None,
        languagecode: Optional[int] = None,
        referenceid: Optional[str] = None,
        requesthash: Optional[str] = None,
        userid: Optional[int] = None
    ) -> Dict[str, Any]:
        """
        Create Rebalance Setup
        
        Generated from: POST /crypto/rebalanceSetup
        Source: swagger_2_0
        Operation ID: AMEBTCreateRebalSetupUsingPOST
        
        
        Authentication: Not required
        
        Parameters:
        - request_body: any (required)
          input
        
        
        
        Headers:
        - Accesstoken: string
          Authorization token for identification of the caller
        - ChannelType: integer
          Channel identifier from where the TXN has originated (Internet, Mobile, ATM, Branch Channel )
        - Co-Relationid: integer
          Unique ID for the service invoked, will be set by the TXN system
        - InitiatingSystem: string
          Indicating the initiated system
        - ServiceMode: integer
          Used for branch channel to indicate the type of customer
        - UUIDSeqNo: integer
          UUID Sequence Number
        - entity: string
          entity
        - languageCode: integer
          languageCode
        - referenceId: string
          Place holder for Token based authentication
        - requesthash: string
          Request payload for hash validation
        - userId: integer
          userId
        
        
        """
        
        
        # Prepare request data
        
        # Single body parameter - send directly
        data = request_body if request_body is not None else {}
        
        
        
        # Prepare query parameters
        params = {}
        
        
        # Replace path parameters in URL
        path = "/crypto/rebalanceSetup"
        
        
        # Prepare headers
        headers = {}
        if accesstoken is not None:
            headers["Accesstoken"] = str(accesstoken)
        if channeltype is not None:
            headers["ChannelType"] = str(channeltype)
        if co_relationid is not None:
            headers["Co-Relationid"] = str(co_relationid)
        if initiatingsystem is not None:
            headers["InitiatingSystem"] = str(initiatingsystem)
        if servicemode is not None:
            headers["ServiceMode"] = str(servicemode)
        if uuidseqno is not None:
            headers["UUIDSeqNo"] = str(uuidseqno)
        if entity is not None:
            headers["entity"] = str(entity)
        if languagecode is not None:
            headers["languageCode"] = str(languagecode)
        if referenceid is not None:
            headers["referenceId"] = str(referenceid)
        if requesthash is not None:
            headers["requesthash"] = str(requesthash)
        if userid is not None:
            headers["userId"] = str(userid)
        
        
        return await make_api_request(
            "POST", 
            path, 
            data=data, 
            params=params if params else None, 
            headers=headers if headers else None
        )
    
    
    
    @mcp.tool()
    async def amebtmodify_rebal_setup_using_put(
        request_body:Dict[str, Any] ,  # modifyRebalanceSetupResource,
        accesstoken: Optional[str] = None,
        channeltype: Optional[int] = None,
        co_relationid: Optional[int] = None,
        initiatingsystem: Optional[str] = None,
        servicemode: Optional[int] = None,
        uuidseqno: Optional[int] = None,
        entity: Optional[str] = None,
        languagecode: Optional[int] = None,
        referenceid: Optional[str] = None,
        requesthash: Optional[str] = None,
        userid: Optional[int] = None
    ) -> Dict[str, Any]:
        """
        Modify Rebalance Setup
        
        Generated from: PUT /crypto/rebalanceSetup
        Source: swagger_2_0
        Operation ID: AMEBTModifyRebalSetupUsingPUT
        
        
        Authentication: Not required
        
        Parameters:
        - request_body: any (required)
          input
        
        
        
        Headers:
        - Accesstoken: string
          Authorization token for identification of the caller
        - ChannelType: integer
          Channel identifier from where the TXN has originated (Internet, Mobile, ATM, Branch Channel )
        - Co-Relationid: integer
          Unique ID for the service invoked, will be set by the TXN system
        - InitiatingSystem: string
          Indicating the initiated system
        - ServiceMode: integer
          Used for branch channel to indicate the type of customer
        - UUIDSeqNo: integer
          UUID Sequence Number
        - entity: string
          entity
        - languageCode: integer
          languageCode
        - referenceId: string
          Place holder for Token based authentication
        - requesthash: string
          Request payload for hash validation
        - userId: integer
          userId
        
        
        """
        
        
        # Prepare request data
        
        # Single body parameter - send directly
        data = request_body if request_body is not None else {}
        
        
        
        # Prepare query parameters
        params = {}
        
        
        # Replace path parameters in URL
        path = "/crypto/rebalanceSetup"
        
        
        # Prepare headers
        headers = {}
        if accesstoken is not None:
            headers["Accesstoken"] = str(accesstoken)
        if channeltype is not None:
            headers["ChannelType"] = str(channeltype)
        if co_relationid is not None:
            headers["Co-Relationid"] = str(co_relationid)
        if initiatingsystem is not None:
            headers["InitiatingSystem"] = str(initiatingsystem)
        if servicemode is not None:
            headers["ServiceMode"] = str(servicemode)
        if uuidseqno is not None:
            headers["UUIDSeqNo"] = str(uuidseqno)
        if entity is not None:
            headers["entity"] = str(entity)
        if languagecode is not None:
            headers["languageCode"] = str(languagecode)
        if referenceid is not None:
            headers["referenceId"] = str(referenceid)
        if requesthash is not None:
            headers["requesthash"] = str(requesthash)
        if userid is not None:
            headers["userId"] = str(userid)
        
        
        return await make_api_request(
            "PUT", 
            path, 
            data=data, 
            params=params if params else None, 
            headers=headers if headers else None
        )
    
    
    
    @mcp.tool()
    async def amebtstaking_plac_exit_ack_nack_postusing_post(
        request_body:Dict[str, Any] ,  # cryptoStakingPlacExitAckNackResource,
        accesstoken: Optional[str] = None,
        channeltype: Optional[int] = None,
        co_relationid: Optional[int] = None,
        initiatingsystem: Optional[str] = None,
        servicemode: Optional[int] = None,
        uuidseqno: Optional[int] = None,
        entity: Optional[str] = None,
        languagecode: Optional[int] = None,
        referenceid: Optional[str] = None,
        requesthash: Optional[str] = None,
        userid: Optional[int] = None
    ) -> Dict[str, Any]:
        """
        ACK or NACK of crypto staking orders
        
        Generated from: POST /crypto/stakingOrder/ackOrNack
        Source: swagger_2_0
        Operation ID: AMEBTStakingPlacExitAckNack_POSTUsingPOST
        
        
        Authentication: Not required
        
        Parameters:
        - request_body: any (required)
          input
        
        
        
        Headers:
        - Accesstoken: string
          Authorization token for identification of the caller
        - ChannelType: integer
          Channel identifier from where the TXN has originated (Internet, Mobile, ATM, Branch Channel )
        - Co-Relationid: integer
          Unique ID for the service invoked, will be set by the TXN system
        - InitiatingSystem: string
          Indicating the initiated system
        - ServiceMode: integer
          Used for branch channel to indicate the type of customer
        - UUIDSeqNo: integer
          UUID Sequence Number
        - entity: string
          entity
        - languageCode: integer
          languageCode
        - referenceId: string
          Place holder for Token based authentication
        - requesthash: string
          Request payload for hash validation
        - userId: integer
          userId
        
        
        """
        
        
        # Prepare request data
        
        # Single body parameter - send directly
        data = request_body if request_body is not None else {}
        
        
        
        # Prepare query parameters
        params = {}
        
        
        # Replace path parameters in URL
        path = "/crypto/stakingOrder/ackOrNack"
        
        
        # Prepare headers
        headers = {}
        if accesstoken is not None:
            headers["Accesstoken"] = str(accesstoken)
        if channeltype is not None:
            headers["ChannelType"] = str(channeltype)
        if co_relationid is not None:
            headers["Co-Relationid"] = str(co_relationid)
        if initiatingsystem is not None:
            headers["InitiatingSystem"] = str(initiatingsystem)
        if servicemode is not None:
            headers["ServiceMode"] = str(servicemode)
        if uuidseqno is not None:
            headers["UUIDSeqNo"] = str(uuidseqno)
        if entity is not None:
            headers["entity"] = str(entity)
        if languagecode is not None:
            headers["languageCode"] = str(languagecode)
        if referenceid is not None:
            headers["referenceId"] = str(referenceid)
        if requesthash is not None:
            headers["requesthash"] = str(requesthash)
        if userid is not None:
            headers["userId"] = str(userid)
        
        
        return await make_api_request(
            "POST", 
            path, 
            data=data, 
            params=params if params else None, 
            headers=headers if headers else None
        )
    
    
    
    @mcp.tool()
    async def ameetget_staking_place_exit_list_using_get(
        customerreference: Optional[int] = None,
        externalorderreference: Optional[str] = None,
        orderamount: Optional[float] = None,
        ordercurrency: Optional[str] = None,
        orderdate: Optional[str] = None,
        orderid: Optional[int] = None,
        ordertype: Optional[int] = None,
        pagenum: Optional[int] = None,
        pagesize: Optional[int] = None,
        stakingaccountreference: Optional[str] = None,
        status: Optional[int] = None,
        tradingaccountreference: Optional[str] = None,
        accesstoken: Optional[str] = None,
        channeltype: Optional[int] = None,
        co_relationid: Optional[int] = None,
        initiatingsystem: Optional[str] = None,
        servicemode: Optional[int] = None,
        uuidseqno: Optional[int] = None,
        entity: Optional[str] = None,
        languagecode: Optional[int] = None,
        referenceid: Optional[str] = None,
        userid: Optional[int] = None
    ) -> Dict[str, Any]:
        """
        List of crypto staking order
        
        Generated from: GET /crypto/stakingOrder/list
        Source: swagger_2_0
        Operation ID: AMEETGetStakingPlaceExitListUsingGET
        
        
        Authentication: Not required
        
        Parameters:
        - customerReference: integer
          Customer reference for which staking order is to be initiated
        - externalOrderReference: string
          Reference from the external system
        - orderAmount: number
          Order amount is the staking amount
        - orderCurrency: string
          Order currency is the staking currency (Domain Name: d_CurrCode / 3 character ISO currency code) Eg : MXN, EUR, USD, INR
        - orderDate: string
          Order date is the current application date(Date Format :  yyyyMMdd)
        - orderId: integer
          Order ID is the transaction reference generated for staking order
        - orderType: integer
          Type of staking order 1-Placement,2-Exit Order(Domain Name: d_StakOrderType)
        - pageNum: integer
          pageNum
        - pageSize: integer
          pageSize
        - stakingAccountReference: string
          IBAN number for staking order
        - status: integer
          status of the staking order OnHold-7, Rejected-9, Released-18, Authorized-28, Settled-44(Domain Name: d_Status)
        - tradingAccountReference: string
          IBAN number of the trading account
        
        
        
        Headers:
        - Accesstoken: string
          Authorization token for identification of the caller
        - ChannelType: integer
          Channel identifier from where the TXN has originated (Internet, Mobile, ATM, Branch Channel )
        - Co-Relationid: integer
          Unique ID for the service invoked, will be set by the TXN system
        - InitiatingSystem: string
          Indicating the initiated system
        - ServiceMode: integer
          Used for branch channel to indicate the type of customer
        - UUIDSeqNo: integer
          UUID Sequence Number
        - entity: string
          entity
        - languageCode: integer
          languageCode
        - referenceId: string
          Place holder for Token based authentication
        - userId: integer
          userId
        
        
        """
        
        
        # Prepare query parameters
        params = {}
        if customerreference is not None:
            params["customerReference"] = customerreference
            
        if externalorderreference is not None:
            params["externalOrderReference"] = externalorderreference
            
        if orderamount is not None:
            params["orderAmount"] = orderamount
            
        if ordercurrency is not None:
            params["orderCurrency"] = ordercurrency
            
        if orderdate is not None:
            params["orderDate"] = orderdate
            
        if orderid is not None:
            params["orderId"] = orderid
            
        if ordertype is not None:
            params["orderType"] = ordertype
            
        if pagenum is not None:
            params["pageNum"] = pagenum
            
        if pagesize is not None:
            params["pageSize"] = pagesize
            
        if stakingaccountreference is not None:
            params["stakingAccountReference"] = stakingaccountreference
            
        if status is not None:
            params["status"] = status
            
        if tradingaccountreference is not None:
            params["tradingAccountReference"] = tradingaccountreference
            
        
        
        # Replace path parameters in URL
        path = "/crypto/stakingOrder/list"
        
        
        # Prepare headers
        headers = {}
        if accesstoken is not None:
            headers["Accesstoken"] = str(accesstoken)
        if channeltype is not None:
            headers["ChannelType"] = str(channeltype)
        if co_relationid is not None:
            headers["Co-Relationid"] = str(co_relationid)
        if initiatingsystem is not None:
            headers["InitiatingSystem"] = str(initiatingsystem)
        if servicemode is not None:
            headers["ServiceMode"] = str(servicemode)
        if uuidseqno is not None:
            headers["UUIDSeqNo"] = str(uuidseqno)
        if entity is not None:
            headers["entity"] = str(entity)
        if languagecode is not None:
            headers["languageCode"] = str(languagecode)
        if referenceid is not None:
            headers["referenceId"] = str(referenceid)
        if userid is not None:
            headers["userId"] = str(userid)
        
        
        return await make_api_request(
            "GET", 
            path, 
            
            params=params if params else None, 
            headers=headers if headers else None
        )
    
    
    
    @mcp.tool()
    async def amebtcrypto_staking_maint_api_using_post(
        request_body:Dict[str, Any] ,  # cryptoStakingOrderMaintenanceResource,
        accesstoken: Optional[str] = None,
        channeltype: Optional[int] = None,
        co_relationid: Optional[int] = None,
        initiatingsystem: Optional[str] = None,
        servicemode: Optional[int] = None,
        uuidseqno: Optional[int] = None,
        entity: Optional[str] = None,
        languagecode: Optional[int] = None,
        referenceid: Optional[str] = None,
        requesthash: Optional[str] = None,
        userid: Optional[int] = None
    ) -> Dict[str, Any]:
        """
        Maintenance of crypto staking orders
        
        Generated from: POST /crypto/stakingOrder/maintenance
        Source: swagger_2_0
        Operation ID: AMEBTCryptoStakingMaintApiUsingPOST
        
        
        Authentication: Not required
        
        Parameters:
        - request_body: any (required)
          input
        
        
        
        Headers:
        - Accesstoken: string
          Authorization token for identification of the caller
        - ChannelType: integer
          Channel identifier from where the TXN has originated (Internet, Mobile, ATM, Branch Channel )
        - Co-Relationid: integer
          Unique ID for the service invoked, will be set by the TXN system
        - InitiatingSystem: string
          Indicating the initiated system
        - ServiceMode: integer
          Used for branch channel to indicate the type of customer
        - UUIDSeqNo: integer
          UUID Sequence Number
        - entity: string
          entity
        - languageCode: integer
          languageCode
        - referenceId: string
          Place holder for Token based authentication
        - requesthash: string
          Request payload for hash validation
        - userId: integer
          userId
        
        
        """
        
        
        # Prepare request data
        
        # Single body parameter - send directly
        data = request_body if request_body is not None else {}
        
        
        
        # Prepare query parameters
        params = {}
        
        
        # Replace path parameters in URL
        path = "/crypto/stakingOrder/maintenance"
        
        
        # Prepare headers
        headers = {}
        if accesstoken is not None:
            headers["Accesstoken"] = str(accesstoken)
        if channeltype is not None:
            headers["ChannelType"] = str(channeltype)
        if co_relationid is not None:
            headers["Co-Relationid"] = str(co_relationid)
        if initiatingsystem is not None:
            headers["InitiatingSystem"] = str(initiatingsystem)
        if servicemode is not None:
            headers["ServiceMode"] = str(servicemode)
        if uuidseqno is not None:
            headers["UUIDSeqNo"] = str(uuidseqno)
        if entity is not None:
            headers["entity"] = str(entity)
        if languagecode is not None:
            headers["languageCode"] = str(languagecode)
        if referenceid is not None:
            headers["referenceId"] = str(referenceid)
        if requesthash is not None:
            headers["requesthash"] = str(requesthash)
        if userid is not None:
            headers["userId"] = str(userid)
        
        
        return await make_api_request(
            "POST", 
            path, 
            data=data, 
            params=params if params else None, 
            headers=headers if headers else None
        )
    
    
    
    @mcp.tool()
    async def amebtstaking_plac_exit_modify_api_postusing_put(
        request_body:Dict[str, Any] ,  # cryptoStakingOrderModificationResource,
        accesstoken: Optional[str] = None,
        channeltype: Optional[int] = None,
        co_relationid: Optional[int] = None,
        initiatingsystem: Optional[str] = None,
        servicemode: Optional[int] = None,
        uuidseqno: Optional[int] = None,
        entity: Optional[str] = None,
        languagecode: Optional[int] = None,
        referenceid: Optional[str] = None,
        requesthash: Optional[str] = None,
        userid: Optional[int] = None
    ) -> Dict[str, Any]:
        """
        Modification of Crypto Staking Order
        
        Generated from: PUT /crypto/stakingOrder/update
        Source: swagger_2_0
        Operation ID: AMEBTStakingPlacExitModifyApi_POSTUsingPUT
        
        
        Authentication: Not required
        
        Parameters:
        - request_body: any (required)
          input
        
        
        
        Headers:
        - Accesstoken: string
          Authorization token for identification of the caller
        - ChannelType: integer
          Channel identifier from where the TXN has originated (Internet, Mobile, ATM, Branch Channel )
        - Co-Relationid: integer
          Unique ID for the service invoked, will be set by the TXN system
        - InitiatingSystem: string
          Indicating the initiated system
        - ServiceMode: integer
          Used for branch channel to indicate the type of customer
        - UUIDSeqNo: integer
          UUID Sequence Number
        - entity: string
          entity
        - languageCode: integer
          languageCode
        - referenceId: string
          Place holder for Token based authentication
        - requesthash: string
          Request payload for hash validation
        - userId: integer
          userId
        
        
        """
        
        
        # Prepare request data
        
        # Single body parameter - send directly
        data = request_body if request_body is not None else {}
        
        
        
        # Prepare query parameters
        params = {}
        
        
        # Replace path parameters in URL
        path = "/crypto/stakingOrder/update"
        
        
        # Prepare headers
        headers = {}
        if accesstoken is not None:
            headers["Accesstoken"] = str(accesstoken)
        if channeltype is not None:
            headers["ChannelType"] = str(channeltype)
        if co_relationid is not None:
            headers["Co-Relationid"] = str(co_relationid)
        if initiatingsystem is not None:
            headers["InitiatingSystem"] = str(initiatingsystem)
        if servicemode is not None:
            headers["ServiceMode"] = str(servicemode)
        if uuidseqno is not None:
            headers["UUIDSeqNo"] = str(uuidseqno)
        if entity is not None:
            headers["entity"] = str(entity)
        if languagecode is not None:
            headers["languageCode"] = str(languagecode)
        if referenceid is not None:
            headers["referenceId"] = str(referenceid)
        if requesthash is not None:
            headers["requesthash"] = str(requesthash)
        if userid is not None:
            headers["userId"] = str(userid)
        
        
        return await make_api_request(
            "PUT", 
            path, 
            data=data, 
            params=params if params else None, 
            headers=headers if headers else None
        )
    
    
    
    @mcp.tool()
    async def ameetview_staking_place_exit_using_get(
        orderid: int,
        ordertransactiontype: int,
        accesstoken: Optional[str] = None,
        channeltype: Optional[int] = None,
        co_relationid: Optional[int] = None,
        initiatingsystem: Optional[str] = None,
        servicemode: Optional[int] = None,
        uuidseqno: Optional[int] = None,
        authorization: Optional[str] = None,
        entity: Optional[str] = None,
        languagecode: Optional[int] = None,
        referenceid: Optional[str] = None,
        requesthash: Optional[str] = None,
        userid: Optional[int] = None
    ) -> Dict[str, Any]:
        """
        To view staking order
        
        Generated from: GET /crypto/stakingOrder/view/{orderId}/{orderTransactionType}
        Source: swagger_2_0
        Operation ID: AMEETViewStakingPlaceExitUsingGET
        
        
        Authentication: Not required
        
        Parameters:
        - orderId: integer (required)
          Transaction reference that has been generated for staking order
        - orderTransactionType: integer (required)
          Transaction type for staking order (Placement-1803, Exit-1804, Code Name: d_PosTyp)
        
        
        
        Headers:
        - Accesstoken: string
          Authorization token for identification of the caller
        - ChannelType: integer
          Channel identifier from where the TXN has originated (Internet, Mobile, ATM, Branch Channel )
        - Co-Relationid: integer
          Unique ID for the service invoked, will be set by the TXN system
        - InitiatingSystem: string
          Indicating the initiated system
        - ServiceMode: integer
          Used for branch channel to indicate the type of customer
        - UUIDSeqNo: integer
          UUID Sequence Number
        - authorization: string
          Authorization Token to validation the caller
        - entity: string
          entity
        - languageCode: integer
          languageCode
        - referenceId: string
          Identified reference field for authorization
        - requesthash: string
          Request payload for hash validation
        - userId: integer
          userId
        
        
        """
        
        
        # Prepare query parameters
        params = {}
        
        
        # Replace path parameters in URL
        path = "/crypto/stakingOrder/view/{orderId}/{orderTransactionType}"
        if orderid is not None:
            path = path.replace("{orderId}", str(orderid))
        if ordertransactiontype is not None:
            path = path.replace("{orderTransactionType}", str(ordertransactiontype))
        
        
        # Prepare headers
        headers = {}
        if accesstoken is not None:
            headers["Accesstoken"] = str(accesstoken)
        if channeltype is not None:
            headers["ChannelType"] = str(channeltype)
        if co_relationid is not None:
            headers["Co-Relationid"] = str(co_relationid)
        if initiatingsystem is not None:
            headers["InitiatingSystem"] = str(initiatingsystem)
        if servicemode is not None:
            headers["ServiceMode"] = str(servicemode)
        if uuidseqno is not None:
            headers["UUIDSeqNo"] = str(uuidseqno)
        if authorization is not None:
            headers["authorization"] = str(authorization)
        if entity is not None:
            headers["entity"] = str(entity)
        if languagecode is not None:
            headers["languageCode"] = str(languagecode)
        if referenceid is not None:
            headers["referenceId"] = str(referenceid)
        if requesthash is not None:
            headers["requesthash"] = str(requesthash)
        if userid is not None:
            headers["userId"] = str(userid)
        
        
        return await make_api_request(
            "GET", 
            path, 
            
            params=params if params else None, 
            headers=headers if headers else None
        )
    
    
    
    @mcp.tool()
    async def ameet2022_fetch_stak_rwrd_list_using_get(
        stakingaccountreference: str,
        pagenum: Optional[int] = None,
        pagesize: Optional[int] = None,
        rewardbookedfromdate: Optional[str] = None,
        rewardbookedtodate: Optional[str] = None,
        accesstoken: Optional[str] = None,
        channeltype: Optional[int] = None,
        co_relationid: Optional[int] = None,
        initiatingsystem: Optional[str] = None,
        servicemode: Optional[int] = None,
        uuidseqno: Optional[int] = None,
        entity: Optional[str] = None,
        languagecode: Optional[int] = None,
        referenceid: Optional[str] = None,
        userid: Optional[int] = None
    ) -> Dict[str, Any]:
        """
        Fetch Crypto Staking Rewards List
        
        Generated from: GET /crypto/stakingRewardsList
        Source: swagger_2_0
        Operation ID: AMEET2022FetchStakRwrdListUsingGET
        
        
        Authentication: Not required
        
        Parameters:
        - pageNum: integer
          pageNum
        - pageSize: integer
          pageSize
        - rewardBookedFromDate: string
          Search criteria on Reward Order date(Date Format : yyyyMMdd)
        - rewardBookedToDate: string
          Search criteria on Reward Order date(Date Format : yyyyMMdd)
        - stakingAccountReference: string (required)
          Account Number of the Staking Account
        
        
        
        Headers:
        - Accesstoken: string
          Authorization token for identification of the caller
        - ChannelType: integer
          Channel identifier from where the TXN has originated (Internet, Mobile, ATM, Branch Channel )
        - Co-Relationid: integer
          Unique ID for the service invoked, will be set by the TXN system
        - InitiatingSystem: string
          Indicating the initiated system
        - ServiceMode: integer
          Used for branch channel to indicate the type of customer
        - UUIDSeqNo: integer
          UUID Sequence Number
        - entity: string
          entity
        - languageCode: integer
          languageCode
        - referenceId: string
          Place holder for Token based authentication
        - userId: integer
          userId
        
        
        """
        
        
        # Prepare query parameters
        params = {}
        if pagenum is not None:
            params["pageNum"] = pagenum
            
        if pagesize is not None:
            params["pageSize"] = pagesize
            
        if rewardbookedfromdate is not None:
            params["rewardBookedFromDate"] = rewardbookedfromdate
            
        if rewardbookedtodate is not None:
            params["rewardBookedToDate"] = rewardbookedtodate
            
        if stakingaccountreference is not None:
            params["stakingAccountReference"] = stakingaccountreference
            
        
        
        # Replace path parameters in URL
        path = "/crypto/stakingRewardsList"
        
        
        # Prepare headers
        headers = {}
        if accesstoken is not None:
            headers["Accesstoken"] = str(accesstoken)
        if channeltype is not None:
            headers["ChannelType"] = str(channeltype)
        if co_relationid is not None:
            headers["Co-Relationid"] = str(co_relationid)
        if initiatingsystem is not None:
            headers["InitiatingSystem"] = str(initiatingsystem)
        if servicemode is not None:
            headers["ServiceMode"] = str(servicemode)
        if uuidseqno is not None:
            headers["UUIDSeqNo"] = str(uuidseqno)
        if entity is not None:
            headers["entity"] = str(entity)
        if languagecode is not None:
            headers["languageCode"] = str(languagecode)
        if referenceid is not None:
            headers["referenceId"] = str(referenceid)
        if userid is not None:
            headers["userId"] = str(userid)
        
        
        return await make_api_request(
            "GET", 
            path, 
            
            params=params if params else None, 
            headers=headers if headers else None
        )
    
    
    
    @mcp.tool()
    async def amebt2022_crt_stak_rwrd_order_using_post(
        request_body:Dict[str, Any] ,  # createStakingRewardOrderResource,
        accesstoken: Optional[str] = None,
        channeltype: Optional[int] = None,
        co_relationid: Optional[int] = None,
        initiatingsystem: Optional[str] = None,
        servicemode: Optional[int] = None,
        uuidseqno: Optional[int] = None,
        entity: Optional[str] = None,
        languagecode: Optional[int] = None,
        referenceid: Optional[str] = None,
        requesthash: Optional[str] = None,
        userid: Optional[int] = None
    ) -> Dict[str, Any]:
        """
        Create Staking Reward Order
        
        Generated from: POST /crypto/stakingRewardsOrder
        Source: swagger_2_0
        Operation ID: AMEBT2022CrtStakRwrdOrderUsingPOST
        
        
        Authentication: Not required
        
        Parameters:
        - request_body: any (required)
          input
        
        
        
        Headers:
        - Accesstoken: string
          Authorization token for identification of the caller
        - ChannelType: integer
          Channel identifier from where the TXN has originated (Internet, Mobile, ATM, Branch Channel )
        - Co-Relationid: integer
          Unique ID for the service invoked, will be set by the TXN system
        - InitiatingSystem: string
          Indicating the initiated system
        - ServiceMode: integer
          Used for branch channel to indicate the type of customer
        - UUIDSeqNo: integer
          UUID Sequence Number
        - entity: string
          entity
        - languageCode: integer
          languageCode
        - referenceId: string
          Place holder for Token based authentication
        - requesthash: string
          Request payload for hash validation
        - userId: integer
          userId
        
        
        """
        
        
        # Prepare request data
        
        # Single body parameter - send directly
        data = request_body if request_body is not None else {}
        
        
        
        # Prepare query parameters
        params = {}
        
        
        # Replace path parameters in URL
        path = "/crypto/stakingRewardsOrder"
        
        
        # Prepare headers
        headers = {}
        if accesstoken is not None:
            headers["Accesstoken"] = str(accesstoken)
        if channeltype is not None:
            headers["ChannelType"] = str(channeltype)
        if co_relationid is not None:
            headers["Co-Relationid"] = str(co_relationid)
        if initiatingsystem is not None:
            headers["InitiatingSystem"] = str(initiatingsystem)
        if servicemode is not None:
            headers["ServiceMode"] = str(servicemode)
        if uuidseqno is not None:
            headers["UUIDSeqNo"] = str(uuidseqno)
        if entity is not None:
            headers["entity"] = str(entity)
        if languagecode is not None:
            headers["languageCode"] = str(languagecode)
        if referenceid is not None:
            headers["referenceId"] = str(referenceid)
        if requesthash is not None:
            headers["requesthash"] = str(requesthash)
        if userid is not None:
            headers["userId"] = str(userid)
        
        
        return await make_api_request(
            "POST", 
            path, 
            data=data, 
            params=params if params else None, 
            headers=headers if headers else None
        )
    
    
    
    @mcp.tool()
    async def amebtcrypto_hot_wallet_check_postusing_post(
        request_body:Dict[str, Any] ,  # CryptoHotWalletAckNackCheckRequest,
        accesstoken: Optional[str] = None,
        channeltype: Optional[int] = None,
        co_relationid: Optional[int] = None,
        initiatingsystem: Optional[str] = None,
        servicemode: Optional[int] = None,
        uuidseqno: Optional[int] = None,
        entity: Optional[str] = None,
        languagecode: Optional[int] = None,
        referenceid: Optional[str] = None,
        requesthash: Optional[str] = None,
        userid: Optional[int] = None
    ) -> Dict[str, Any]:
        """
        Crypto Hot Wallet Check
        
        Generated from: POST /crypto/transfers/ackNack
        Source: swagger_2_0
        Operation ID: AMEBTCryptoHotWalletCheck_POSTUsingPOST
        
        
        Authentication: Not required
        
        Parameters:
        - request_body: any (required)
          input
        
        
        
        Headers:
        - Accesstoken: string
          Authorization token for identification of the caller
        - ChannelType: integer
          Channel identifier from where the TXN has originated (Internet, Mobile, ATM, Branch Channel )
        - Co-Relationid: integer
          Unique ID for the service invoked, will be set by the TXN system
        - InitiatingSystem: string
          Indicating the initiated system
        - ServiceMode: integer
          Used for branch channel to indicate the type of customer
        - UUIDSeqNo: integer
          UUID Sequence Number
        - entity: string
          entity
        - languageCode: integer
          languageCode
        - referenceId: string
          Place holder for Token based authentication
        - requesthash: string
          Request payload for hash validation
        - userId: integer
          userId
        
        
        """
        
        
        # Prepare request data
        
        # Single body parameter - send directly
        data = request_body if request_body is not None else {}
        
        
        
        # Prepare query parameters
        params = {}
        
        
        # Replace path parameters in URL
        path = "/crypto/transfers/ackNack"
        
        
        # Prepare headers
        headers = {}
        if accesstoken is not None:
            headers["Accesstoken"] = str(accesstoken)
        if channeltype is not None:
            headers["ChannelType"] = str(channeltype)
        if co_relationid is not None:
            headers["Co-Relationid"] = str(co_relationid)
        if initiatingsystem is not None:
            headers["InitiatingSystem"] = str(initiatingsystem)
        if servicemode is not None:
            headers["ServiceMode"] = str(servicemode)
        if uuidseqno is not None:
            headers["UUIDSeqNo"] = str(uuidseqno)
        if entity is not None:
            headers["entity"] = str(entity)
        if languagecode is not None:
            headers["languageCode"] = str(languagecode)
        if referenceid is not None:
            headers["referenceId"] = str(referenceid)
        if requesthash is not None:
            headers["requesthash"] = str(requesthash)
        if userid is not None:
            headers["userId"] = str(userid)
        
        
        return await make_api_request(
            "POST", 
            path, 
            data=data, 
            params=params if params else None, 
            headers=headers if headers else None
        )
    
    
    
    @mcp.tool()
    async def amebtmdfy_crypto_block_chain_txn_id_postusing_put(
        request_body:Dict[str, Any] ,  # cryptoBlockChainIdRequest,
        accesstoken: Optional[str] = None,
        channeltype: Optional[int] = None,
        co_relationid: Optional[int] = None,
        initiatingsystem: Optional[str] = None,
        servicemode: Optional[int] = None,
        uuidseqno: Optional[int] = None,
        entity: Optional[str] = None,
        languagecode: Optional[int] = None,
        referenceid: Optional[str] = None,
        requesthash: Optional[str] = None,
        userid: Optional[int] = None
    ) -> Dict[str, Any]:
        """
        Update Crypto Block Chain ID
        
        Generated from: PUT /crypto/transfers/cryptoBlockChainID
        Source: swagger_2_0
        Operation ID: AMEBTMdfyCryptoBlockChainTxnId_POSTUsingPUT
        
        
        Authentication: Not required
        
        Parameters:
        - request_body: any (required)
          input
        
        
        
        Headers:
        - Accesstoken: string
          Authorization token for identification of the caller
        - ChannelType: integer
          Channel identifier from where the TXN has originated (Internet, Mobile, ATM, Branch Channel )
        - Co-Relationid: integer
          Unique ID for the service invoked, will be set by the TXN system
        - InitiatingSystem: string
          Indicating the initiated system
        - ServiceMode: integer
          Used for branch channel to indicate the type of customer
        - UUIDSeqNo: integer
          UUID Sequence Number
        - entity: string
          entity
        - languageCode: integer
          languageCode
        - referenceId: string
          Place holder for Token based authentication
        - requesthash: string
          Request payload for hash validation
        - userId: integer
          userId
        
        
        """
        
        
        # Prepare request data
        
        # Single body parameter - send directly
        data = request_body if request_body is not None else {}
        
        
        
        # Prepare query parameters
        params = {}
        
        
        # Replace path parameters in URL
        path = "/crypto/transfers/cryptoBlockChainID"
        
        
        # Prepare headers
        headers = {}
        if accesstoken is not None:
            headers["Accesstoken"] = str(accesstoken)
        if channeltype is not None:
            headers["ChannelType"] = str(channeltype)
        if co_relationid is not None:
            headers["Co-Relationid"] = str(co_relationid)
        if initiatingsystem is not None:
            headers["InitiatingSystem"] = str(initiatingsystem)
        if servicemode is not None:
            headers["ServiceMode"] = str(servicemode)
        if uuidseqno is not None:
            headers["UUIDSeqNo"] = str(uuidseqno)
        if entity is not None:
            headers["entity"] = str(entity)
        if languagecode is not None:
            headers["languageCode"] = str(languagecode)
        if referenceid is not None:
            headers["referenceId"] = str(referenceid)
        if requesthash is not None:
            headers["requesthash"] = str(requesthash)
        if userid is not None:
            headers["userId"] = str(userid)
        
        
        return await make_api_request(
            "PUT", 
            path, 
            data=data, 
            params=params if params else None, 
            headers=headers if headers else None
        )
    
    
    
    @mcp.tool()
    async def ameet1612_fetch_ameleg_txn_list_using_get(
        transactionid: str,
        accesstoken: Optional[str] = None,
        channeltype: Optional[int] = None,
        co_relationid: Optional[int] = None,
        initiatingsystem: Optional[str] = None,
        servicemode: Optional[int] = None,
        uuidseqno: Optional[int] = None,
        entity: Optional[str] = None,
        languagecode: Optional[int] = None,
        referenceid: Optional[str] = None,
        userid: Optional[int] = None
    ) -> Dict[str, Any]:
        """
        View Crypto Transaction Record
        
        Generated from: GET /crypto/transfers/transactionDetails/{transactionId}
        Source: swagger_2_0
        Operation ID: AMEET1612FetchAMELegTxnListUsingGET
        
        
        Authentication: Not required
        
        Parameters:
        - transactionId: string (required)
          Unique Transaction ID generated by Bancs
        
        
        
        Headers:
        - Accesstoken: string
          Authorization token for identification of the caller
        - ChannelType: integer
          Channel identifier from where the TXN has originated (Internet, Mobile, ATM, Branch Channel )
        - Co-Relationid: integer
          Unique ID for the service invoked, will be set by the TXN system
        - InitiatingSystem: string
          Indicating the initiated system
        - ServiceMode: integer
          Used for branch channel to indicate the type of customer
        - UUIDSeqNo: integer
          UUID Sequence Number
        - entity: string
          entity
        - languageCode: integer
          languageCode
        - referenceId: string
          Place holder for Token based authentication
        - userId: integer
          userId
        
        
        """
        
        
        # Prepare query parameters
        params = {}
        
        
        # Replace path parameters in URL
        path = "/crypto/transfers/transactionDetails/{transactionId}"
        if transactionid is not None:
            path = path.replace("{transactionId}", str(transactionid))
        
        
        # Prepare headers
        headers = {}
        if accesstoken is not None:
            headers["Accesstoken"] = str(accesstoken)
        if channeltype is not None:
            headers["ChannelType"] = str(channeltype)
        if co_relationid is not None:
            headers["Co-Relationid"] = str(co_relationid)
        if initiatingsystem is not None:
            headers["InitiatingSystem"] = str(initiatingsystem)
        if servicemode is not None:
            headers["ServiceMode"] = str(servicemode)
        if uuidseqno is not None:
            headers["UUIDSeqNo"] = str(uuidseqno)
        if entity is not None:
            headers["entity"] = str(entity)
        if languagecode is not None:
            headers["languageCode"] = str(languagecode)
        if referenceid is not None:
            headers["referenceId"] = str(referenceid)
        if userid is not None:
            headers["userId"] = str(userid)
        
        
        return await make_api_request(
            "GET", 
            path, 
            
            params=params if params else None, 
            headers=headers if headers else None
        )
    
    
    
    @mcp.tool()
    async def ameet1612_fetch_ametxn_list_postusing_get(
        chargeitemtype: Optional[int] = None,
        blockchaintxnid: Optional[str] = None,
        creditaccount: Optional[str] = None,
        customerreference: Optional[int] = None,
        debitaccount: Optional[str] = None,
        externalreference: Optional[str] = None,
        highpriorityflag: Optional[int] = None,
        processingtype: Optional[int] = None,
        rebalancetype: Optional[int] = None,
        transactionamount: Optional[str] = None,
        transactionfromdate: Optional[str] = None,
        transactionreference: Optional[int] = None,
        transactionstatus: Optional[int] = None,
        transactiontodate: Optional[str] = None,
        transactiontype: Optional[int] = None,
        accesstoken: Optional[str] = None,
        channeltype: Optional[int] = None,
        co_relationid: Optional[int] = None,
        initiatingsystem: Optional[str] = None,
        servicemode: Optional[int] = None,
        uuidseqno: Optional[int] = None,
        entity: Optional[str] = None,
        languagecode: Optional[int] = None,
        referenceid: Optional[str] = None,
        userid: Optional[int] = None
    ) -> Dict[str, Any]:
        """
        Fetch Crypto Transaction List
        
        Generated from: GET /crypto/transfers/transactionList
        Source: swagger_2_0
        Operation ID: AMEET1612FetchAMETxnList_POSTUsingGET
        
        
        Authentication: Not required
        
        Parameters:
        - ChargeItemType: integer
          chargeItemType 5116-CryptoStakingRewardsFee,5117-PaymentGatewayMerchantFee,5118-PaymentGatewayEndCustomerFee, 8503-VaultWithdrawalFee, 8504-VaultRoleFee, 8505-VaultStorageAddressFee, 8506-SpecialCustodyFee
        - blockChainTxnId: string
          Block Chain Transaction Reference
        - creditAccount: string
          This field describes the  credit account reference
        - customerReference: integer
          This field describes the customer reference
        - debitAccount: string
          This field describes the  debit account reference
        - externalReference: string
          This field describes the external reference
        - highPriorityFlag: integer
          High Priority Flag(1-Yes,2-No d_YesNoFlg)
        - processingType: integer
          processing Type 1-Auto,2-Manual,3-Both (Domain Name : d_ProcessingType)
        - rebalanceType: integer
          Rebalance Type 1-OnBaltoOffBal,2-OffBaltoOnBal (Domain Name : d_RebalancingType)
        - transactionAmount: string
          Transaction Amount
        - transactionFromDate: string
          Transaction From Date(Date Format: yyyyMMdd)
        - transactionReference: integer
          Unique reference generated in BaNCS
        - transactionStatus: integer
          Transaction Status AuthAwaited-22,Executed-23,Blocked-24,Authorized-3,Awaiting Authorization-1514,Rejected-4,Released-7,Execution Awaited-721,Pending Execution-1702,onHold-8(Domain Name:d_PmntOrdStat)
        - transactionToDate: string
          Transaction To Date(Date Format: yyyyMMdd)
        - transactionType: integer
          Transaction Type Fee-1094,Withdrawl -1095,Deposit -1096,MerchantDeposit -1089,MerchantWithdrawal -1088,RebalancingTransfer -1090(Domain Name:d_AMETxnType)
        
        
        
        Headers:
        - Accesstoken: string
          Authorization token for identification of the caller
        - ChannelType: integer
          Channel identifier from where the TXN has originated (Internet, Mobile, ATM, Branch Channel )
        - Co-Relationid: integer
          Unique ID for the service invoked, will be set by the TXN system
        - InitiatingSystem: string
          Indicating the initiated system
        - ServiceMode: integer
          Used for branch channel to indicate the type of customer
        - UUIDSeqNo: integer
          UUID Sequence Number
        - entity: string
          entity
        - languageCode: integer
          languageCode
        - referenceId: string
          Place holder for Token based authentication
        - userId: integer
          userId
        
        
        """
        
        
        # Prepare query parameters
        params = {}
        if chargeitemtype is not None:
            params["ChargeItemType"] = chargeitemtype
            
        if blockchaintxnid is not None:
            params["blockChainTxnId"] = blockchaintxnid
            
        if creditaccount is not None:
            params["creditAccount"] = creditaccount
            
        if customerreference is not None:
            params["customerReference"] = customerreference
            
        if debitaccount is not None:
            params["debitAccount"] = debitaccount
            
        if externalreference is not None:
            params["externalReference"] = externalreference
            
        if highpriorityflag is not None:
            params["highPriorityFlag"] = highpriorityflag
            
        if processingtype is not None:
            params["processingType"] = processingtype
            
        if rebalancetype is not None:
            params["rebalanceType"] = rebalancetype
            
        if transactionamount is not None:
            params["transactionAmount"] = transactionamount
            
        if transactionfromdate is not None:
            params["transactionFromDate"] = transactionfromdate
            
        if transactionreference is not None:
            params["transactionReference"] = transactionreference
            
        if transactionstatus is not None:
            params["transactionStatus"] = transactionstatus
            
        if transactiontodate is not None:
            params["transactionToDate"] = transactiontodate
            
        if transactiontype is not None:
            params["transactionType"] = transactiontype
            
        
        
        # Replace path parameters in URL
        path = "/crypto/transfers/transactionList"
        
        
        # Prepare headers
        headers = {}
        if accesstoken is not None:
            headers["Accesstoken"] = str(accesstoken)
        if channeltype is not None:
            headers["ChannelType"] = str(channeltype)
        if co_relationid is not None:
            headers["Co-Relationid"] = str(co_relationid)
        if initiatingsystem is not None:
            headers["InitiatingSystem"] = str(initiatingsystem)
        if servicemode is not None:
            headers["ServiceMode"] = str(servicemode)
        if uuidseqno is not None:
            headers["UUIDSeqNo"] = str(uuidseqno)
        if entity is not None:
            headers["entity"] = str(entity)
        if languagecode is not None:
            headers["languageCode"] = str(languagecode)
        if referenceid is not None:
            headers["referenceId"] = str(referenceid)
        if userid is not None:
            headers["userId"] = str(userid)
        
        
        return await make_api_request(
            "GET", 
            path, 
            
            params=params if params else None, 
            headers=headers if headers else None
        )
    
    
    
    @mcp.tool()
    async def amebt2020_wallet_transfer_postusing_post(
        request_body:Dict[str, Any] ,  # walletTransferResource,
        accesstoken: Optional[str] = None,
        channeltype: Optional[int] = None,
        co_relationid: Optional[int] = None,
        initiatingsystem: Optional[str] = None,
        servicemode: Optional[int] = None,
        uuidseqno: Optional[str] = None,
        entity: Optional[str] = None,
        languagecode: Optional[int] = None,
        referenceid: Optional[str] = None,
        requesthash: Optional[str] = None,
        userid: Optional[int] = None
    ) -> Dict[str, Any]:
        """
        Wallet Transfer for A2A P2P C2C FEE CWDL CDEP CMDEP CMWDL OnBaltoOffBal OffBaltoOnBal CVDEP CVWDL CINTRNR CXFUND CXWDL CX2X
        
        Generated from: POST /crypto/transfers/walletTransfer
        Source: swagger_2_0
        Operation ID: AMEBT2020WalletTransfer_POSTUsingPOST
        
        
        Authentication: Not required
        
        Parameters:
        - request_body: any (required)
          input
        
        
        
        Headers:
        - Accesstoken: string
          Authorization token for identification of the caller
        - ChannelType: integer
          Channel identifier from where the TXN has originated (Internet, Mobile, ATM, Branch Channel )
        - Co-Relationid: integer
          Unique ID for the service invoked, will be set by the TXN system
        - InitiatingSystem: string
          Indicating the initiated system
        - ServiceMode: integer
          Used for branch channel to indicate the type of customer
        - UUIDSeqNo: string
          UUID Sequence Number
        - entity: string
          entity
        - languageCode: integer
          languageCode
        - referenceId: string
          Place holder for Token based authentication
        - requesthash: string
          Request payload for hash validation
        - userId: integer
          userId
        
        
        """
        
        
        # Prepare request data
        
        # Single body parameter - send directly
        data = request_body if request_body is not None else {}
        
        
        
        # Prepare query parameters
        params = {}
        
        
        # Replace path parameters in URL
        path = "/crypto/transfers/walletTransfer"
        
        
        # Prepare headers
        headers = {}
        if accesstoken is not None:
            headers["Accesstoken"] = str(accesstoken)
        if channeltype is not None:
            headers["ChannelType"] = str(channeltype)
        if co_relationid is not None:
            headers["Co-Relationid"] = str(co_relationid)
        if initiatingsystem is not None:
            headers["InitiatingSystem"] = str(initiatingsystem)
        if servicemode is not None:
            headers["ServiceMode"] = str(servicemode)
        if uuidseqno is not None:
            headers["UUIDSeqNo"] = str(uuidseqno)
        if entity is not None:
            headers["entity"] = str(entity)
        if languagecode is not None:
            headers["languageCode"] = str(languagecode)
        if referenceid is not None:
            headers["referenceId"] = str(referenceid)
        if requesthash is not None:
            headers["requesthash"] = str(requesthash)
        if userid is not None:
            headers["userId"] = str(userid)
        
        
        return await make_api_request(
            "POST", 
            path, 
            data=data, 
            params=params if params else None, 
            headers=headers if headers else None
        )
    
    
    
    @mcp.tool()
    async def amebt2020_wallet_rev_auth_postusing_post(
        request_body:Dict[str, Any] ,  # WalletReversalAuthResource,
        accesstoken: Optional[str] = None,
        channeltype: Optional[int] = None,
        co_relationid: Optional[int] = None,
        initiatingsystem: Optional[str] = None,
        servicemode: Optional[int] = None,
        uuidseqno: Optional[int] = None,
        entity: Optional[str] = None,
        languagecode: Optional[int] = None,
        referenceid: Optional[str] = None,
        requesthash: Optional[str] = None,
        userid: Optional[int] = None
    ) -> Dict[str, Any]:
        """
        Wallet Reversal Authorize
        
        Generated from: POST /crypto/walletReversal/auth
        Source: swagger_2_0
        Operation ID: AMEBT2020WalletRevAuth_POSTUsingPOST
        
        
        Authentication: Not required
        
        Parameters:
        - request_body: any (required)
          input
        
        
        
        Headers:
        - Accesstoken: string
          Authorization token for identification of the caller
        - ChannelType: integer
          Channel identifier from where the TXN has originated (Internet, Mobile, ATM, Branch Channel )
        - Co-Relationid: integer
          Unique ID for the service invoked, will be set by the TXN system
        - InitiatingSystem: string
          Indicating the initiated system
        - ServiceMode: integer
          Used for branch channel to indicate the type of customer
        - UUIDSeqNo: integer
          UUID Sequence Number
        - entity: string
          entity
        - languageCode: integer
          languageCode
        - referenceId: string
          Place holder for Token based authentication
        - requesthash: string
          Request payload for hash validation
        - userId: integer
          userId
        
        
        """
        
        
        # Prepare request data
        
        # Single body parameter - send directly
        data = request_body if request_body is not None else {}
        
        
        
        # Prepare query parameters
        params = {}
        
        
        # Replace path parameters in URL
        path = "/crypto/walletReversal/auth"
        
        
        # Prepare headers
        headers = {}
        if accesstoken is not None:
            headers["Accesstoken"] = str(accesstoken)
        if channeltype is not None:
            headers["ChannelType"] = str(channeltype)
        if co_relationid is not None:
            headers["Co-Relationid"] = str(co_relationid)
        if initiatingsystem is not None:
            headers["InitiatingSystem"] = str(initiatingsystem)
        if servicemode is not None:
            headers["ServiceMode"] = str(servicemode)
        if uuidseqno is not None:
            headers["UUIDSeqNo"] = str(uuidseqno)
        if entity is not None:
            headers["entity"] = str(entity)
        if languagecode is not None:
            headers["languageCode"] = str(languagecode)
        if referenceid is not None:
            headers["referenceId"] = str(referenceid)
        if requesthash is not None:
            headers["requesthash"] = str(requesthash)
        if userid is not None:
            headers["userId"] = str(userid)
        
        
        return await make_api_request(
            "POST", 
            path, 
            data=data, 
            params=params if params else None, 
            headers=headers if headers else None
        )
    
    
    
    @mcp.tool()
    async def amebt2020_wallet_rev_int_postusing_post(
        request_body:Dict[str, Any] ,  # WalletReversalInitResource,
        accesstoken: Optional[str] = None,
        channeltype: Optional[int] = None,
        co_relationid: Optional[int] = None,
        initiatingsystem: Optional[str] = None,
        servicemode: Optional[int] = None,
        uuidseqno: Optional[int] = None,
        entity: Optional[str] = None,
        languagecode: Optional[int] = None,
        referenceid: Optional[str] = None,
        requesthash: Optional[str] = None,
        userid: Optional[int] = None
    ) -> Dict[str, Any]:
        """
        Wallet Reversal Initiate
        
        Generated from: POST /crypto/walletReversal/init
        Source: swagger_2_0
        Operation ID: AMEBT2020WalletRevInt_POSTUsingPOST
        
        
        Authentication: Not required
        
        Parameters:
        - request_body: any (required)
          input
        
        
        
        Headers:
        - Accesstoken: string
          Authorization token for identification of the caller
        - ChannelType: integer
          Channel identifier from where the TXN has originated (Internet, Mobile, ATM, Branch Channel )
        - Co-Relationid: integer
          Unique ID for the service invoked, will be set by the TXN system
        - InitiatingSystem: string
          Indicating the initiated system
        - ServiceMode: integer
          Used for branch channel to indicate the type of customer
        - UUIDSeqNo: integer
          UUID Sequence Number
        - entity: string
          entity
        - languageCode: integer
          languageCode
        - referenceId: string
          Place holder for Token based authentication
        - requesthash: string
          Request payload for hash validation
        - userId: integer
          userId
        
        
        """
        
        
        # Prepare request data
        
        # Single body parameter - send directly
        data = request_body if request_body is not None else {}
        
        
        
        # Prepare query parameters
        params = {}
        
        
        # Replace path parameters in URL
        path = "/crypto/walletReversal/init"
        
        
        # Prepare headers
        headers = {}
        if accesstoken is not None:
            headers["Accesstoken"] = str(accesstoken)
        if channeltype is not None:
            headers["ChannelType"] = str(channeltype)
        if co_relationid is not None:
            headers["Co-Relationid"] = str(co_relationid)
        if initiatingsystem is not None:
            headers["InitiatingSystem"] = str(initiatingsystem)
        if servicemode is not None:
            headers["ServiceMode"] = str(servicemode)
        if uuidseqno is not None:
            headers["UUIDSeqNo"] = str(uuidseqno)
        if entity is not None:
            headers["entity"] = str(entity)
        if languagecode is not None:
            headers["languageCode"] = str(languagecode)
        if referenceid is not None:
            headers["referenceId"] = str(referenceid)
        if requesthash is not None:
            headers["requesthash"] = str(requesthash)
        if userid is not None:
            headers["userId"] = str(userid)
        
        
        return await make_api_request(
            "POST", 
            path, 
            data=data, 
            params=params if params else None, 
            headers=headers if headers else None
        )
    
    
    
    @mcp.tool()
    async def bret0305_ftch_adrs_cptre_mstr_postusing_post(
        pincode: str,
        channeltype: Optional[int] = None,
        co_relationid: Optional[int] = None,
        initiatingsystem: Optional[str] = None,
        servicemode: Optional[int] = None,
        uuidseqno: Optional[int] = None,
        entity: Optional[str] = None,
        languagecode: Optional[int] = None,
        userid: Optional[int] = None
    ) -> Dict[str, Any]:
        """
        This service fetches address details
        
        Generated from: POST /customerManagement/address/autopopulate
        Source: swagger_2_0
        Operation ID: BRET0305FtchAdrsCptreMstr_POSTUsingPOST
        
        
        Authentication: Not required
        
        Parameters:
        - pincode: string (required)
          Pin Code
        
        
        
        Headers:
        - ChannelType: integer
          Channel identifier from where the TXN has originated (Internet, Mobile, ATM, Branch Channel )
        - Co-Relationid: integer
          Unique ID for the service invoked, will be set by the TXN system
        - InitiatingSystem: string
          Indicating the initiated system
        - ServiceMode: integer
          Used for branch channel to indicate the type of customer
        - UUIDSeqNo: integer
          UUID Sequence Number
        - entity: string
          entity
        - languageCode: integer
          languageCode
        - userId: integer
          userId
        
        
        """
        
        
        # Prepare query parameters
        params = {}
        if pincode is not None:
            params["pincode"] = pincode
            
        
        
        # Replace path parameters in URL
        path = "/customerManagement/address/autopopulate"
        
        
        # Prepare headers
        headers = {}
        if channeltype is not None:
            headers["ChannelType"] = str(channeltype)
        if co_relationid is not None:
            headers["Co-Relationid"] = str(co_relationid)
        if initiatingsystem is not None:
            headers["InitiatingSystem"] = str(initiatingsystem)
        if servicemode is not None:
            headers["ServiceMode"] = str(servicemode)
        if uuidseqno is not None:
            headers["UUIDSeqNo"] = str(uuidseqno)
        if entity is not None:
            headers["entity"] = str(entity)
        if languagecode is not None:
            headers["languageCode"] = str(languagecode)
        if userid is not None:
            headers["userId"] = str(userid)
        
        
        return await make_api_request(
            "POST", 
            path, 
            
            params=params if params else None, 
            headers=headers if headers else None
        )
    
    
    
    @mcp.tool()
    async def bret0507_gt_doc_purpse_postusing_post(
        addressproof: int,
        documentlevel: int,
        channeltype: Optional[int] = None,
        co_relationid: Optional[int] = None,
        initiatingsystem: Optional[str] = None,
        servicemode: Optional[int] = None,
        uuidseqno: Optional[int] = None,
        entity: Optional[str] = None,
        languagecode: Optional[int] = None,
        userid: Optional[int] = None
    ) -> Dict[str, Any]:
        """
        The service is used to autopopulate ID purpose
        
        Generated from: POST /customerManagement/autopopulate
        Source: swagger_2_0
        Operation ID: BRET0507GtDocPurpse_POSTUsingPOST
        
        
        Authentication: Not required
        
        Parameters:
        - addressProof: integer (required)
          Address Proof
        - documentLevel: integer (required)
          Document Level
        
        
        
        Headers:
        - ChannelType: integer
          Channel identifier from where the TXN has originated (Internet, Mobile, ATM, Branch Channel )
        - Co-Relationid: integer
          Unique ID for the service invoked, will be set by the TXN system
        - InitiatingSystem: string
          Indicating the initiated system
        - ServiceMode: integer
          Used for branch channel to indicate the type of customer
        - UUIDSeqNo: integer
          UUID Sequence Number
        - entity: string
          entity
        - languageCode: integer
          languageCode
        - userId: integer
          userId
        
        
        """
        
        
        # Prepare query parameters
        params = {}
        if addressproof is not None:
            params["addressProof"] = addressproof
            
        if documentlevel is not None:
            params["documentLevel"] = documentlevel
            
        
        
        # Replace path parameters in URL
        path = "/customerManagement/autopopulate"
        
        
        # Prepare headers
        headers = {}
        if channeltype is not None:
            headers["ChannelType"] = str(channeltype)
        if co_relationid is not None:
            headers["Co-Relationid"] = str(co_relationid)
        if initiatingsystem is not None:
            headers["InitiatingSystem"] = str(initiatingsystem)
        if servicemode is not None:
            headers["ServiceMode"] = str(servicemode)
        if uuidseqno is not None:
            headers["UUIDSeqNo"] = str(uuidseqno)
        if entity is not None:
            headers["entity"] = str(entity)
        if languagecode is not None:
            headers["languageCode"] = str(languagecode)
        if userid is not None:
            headers["userId"] = str(userid)
        
        
        return await make_api_request(
            "POST", 
            path, 
            
            params=params if params else None, 
            headers=headers if headers else None
        )
    
    
    
    @mcp.tool()
    async def brbt0101_bp_info_modify_postusing_post(
        request_body:Dict[str, Any] ,  # BpInfoModifyResource,
        accesstoken: Optional[str] = None,
        channeltype: Optional[int] = None,
        co_relationid: Optional[int] = None,
        initiatingsystem: Optional[str] = None,
        servicemode: Optional[int] = None,
        uuidseqno: Optional[int] = None,
        entity: Optional[str] = None,
        languagecode: Optional[int] = None,
        referenceid: Optional[str] = None,
        requesthash: Optional[str] = None,
        userid: Optional[int] = None
    ) -> Dict[str, Any]:
        """
        Business Partner Information Modify
        
        Generated from: POST /customerManagement/businessPartnerInfoModify
        Source: swagger_2_0
        Operation ID: BRBT0101BpInfoModify_POSTUsingPOST
        
        
        Authentication: Not required
        
        Parameters:
        - request_body: any (required)
          input
        
        
        
        Headers:
        - Accesstoken: string
          Authorization token for identification of the caller
        - ChannelType: integer
          Channel identifier from where the TXN has originated (Internet, Mobile, ATM, Branch Channel )
        - Co-Relationid: integer
          Unique ID for the service invoked, will be set by the TXN system
        - InitiatingSystem: string
          Indicating the initiated system
        - ServiceMode: integer
          Used for branch channel to indicate the type of customer
        - UUIDSeqNo: integer
          UUID Sequence Number
        - entity: string
          entity
        - languageCode: integer
          languageCode
        - referenceId: string
          Place holder for Token based authentication
        - requesthash: string
          Request payload for hash validation
        - userId: integer
          userId
        
        
        """
        
        
        # Prepare request data
        
        # Single body parameter - send directly
        data = request_body if request_body is not None else {}
        
        
        
        # Prepare query parameters
        params = {}
        
        
        # Replace path parameters in URL
        path = "/customerManagement/businessPartnerInfoModify"
        
        
        # Prepare headers
        headers = {}
        if accesstoken is not None:
            headers["Accesstoken"] = str(accesstoken)
        if channeltype is not None:
            headers["ChannelType"] = str(channeltype)
        if co_relationid is not None:
            headers["Co-Relationid"] = str(co_relationid)
        if initiatingsystem is not None:
            headers["InitiatingSystem"] = str(initiatingsystem)
        if servicemode is not None:
            headers["ServiceMode"] = str(servicemode)
        if uuidseqno is not None:
            headers["UUIDSeqNo"] = str(uuidseqno)
        if entity is not None:
            headers["entity"] = str(entity)
        if languagecode is not None:
            headers["languageCode"] = str(languagecode)
        if referenceid is not None:
            headers["referenceId"] = str(referenceid)
        if requesthash is not None:
            headers["requesthash"] = str(requesthash)
        if userid is not None:
            headers["userId"] = str(userid)
        
        
        return await make_api_request(
            "POST", 
            path, 
            data=data, 
            params=params if params else None, 
            headers=headers if headers else None
        )
    
    
    
    @mcp.tool()
    async def crbt1406_create_customer_npa_postusing_post(
        request_body:Dict[str, Any] ,  # createCustNPARequest,
        accesstoken: Optional[str] = None,
        channeltype: Optional[int] = None,
        co_relationid: Optional[int] = None,
        initiatingsystem: Optional[str] = None,
        servicemode: Optional[int] = None,
        uuidseqno: Optional[int] = None,
        entity: Optional[str] = None,
        languagecode: Optional[int] = None,
        referenceid: Optional[str] = None,
        requesthash: Optional[str] = None,
        userid: Optional[int] = None
    ) -> Dict[str, Any]:
        """
        Create Customer NPA
        
        Generated from: POST /customerManagement/createCustomerNPA
        Source: swagger_2_0
        Operation ID: CRBT1406CreateCustomerNPA_POSTUsingPOST
        
        
        Authentication: Not required
        
        Parameters:
        - request_body: any (required)
          input
        
        
        
        Headers:
        - Accesstoken: string
          Authorization token for identification of the caller
        - ChannelType: integer
          Channel identifier from where the TXN has originated (Internet, Mobile, ATM, Branch Channel )
        - Co-Relationid: integer
          Unique ID for the service invoked, will be set by the TXN system
        - InitiatingSystem: string
          Indicating the initiated system
        - ServiceMode: integer
          Used for branch channel to indicate the type of customer
        - UUIDSeqNo: integer
          UUID Sequence Number
        - entity: string
          entity
        - languageCode: integer
          languageCode
        - referenceId: string
          Place holder for Token based authentication
        - requesthash: string
          Request payload for hash validation
        - userId: integer
          userId
        
        
        """
        
        
        # Prepare request data
        
        # Single body parameter - send directly
        data = request_body if request_body is not None else {}
        
        
        
        # Prepare query parameters
        params = {}
        
        
        # Replace path parameters in URL
        path = "/customerManagement/createCustomerNPA"
        
        
        # Prepare headers
        headers = {}
        if accesstoken is not None:
            headers["Accesstoken"] = str(accesstoken)
        if channeltype is not None:
            headers["ChannelType"] = str(channeltype)
        if co_relationid is not None:
            headers["Co-Relationid"] = str(co_relationid)
        if initiatingsystem is not None:
            headers["InitiatingSystem"] = str(initiatingsystem)
        if servicemode is not None:
            headers["ServiceMode"] = str(servicemode)
        if uuidseqno is not None:
            headers["UUIDSeqNo"] = str(uuidseqno)
        if entity is not None:
            headers["entity"] = str(entity)
        if languagecode is not None:
            headers["languageCode"] = str(languagecode)
        if referenceid is not None:
            headers["referenceId"] = str(referenceid)
        if requesthash is not None:
            headers["requesthash"] = str(requesthash)
        if userid is not None:
            headers["userId"] = str(userid)
        
        
        return await make_api_request(
            "POST", 
            path, 
            data=data, 
            params=params if params else None, 
            headers=headers if headers else None
        )
    
    
    
    @mcp.tool()
    async def brbt2021_create_doc_upload_postusing_post(
        request_body:Dict[str, Any] ,  # DOCUMENT_UPLOAD_BRBT2021CreateDocUpload_Resource,
        channeltype: Optional[int] = None,
        co_relationid: Optional[int] = None,
        initiatingsystem: Optional[str] = None,
        servicemode: Optional[int] = None,
        uuidseqno: Optional[int] = None,
        entity: Optional[str] = None,
        languagecode: Optional[int] = None,
        userid: Optional[int] = None
    ) -> Dict[str, Any]:
        """
        This API is used to upload document
        
        Generated from: POST /customerManagement/createDocumentUpload
        Source: swagger_2_0
        Operation ID: BRBT2021CreateDocUpload_POSTUsingPOST
        
        
        Authentication: Not required
        
        Parameters:
        - request_body: any (required)
          input
        
        
        
        Headers:
        - ChannelType: integer
          Channel identifier from where the TXN has originated (Internet, Mobile, ATM, Branch Channel )
        - Co-Relationid: integer
          Unique ID for the service invoked, will be set by the TXN system
        - InitiatingSystem: string
          Indicating the initiated system
        - ServiceMode: integer
          Used for branch channel to indicate the type of customer
        - UUIDSeqNo: integer
          UUID Sequence Number
        - entity: string
          entity
        - languageCode: integer
          languageCode
        - userId: integer
          userId
        
        
        """
        
        
        # Prepare request data
        
        # Single body parameter - send directly
        data = request_body if request_body is not None else {}
        
        
        
        # Prepare query parameters
        params = {}
        
        
        # Replace path parameters in URL
        path = "/customerManagement/createDocumentUpload"
        
        
        # Prepare headers
        headers = {}
        if channeltype is not None:
            headers["ChannelType"] = str(channeltype)
        if co_relationid is not None:
            headers["Co-Relationid"] = str(co_relationid)
        if initiatingsystem is not None:
            headers["InitiatingSystem"] = str(initiatingsystem)
        if servicemode is not None:
            headers["ServiceMode"] = str(servicemode)
        if uuidseqno is not None:
            headers["UUIDSeqNo"] = str(uuidseqno)
        if entity is not None:
            headers["entity"] = str(entity)
        if languagecode is not None:
            headers["languageCode"] = str(languagecode)
        if userid is not None:
            headers["userId"] = str(userid)
        
        
        return await make_api_request(
            "POST", 
            path, 
            data=data, 
            params=params if params else None, 
            headers=headers if headers else None
        )
    
    
    
    @mcp.tool()
    async def rstbtquick_customer_onboarding_using_post(
        request_body:Dict[str, Any] ,  # createCustomerResource,
        accesstoken: Optional[str] = None,
        channeltype: Optional[int] = None,
        co_relationid: Optional[int] = None,
        initiatingsystem: Optional[str] = None,
        servicemode: Optional[int] = None,
        uuidseqno: Optional[int] = None,
        entity: Optional[str] = None,
        languagecode: Optional[int] = None,
        referenceid: Optional[str] = None,
        requesthash: Optional[str] = None,
        userid: Optional[int] = None
    ) -> Dict[str, Any]:
        """
        Create Individual/Corporate Customer
        
        Generated from: POST /customerManagement/customer
        Source: swagger_2_0
        Operation ID: RSTBTQuickCustomerOnboardingUsingPOST
        
        
        Authentication: Not required
        
        Parameters:
        - request_body: any (required)
          input
        
        
        
        Headers:
        - Accesstoken: string
          Authorization Token to validation the caller
        - ChannelType: integer
          Channel identifier from where the TXN has originated (Internet, Mobile, ATM, Branch Channel )
        - Co-Relationid: integer
          Unique ID for the service invoked, will be set by the TXN system
        - InitiatingSystem: string
          Indicating the initiated system
        - ServiceMode: integer
          Used for branch channel to indicate the type of customer
        - UUIDSeqNo: integer
          UUID Sequence Number
        - entity: string
          entity
        - languageCode: integer
          languageCode
        - referenceId: string
          Place holder forToken based authetication
        - requesthash: string
          Request payload for hash validation
        - userId: integer
          userId
        
        
        """
        
        
        # Prepare request data
        
        # Single body parameter - send directly
        data = request_body if request_body is not None else {}
        
        
        
        # Prepare query parameters
        params = {}
        
        
        # Replace path parameters in URL
        path = "/customerManagement/customer"
        
        
        # Prepare headers
        headers = {}
        if accesstoken is not None:
            headers["Accesstoken"] = str(accesstoken)
        if channeltype is not None:
            headers["ChannelType"] = str(channeltype)
        if co_relationid is not None:
            headers["Co-Relationid"] = str(co_relationid)
        if initiatingsystem is not None:
            headers["InitiatingSystem"] = str(initiatingsystem)
        if servicemode is not None:
            headers["ServiceMode"] = str(servicemode)
        if uuidseqno is not None:
            headers["UUIDSeqNo"] = str(uuidseqno)
        if entity is not None:
            headers["entity"] = str(entity)
        if languagecode is not None:
            headers["languageCode"] = str(languagecode)
        if referenceid is not None:
            headers["referenceId"] = str(referenceid)
        if requesthash is not None:
            headers["requesthash"] = str(requesthash)
        if userid is not None:
            headers["userId"] = str(userid)
        
        
        return await make_api_request(
            "POST", 
            path, 
            data=data, 
            params=params if params else None, 
            headers=headers if headers else None
        )
    
    
    
    @mcp.tool()
    async def rstbtcustomer_onboarding_postusing_post(
        request_body:Dict[str, Any] ,  # customerCreateResource,
        accesstoken: Optional[str] = None,
        channeltype: Optional[int] = None,
        co_relationid: Optional[int] = None,
        initiatingsystem: Optional[str] = None,
        servicemode: Optional[int] = None,
        uuidseqno: Optional[int] = None,
        entity: Optional[str] = None,
        languagecode: Optional[int] = None,
        referenceid: Optional[str] = None,
        requesthash: Optional[str] = None,
        userid: Optional[int] = None
    ) -> Dict[str, Any]:
        """
        Create Individual/Corporate Customer With All Details
        
        Generated from: POST /customerManagement/customer/CreateWithDetails
        Source: swagger_2_0
        Operation ID: RSTBTCustomerOnboarding_POSTUsingPOST
        
        
        Authentication: Not required
        
        Parameters:
        - request_body: any (required)
          input
        
        
        
        Headers:
        - Accesstoken: string
          Authorization Token to validation the caller
        - ChannelType: integer
          Channel identifier from where the TXN has originated (Internet, Mobile, ATM, Branch Channel )
        - Co-Relationid: integer
          Unique ID for the service invoked, will be set by the TXN system
        - InitiatingSystem: string
          Indicating the initiated system
        - ServiceMode: integer
          Used for branch channel to indicate the type of customer
        - UUIDSeqNo: integer
          UUID Sequence Number
        - entity: string
          entity
        - languageCode: integer
          languageCode
        - referenceId: string
          Place holder forToken based authetication
        - requesthash: string
          Request payload for hash validation
        - userId: integer
          userId
        
        
        """
        
        
        # Prepare request data
        
        # Single body parameter - send directly
        data = request_body if request_body is not None else {}
        
        
        
        # Prepare query parameters
        params = {}
        
        
        # Replace path parameters in URL
        path = "/customerManagement/customer/CreateWithDetails"
        
        
        # Prepare headers
        headers = {}
        if accesstoken is not None:
            headers["Accesstoken"] = str(accesstoken)
        if channeltype is not None:
            headers["ChannelType"] = str(channeltype)
        if co_relationid is not None:
            headers["Co-Relationid"] = str(co_relationid)
        if initiatingsystem is not None:
            headers["InitiatingSystem"] = str(initiatingsystem)
        if servicemode is not None:
            headers["ServiceMode"] = str(servicemode)
        if uuidseqno is not None:
            headers["UUIDSeqNo"] = str(uuidseqno)
        if entity is not None:
            headers["entity"] = str(entity)
        if languagecode is not None:
            headers["languageCode"] = str(languagecode)
        if referenceid is not None:
            headers["referenceId"] = str(referenceid)
        if requesthash is not None:
            headers["requesthash"] = str(requesthash)
        if userid is not None:
            headers["userId"] = str(userid)
        
        
        return await make_api_request(
            "POST", 
            path, 
            data=data, 
            params=params if params else None, 
            headers=headers if headers else None
        )
    
    
    
    @mcp.tool()
    async def bret1084_ftch_actv_prtfl_getusing_get(
        customerreference: int,
        channeltype: Optional[int] = None,
        co_relationid: Optional[int] = None,
        initiatingsystem: Optional[str] = None,
        servicemode: Optional[int] = None,
        uuidseqno: Optional[int] = None,
        entity: Optional[str] = None,
        languagecode: Optional[int] = None,
        userid: Optional[int] = None
    ) -> Dict[str, Any]:
        """
        API to fetch Oldest Active Portfolio
        
        Generated from: GET /customerManagement/customer/activePortfolio/{customerReference}
        Source: swagger_2_0
        Operation ID: BRET1084FtchActvPrtfl_GETUsingGET
        
        
        Authentication: Not required
        
        Parameters:
        - customerReference: integer (required)
          customer Reference
        
        
        
        Headers:
        - ChannelType: integer
          Channel identifier from where the TXN has originated (Internet, Mobile, ATM, Branch Channel )
        - Co-Relationid: integer
          Unique ID for the service invoked, will be set by the TXN system
        - InitiatingSystem: string
          Indicating the initiated system
        - ServiceMode: integer
          Used for branch channel to indicate the type of customer
        - UUIDSeqNo: integer
          UUID Sequence Number
        - entity: string
          entity
        - languageCode: integer
          languageCode
        - userId: integer
          userId
        
        
        """
        
        
        # Prepare query parameters
        params = {}
        
        
        # Replace path parameters in URL
        path = "/customerManagement/customer/activePortfolio/{customerReference}"
        if customerreference is not None:
            path = path.replace("{customerReference}", str(customerreference))
        
        
        # Prepare headers
        headers = {}
        if channeltype is not None:
            headers["ChannelType"] = str(channeltype)
        if co_relationid is not None:
            headers["Co-Relationid"] = str(co_relationid)
        if initiatingsystem is not None:
            headers["InitiatingSystem"] = str(initiatingsystem)
        if servicemode is not None:
            headers["ServiceMode"] = str(servicemode)
        if uuidseqno is not None:
            headers["UUIDSeqNo"] = str(uuidseqno)
        if entity is not None:
            headers["entity"] = str(entity)
        if languagecode is not None:
            headers["languageCode"] = str(languagecode)
        if userid is not None:
            headers["userId"] = str(userid)
        
        
        return await make_api_request(
            "GET", 
            path, 
            
            params=params if params else None, 
            headers=headers if headers else None
        )
    
    
    
    @mcp.tool()
    async def rstbtamend_postal_address_using_put(
        request_body:Dict[str, Any] ,  # AmendCustomerPostalAddress_Resource,
        accesstoken: Optional[str] = None,
        channeltype: Optional[int] = None,
        co_relationid: Optional[int] = None,
        initiatingsystem: Optional[str] = None,
        servicemode: Optional[int] = None,
        uuidseqno: Optional[int] = None,
        entity: Optional[str] = None,
        languagecode: Optional[int] = None,
        referenceid: Optional[str] = None,
        requesthash: Optional[str] = None,
        userid: Optional[int] = None
    ) -> Dict[str, Any]:
        """
        Amend Customer Postal Address
        
        Generated from: PUT /customerManagement/customer/address
        Source: swagger_2_0
        Operation ID: RSTBTAmendPostalAddressUsingPUT
        
        
        Authentication: Not required
        
        Parameters:
        - request_body: any (required)
          input
        
        
        
        Headers:
        - Accesstoken: string
          Authorization token for identification of the caller
        - ChannelType: integer
          Channel identifier from where the TXN has originated (Internet, Mobile, ATM, Branch Channel )
        - Co-Relationid: integer
          Unique ID for the service invoked, will be set by the TXN system
        - InitiatingSystem: string
          Indicating the initiated system
        - ServiceMode: integer
          Used for branch channel to indicate the type of customer
        - UUIDSeqNo: integer
          UUID Sequence Number
        - entity: string
          entity
        - languageCode: integer
          languageCode
        - referenceId: string
          Place holder for Token based authentication
        - requesthash: string
          Request payload for hash validation
        - userId: integer
          userId
        
        
        """
        
        
        # Prepare request data
        
        # Single body parameter - send directly
        data = request_body if request_body is not None else {}
        
        
        
        # Prepare query parameters
        params = {}
        
        
        # Replace path parameters in URL
        path = "/customerManagement/customer/address"
        
        
        # Prepare headers
        headers = {}
        if accesstoken is not None:
            headers["Accesstoken"] = str(accesstoken)
        if channeltype is not None:
            headers["ChannelType"] = str(channeltype)
        if co_relationid is not None:
            headers["Co-Relationid"] = str(co_relationid)
        if initiatingsystem is not None:
            headers["InitiatingSystem"] = str(initiatingsystem)
        if servicemode is not None:
            headers["ServiceMode"] = str(servicemode)
        if uuidseqno is not None:
            headers["UUIDSeqNo"] = str(uuidseqno)
        if entity is not None:
            headers["entity"] = str(entity)
        if languagecode is not None:
            headers["languageCode"] = str(languagecode)
        if referenceid is not None:
            headers["referenceId"] = str(referenceid)
        if requesthash is not None:
            headers["requesthash"] = str(requesthash)
        if userid is not None:
            headers["userId"] = str(userid)
        
        
        return await make_api_request(
            "PUT", 
            path, 
            data=data, 
            params=params if params else None, 
            headers=headers if headers else None
        )
    
    
    
    @mcp.tool()
    async def bretget_alert_cnt_using_get(
        accountreference: Optional[str] = None,
        customerreference: Optional[int] = None,
        externalreference: Optional[str] = None,
        fromdate: Optional[str] = None,
        todate: Optional[str] = None,
        pagenum: Optional[int] = None,
        pagesize: Optional[int] = None,
        accesstoken: Optional[str] = None,
        channeltype: Optional[int] = None,
        co_relationid: Optional[int] = None,
        initiatingsystem: Optional[str] = None,
        servicemode: Optional[int] = None,
        uuidseqno: Optional[int] = None,
        entity: Optional[str] = None,
        languagecode: Optional[int] = None,
        referenceid: Optional[str] = None,
        userid: Optional[int] = None
    ) -> Dict[str, Any]:
        """
        Fetch Alert Count
        
        Generated from: GET /customerManagement/customer/alertCount
        Source: swagger_2_0
        Operation ID: BRETGetAlertCntUsingGET
        
        
        Authentication: Not required
        
        Parameters:
        - AccountReference: string
          Account Reference
        - CustomerReference: integer
          Customer ID
        - ExternalReference: string
          GCIS No
        - FromDate: string
          Alert Count Start Date(Date Format: YYYYMMDD)
        - ToDate: string
          Alert Count End Date(Date Format: YYYYMMDD)
        - pageNum: integer
          pageNum
        - pageSize: integer
          pageSize
        
        
        
        Headers:
        - Accesstoken: string
          Authorization token for identification of the caller
        - ChannelType: integer
          Channel identifier from where the TXN has originated (Internet, Mobile, ATM, Branch Channel )
        - Co-Relationid: integer
          Unique ID for the service invoked, will be set by the TXN system
        - InitiatingSystem: string
          Indicating the initiated system
        - ServiceMode: integer
          Used for branch channel to indicate the type of customer
        - UUIDSeqNo: integer
          UUID Sequence Number
        - entity: string
          entity
        - languageCode: integer
          languageCode
        - referenceId: string
          Place holder for Token based authentication
        - userId: integer
          userId
        
        
        """
        
        
        # Prepare query parameters
        params = {}
        if accountreference is not None:
            params["AccountReference"] = accountreference
            
        if customerreference is not None:
            params["CustomerReference"] = customerreference
            
        if externalreference is not None:
            params["ExternalReference"] = externalreference
            
        if fromdate is not None:
            params["FromDate"] = fromdate
            
        if todate is not None:
            params["ToDate"] = todate
            
        if pagenum is not None:
            params["pageNum"] = pagenum
            
        if pagesize is not None:
            params["pageSize"] = pagesize
            
        
        
        # Replace path parameters in URL
        path = "/customerManagement/customer/alertCount"
        
        
        # Prepare headers
        headers = {}
        if accesstoken is not None:
            headers["Accesstoken"] = str(accesstoken)
        if channeltype is not None:
            headers["ChannelType"] = str(channeltype)
        if co_relationid is not None:
            headers["Co-Relationid"] = str(co_relationid)
        if initiatingsystem is not None:
            headers["InitiatingSystem"] = str(initiatingsystem)
        if servicemode is not None:
            headers["ServiceMode"] = str(servicemode)
        if uuidseqno is not None:
            headers["UUIDSeqNo"] = str(uuidseqno)
        if entity is not None:
            headers["entity"] = str(entity)
        if languagecode is not None:
            headers["languageCode"] = str(languagecode)
        if referenceid is not None:
            headers["referenceId"] = str(referenceid)
        if userid is not None:
            headers["userId"] = str(userid)
        
        
        return await make_api_request(
            "GET", 
            path, 
            
            params=params if params else None, 
            headers=headers if headers else None
        )
    
    
    
    @mcp.tool()
    async def bretget_alert_list_using_get(
        accountreference: Optional[str] = None,
        alerttype: Optional[int] = None,
        customerreference: Optional[int] = None,
        externalreference: Optional[str] = None,
        fromdate: Optional[str] = None,
        status: Optional[int] = None,
        todate: Optional[str] = None,
        pagenum: Optional[int] = None,
        pagesize: Optional[int] = None,
        accesstoken: Optional[str] = None,
        channeltype: Optional[int] = None,
        co_relationid: Optional[int] = None,
        initiatingsystem: Optional[str] = None,
        servicemode: Optional[int] = None,
        uuidseqno: Optional[int] = None,
        entity: Optional[str] = None,
        languagecode: Optional[int] = None,
        referenceid: Optional[str] = None,
        userid: Optional[int] = None
    ) -> Dict[str, Any]:
        """
        Fetch Alert List
        
        Generated from: GET /customerManagement/customer/alertList
        Source: swagger_2_0
        Operation ID: BRETGetAlertListUsingGET
        
        
        Authentication: Not required
        
        Parameters:
        - AccountReference: string
          Account Reference
        - AlertType: integer
          Alert Type 1-DebitCreditBlocked,6-Dormant,8-Inactive,11-Active (Domain Name : d_FollowupStat)
        - CustomerReference: integer
          Customer ID
        - ExternalReference: string
          GCIS No
        - FromDate: string
          Alert Count Start Date(Date Format: YYYYMMDD)
        - Status: integer
          Status 1-OnHold,3-Active(Domain Name:d_WorkflowStatus)
        - ToDate: string
          Alert Count End Date(Date Format: YYYYMMDD)
        - pageNum: integer
          pageNum
        - pageSize: integer
          pageSize
        
        
        
        Headers:
        - Accesstoken: string
          Authorization token for identification of the caller
        - ChannelType: integer
          Channel identifier from where the TXN has originated (Internet, Mobile, ATM, Branch Channel )
        - Co-Relationid: integer
          Unique ID for the service invoked, will be set by the TXN system
        - InitiatingSystem: string
          Indicating the initiated system
        - ServiceMode: integer
          Used for branch channel to indicate the type of customer
        - UUIDSeqNo: integer
          UUID Sequence Number
        - entity: string
          entity
        - languageCode: integer
          languageCode
        - referenceId: string
          Place holder for Token based authentication
        - userId: integer
          userId
        
        
        """
        
        
        # Prepare query parameters
        params = {}
        if accountreference is not None:
            params["AccountReference"] = accountreference
            
        if alerttype is not None:
            params["AlertType"] = alerttype
            
        if customerreference is not None:
            params["CustomerReference"] = customerreference
            
        if externalreference is not None:
            params["ExternalReference"] = externalreference
            
        if fromdate is not None:
            params["FromDate"] = fromdate
            
        if status is not None:
            params["Status"] = status
            
        if todate is not None:
            params["ToDate"] = todate
            
        if pagenum is not None:
            params["pageNum"] = pagenum
            
        if pagesize is not None:
            params["pageSize"] = pagesize
            
        
        
        # Replace path parameters in URL
        path = "/customerManagement/customer/alertList"
        
        
        # Prepare headers
        headers = {}
        if accesstoken is not None:
            headers["Accesstoken"] = str(accesstoken)
        if channeltype is not None:
            headers["ChannelType"] = str(channeltype)
        if co_relationid is not None:
            headers["Co-Relationid"] = str(co_relationid)
        if initiatingsystem is not None:
            headers["InitiatingSystem"] = str(initiatingsystem)
        if servicemode is not None:
            headers["ServiceMode"] = str(servicemode)
        if uuidseqno is not None:
            headers["UUIDSeqNo"] = str(uuidseqno)
        if entity is not None:
            headers["entity"] = str(entity)
        if languagecode is not None:
            headers["languageCode"] = str(languagecode)
        if referenceid is not None:
            headers["referenceId"] = str(referenceid)
        if userid is not None:
            headers["userId"] = str(userid)
        
        
        return await make_api_request(
            "GET", 
            path, 
            
            params=params if params else None, 
            headers=headers if headers else None
        )
    
    
    
    @mcp.tool()
    async def cbcet1084_amlcheck_cust_onboarding_getusing_get(
        activity_id: Optional[str] = None,
        customerreference: Optional[int] = None,
        dateoforigin: Optional[str] = None,
        firstname: Optional[str] = None,
        identifiertype: Optional[str] = None,
        identifiervalue: Optional[str] = None,
        issuecountry: Optional[str] = None,
        lastname: Optional[str] = None,
        middlename: Optional[str] = None,
        channeltype: Optional[int] = None,
        co_relationid: Optional[int] = None,
        initiatingsystem: Optional[str] = None,
        servicemode: Optional[int] = None,
        uuidseqno: Optional[int] = None,
        entity: Optional[str] = None,
        languagecode: Optional[int] = None,
        userid: Optional[int] = None
    ) -> Dict[str, Any]:
        """
        API to perform Customer AML check
        
        Generated from: GET /customerManagement/customer/amlcheck
        Source: swagger_2_0
        Operation ID: CBCET1084AMLCheckCustOnboarding_GETUsingGET
        
        
        Authentication: Not required
        
        Parameters:
        - Activity Id: string
          Activity Id
        - CustomerReference: integer
          Customer Reference
        - DateOfOrigin: string
          Date of origin
        - FirstName: string
          First Name
        - IdentifierType: string
          Identifier Type
        - IdentifierValue: string
          Identifier Value
        - IssueCountry: string
          Issue Country
        - LastName: string
          Last Name
        - MiddleName: string
          Middle Name
        
        
        
        Headers:
        - ChannelType: integer
          Channel identifier from where the TXN has originated (Internet, Mobile, ATM, Branch Channel )
        - Co-Relationid: integer
          Unique ID for the service invoked, will be set by the TXN system
        - InitiatingSystem: string
          Indicating the initiated system
        - ServiceMode: integer
          Used for branch channel to indicate the type of customer
        - UUIDSeqNo: integer
          UUID Sequence Number
        - entity: string
          entity
        - languageCode: integer
          languageCode
        - userId: integer
          userId
        
        
        """
        
        
        # Prepare query parameters
        params = {}
        if activity_id is not None:
            params["Activity Id"] = activity_id
            
        if customerreference is not None:
            params["CustomerReference"] = customerreference
            
        if dateoforigin is not None:
            params["DateOfOrigin"] = dateoforigin
            
        if firstname is not None:
            params["FirstName"] = firstname
            
        if identifiertype is not None:
            params["IdentifierType"] = identifiertype
            
        if identifiervalue is not None:
            params["IdentifierValue"] = identifiervalue
            
        if issuecountry is not None:
            params["IssueCountry"] = issuecountry
            
        if lastname is not None:
            params["LastName"] = lastname
            
        if middlename is not None:
            params["MiddleName"] = middlename
            
        
        
        # Replace path parameters in URL
        path = "/customerManagement/customer/amlcheck"
        
        
        # Prepare headers
        headers = {}
        if channeltype is not None:
            headers["ChannelType"] = str(channeltype)
        if co_relationid is not None:
            headers["Co-Relationid"] = str(co_relationid)
        if initiatingsystem is not None:
            headers["InitiatingSystem"] = str(initiatingsystem)
        if servicemode is not None:
            headers["ServiceMode"] = str(servicemode)
        if uuidseqno is not None:
            headers["UUIDSeqNo"] = str(uuidseqno)
        if entity is not None:
            headers["entity"] = str(entity)
        if languagecode is not None:
            headers["languageCode"] = str(languagecode)
        if userid is not None:
            headers["userId"] = str(userid)
        
        
        return await make_api_request(
            "GET", 
            path, 
            
            params=params if params else None, 
            headers=headers if headers else None
        )
    
    
    
    @mcp.tool()
    async def brbt2012_auth_nominee_postusing_post(
        request_body:Dict[str, Any] ,  # authNomineeResource,
        entity: Optional[str] = None,
        languagecode: Optional[int] = None,
        userid: Optional[int] = None
    ) -> Dict[str, Any]:
        """
        authorise locker nominee of the customer
        
        Generated from: POST /customerManagement/customer/authNominee
        Source: swagger_2_0
        Operation ID: BRBT2012AuthNominee_POSTUsingPOST
        
        
        Authentication: Not required
        
        Parameters:
        - request_body: any (required)
          input
        
        
        
        Headers:
        - entity: string
          entity
        - languageCode: integer
          languageCode
        - userId: integer
          userId
        
        
        """
        
        
        # Prepare request data
        
        # Single body parameter - send directly
        data = request_body if request_body is not None else {}
        
        
        
        # Prepare query parameters
        params = {}
        
        
        # Replace path parameters in URL
        path = "/customerManagement/customer/authNominee"
        
        
        # Prepare headers
        headers = {}
        if entity is not None:
            headers["entity"] = str(entity)
        if languagecode is not None:
            headers["languageCode"] = str(languagecode)
        if userid is not None:
            headers["userId"] = str(userid)
        
        
        return await make_api_request(
            "POST", 
            path, 
            data=data, 
            params=params if params else None, 
            headers=headers if headers else None
        )
    
    
    
    @mcp.tool()
    async def bret0103_gt_bpdtls_using_get(
        customerid: Optional[int] = None,
        identifiertype: Optional[int] = None,
        identifiervalue: Optional[str] = None,
        accesstoken: Optional[str] = None,
        channeltype: Optional[int] = None,
        co_relationid: Optional[int] = None,
        initiatingsystem: Optional[str] = None,
        servicemode: Optional[int] = None,
        uuidseqno: Optional[int] = None,
        entity: Optional[str] = None,
        languagecode: Optional[int] = None,
        referenceid: Optional[str] = None,
        userid: Optional[int] = None
    ) -> Dict[str, Any]:
        """
        Black List Validation
        
        Generated from: GET /customerManagement/customer/blockListValidate
        Source: swagger_2_0
        Operation ID: BRET0103GtBPDtlsUsingGET
        
        
        Authentication: Not required
        
        Parameters:
        - CustomerID: integer
          Customer ID
        - IdentifierType: integer
          Identifier Type
        - IdentifierValue: string
          Identifier Value
        
        
        
        Headers:
        - Accesstoken: string
          Authorization token for identification of the caller
        - ChannelType: integer
          Channel identifier from where the TXN has originated (Internet, Mobile, ATM, Branch Channel )
        - Co-Relationid: integer
          Unique ID for the service invoked, will be set by the TXN system
        - InitiatingSystem: string
          Indicating the initiated system
        - ServiceMode: integer
          Used for branch channel to indicate the type of customer
        - UUIDSeqNo: integer
          UUID Sequence Number
        - entity: string
          entity
        - languageCode: integer
          languageCode
        - referenceId: string
          Place holder for Token based authentication
        - userId: integer
          userId
        
        
        """
        
        
        # Prepare query parameters
        params = {}
        if customerid is not None:
            params["CustomerID"] = customerid
            
        if identifiertype is not None:
            params["IdentifierType"] = identifiertype
            
        if identifiervalue is not None:
            params["IdentifierValue"] = identifiervalue
            
        
        
        # Replace path parameters in URL
        path = "/customerManagement/customer/blockListValidate"
        
        
        # Prepare headers
        headers = {}
        if accesstoken is not None:
            headers["Accesstoken"] = str(accesstoken)
        if channeltype is not None:
            headers["ChannelType"] = str(channeltype)
        if co_relationid is not None:
            headers["Co-Relationid"] = str(co_relationid)
        if initiatingsystem is not None:
            headers["InitiatingSystem"] = str(initiatingsystem)
        if servicemode is not None:
            headers["ServiceMode"] = str(servicemode)
        if uuidseqno is not None:
            headers["UUIDSeqNo"] = str(uuidseqno)
        if entity is not None:
            headers["entity"] = str(entity)
        if languagecode is not None:
            headers["languageCode"] = str(languagecode)
        if referenceid is not None:
            headers["referenceId"] = str(referenceid)
        if userid is not None:
            headers["userId"] = str(userid)
        
        
        return await make_api_request(
            "GET", 
            path, 
            
            params=params if params else None, 
            headers=headers if headers else None
        )
    
    
    
    @mcp.tool()
    async def bretget_client_count_using_get(
        accesstoken: Optional[str] = None,
        channeltype: Optional[int] = None,
        co_relationid: Optional[int] = None,
        initiatingsystem: Optional[str] = None,
        servicemode: Optional[int] = None,
        uuidseqno: Optional[int] = None,
        entity: Optional[str] = None,
        languagecode: Optional[int] = None,
        referenceid: Optional[str] = None,
        userid: Optional[int] = None
    ) -> Dict[str, Any]:
        """
        Fetch Client Count
        
        Generated from: GET /customerManagement/customer/clientCount
        Source: swagger_2_0
        Operation ID: BRETGetClientCountUsingGET
        
        
        Authentication: Not required
        
        Parameters:
        
        
        
        Headers:
        - Accesstoken: string
          Authorization token for identification of the caller
        - ChannelType: integer
          Channel identifier from where the TXN has originated (Internet, Mobile, ATM, Branch Channel )
        - Co-Relationid: integer
          Unique ID for the service invoked, will be set by the TXN system
        - InitiatingSystem: string
          Indicating the initiated system
        - ServiceMode: integer
          Used for branch channel to indicate the type of customer
        - UUIDSeqNo: integer
          UUID Sequence Number
        - entity: string
          entity
        - languageCode: integer
          languageCode
        - referenceId: string
          Place holder for Token based authentication
        - userId: integer
          userId
        
        
        """
        
        
        # Prepare query parameters
        params = {}
        
        
        # Replace path parameters in URL
        path = "/customerManagement/customer/clientCount"
        
        
        # Prepare headers
        headers = {}
        if accesstoken is not None:
            headers["Accesstoken"] = str(accesstoken)
        if channeltype is not None:
            headers["ChannelType"] = str(channeltype)
        if co_relationid is not None:
            headers["Co-Relationid"] = str(co_relationid)
        if initiatingsystem is not None:
            headers["InitiatingSystem"] = str(initiatingsystem)
        if servicemode is not None:
            headers["ServiceMode"] = str(servicemode)
        if uuidseqno is not None:
            headers["UUIDSeqNo"] = str(uuidseqno)
        if entity is not None:
            headers["entity"] = str(entity)
        if languagecode is not None:
            headers["languageCode"] = str(languagecode)
        if referenceid is not None:
            headers["referenceId"] = str(referenceid)
        if userid is not None:
            headers["userId"] = str(userid)
        
        
        return await make_api_request(
            "GET", 
            path, 
            
            params=params if params else None, 
            headers=headers if headers else None
        )
    
    
    
    @mcp.tool()
    async def bret0202_get_comm_dtls_using_get(
        addresstype: int,
        contacttype: int,
        customerid: int,
        identifiertype: Optional[int] = None,
        identifiervalue: Optional[str] = None,
        accesstoken: Optional[str] = None,
        channeltype: Optional[int] = None,
        co_relationid: Optional[int] = None,
        initiatingsystem: Optional[str] = None,
        servicemode: Optional[int] = None,
        uuidseqno: Optional[int] = None,
        entity: Optional[str] = None,
        languagecode: Optional[int] = None,
        referenceid: Optional[str] = None,
        userid: Optional[int] = None
    ) -> Dict[str, Any]:
        """
        Fetch Customer Communication Details
        
        Generated from: GET /customerManagement/customer/communicationDetails
        Source: swagger_2_0
        Operation ID: BRET0202GetCommDtlsUsingGET
        
        
        Authentication: Not required
        
        Parameters:
        - AddressType: integer (required)
          Enter the address type 2-Permanent,65-Work,4-Temporary,16-Legal,8-Swift(Domain Name: d_AddrTyp)
        - ContactType: integer (required)
          Enter the Contact type 31-LocalMobile,32-LocalLandline,33-WorkLandline(Domain Name:d_AddrTyp)
        - CustomerID: integer (required)
          Customer ID
        - IdentifierType: integer
          Identifier Type
        - IdentifierValue: string
          Identifier Value
        
        
        
        Headers:
        - Accesstoken: string
          Authorization token for identification of the caller
        - ChannelType: integer
          Channel identifier from where the TXN has originated (Internet, Mobile, ATM, Branch Channel )
        - Co-Relationid: integer
          Unique ID for the service invoked, will be set by the TXN system
        - InitiatingSystem: string
          Indicating the initiated system
        - ServiceMode: integer
          Used for branch channel to indicate the type of customer
        - UUIDSeqNo: integer
          UUID Sequence Number
        - entity: string
          entity
        - languageCode: integer
          languageCode
        - referenceId: string
          Place holder for Token based authentication
        - userId: integer
          userId
        
        
        """
        
        
        # Prepare query parameters
        params = {}
        if addresstype is not None:
            params["AddressType"] = addresstype
            
        if contacttype is not None:
            params["ContactType"] = contacttype
            
        if customerid is not None:
            params["CustomerID"] = customerid
            
        if identifiertype is not None:
            params["IdentifierType"] = identifiertype
            
        if identifiervalue is not None:
            params["IdentifierValue"] = identifiervalue
            
        
        
        # Replace path parameters in URL
        path = "/customerManagement/customer/communicationDetails"
        
        
        # Prepare headers
        headers = {}
        if accesstoken is not None:
            headers["Accesstoken"] = str(accesstoken)
        if channeltype is not None:
            headers["ChannelType"] = str(channeltype)
        if co_relationid is not None:
            headers["Co-Relationid"] = str(co_relationid)
        if initiatingsystem is not None:
            headers["InitiatingSystem"] = str(initiatingsystem)
        if servicemode is not None:
            headers["ServiceMode"] = str(servicemode)
        if uuidseqno is not None:
            headers["UUIDSeqNo"] = str(uuidseqno)
        if entity is not None:
            headers["entity"] = str(entity)
        if languagecode is not None:
            headers["languageCode"] = str(languagecode)
        if referenceid is not None:
            headers["referenceId"] = str(referenceid)
        if userid is not None:
            headers["userId"] = str(userid)
        
        
        return await make_api_request(
            "GET", 
            path, 
            
            params=params if params else None, 
            headers=headers if headers else None
        )
    
    
    
    @mcp.tool()
    async def bret0201_get_comm_dtls_list_using_get(
        customerid: Optional[int] = None,
        identifiertype: Optional[int] = None,
        identifiervalue: Optional[str] = None,
        accesstoken: Optional[str] = None,
        channeltype: Optional[int] = None,
        co_relationid: Optional[int] = None,
        initiatingsystem: Optional[str] = None,
        servicemode: Optional[int] = None,
        uuidseqno: Optional[int] = None,
        entity: Optional[str] = None,
        languagecode: Optional[int] = None,
        referenceid: Optional[str] = None,
        userid: Optional[int] = None
    ) -> Dict[str, Any]:
        """
        Fetch Customer Communication List
        
        Generated from: GET /customerManagement/customer/communicationList
        Source: swagger_2_0
        Operation ID: BRET0201GetCommDtlsListUsingGET
        
        
        Authentication: Not required
        
        Parameters:
        - CustomerID: integer
          Customer ID
        - IdentifierType: integer
          Identifier Type
        - IdentifierValue: string
          Identifier Value
        
        
        
        Headers:
        - Accesstoken: string
          Authorization token for identification of the caller
        - ChannelType: integer
          Channel identifier from where the TXN has originated (Internet, Mobile, ATM, Branch Channel )
        - Co-Relationid: integer
          Unique ID for the service invoked, will be set by the TXN system
        - InitiatingSystem: string
          Indicating the initiated system
        - ServiceMode: integer
          Used for branch channel to indicate the type of customer
        - UUIDSeqNo: integer
          UUID Sequence Number
        - entity: string
          entity
        - languageCode: integer
          languageCode
        - referenceId: string
          Place holder for Token based authentication
        - userId: integer
          userId
        
        
        """
        
        
        # Prepare query parameters
        params = {}
        if customerid is not None:
            params["CustomerID"] = customerid
            
        if identifiertype is not None:
            params["IdentifierType"] = identifiertype
            
        if identifiervalue is not None:
            params["IdentifierValue"] = identifiervalue
            
        
        
        # Replace path parameters in URL
        path = "/customerManagement/customer/communicationList"
        
        
        # Prepare headers
        headers = {}
        if accesstoken is not None:
            headers["Accesstoken"] = str(accesstoken)
        if channeltype is not None:
            headers["ChannelType"] = str(channeltype)
        if co_relationid is not None:
            headers["Co-Relationid"] = str(co_relationid)
        if initiatingsystem is not None:
            headers["InitiatingSystem"] = str(initiatingsystem)
        if servicemode is not None:
            headers["ServiceMode"] = str(servicemode)
        if uuidseqno is not None:
            headers["UUIDSeqNo"] = str(uuidseqno)
        if entity is not None:
            headers["entity"] = str(entity)
        if languagecode is not None:
            headers["languageCode"] = str(languagecode)
        if referenceid is not None:
            headers["referenceId"] = str(referenceid)
        if userid is not None:
            headers["userId"] = str(userid)
        
        
        return await make_api_request(
            "GET", 
            path, 
            
            params=params if params else None, 
            headers=headers if headers else None
        )
    
    
    
    @mcp.tool()
    async def bret1084_fetch_complnc_data_getusing_get(
        customerreference: Optional[int] = None,
        txnref: Optional[int] = None,
        channeltype: Optional[int] = None,
        co_relationid: Optional[int] = None,
        initiatingsystem: Optional[str] = None,
        servicemode: Optional[int] = None,
        uuidseqno: Optional[int] = None,
        entity: Optional[str] = None,
        languagecode: Optional[int] = None,
        userid: Optional[int] = None
    ) -> Dict[str, Any]:
        """
        API is used to fetch customer compliance data
        
        Generated from: GET /customerManagement/customer/complianceDetails
        Source: swagger_2_0
        Operation ID: BRET1084FetchComplncData_GETUsingGET
        
        
        Authentication: Not required
        
        Parameters:
        - customerReference: integer
          Customer Reference
        - txnRef: integer
          Transaction Reference of the compliance data
        
        
        
        Headers:
        - ChannelType: integer
          Channel identifier from where the TXN has originated (Internet, Mobile, ATM, Branch Channel )
        - Co-Relationid: integer
          Unique ID for the service invoked, will be set by the TXN system
        - InitiatingSystem: string
          Indicating the initiated system
        - ServiceMode: integer
          Used for branch channel to indicate the type of customer
        - UUIDSeqNo: integer
          UUID Sequence Number
        - entity: string
          entity
        - languageCode: integer
          languageCode
        - userId: integer
          userId
        
        
        """
        
        
        # Prepare query parameters
        params = {}
        if customerreference is not None:
            params["customerReference"] = customerreference
            
        if txnref is not None:
            params["txnRef"] = txnref
            
        
        
        # Replace path parameters in URL
        path = "/customerManagement/customer/complianceDetails"
        
        
        # Prepare headers
        headers = {}
        if channeltype is not None:
            headers["ChannelType"] = str(channeltype)
        if co_relationid is not None:
            headers["Co-Relationid"] = str(co_relationid)
        if initiatingsystem is not None:
            headers["InitiatingSystem"] = str(initiatingsystem)
        if servicemode is not None:
            headers["ServiceMode"] = str(servicemode)
        if uuidseqno is not None:
            headers["UUIDSeqNo"] = str(uuidseqno)
        if entity is not None:
            headers["entity"] = str(entity)
        if languagecode is not None:
            headers["languageCode"] = str(languagecode)
        if userid is not None:
            headers["userId"] = str(userid)
        
        
        return await make_api_request(
            "GET", 
            path, 
            
            params=params if params else None, 
            headers=headers if headers else None
        )
    
    
    
    @mcp.tool()
    async def bretftch_consent_details_using_get(
        customerid: Optional[int] = None,
        identifiertype: Optional[int] = None,
        identifiervalue: Optional[str] = None,
        accesstoken: Optional[str] = None,
        channeltype: Optional[int] = None,
        co_relationid: Optional[int] = None,
        initiatingsystem: Optional[str] = None,
        servicemode: Optional[int] = None,
        uuidseqno: Optional[int] = None,
        entity: Optional[str] = None,
        languagecode: Optional[int] = None,
        referenceid: Optional[str] = None,
        userid: Optional[int] = None
    ) -> Dict[str, Any]:
        """
        Fetch Consent Details
        
        Generated from: GET /customerManagement/customer/consentDetails
        Source: swagger_2_0
        Operation ID: BRETFtchConsentDetailsUsingGET
        
        
        Authentication: Not required
        
        Parameters:
        - CustomerID: integer
          Customer ID
        - IdentifierType: integer
          Identifier Type
        - IdentifierValue: string
          Identifier Value
        
        
        
        Headers:
        - Accesstoken: string
          Authorization token for identification of the caller
        - ChannelType: integer
          Channel identifier from where the TXN has originated (Internet, Mobile, ATM, Branch Channel )
        - Co-Relationid: integer
          Unique ID for the service invoked, will be set by the TXN system
        - InitiatingSystem: string
          Indicating the initiated system
        - ServiceMode: integer
          Used for branch channel to indicate the type of customer
        - UUIDSeqNo: integer
          UUID Sequence Number
        - entity: string
          entity
        - languageCode: integer
          languageCode
        - referenceId: string
          Place holder for Token based Authentication
        - userId: integer
          userId
        
        
        """
        
        
        # Prepare query parameters
        params = {}
        if customerid is not None:
            params["CustomerID"] = customerid
            
        if identifiertype is not None:
            params["IdentifierType"] = identifiertype
            
        if identifiervalue is not None:
            params["IdentifierValue"] = identifiervalue
            
        
        
        # Replace path parameters in URL
        path = "/customerManagement/customer/consentDetails"
        
        
        # Prepare headers
        headers = {}
        if accesstoken is not None:
            headers["Accesstoken"] = str(accesstoken)
        if channeltype is not None:
            headers["ChannelType"] = str(channeltype)
        if co_relationid is not None:
            headers["Co-Relationid"] = str(co_relationid)
        if initiatingsystem is not None:
            headers["InitiatingSystem"] = str(initiatingsystem)
        if servicemode is not None:
            headers["ServiceMode"] = str(servicemode)
        if uuidseqno is not None:
            headers["UUIDSeqNo"] = str(uuidseqno)
        if entity is not None:
            headers["entity"] = str(entity)
        if languagecode is not None:
            headers["languageCode"] = str(languagecode)
        if referenceid is not None:
            headers["referenceId"] = str(referenceid)
        if userid is not None:
            headers["userId"] = str(userid)
        
        
        return await make_api_request(
            "GET", 
            path, 
            
            params=params if params else None, 
            headers=headers if headers else None
        )
    
    
    
    @mcp.tool()
    async def rstbtamend_phonenumber_using_put(
        request_body:Dict[str, Any] ,  # amendCustomerPhoneNumberResource,
        accesstoken: Optional[str] = None,
        channeltype: Optional[int] = None,
        co_relationid: Optional[int] = None,
        initiatingsystem: Optional[str] = None,
        servicemode: Optional[int] = None,
        uuidseqno: Optional[int] = None,
        entity: Optional[str] = None,
        languagecode: Optional[int] = None,
        referenceid: Optional[str] = None,
        requesthash: Optional[str] = None,
        userid: Optional[int] = None
    ) -> Dict[str, Any]:
        """
        Amend Customer Phone number
        
        Generated from: PUT /customerManagement/customer/contact
        Source: swagger_2_0
        Operation ID: RSTBTAmendPhonenumberUsingPUT
        
        
        Authentication: Not required
        
        Parameters:
        - request_body: any (required)
          input
        
        
        
        Headers:
        - Accesstoken: string
          Authorization token for identification of the caller
        - ChannelType: integer
          Channel identifier from where the TXN has originated (Internet, Mobile, ATM, Branch Channel )
        - Co-Relationid: integer
          Unique ID for the service invoked, will be set by the TXN system
        - InitiatingSystem: string
          Indicating the initiated system
        - ServiceMode: integer
          Used for branch channel to indicate the type of customer
        - UUIDSeqNo: integer
          UUID Sequence Number
        - entity: string
          entity
        - languageCode: integer
          languageCode
        - referenceId: string
          Place holder for Token based authentication
        - requesthash: string
          Request payload for hash validation
        - userId: integer
          userId
        
        
        """
        
        
        # Prepare request data
        
        # Single body parameter - send directly
        data = request_body if request_body is not None else {}
        
        
        
        # Prepare query parameters
        params = {}
        
        
        # Replace path parameters in URL
        path = "/customerManagement/customer/contact"
        
        
        # Prepare headers
        headers = {}
        if accesstoken is not None:
            headers["Accesstoken"] = str(accesstoken)
        if channeltype is not None:
            headers["ChannelType"] = str(channeltype)
        if co_relationid is not None:
            headers["Co-Relationid"] = str(co_relationid)
        if initiatingsystem is not None:
            headers["InitiatingSystem"] = str(initiatingsystem)
        if servicemode is not None:
            headers["ServiceMode"] = str(servicemode)
        if uuidseqno is not None:
            headers["UUIDSeqNo"] = str(uuidseqno)
        if entity is not None:
            headers["entity"] = str(entity)
        if languagecode is not None:
            headers["languageCode"] = str(languagecode)
        if referenceid is not None:
            headers["referenceId"] = str(referenceid)
        if requesthash is not None:
            headers["requesthash"] = str(requesthash)
        if userid is not None:
            headers["userId"] = str(userid)
        
        
        return await make_api_request(
            "PUT", 
            path, 
            data=data, 
            params=params if params else None, 
            headers=headers if headers else None
        )
    
    
    
    @mcp.tool()
    async def rstbtcorporate_contact_details_modification_postusing_post(
        request_body:Dict[str, Any] ,  # corporateContactDetailsResource,
        accesstoken: Optional[str] = None,
        channeltype: Optional[int] = None,
        co_relationid: Optional[int] = None,
        initiatingsystem: Optional[str] = None,
        servicemode: Optional[int] = None,
        uuidseqno: Optional[int] = None,
        entity: Optional[str] = None,
        languagecode: Optional[int] = None,
        referenceid: Optional[str] = None,
        requesthash: Optional[str] = None,
        userid: Optional[int] = None
    ) -> Dict[str, Any]:
        """
        Add/Modify/Delete Corporate Contact Details
        
        Generated from: POST /customerManagement/customer/corporateContactDetails/modify
        Source: swagger_2_0
        Operation ID: RSTBTCorporateContactDetailsModification_POSTUsingPOST
        
        
        Authentication: Not required
        
        Parameters:
        - request_body: any (required)
          input
        
        
        
        Headers:
        - Accesstoken: string
          Authorization Token to validation the caller
        - ChannelType: integer
          Channel identifier from where the TXN has originated (Internet, Mobile, ATM, Branch Channel )
        - Co-Relationid: integer
          Unique ID for the service invoked, will be set by the TXN system
        - InitiatingSystem: string
          Indicating the initiated system
        - ServiceMode: integer
          Used for branch channel to indicate the type of customer
        - UUIDSeqNo: integer
          UUID Sequence Number
        - entity: string
          entity
        - languageCode: integer
          languageCode
        - referenceId: string
          Place holder forToken based authetication
        - requesthash: string
          Request payload for hash validation
        - userId: integer
          userId
        
        
        """
        
        
        # Prepare request data
        
        # Single body parameter - send directly
        data = request_body if request_body is not None else {}
        
        
        
        # Prepare query parameters
        params = {}
        
        
        # Replace path parameters in URL
        path = "/customerManagement/customer/corporateContactDetails/modify"
        
        
        # Prepare headers
        headers = {}
        if accesstoken is not None:
            headers["Accesstoken"] = str(accesstoken)
        if channeltype is not None:
            headers["ChannelType"] = str(channeltype)
        if co_relationid is not None:
            headers["Co-Relationid"] = str(co_relationid)
        if initiatingsystem is not None:
            headers["InitiatingSystem"] = str(initiatingsystem)
        if servicemode is not None:
            headers["ServiceMode"] = str(servicemode)
        if uuidseqno is not None:
            headers["UUIDSeqNo"] = str(uuidseqno)
        if entity is not None:
            headers["entity"] = str(entity)
        if languagecode is not None:
            headers["languageCode"] = str(languagecode)
        if referenceid is not None:
            headers["referenceId"] = str(referenceid)
        if requesthash is not None:
            headers["requesthash"] = str(requesthash)
        if userid is not None:
            headers["userId"] = str(userid)
        
        
        return await make_api_request(
            "POST", 
            path, 
            data=data, 
            params=params if params else None, 
            headers=headers if headers else None
        )
    
    
    
    @mcp.tool()
    async def brbt2010_crt_mdf_nominee_postusing_post(
        request_body:Dict[str, Any] ,  # BRBT2010CrtMdfNominee_Resource,
        accesstoken: Optional[str] = None,
        channeltype: Optional[int] = None,
        co_relationid: Optional[int] = None,
        initiatingsystem: Optional[str] = None,
        servicemode: Optional[int] = None,
        uuidseqno: Optional[int] = None,
        entity: Optional[str] = None,
        languagecode: Optional[int] = None,
        referenceid: Optional[str] = None,
        requesthash: Optional[str] = None,
        userid: Optional[int] = None
    ) -> Dict[str, Any]:
        """
        create and modify locker nominee
        
        Generated from: POST /customerManagement/customer/createLockerNominee
        Source: swagger_2_0
        Operation ID: BRBT2010CrtMdfNominee_POSTUsingPOST
        
        
        Authentication: Not required
        
        Parameters:
        - request_body: any (required)
          input
        
        
        
        Headers:
        - Accesstoken: string
          Authorization token for identification of the caller
        - ChannelType: integer
          Channel identifier from where the TXN has originated (Internet, Mobile, ATM, Branch Channel )
        - Co-Relationid: integer
          Unique ID for the service invoked, will be set by the TXN system
        - InitiatingSystem: string
          Indicating the initiated system
        - ServiceMode: integer
          Used for branch channel to indicate the type of customer
        - UUIDSeqNo: integer
          UUID Sequence Number
        - entity: string
          entity
        - languageCode: integer
          languageCode
        - referenceId: string
          Place holder for Token based authentication
        - requesthash: string
          Request payload for hash validation
        - userId: integer
          userId
        
        
        """
        
        
        # Prepare request data
        
        # Single body parameter - send directly
        data = request_body if request_body is not None else {}
        
        
        
        # Prepare query parameters
        params = {}
        
        
        # Replace path parameters in URL
        path = "/customerManagement/customer/createLockerNominee"
        
        
        # Prepare headers
        headers = {}
        if accesstoken is not None:
            headers["Accesstoken"] = str(accesstoken)
        if channeltype is not None:
            headers["ChannelType"] = str(channeltype)
        if co_relationid is not None:
            headers["Co-Relationid"] = str(co_relationid)
        if initiatingsystem is not None:
            headers["InitiatingSystem"] = str(initiatingsystem)
        if servicemode is not None:
            headers["ServiceMode"] = str(servicemode)
        if uuidseqno is not None:
            headers["UUIDSeqNo"] = str(uuidseqno)
        if entity is not None:
            headers["entity"] = str(entity)
        if languagecode is not None:
            headers["languageCode"] = str(languagecode)
        if referenceid is not None:
            headers["referenceId"] = str(referenceid)
        if requesthash is not None:
            headers["requesthash"] = str(requesthash)
        if userid is not None:
            headers["userId"] = str(userid)
        
        
        return await make_api_request(
            "POST", 
            path, 
            data=data, 
            params=params if params else None, 
            headers=headers if headers else None
        )
    
    
    
    @mcp.tool()
    async def brbt1084_crt_complnc_data_postusing_post(
        request_body:Dict[str, Any] ,  # ComplianceSystemServiceResource,
        channeltype: Optional[int] = None,
        co_relationid: Optional[int] = None,
        initiatingsystem: Optional[str] = None,
        servicemode: Optional[int] = None,
        uuidseqno: Optional[int] = None,
        entity: Optional[str] = None,
        languagecode: Optional[int] = None,
        userid: Optional[int] = None
    ) -> Dict[str, Any]:
        """
        API is used to create customer compliance data
        
        Generated from: POST /customerManagement/customer/createcompliance
        Source: swagger_2_0
        Operation ID: BRBT1084CrtComplncData_POSTUsingPOST
        
        
        Authentication: Not required
        
        Parameters:
        - request_body: any (required)
          input
        
        
        
        Headers:
        - ChannelType: integer
          Channel identifier from where the TXN has originated (Internet, Mobile, ATM, Branch Channel )
        - Co-Relationid: integer
          Unique ID for the service invoked, will be set by the TXN system
        - InitiatingSystem: string
          Indicating the initiated system
        - ServiceMode: integer
          Used for branch channel to indicate the type of customer
        - UUIDSeqNo: integer
          UUID Sequence Number
        - entity: string
          entity
        - languageCode: integer
          languageCode
        - userId: integer
          userId
        
        
        """
        
        
        # Prepare request data
        
        # Single body parameter - send directly
        data = request_body if request_body is not None else {}
        
        
        
        # Prepare query parameters
        params = {}
        
        
        # Replace path parameters in URL
        path = "/customerManagement/customer/createcompliance"
        
        
        # Prepare headers
        headers = {}
        if channeltype is not None:
            headers["ChannelType"] = str(channeltype)
        if co_relationid is not None:
            headers["Co-Relationid"] = str(co_relationid)
        if initiatingsystem is not None:
            headers["InitiatingSystem"] = str(initiatingsystem)
        if servicemode is not None:
            headers["ServiceMode"] = str(servicemode)
        if uuidseqno is not None:
            headers["UUIDSeqNo"] = str(uuidseqno)
        if entity is not None:
            headers["entity"] = str(entity)
        if languagecode is not None:
            headers["languageCode"] = str(languagecode)
        if userid is not None:
            headers["userId"] = str(userid)
        
        
        return await make_api_request(
            "POST", 
            path, 
            data=data, 
            params=params if params else None, 
            headers=headers if headers else None
        )
    
    
    
    @mcp.tool()
    async def brbt5704_crt_sign_card_postusing_post(
        request_body:Dict[str, Any] ,  # SIGNATURE_CARD_BRBT5704CrtSignCard_Resource,
        accesstoken: Optional[str] = None,
        channeltype: Optional[int] = None,
        co_relationid: Optional[int] = None,
        initiatingsystem: Optional[str] = None,
        servicemode: Optional[int] = None,
        uuidseqno: Optional[int] = None,
        entity: Optional[str] = None,
        languagecode: Optional[int] = None,
        referenceid: Optional[str] = None,
        userid: Optional[int] = None
    ) -> Dict[str, Any]:
        """
        create signature card
        
        Generated from: POST /customerManagement/customer/createsignaturecard
        Source: swagger_2_0
        Operation ID: BRBT5704CrtSignCard_POSTUsingPOST
        
        
        Authentication: Not required
        
        Parameters:
        - request_body: any (required)
          input
        
        
        
        Headers:
        - Accesstoken: string
          Authorization token for identification of the caller
        - ChannelType: integer
          Channel identifier from where the TXN has originated (Internet, Mobile, ATM, Branch Channel )
        - Co-Relationid: integer
          Unique ID for the service invoked, will be set by the TXN system
        - InitiatingSystem: string
          Indicating the initiated system
        - ServiceMode: integer
          Used for branch channel to indicate the type of customer
        - UUIDSeqNo: integer
          UUID Sequence Number
        - entity: string
          entity
        - languageCode: integer
          languageCode
        - referenceId: string
          Place holder for Token based authentication
        - userId: integer
          userId
        
        
        """
        
        
        # Prepare request data
        
        # Single body parameter - send directly
        data = request_body if request_body is not None else {}
        
        
        
        # Prepare query parameters
        params = {}
        
        
        # Replace path parameters in URL
        path = "/customerManagement/customer/createsignaturecard"
        
        
        # Prepare headers
        headers = {}
        if accesstoken is not None:
            headers["Accesstoken"] = str(accesstoken)
        if channeltype is not None:
            headers["ChannelType"] = str(channeltype)
        if co_relationid is not None:
            headers["Co-Relationid"] = str(co_relationid)
        if initiatingsystem is not None:
            headers["InitiatingSystem"] = str(initiatingsystem)
        if servicemode is not None:
            headers["ServiceMode"] = str(servicemode)
        if uuidseqno is not None:
            headers["UUIDSeqNo"] = str(uuidseqno)
        if entity is not None:
            headers["entity"] = str(entity)
        if languagecode is not None:
            headers["languageCode"] = str(languagecode)
        if referenceid is not None:
            headers["referenceId"] = str(referenceid)
        if userid is not None:
            headers["userId"] = str(userid)
        
        
        return await make_api_request(
            "POST", 
            path, 
            data=data, 
            params=params if params else None, 
            headers=headers if headers else None
        )
    
    
    
    @mcp.tool()
    async def brbt3197_actv_bppndng_auth_postusing_put(
        request_body:Dict[str, Any] ,  # activeToPendingClosureResource,
        accesstoken: Optional[str] = None,
        channeltype: Optional[int] = None,
        co_relationid: Optional[int] = None,
        initiatingsystem: Optional[str] = None,
        servicemode: Optional[int] = None,
        uuidseqno: Optional[int] = None,
        entity: Optional[str] = None,
        languagecode: Optional[int] = None,
        referenceid: Optional[str] = None,
        requesthash: Optional[str] = None,
        userid: Optional[int] = None
    ) -> Dict[str, Any]:
        """
        Customer Status Change from Active to Pending Closure
        
        Generated from: PUT /customerManagement/customer/customerClosure
        Source: swagger_2_0
        Operation ID: BRBT3197ActvBPPndngAuth_POSTUsingPUT
        
        
        Authentication: Not required
        
        Parameters:
        - request_body: any (required)
          input
        
        
        
        Headers:
        - Accesstoken: string
          Authorization Token to validation the caller
        - ChannelType: integer
          Channel identifier from where the TXN has originated (Internet, Mobile, ATM, Branch Channel )
        - Co-Relationid: integer
          Unique ID for the service invoked, will be set by the TXN system
        - InitiatingSystem: string
          Indicating the initiated system
        - ServiceMode: integer
          Used for branch channel to indicate the type of customer
        - UUIDSeqNo: integer
          UUID Sequence Number
        - entity: string
          entity
        - languageCode: integer
          languageCode
        - referenceId: string
          Place holder for Token based authentication
        - requesthash: string
          Request payload for hash validation
        - userId: integer
          userId
        
        
        """
        
        
        # Prepare request data
        
        # Single body parameter - send directly
        data = request_body if request_body is not None else {}
        
        
        
        # Prepare query parameters
        params = {}
        
        
        # Replace path parameters in URL
        path = "/customerManagement/customer/customerClosure"
        
        
        # Prepare headers
        headers = {}
        if accesstoken is not None:
            headers["Accesstoken"] = str(accesstoken)
        if channeltype is not None:
            headers["ChannelType"] = str(channeltype)
        if co_relationid is not None:
            headers["Co-Relationid"] = str(co_relationid)
        if initiatingsystem is not None:
            headers["InitiatingSystem"] = str(initiatingsystem)
        if servicemode is not None:
            headers["ServiceMode"] = str(servicemode)
        if uuidseqno is not None:
            headers["UUIDSeqNo"] = str(uuidseqno)
        if entity is not None:
            headers["entity"] = str(entity)
        if languagecode is not None:
            headers["languageCode"] = str(languagecode)
        if referenceid is not None:
            headers["referenceId"] = str(referenceid)
        if requesthash is not None:
            headers["requesthash"] = str(requesthash)
        if userid is not None:
            headers["userId"] = str(userid)
        
        
        return await make_api_request(
            "PUT", 
            path, 
            data=data, 
            params=params if params else None, 
            headers=headers if headers else None
        )
    
    
    
    @mcp.tool()
    async def brbt2029_crt_cust_cnst_dtls_postusing_post(
        request_body:Dict[str, Any] ,  # createCustomerConsentDetailResource,
        accesstoken: Optional[str] = None,
        channeltype: Optional[int] = None,
        co_relationid: Optional[int] = None,
        initiatingsystem: Optional[str] = None,
        servicemode: Optional[int] = None,
        uuidseqno: Optional[int] = None,
        entity: Optional[str] = None,
        languagecode: Optional[int] = None,
        referenceid: Optional[str] = None,
        requesthash: Optional[str] = None,
        userid: Optional[int] = None
    ) -> Dict[str, Any]:
        """
        Customer Consent Details
        
        Generated from: POST /customerManagement/customer/customerConsent
        Source: swagger_2_0
        Operation ID: BRBT2029CrtCustCnstDtls_POSTUsingPOST
        
        
        Authentication: Not required
        
        Parameters:
        - request_body: any (required)
          input
        
        
        
        Headers:
        - Accesstoken: string
          Authorization Token to validation the caller
        - ChannelType: integer
          Channel identifier from where the Transaction has originated (Internet, Mobile, ATM, Branch Channel )
        - Co-Relationid: integer
          Unique ID for the service invoked, will be set by the Transaction system
        - InitiatingSystem: string
          Indicating the initiated system
        - ServiceMode: integer
          Used for branch channel to indicate the type of customer
        - UUIDSeqNo: integer
          UUID Sequence Number
        - entity: string
          entity
        - languageCode: integer
          languageCode
        - referenceId: string
          Place holder for Token based authentication
        - requesthash: string
          Request payload for hash validation
        - userId: integer
          userId
        
        
        """
        
        
        # Prepare request data
        
        # Single body parameter - send directly
        data = request_body if request_body is not None else {}
        
        
        
        # Prepare query parameters
        params = {}
        
        
        # Replace path parameters in URL
        path = "/customerManagement/customer/customerConsent"
        
        
        # Prepare headers
        headers = {}
        if accesstoken is not None:
            headers["Accesstoken"] = str(accesstoken)
        if channeltype is not None:
            headers["ChannelType"] = str(channeltype)
        if co_relationid is not None:
            headers["Co-Relationid"] = str(co_relationid)
        if initiatingsystem is not None:
            headers["InitiatingSystem"] = str(initiatingsystem)
        if servicemode is not None:
            headers["ServiceMode"] = str(servicemode)
        if uuidseqno is not None:
            headers["UUIDSeqNo"] = str(uuidseqno)
        if entity is not None:
            headers["entity"] = str(entity)
        if languagecode is not None:
            headers["languageCode"] = str(languagecode)
        if referenceid is not None:
            headers["referenceId"] = str(referenceid)
        if requesthash is not None:
            headers["requesthash"] = str(requesthash)
        if userid is not None:
            headers["userId"] = str(userid)
        
        
        return await make_api_request(
            "POST", 
            path, 
            data=data, 
            params=params if params else None, 
            headers=headers if headers else None
        )
    
    
    
    @mcp.tool()
    async def brbt2030_mdf_cyst_cnst_dtls_postusing_put(
        request_body:Dict[str, Any] ,  # ModifyCustomerConsentDetailRequest,
        accesstoken: Optional[str] = None,
        channeltype: Optional[int] = None,
        co_relationid: Optional[int] = None,
        initiatingsystem: Optional[str] = None,
        servicemode: Optional[int] = None,
        uuidseqno: Optional[int] = None,
        entity: Optional[str] = None,
        languagecode: Optional[int] = None,
        referenceid: Optional[str] = None,
        userid: Optional[int] = None
    ) -> Dict[str, Any]:
        """
        Modify Customer Consent Details
        
        Generated from: PUT /customerManagement/customer/customerConsent
        Source: swagger_2_0
        Operation ID: BRBT2030MdfCystCnstDtls_POSTUsingPUT
        
        
        Authentication: Not required
        
        Parameters:
        - request_body: any (required)
          input
        
        
        
        Headers:
        - Accesstoken: string
          Authorization Token to validation the caller
        - ChannelType: integer
          Channel identifier from where the Transaction has originated (Internet, Mobile, ATM, Branch Channel )
        - Co-Relationid: integer
          Unique ID for the service invoked, will be set by the Transaction system
        - InitiatingSystem: string
          Indicating the initiated system
        - ServiceMode: integer
          Used for branch channel to indicate the type of customer
        - UUIDSeqNo: integer
          UUID Sequence Number
        - entity: string
          entity
        - languageCode: integer
          languageCode
        - referenceId: string
          Place holder for Token based authentication
        - userId: integer
          userId
        
        
        """
        
        
        # Prepare request data
        
        # Single body parameter - send directly
        data = request_body if request_body is not None else {}
        
        
        
        # Prepare query parameters
        params = {}
        
        
        # Replace path parameters in URL
        path = "/customerManagement/customer/customerConsent"
        
        
        # Prepare headers
        headers = {}
        if accesstoken is not None:
            headers["Accesstoken"] = str(accesstoken)
        if channeltype is not None:
            headers["ChannelType"] = str(channeltype)
        if co_relationid is not None:
            headers["Co-Relationid"] = str(co_relationid)
        if initiatingsystem is not None:
            headers["InitiatingSystem"] = str(initiatingsystem)
        if servicemode is not None:
            headers["ServiceMode"] = str(servicemode)
        if uuidseqno is not None:
            headers["UUIDSeqNo"] = str(uuidseqno)
        if entity is not None:
            headers["entity"] = str(entity)
        if languagecode is not None:
            headers["languageCode"] = str(languagecode)
        if referenceid is not None:
            headers["referenceId"] = str(referenceid)
        if userid is not None:
            headers["userId"] = str(userid)
        
        
        return await make_api_request(
            "PUT", 
            path, 
            data=data, 
            params=params if params else None, 
            headers=headers if headers else None
        )
    
    
    
    @mcp.tool()
    async def brbt2025_create_cust_doc_dtls_postusing_post(
        request_body:Dict[str, Any] ,  # createCustomerDocumentDetailResource,
        accesstoken: Optional[str] = None,
        channeltype: Optional[int] = None,
        co_relationid: Optional[int] = None,
        initiatingsystem: Optional[str] = None,
        servicemode: Optional[int] = None,
        uuidseqno: Optional[int] = None,
        entity: Optional[str] = None,
        languagecode: Optional[int] = None,
        referenceid: Optional[str] = None,
        requesthash: Optional[str] = None,
        userid: Optional[int] = None
    ) -> Dict[str, Any]:
        """
        Create document details
        
        Generated from: POST /customerManagement/customer/customerDocumentDetails
        Source: swagger_2_0
        Operation ID: BRBT2025CreateCustDocDtls_POSTUsingPOST
        
        
        Authentication: Not required
        
        Parameters:
        - request_body: any (required)
          input
        
        
        
        Headers:
        - Accesstoken: string
          Authorization Token to validation the caller
        - ChannelType: integer
          Channel identifier from where the Transaction has originated (Internet, Mobile, ATM, Branch Channel )
        - Co-Relationid: integer
          Unique ID for the service invoked, will be set by the Transaction system
        - InitiatingSystem: string
          Indicating the initiated system
        - ServiceMode: integer
          Used for branch channel to indicate the type of customer
        - UUIDSeqNo: integer
          UUID Sequence Number
        - entity: string
          entity
        - languageCode: integer
          languageCode
        - referenceId: string
          Place holder for Token based authentication
        - requesthash: string
          Request payload for hash validation
        - userId: integer
          userId
        
        
        """
        
        
        # Prepare request data
        
        # Single body parameter - send directly
        data = request_body if request_body is not None else {}
        
        
        
        # Prepare query parameters
        params = {}
        
        
        # Replace path parameters in URL
        path = "/customerManagement/customer/customerDocumentDetails"
        
        
        # Prepare headers
        headers = {}
        if accesstoken is not None:
            headers["Accesstoken"] = str(accesstoken)
        if channeltype is not None:
            headers["ChannelType"] = str(channeltype)
        if co_relationid is not None:
            headers["Co-Relationid"] = str(co_relationid)
        if initiatingsystem is not None:
            headers["InitiatingSystem"] = str(initiatingsystem)
        if servicemode is not None:
            headers["ServiceMode"] = str(servicemode)
        if uuidseqno is not None:
            headers["UUIDSeqNo"] = str(uuidseqno)
        if entity is not None:
            headers["entity"] = str(entity)
        if languagecode is not None:
            headers["languageCode"] = str(languagecode)
        if referenceid is not None:
            headers["referenceId"] = str(referenceid)
        if requesthash is not None:
            headers["requesthash"] = str(requesthash)
        if userid is not None:
            headers["userId"] = str(userid)
        
        
        return await make_api_request(
            "POST", 
            path, 
            data=data, 
            params=params if params else None, 
            headers=headers if headers else None
        )
    
    
    
    @mcp.tool()
    async def brbt2026_modify_cust_doc_dtls_postusing_put(
        request_body:Dict[str, Any] ,  # ModifyCustomerDocumentDetailRequest,
        accesstoken: Optional[str] = None,
        channeltype: Optional[int] = None,
        co_relationid: Optional[int] = None,
        initiatingsystem: Optional[str] = None,
        servicemode: Optional[int] = None,
        uuidseqno: Optional[int] = None,
        entity: Optional[str] = None,
        languagecode: Optional[int] = None,
        referenceid: Optional[str] = None,
        requesthash: Optional[str] = None,
        userid: Optional[int] = None
    ) -> Dict[str, Any]:
        """
        Modify document details
        
        Generated from: PUT /customerManagement/customer/customerDocumentDetails
        Source: swagger_2_0
        Operation ID: BRBT2026ModifyCustDocDtls_POSTUsingPUT
        
        
        Authentication: Not required
        
        Parameters:
        - request_body: any (required)
          input
        
        
        
        Headers:
        - Accesstoken: string
          Authorization token for identification of the caller
        - ChannelType: integer
          Channel identifier from where the TXN has originated (Internet, Mobile, ATM, Branch Channel )
        - Co-Relationid: integer
          Unique ID for the service invoked, will be set by the TXN system
        - InitiatingSystem: string
          Indicating the initiated system
        - ServiceMode: integer
          Used for branch channel to indicate the type of customer
        - UUIDSeqNo: integer
          UUID Sequence Number
        - entity: string
          entity
        - languageCode: integer
          languageCode
        - referenceId: string
          Place holder for Token based authentication
        - requesthash: string
          Request payload for hash validation
        - userId: integer
          userId
        
        
        """
        
        
        # Prepare request data
        
        # Single body parameter - send directly
        data = request_body if request_body is not None else {}
        
        
        
        # Prepare query parameters
        params = {}
        
        
        # Replace path parameters in URL
        path = "/customerManagement/customer/customerDocumentDetails"
        
        
        # Prepare headers
        headers = {}
        if accesstoken is not None:
            headers["Accesstoken"] = str(accesstoken)
        if channeltype is not None:
            headers["ChannelType"] = str(channeltype)
        if co_relationid is not None:
            headers["Co-Relationid"] = str(co_relationid)
        if initiatingsystem is not None:
            headers["InitiatingSystem"] = str(initiatingsystem)
        if servicemode is not None:
            headers["ServiceMode"] = str(servicemode)
        if uuidseqno is not None:
            headers["UUIDSeqNo"] = str(uuidseqno)
        if entity is not None:
            headers["entity"] = str(entity)
        if languagecode is not None:
            headers["languageCode"] = str(languagecode)
        if referenceid is not None:
            headers["referenceId"] = str(referenceid)
        if requesthash is not None:
            headers["requesthash"] = str(requesthash)
        if userid is not None:
            headers["userId"] = str(userid)
        
        
        return await make_api_request(
            "PUT", 
            path, 
            data=data, 
            params=params if params else None, 
            headers=headers if headers else None
        )
    
    
    
    @mcp.tool()
    async def cbcbtmodify_active_ssiloans_mon_hold_postusing_post(
        request_body:Dict[str, Any] ,  # customerMOnHold_Resource,
        accesstoken: Optional[str] = None,
        channeltype: Optional[int] = None,
        co_relationid: Optional[int] = None,
        initiatingsystem: Optional[str] = None,
        servicemode: Optional[int] = None,
        uuidseqno: Optional[int] = None,
        entity: Optional[str] = None,
        languagecode: Optional[int] = None,
        referenceid: Optional[str] = None,
        requesthash: Optional[str] = None,
        userid: Optional[int] = None
    ) -> Dict[str, Any]:
        """
        Customer SSI Modify Active to Modify OnHold
        
        Generated from: POST /customerManagement/customer/customerSSImodifyMonHold
        Source: swagger_2_0
        Operation ID: CBCBTModifyActiveSSILoansMOnHold_POSTUsingPOST
        
        
        Authentication: Not required
        
        Parameters:
        - request_body: any (required)
          input
        
        
        
        Headers:
        - Accesstoken: string
          Authorization token for identification of the caller
        - ChannelType: integer
          Channel identifier from where the TXN has originated (Internet, Mobile, ATM, Branch Channel )
        - Co-Relationid: integer
          Unique ID for the service invoked, will be set by the TXN system
        - InitiatingSystem: string
          Indicating the initiated system
        - ServiceMode: integer
          Used for branch channel to indicate the type of customer
        - UUIDSeqNo: integer
          UUID Sequence Number
        - entity: string
          entity
        - languageCode: integer
          languageCode
        - referenceId: string
          Place holder for Token based authentication
        - requesthash: string
          Request payload for hash validation
        - userId: integer
          userId
        
        
        """
        
        
        # Prepare request data
        
        # Single body parameter - send directly
        data = request_body if request_body is not None else {}
        
        
        
        # Prepare query parameters
        params = {}
        
        
        # Replace path parameters in URL
        path = "/customerManagement/customer/customerSSImodifyMonHold"
        
        
        # Prepare headers
        headers = {}
        if accesstoken is not None:
            headers["Accesstoken"] = str(accesstoken)
        if channeltype is not None:
            headers["ChannelType"] = str(channeltype)
        if co_relationid is not None:
            headers["Co-Relationid"] = str(co_relationid)
        if initiatingsystem is not None:
            headers["InitiatingSystem"] = str(initiatingsystem)
        if servicemode is not None:
            headers["ServiceMode"] = str(servicemode)
        if uuidseqno is not None:
            headers["UUIDSeqNo"] = str(uuidseqno)
        if entity is not None:
            headers["entity"] = str(entity)
        if languagecode is not None:
            headers["languageCode"] = str(languagecode)
        if referenceid is not None:
            headers["referenceId"] = str(referenceid)
        if requesthash is not None:
            headers["requesthash"] = str(requesthash)
        if userid is not None:
            headers["userId"] = str(userid)
        
        
        return await make_api_request(
            "POST", 
            path, 
            data=data, 
            params=params if params else None, 
            headers=headers if headers else None
        )
    
    
    
    @mcp.tool()
    async def cbpet0108_fetch_bpdetails_postusing_get(
        customerid: Optional[int] = None,
        accesstoken: Optional[str] = None,
        channeltype: Optional[int] = None,
        co_relationid: Optional[int] = None,
        initiatingsystem: Optional[str] = None,
        servicemode: Optional[int] = None,
        uuidseqno: Optional[int] = None,
        entity: Optional[str] = None,
        languagecode: Optional[int] = None,
        referenceid: Optional[str] = None,
        userid: Optional[int] = None
    ) -> Dict[str, Any]:
        """
        CIF Details upgraded
        
        Generated from: GET /customerManagement/customer/detail
        Source: swagger_2_0
        Operation ID: CBPET0108FetchBPDetails_POSTUsingGET
        
        
        Authentication: Not required
        
        Parameters:
        - CustomerID: integer
          Enter the customer ID
        
        
        
        Headers:
        - Accesstoken: string
          Authorization token for identification of the caller
        - ChannelType: integer
          Channel identifier from where the TXN has originated (Internet, Mobile, ATM, Branch Channel )
        - Co-Relationid: integer
          Unique ID for the service invoked, will be set by the TXN system
        - InitiatingSystem: string
          Indicating the initiated system
        - ServiceMode: integer
          Used for branch channel to indicate the type of customer
        - UUIDSeqNo: integer
          UUID Sequence Number
        - entity: string
          entity
        - languageCode: integer
          languageCode
        - referenceId: string
          Place holder for Token based authentication
        - userId: integer
          userId
        
        
        """
        
        
        # Prepare query parameters
        params = {}
        if customerid is not None:
            params["CustomerID"] = customerid
            
        
        
        # Replace path parameters in URL
        path = "/customerManagement/customer/detail"
        
        
        # Prepare headers
        headers = {}
        if accesstoken is not None:
            headers["Accesstoken"] = str(accesstoken)
        if channeltype is not None:
            headers["ChannelType"] = str(channeltype)
        if co_relationid is not None:
            headers["Co-Relationid"] = str(co_relationid)
        if initiatingsystem is not None:
            headers["InitiatingSystem"] = str(initiatingsystem)
        if servicemode is not None:
            headers["ServiceMode"] = str(servicemode)
        if uuidseqno is not None:
            headers["UUIDSeqNo"] = str(uuidseqno)
        if entity is not None:
            headers["entity"] = str(entity)
        if languagecode is not None:
            headers["languageCode"] = str(languagecode)
        if referenceid is not None:
            headers["referenceId"] = str(referenceid)
        if userid is not None:
            headers["userId"] = str(userid)
        
        
        return await make_api_request(
            "GET", 
            path, 
            
            params=params if params else None, 
            headers=headers if headers else None
        )
    
    
    
    @mcp.tool()
    async def cbpet0106_get_bpdetails_using_get(
        customerid: Optional[int] = None,
        identifiertype: Optional[int] = None,
        identifiervalue: Optional[str] = None,
        pagenum: Optional[int] = None,
        pagesize: Optional[int] = None,
        accesstoken: Optional[str] = None,
        channeltype: Optional[int] = None,
        co_relationid: Optional[int] = None,
        initiatingsystem: Optional[str] = None,
        servicemode: Optional[int] = None,
        uuidseqno: Optional[int] = None,
        entity: Optional[str] = None,
        languagecode: Optional[int] = None,
        referenceid: Optional[str] = None,
        userid: Optional[int] = None
    ) -> Dict[str, Any]:
        """
        CIF Details
        
        Generated from: GET /customerManagement/customer/details
        Source: swagger_2_0
        Operation ID: CBPET0106GetBPDetailsUsingGET
        
        
        Authentication: Not required
        
        Parameters:
        - CustomerID: integer
          Enter the customer ID
        - IdentifierType: integer
          Identifier Type
        - IdentifierValue: string
          Identifier Value
        - pageNum: integer
          pageNum
        - pageSize: integer
          pageSize
        
        
        
        Headers:
        - Accesstoken: string
          Authorization token for identification of the caller
        - ChannelType: integer
          Channel identifier from where the TXN has originated (Internet, Mobile, ATM, Branch Channel )
        - Co-Relationid: integer
          Unique ID for the service invoked, will be set by the TXN system
        - InitiatingSystem: string
          Indicating the initiated system
        - ServiceMode: integer
          Used for branch channel to indicate the type of customer
        - UUIDSeqNo: integer
          UUID Sequence Number
        - entity: string
          entity
        - languageCode: integer
          languageCode
        - referenceId: string
          Place holder for Token based authentication
        - userId: integer
          userId
        
        
        """
        
        
        # Prepare query parameters
        params = {}
        if customerid is not None:
            params["CustomerID"] = customerid
            
        if identifiertype is not None:
            params["IdentifierType"] = identifiertype
            
        if identifiervalue is not None:
            params["IdentifierValue"] = identifiervalue
            
        if pagenum is not None:
            params["pageNum"] = pagenum
            
        if pagesize is not None:
            params["pageSize"] = pagesize
            
        
        
        # Replace path parameters in URL
        path = "/customerManagement/customer/details"
        
        
        # Prepare headers
        headers = {}
        if accesstoken is not None:
            headers["Accesstoken"] = str(accesstoken)
        if channeltype is not None:
            headers["ChannelType"] = str(channeltype)
        if co_relationid is not None:
            headers["Co-Relationid"] = str(co_relationid)
        if initiatingsystem is not None:
            headers["InitiatingSystem"] = str(initiatingsystem)
        if servicemode is not None:
            headers["ServiceMode"] = str(servicemode)
        if uuidseqno is not None:
            headers["UUIDSeqNo"] = str(uuidseqno)
        if entity is not None:
            headers["entity"] = str(entity)
        if languagecode is not None:
            headers["languageCode"] = str(languagecode)
        if referenceid is not None:
            headers["referenceId"] = str(referenceid)
        if userid is not None:
            headers["userId"] = str(userid)
        
        
        return await make_api_request(
            "GET", 
            path, 
            
            params=params if params else None, 
            headers=headers if headers else None
        )
    
    
    
    @mcp.tool()
    async def bret0808_get_dcmt_sbmt_lst_acc_using_get(
        customerid: Optional[int] = None,
        identifiertype: Optional[int] = None,
        identifiervalue: Optional[str] = None,
        pagenum: Optional[int] = None,
        pagesize: Optional[int] = None,
        accesstoken: Optional[str] = None,
        channeltype: Optional[int] = None,
        co_relationid: Optional[int] = None,
        initiatingsystem: Optional[str] = None,
        servicemode: Optional[int] = None,
        uuidseqno: Optional[int] = None,
        entity: Optional[str] = None,
        languagecode: Optional[int] = None,
        referenceid: Optional[str] = None,
        userid: Optional[int] = None
    ) -> Dict[str, Any]:
        """
        Fetch Customer Document List
        
        Generated from: GET /customerManagement/customer/documentList
        Source: swagger_2_0
        Operation ID: BRET0808GetDcmtSbmtLstAccUsingGET
        
        
        Authentication: Not required
        
        Parameters:
        - CustomerID: integer
          Customer ID
        - IdentifierType: integer
          Identifier Type
        - IdentifierValue: string
          Identifier Value
        - pageNum: integer
          pageNum
        - pageSize: integer
          pageSize
        
        
        
        Headers:
        - Accesstoken: string
          Authorization Token to validation the caller
        - ChannelType: integer
          Channel identifier from where the TXN has originated (Internet, Mobile, ATM, Branch Channel )
        - Co-Relationid: integer
          Unique ID for the service invoked, will be set by the TXN system
        - InitiatingSystem: string
          Indicating the initiated system
        - ServiceMode: integer
          Used for branch channel to indicate the type of customer
        - UUIDSeqNo: integer
          UUID Sequence Number
        - entity: string
          entity
        - languageCode: integer
          languageCode
        - referenceId: string
          Place holder for Token based authentication
        - userId: integer
          userId
        
        
        """
        
        
        # Prepare query parameters
        params = {}
        if customerid is not None:
            params["CustomerID"] = customerid
            
        if identifiertype is not None:
            params["IdentifierType"] = identifiertype
            
        if identifiervalue is not None:
            params["IdentifierValue"] = identifiervalue
            
        if pagenum is not None:
            params["pageNum"] = pagenum
            
        if pagesize is not None:
            params["pageSize"] = pagesize
            
        
        
        # Replace path parameters in URL
        path = "/customerManagement/customer/documentList"
        
        
        # Prepare headers
        headers = {}
        if accesstoken is not None:
            headers["Accesstoken"] = str(accesstoken)
        if channeltype is not None:
            headers["ChannelType"] = str(channeltype)
        if co_relationid is not None:
            headers["Co-Relationid"] = str(co_relationid)
        if initiatingsystem is not None:
            headers["InitiatingSystem"] = str(initiatingsystem)
        if servicemode is not None:
            headers["ServiceMode"] = str(servicemode)
        if uuidseqno is not None:
            headers["UUIDSeqNo"] = str(uuidseqno)
        if entity is not None:
            headers["entity"] = str(entity)
        if languagecode is not None:
            headers["languageCode"] = str(languagecode)
        if referenceid is not None:
            headers["referenceId"] = str(referenceid)
        if userid is not None:
            headers["userId"] = str(userid)
        
        
        return await make_api_request(
            "GET", 
            path, 
            
            params=params if params else None, 
            headers=headers if headers else None
        )
    
    
    
    @mcp.tool()
    async def bret0101_get_latest_cust_emp_dtl_using_get(
        customerid: Optional[int] = None,
        identifiertype: Optional[int] = None,
        identifiervalue: Optional[str] = None,
        accesstoken: Optional[str] = None,
        channeltype: Optional[int] = None,
        co_relationid: Optional[int] = None,
        initiatingsystem: Optional[str] = None,
        servicemode: Optional[int] = None,
        uuidseqno: Optional[int] = None,
        entity: Optional[str] = None,
        languagecode: Optional[int] = None,
        referenceid: Optional[str] = None,
        userid: Optional[int] = None
    ) -> Dict[str, Any]:
        """
        Fetch Customer Employment Details
        
        Generated from: GET /customerManagement/customer/employmentDetails
        Source: swagger_2_0
        Operation ID: BRET0101GetLatestCustEmpDtlUsingGET
        
        
        Authentication: Not required
        
        Parameters:
        - CustomerID: integer
          Customer ID (This field is mandatory if identifierValue is not provided)
        - IdentifierType: integer
          Identifier Type
        - IdentifierValue: string
          Identifier Value (This field is mandatory if customerId is not provided)
        
        
        
        Headers:
        - Accesstoken: string
          Authorization Token to validation the caller
        - ChannelType: integer
          Channel identifier from where the TXN has originated (Internet, Mobile, ATM, Branch Channel )
        - Co-Relationid: integer
          Unique ID for the service invoked, will be set by the TXN system
        - InitiatingSystem: string
          Indicating the initiated system
        - ServiceMode: integer
          Used for branch channel to indicate the type of customer
        - UUIDSeqNo: integer
          UUID Sequence Number
        - entity: string
          entity
        - languageCode: integer
          languageCode
        - referenceId: string
          Place holder for Token based authentication
        - userId: integer
          userId
        
        
        """
        
        
        # Prepare query parameters
        params = {}
        if customerid is not None:
            params["CustomerID"] = customerid
            
        if identifiertype is not None:
            params["IdentifierType"] = identifiertype
            
        if identifiervalue is not None:
            params["IdentifierValue"] = identifiervalue
            
        
        
        # Replace path parameters in URL
        path = "/customerManagement/customer/employmentDetails"
        
        
        # Prepare headers
        headers = {}
        if accesstoken is not None:
            headers["Accesstoken"] = str(accesstoken)
        if channeltype is not None:
            headers["ChannelType"] = str(channeltype)
        if co_relationid is not None:
            headers["Co-Relationid"] = str(co_relationid)
        if initiatingsystem is not None:
            headers["InitiatingSystem"] = str(initiatingsystem)
        if servicemode is not None:
            headers["ServiceMode"] = str(servicemode)
        if uuidseqno is not None:
            headers["UUIDSeqNo"] = str(uuidseqno)
        if entity is not None:
            headers["entity"] = str(entity)
        if languagecode is not None:
            headers["languageCode"] = str(languagecode)
        if referenceid is not None:
            headers["referenceId"] = str(referenceid)
        if userid is not None:
            headers["userId"] = str(userid)
        
        
        return await make_api_request(
            "GET", 
            path, 
            
            params=params if params else None, 
            headers=headers if headers else None
        )
    
    
    
    @mcp.tool()
    async def brbt2021_create_emp_dtls_postusing_post(
        request_body:Dict[str, Any] ,  # createCustomerEmploymentDetailsResource,
        accesstoken: Optional[str] = None,
        channeltype: Optional[int] = None,
        co_relationid: Optional[int] = None,
        initiatingsystem: Optional[str] = None,
        servicemode: Optional[int] = None,
        uuidseqno: Optional[int] = None,
        entity: Optional[str] = None,
        languagecode: Optional[int] = None,
        referenceid: Optional[str] = None,
        requesthash: Optional[str] = None,
        userid: Optional[int] = None
    ) -> Dict[str, Any]:
        """
        Create Employment Details
        
        Generated from: POST /customerManagement/customer/employmentDetails
        Source: swagger_2_0
        Operation ID: BRBT2021CreateEmpDtls_POSTUsingPOST
        
        
        Authentication: Not required
        
        Parameters:
        - request_body: any (required)
          input
        
        
        
        Headers:
        - Accesstoken: string
          Authorization Token to validation the caller
        - ChannelType: integer
          Channel identifier from where the Transaction has originated (Internet, Mobile, ATM, Branch Channel )
        - Co-Relationid: integer
          Unique ID for the service invoked, will be set by the Transaction system
        - InitiatingSystem: string
          Indicating the initiated system
        - ServiceMode: integer
          Used for branch channel to indicate the type of customer
        - UUIDSeqNo: integer
          UUID Sequence Number
        - entity: string
          entity
        - languageCode: integer
          languageCode
        - referenceId: string
          Place holder for Token based authentication
        - requesthash: string
          Request payload for hash validation
        - userId: integer
          userId
        
        
        """
        
        
        # Prepare request data
        
        # Single body parameter - send directly
        data = request_body if request_body is not None else {}
        
        
        
        # Prepare query parameters
        params = {}
        
        
        # Replace path parameters in URL
        path = "/customerManagement/customer/employmentDetails"
        
        
        # Prepare headers
        headers = {}
        if accesstoken is not None:
            headers["Accesstoken"] = str(accesstoken)
        if channeltype is not None:
            headers["ChannelType"] = str(channeltype)
        if co_relationid is not None:
            headers["Co-Relationid"] = str(co_relationid)
        if initiatingsystem is not None:
            headers["InitiatingSystem"] = str(initiatingsystem)
        if servicemode is not None:
            headers["ServiceMode"] = str(servicemode)
        if uuidseqno is not None:
            headers["UUIDSeqNo"] = str(uuidseqno)
        if entity is not None:
            headers["entity"] = str(entity)
        if languagecode is not None:
            headers["languageCode"] = str(languagecode)
        if referenceid is not None:
            headers["referenceId"] = str(referenceid)
        if requesthash is not None:
            headers["requesthash"] = str(requesthash)
        if userid is not None:
            headers["userId"] = str(userid)
        
        
        return await make_api_request(
            "POST", 
            path, 
            data=data, 
            params=params if params else None, 
            headers=headers if headers else None
        )
    
    
    
    @mcp.tool()
    async def brbt2022_modify_emp_dtls_postusing_put(
        request_body:Dict[str, Any] ,  # ModifyCustomerEmploymentDetailsRequest,
        accesstoken: Optional[str] = None,
        channeltype: Optional[int] = None,
        co_relationid: Optional[int] = None,
        initiatingsystem: Optional[str] = None,
        servicemode: Optional[int] = None,
        uuidseqno: Optional[int] = None,
        entity: Optional[str] = None,
        languagecode: Optional[int] = None,
        referenceid: Optional[str] = None,
        userid: Optional[int] = None
    ) -> Dict[str, Any]:
        """
        Modify Employment Details
        
        Generated from: PUT /customerManagement/customer/employmentDetails
        Source: swagger_2_0
        Operation ID: BRBT2022ModifyEmpDtls_POSTUsingPUT
        
        
        Authentication: Not required
        
        Parameters:
        - request_body: any (required)
          input
        
        
        
        Headers:
        - Accesstoken: string
          Authorization Token to validation the caller
        - ChannelType: integer
          Channel identifier from where the Transaction has originated (Internet, Mobile, ATM, Branch Channel )
        - Co-Relationid: integer
          Unique ID for the service invoked, will be set by the Transaction system
        - InitiatingSystem: string
          Indicating the initiated system
        - ServiceMode: integer
          Used for branch channel to indicate the type of customer
        - UUIDSeqNo: integer
          UUID Sequence Number
        - entity: string
          entity
        - languageCode: integer
          languageCode
        - referenceId: string
          Place holder for Token based authentication
        - userId: integer
          userId
        
        
        """
        
        
        # Prepare request data
        
        # Single body parameter - send directly
        data = request_body if request_body is not None else {}
        
        
        
        # Prepare query parameters
        params = {}
        
        
        # Replace path parameters in URL
        path = "/customerManagement/customer/employmentDetails"
        
        
        # Prepare headers
        headers = {}
        if accesstoken is not None:
            headers["Accesstoken"] = str(accesstoken)
        if channeltype is not None:
            headers["ChannelType"] = str(channeltype)
        if co_relationid is not None:
            headers["Co-Relationid"] = str(co_relationid)
        if initiatingsystem is not None:
            headers["InitiatingSystem"] = str(initiatingsystem)
        if servicemode is not None:
            headers["ServiceMode"] = str(servicemode)
        if uuidseqno is not None:
            headers["UUIDSeqNo"] = str(uuidseqno)
        if entity is not None:
            headers["entity"] = str(entity)
        if languagecode is not None:
            headers["languageCode"] = str(languagecode)
        if referenceid is not None:
            headers["referenceId"] = str(referenceid)
        if userid is not None:
            headers["userId"] = str(userid)
        
        
        return await make_api_request(
            "PUT", 
            path, 
            data=data, 
            params=params if params else None, 
            headers=headers if headers else None
        )
    
    
    
    @mcp.tool()
    async def bretget_customer_details_postusing_get(
        customerreference: int,
        externalreference: Optional[str] = None,
        pagenum: Optional[int] = None,
        pagesize: Optional[int] = None,
        accesstoken: Optional[str] = None,
        channeltype: Optional[int] = None,
        co_relationid: Optional[int] = None,
        initiatingsystem: Optional[str] = None,
        servicemode: Optional[int] = None,
        uuidseqno: Optional[int] = None,
        entity: Optional[str] = None,
        languagecode: Optional[int] = None,
        referenceid: Optional[str] = None,
        userid: Optional[int] = None
    ) -> Dict[str, Any]:
        """
        Get enterprise customer details
        
        Generated from: GET /customerManagement/customer/enterprisecustomerdetails
        Source: swagger_2_0
        Operation ID: BRETGetCustomerDetails_POSTUsingGET
        
        
        Authentication: Not required
        
        Parameters:
        - CustomerReference: integer (required)
          This field shows unique reference of the particular Customer
        - ExternalReference: string
          GCIS Number
        - pageNum: integer
          pageNum
        - pageSize: integer
          pageSize
        
        
        
        Headers:
        - Accesstoken: string
          Authorization Token to validation the caller
        - ChannelType: integer
          Channel identifier from where the TXN has originated (Internet, Mobile, ATM, Branch Channel )
        - Co-Relationid: integer
          Unique ID for the service invoked, will be set by the TXN system
        - InitiatingSystem: string
          Indicating the initiated system
        - ServiceMode: integer
          Used for branch channel to indicate the type of customer
        - UUIDSeqNo: integer
          UUID Sequence Number
        - entity: string
          entity
        - languageCode: integer
          languageCode
        - referenceId: string
          Place holder for Token based authentication
        - userId: integer
          userId
        
        
        """
        
        
        # Prepare query parameters
        params = {}
        if customerreference is not None:
            params["CustomerReference"] = customerreference
            
        if externalreference is not None:
            params["ExternalReference"] = externalreference
            
        if pagenum is not None:
            params["pageNum"] = pagenum
            
        if pagesize is not None:
            params["pageSize"] = pagesize
            
        
        
        # Replace path parameters in URL
        path = "/customerManagement/customer/enterprisecustomerdetails"
        
        
        # Prepare headers
        headers = {}
        if accesstoken is not None:
            headers["Accesstoken"] = str(accesstoken)
        if channeltype is not None:
            headers["ChannelType"] = str(channeltype)
        if co_relationid is not None:
            headers["Co-Relationid"] = str(co_relationid)
        if initiatingsystem is not None:
            headers["InitiatingSystem"] = str(initiatingsystem)
        if servicemode is not None:
            headers["ServiceMode"] = str(servicemode)
        if uuidseqno is not None:
            headers["UUIDSeqNo"] = str(uuidseqno)
        if entity is not None:
            headers["entity"] = str(entity)
        if languagecode is not None:
            headers["languageCode"] = str(languagecode)
        if referenceid is not None:
            headers["referenceId"] = str(referenceid)
        if userid is not None:
            headers["userId"] = str(userid)
        
        
        return await make_api_request(
            "GET", 
            path, 
            
            params=params if params else None, 
            headers=headers if headers else None
        )
    
    
    
    @mcp.tool()
    async def bret0105_bpqbeentrprc_chl_postusing_get(
        customercategory: Optional[int] = None,
        customername: Optional[str] = None,
        customerreference: Optional[int] = None,
        email: Optional[str] = None,
        externalreference: Optional[str] = None,
        identificationreference: Optional[str] = None,
        identificationtype: Optional[int] = None,
        mobilenumber: Optional[str] = None,
        pagenum: Optional[int] = None,
        pagesize: Optional[int] = None,
        accesstoken: Optional[str] = None,
        channeltype: Optional[int] = None,
        co_relationid: Optional[int] = None,
        initiatingsystem: Optional[str] = None,
        servicemode: Optional[int] = None,
        uuidseqno: Optional[int] = None,
        entity: Optional[str] = None,
        languagecode: Optional[int] = None,
        referenceid: Optional[str] = None,
        userid: Optional[int] = None
    ) -> Dict[str, Any]:
        """
        Fetch enterprise customer list
        
        Generated from: GET /customerManagement/customer/enterpriselist
        Source: swagger_2_0
        Operation ID: BRET0105BPQBEEntrprcChl_POSTUsingGET
        
        
        Authentication: Not required
        
        Parameters:
        - CustomerCategory: integer
          This field shows Category of Business Partner.1-Individual, 2-Corporate, 3-Bank(Domain Name: d_BPCat)
        - CustomerName: string
          This field shows name of the Business Partner
        - CustomerReference: integer
          This field shows unique reference of the particular Business Partner
        - Email: string
          Email
        - ExternalReference: string
          ExternalReference
        - IdentificationReference: string
          Identifier Value
        - IdentificationType: integer
          Identifier Type
        - MobileNumber: string
          Cell no
        - pageNum: integer
          pageNum
        - pageSize: integer
          pageSize
        
        
        
        Headers:
        - Accesstoken: string
          Authorization Token to validation the caller
        - ChannelType: integer
          Channel identifier from where the TXN has originated (Internet, Mobile, ATM, Branch Channel )
        - Co-Relationid: integer
          Unique ID for the service invoked, will be set by the TXN system
        - InitiatingSystem: string
          Indicating the initiated system
        - ServiceMode: integer
          Used for branch channel to indicate the type of customer
        - UUIDSeqNo: integer
          UUID Sequence Number
        - entity: string
          entity
        - languageCode: integer
          languageCode
        - referenceId: string
          Place holder for Token based authentication
        - userId: integer
          userId
        
        
        """
        
        
        # Prepare query parameters
        params = {}
        if customercategory is not None:
            params["CustomerCategory"] = customercategory
            
        if customername is not None:
            params["CustomerName"] = customername
            
        if customerreference is not None:
            params["CustomerReference"] = customerreference
            
        if email is not None:
            params["Email"] = email
            
        if externalreference is not None:
            params["ExternalReference"] = externalreference
            
        if identificationreference is not None:
            params["IdentificationReference"] = identificationreference
            
        if identificationtype is not None:
            params["IdentificationType"] = identificationtype
            
        if mobilenumber is not None:
            params["MobileNumber"] = mobilenumber
            
        if pagenum is not None:
            params["pageNum"] = pagenum
            
        if pagesize is not None:
            params["pageSize"] = pagesize
            
        
        
        # Replace path parameters in URL
        path = "/customerManagement/customer/enterpriselist"
        
        
        # Prepare headers
        headers = {}
        if accesstoken is not None:
            headers["Accesstoken"] = str(accesstoken)
        if channeltype is not None:
            headers["ChannelType"] = str(channeltype)
        if co_relationid is not None:
            headers["Co-Relationid"] = str(co_relationid)
        if initiatingsystem is not None:
            headers["InitiatingSystem"] = str(initiatingsystem)
        if servicemode is not None:
            headers["ServiceMode"] = str(servicemode)
        if uuidseqno is not None:
            headers["UUIDSeqNo"] = str(uuidseqno)
        if entity is not None:
            headers["entity"] = str(entity)
        if languagecode is not None:
            headers["languageCode"] = str(languagecode)
        if referenceid is not None:
            headers["referenceId"] = str(referenceid)
        if userid is not None:
            headers["userId"] = str(userid)
        
        
        return await make_api_request(
            "GET", 
            path, 
            
            params=params if params else None, 
            headers=headers if headers else None
        )
    
    
    
    @mcp.tool()
    async def bret0105_bpqbe_sgssusing_get(
        accountbban: Optional[str] = None,
        accountiban: Optional[str] = None,
        businesspartnerreference: Optional[int] = None,
        customercategory: Optional[int] = None,
        customername: Optional[str] = None,
        customerrole: Optional[int] = None,
        customerstatus: Optional[int] = None,
        entitycustomerid: Optional[int] = None,
        roleentity: Optional[str] = None,
        pagenum: Optional[int] = None,
        pagesize: Optional[int] = None,
        accesstoken: Optional[str] = None,
        channeltype: Optional[int] = None,
        co_relationid: Optional[int] = None,
        initiatingsystem: Optional[str] = None,
        servicemode: Optional[int] = None,
        uuidseqno: Optional[int] = None,
        entity: Optional[str] = None,
        languagecode: Optional[int] = None,
        referenceid: Optional[str] = None,
        userid: Optional[int] = None
    ) -> Dict[str, Any]:
        """
        Fetch business partners in the system
        
        Generated from: GET /customerManagement/customer/externalCustomerValidation
        Source: swagger_2_0
        Operation ID: BRET0105BPQBE_SGSSUsingGET
        
        
        Authentication: Not required
        
        Parameters:
        - AccountBBAN: string
          This Field shows  BBAN Number of Account which is under the BP
        - AccountIBAN: string
          This field shows Account IBAN Number which is under the BP
        - BusinessPartnerReference: integer
          This field shows unique reference of the particular Business Partner
        - CustomerCategory: integer
          This field shows Category of Business Partner (Individual-1, Corporate-2, Bank-3)
        - CustomerName: string
          This field shows name of the Business Partner
        - CustomerRole: integer
          This field denotes the Role with the  Business Partner will perform on creation (1-Customer, 4-Employee, 9-Correspondent)
        - CustomerStatus: integer
          This field shows current status  of the Business Partner (1-OnHold, 4-Active, 6-Close)
        - EntityCustomerId: integer
          This field shows the Business Partner reference associated with the login entity
        - RoleEntity: string
          This field shows Entity of the Business Partner Role
        - pageNum: integer
          pageNum
        - pageSize: integer
          pageSize
        
        
        
        Headers:
        - Accesstoken: string
          Authorization Token to validation the caller
        - ChannelType: integer
          Channel identifier from where the Transaction has originated (Internet, Mobile, ATM, Branch Channel )
        - Co-Relationid: integer
          Unique ID for the service invoked, will be set by the Transaction system
        - InitiatingSystem: string
          Indicating the initiated system
        - ServiceMode: integer
          Used for branch channel to indicate the type of customer
        - UUIDSeqNo: integer
          UUID Sequence Number
        - entity: string
          entity
        - languageCode: integer
          languageCode
        - referenceId: string
          Place holder for Token based authentication
        - userId: integer
          userId
        
        
        """
        
        
        # Prepare query parameters
        params = {}
        if accountbban is not None:
            params["AccountBBAN"] = accountbban
            
        if accountiban is not None:
            params["AccountIBAN"] = accountiban
            
        if businesspartnerreference is not None:
            params["BusinessPartnerReference"] = businesspartnerreference
            
        if customercategory is not None:
            params["CustomerCategory"] = customercategory
            
        if customername is not None:
            params["CustomerName"] = customername
            
        if customerrole is not None:
            params["CustomerRole"] = customerrole
            
        if customerstatus is not None:
            params["CustomerStatus"] = customerstatus
            
        if entitycustomerid is not None:
            params["EntityCustomerId"] = entitycustomerid
            
        if roleentity is not None:
            params["RoleEntity"] = roleentity
            
        if pagenum is not None:
            params["pageNum"] = pagenum
            
        if pagesize is not None:
            params["pageSize"] = pagesize
            
        
        
        # Replace path parameters in URL
        path = "/customerManagement/customer/externalCustomerValidation"
        
        
        # Prepare headers
        headers = {}
        if accesstoken is not None:
            headers["Accesstoken"] = str(accesstoken)
        if channeltype is not None:
            headers["ChannelType"] = str(channeltype)
        if co_relationid is not None:
            headers["Co-Relationid"] = str(co_relationid)
        if initiatingsystem is not None:
            headers["InitiatingSystem"] = str(initiatingsystem)
        if servicemode is not None:
            headers["ServiceMode"] = str(servicemode)
        if uuidseqno is not None:
            headers["UUIDSeqNo"] = str(uuidseqno)
        if entity is not None:
            headers["entity"] = str(entity)
        if languagecode is not None:
            headers["languageCode"] = str(languagecode)
        if referenceid is not None:
            headers["referenceId"] = str(referenceid)
        if userid is not None:
            headers["userId"] = str(userid)
        
        
        return await make_api_request(
            "GET", 
            path, 
            
            params=params if params else None, 
            headers=headers if headers else None
        )
    
    
    
    @mcp.tool()
    async def brbt2023_create_fatca_dtls_corporate_postusing_post(
        request_body:Dict[str, Any] ,  # CreateCorporateFatcaDtls_Resource,
        accesstoken: Optional[str] = None,
        channeltype: Optional[int] = None,
        co_relationid: Optional[int] = None,
        initiatingsystem: Optional[str] = None,
        servicemode: Optional[int] = None,
        uuidseqno: Optional[int] = None,
        entity: Optional[str] = None,
        languagecode: Optional[int] = None,
        referenceid: Optional[str] = None,
        requesthash: Optional[str] = None,
        userid: Optional[int] = None
    ) -> Dict[str, Any]:
        """
        Create Corporate Fatca Details
        
        Generated from: POST /customerManagement/customer/fatcaDetails/corporate
        Source: swagger_2_0
        Operation ID: BRBT2023CreateFatcaDtlsCorporate_POSTUsingPOST
        
        
        Authentication: Not required
        
        Parameters:
        - request_body: any (required)
          input
        
        
        
        Headers:
        - Accesstoken: string
          Authorization token for identification of the caller
        - ChannelType: integer
          Channel identifier from where the TXN has originated (Internet, Mobile, ATM, Branch Channel )
        - Co-Relationid: integer
          Unique ID for the service invoked, will be set by the TXN system
        - InitiatingSystem: string
          Indicating the initiated system
        - ServiceMode: integer
          Used for branch channel to indicate the type of customer
        - UUIDSeqNo: integer
          UUID Sequence Number
        - entity: string
          entity
        - languageCode: integer
          languageCode
        - referenceId: string
          Place holder for Token based authentication
        - requesthash: string
          Request payload for hash validation
        - userId: integer
          userId
        
        
        """
        
        
        # Prepare request data
        
        # Single body parameter - send directly
        data = request_body if request_body is not None else {}
        
        
        
        # Prepare query parameters
        params = {}
        
        
        # Replace path parameters in URL
        path = "/customerManagement/customer/fatcaDetails/corporate"
        
        
        # Prepare headers
        headers = {}
        if accesstoken is not None:
            headers["Accesstoken"] = str(accesstoken)
        if channeltype is not None:
            headers["ChannelType"] = str(channeltype)
        if co_relationid is not None:
            headers["Co-Relationid"] = str(co_relationid)
        if initiatingsystem is not None:
            headers["InitiatingSystem"] = str(initiatingsystem)
        if servicemode is not None:
            headers["ServiceMode"] = str(servicemode)
        if uuidseqno is not None:
            headers["UUIDSeqNo"] = str(uuidseqno)
        if entity is not None:
            headers["entity"] = str(entity)
        if languagecode is not None:
            headers["languageCode"] = str(languagecode)
        if referenceid is not None:
            headers["referenceId"] = str(referenceid)
        if requesthash is not None:
            headers["requesthash"] = str(requesthash)
        if userid is not None:
            headers["userId"] = str(userid)
        
        
        return await make_api_request(
            "POST", 
            path, 
            data=data, 
            params=params if params else None, 
            headers=headers if headers else None
        )
    
    
    
    @mcp.tool()
    async def brbt2024_modify_fatca_dtls_corporate_postusing_put(
        request_body:Dict[str, Any] ,  # ModifyCorporateFatcaDtls_Resource,
        accesstoken: Optional[str] = None,
        channeltype: Optional[int] = None,
        co_relationid: Optional[int] = None,
        initiatingsystem: Optional[str] = None,
        servicemode: Optional[int] = None,
        uuidseqno: Optional[int] = None,
        entity: Optional[str] = None,
        languagecode: Optional[int] = None,
        referenceid: Optional[str] = None,
        requesthash: Optional[str] = None,
        userid: Optional[int] = None
    ) -> Dict[str, Any]:
        """
        Modify Corporate Fatca Details
        
        Generated from: PUT /customerManagement/customer/fatcaDetails/corporate
        Source: swagger_2_0
        Operation ID: BRBT2024ModifyFatcaDtlsCorporate_POSTUsingPUT
        
        
        Authentication: Not required
        
        Parameters:
        - request_body: any (required)
          input
        
        
        
        Headers:
        - Accesstoken: string
          Authorization token for identification of the caller
        - ChannelType: integer
          Channel identifier from where the TXN has originated (Internet, Mobile, ATM, Branch Channel )
        - Co-Relationid: integer
          Unique ID for the service invoked, will be set by the TXN system
        - InitiatingSystem: string
          Indicating the initiated system
        - ServiceMode: integer
          Used for branch channel to indicate the type of customer
        - UUIDSeqNo: integer
          UUID Sequence Number
        - entity: string
          entity
        - languageCode: integer
          languageCode
        - referenceId: string
          Place holder for Token based authentication
        - requesthash: string
          Request payload for hash validation
        - userId: integer
          userId
        
        
        """
        
        
        # Prepare request data
        
        # Single body parameter - send directly
        data = request_body if request_body is not None else {}
        
        
        
        # Prepare query parameters
        params = {}
        
        
        # Replace path parameters in URL
        path = "/customerManagement/customer/fatcaDetails/corporate"
        
        
        # Prepare headers
        headers = {}
        if accesstoken is not None:
            headers["Accesstoken"] = str(accesstoken)
        if channeltype is not None:
            headers["ChannelType"] = str(channeltype)
        if co_relationid is not None:
            headers["Co-Relationid"] = str(co_relationid)
        if initiatingsystem is not None:
            headers["InitiatingSystem"] = str(initiatingsystem)
        if servicemode is not None:
            headers["ServiceMode"] = str(servicemode)
        if uuidseqno is not None:
            headers["UUIDSeqNo"] = str(uuidseqno)
        if entity is not None:
            headers["entity"] = str(entity)
        if languagecode is not None:
            headers["languageCode"] = str(languagecode)
        if referenceid is not None:
            headers["referenceId"] = str(referenceid)
        if requesthash is not None:
            headers["requesthash"] = str(requesthash)
        if userid is not None:
            headers["userId"] = str(userid)
        
        
        return await make_api_request(
            "PUT", 
            path, 
            data=data, 
            params=params if params else None, 
            headers=headers if headers else None
        )
    
    
    
    @mcp.tool()
    async def brbt2023_create_fatca_dtls_retail_postusing_post(
        request_body:Dict[str, Any] ,  # createRetailFatcaDtlsResource,
        accesstoken: Optional[str] = None,
        channeltype: Optional[int] = None,
        co_relationid: Optional[int] = None,
        initiatingsystem: Optional[str] = None,
        servicemode: Optional[int] = None,
        uuidseqno: Optional[int] = None,
        entity: Optional[str] = None,
        languagecode: Optional[int] = None,
        referenceid: Optional[str] = None,
        requesthash: Optional[str] = None,
        userid: Optional[int] = None
    ) -> Dict[str, Any]:
        """
        Create Retail Fatca Details
        
        Generated from: POST /customerManagement/customer/fatcaDetails/retail
        Source: swagger_2_0
        Operation ID: BRBT2023CreateFatcaDtlsRetail_POSTUsingPOST
        
        
        Authentication: Not required
        
        Parameters:
        - request_body: any (required)
          input
        
        
        
        Headers:
        - Accesstoken: string
          Authorization token for identification of the caller
        - ChannelType: integer
          Channel identifier from where the TXN has originated (Internet, Mobile, ATM, Branch Channel )
        - Co-Relationid: integer
          Unique ID for the service invoked, will be set by the TXN system
        - InitiatingSystem: string
          Indicating the initiated system
        - ServiceMode: integer
          Used for branch channel to indicate the type of customer
        - UUIDSeqNo: integer
          UUID Sequence Number
        - entity: string
          entity
        - languageCode: integer
          languageCode
        - referenceId: string
          Place holder for Token based authentication
        - requesthash: string
          Request payload for hash validation
        - userId: integer
          userId
        
        
        """
        
        
        # Prepare request data
        
        # Single body parameter - send directly
        data = request_body if request_body is not None else {}
        
        
        
        # Prepare query parameters
        params = {}
        
        
        # Replace path parameters in URL
        path = "/customerManagement/customer/fatcaDetails/retail"
        
        
        # Prepare headers
        headers = {}
        if accesstoken is not None:
            headers["Accesstoken"] = str(accesstoken)
        if channeltype is not None:
            headers["ChannelType"] = str(channeltype)
        if co_relationid is not None:
            headers["Co-Relationid"] = str(co_relationid)
        if initiatingsystem is not None:
            headers["InitiatingSystem"] = str(initiatingsystem)
        if servicemode is not None:
            headers["ServiceMode"] = str(servicemode)
        if uuidseqno is not None:
            headers["UUIDSeqNo"] = str(uuidseqno)
        if entity is not None:
            headers["entity"] = str(entity)
        if languagecode is not None:
            headers["languageCode"] = str(languagecode)
        if referenceid is not None:
            headers["referenceId"] = str(referenceid)
        if requesthash is not None:
            headers["requesthash"] = str(requesthash)
        if userid is not None:
            headers["userId"] = str(userid)
        
        
        return await make_api_request(
            "POST", 
            path, 
            data=data, 
            params=params if params else None, 
            headers=headers if headers else None
        )
    
    
    
    @mcp.tool()
    async def brbt2024_modify_fatca_dtls_retail_postusing_put(
        request_body:Dict[str, Any] ,  # modifyRetailFatcaDtlsResource,
        accesstoken: Optional[str] = None,
        channeltype: Optional[int] = None,
        co_relationid: Optional[int] = None,
        initiatingsystem: Optional[str] = None,
        servicemode: Optional[int] = None,
        uuidseqno: Optional[int] = None,
        entity: Optional[str] = None,
        languagecode: Optional[int] = None,
        referenceid: Optional[str] = None,
        requesthash: Optional[str] = None,
        userid: Optional[int] = None
    ) -> Dict[str, Any]:
        """
        Modify Retail Fatca Details
        
        Generated from: PUT /customerManagement/customer/fatcaDetails/retail
        Source: swagger_2_0
        Operation ID: BRBT2024ModifyFatcaDtlsRetail_POSTUsingPUT
        
        
        Authentication: Not required
        
        Parameters:
        - request_body: any (required)
          input
        
        
        
        Headers:
        - Accesstoken: string
          Authorization token for identification of the caller
        - ChannelType: integer
          Channel identifier from where the TXN has originated (Internet, Mobile, ATM, Branch Channel )
        - Co-Relationid: integer
          Unique ID for the service invoked, will be set by the TXN system
        - InitiatingSystem: string
          Indicating the initiated system
        - ServiceMode: integer
          Used for branch channel to indicate the type of customer
        - UUIDSeqNo: integer
          UUID Sequence Number
        - entity: string
          entity
        - languageCode: integer
          languageCode
        - referenceId: string
          Place holder for Token based authentication
        - requesthash: string
          Request payload for hash validation
        - userId: integer
          userId
        
        
        """
        
        
        # Prepare request data
        
        # Single body parameter - send directly
        data = request_body if request_body is not None else {}
        
        
        
        # Prepare query parameters
        params = {}
        
        
        # Replace path parameters in URL
        path = "/customerManagement/customer/fatcaDetails/retail"
        
        
        # Prepare headers
        headers = {}
        if accesstoken is not None:
            headers["Accesstoken"] = str(accesstoken)
        if channeltype is not None:
            headers["ChannelType"] = str(channeltype)
        if co_relationid is not None:
            headers["Co-Relationid"] = str(co_relationid)
        if initiatingsystem is not None:
            headers["InitiatingSystem"] = str(initiatingsystem)
        if servicemode is not None:
            headers["ServiceMode"] = str(servicemode)
        if uuidseqno is not None:
            headers["UUIDSeqNo"] = str(uuidseqno)
        if entity is not None:
            headers["entity"] = str(entity)
        if languagecode is not None:
            headers["languageCode"] = str(languagecode)
        if referenceid is not None:
            headers["referenceId"] = str(referenceid)
        if requesthash is not None:
            headers["requesthash"] = str(requesthash)
        if userid is not None:
            headers["userId"] = str(userid)
        
        
        return await make_api_request(
            "PUT", 
            path, 
            data=data, 
            params=params if params else None, 
            headers=headers if headers else None
        )
    
    
    
    @mcp.tool()
    async def cbcbt6201_crt_follow_up_stat_wrapper_using_post(
        request_body:Dict[str, Any] ,  # createCustomerFollowUpResource,
        accesstoken: Optional[str] = None,
        channeltype: Optional[int] = None,
        co_relationid: Optional[int] = None,
        initiatingsystem: Optional[str] = None,
        servicemode: Optional[int] = None,
        uuidseqno: Optional[int] = None,
        entity: Optional[str] = None,
        languagecode: Optional[int] = None,
        referenceid: Optional[str] = None,
        requesthash: Optional[str] = None,
        userid: Optional[int] = None
    ) -> Dict[str, Any]:
        """
        Create Customer Follow Up
        
        Generated from: POST /customerManagement/customer/followUp
        Source: swagger_2_0
        Operation ID: CBCBT6201CrtFollowUpStatWrapperUsingPOST
        
        
        Authentication: Not required
        
        Parameters:
        - request_body: any (required)
          input
        
        
        
        Headers:
        - Accesstoken: string
          Authorization Token to validation the caller
        - ChannelType: integer
          Channel identifier from where the TXN has originated (Internet, Mobile, ATM, Branch Channel )
        - Co-Relationid: integer
          Unique ID for the service invoked, will be set by the TXN system
        - InitiatingSystem: string
          Indicating the initiated system
        - ServiceMode: integer
          Used for branch channel to indicate the type of customer
        - UUIDSeqNo: integer
          UUID Sequence Number
        - entity: string
          entity
        - languageCode: integer
          languageCode
        - referenceId: string
          Place holder for Token based authentication
        - requesthash: string
          Request payload for hash validation
        - userId: integer
          userId
        
        
        """
        
        
        # Prepare request data
        
        # Single body parameter - send directly
        data = request_body if request_body is not None else {}
        
        
        
        # Prepare query parameters
        params = {}
        
        
        # Replace path parameters in URL
        path = "/customerManagement/customer/followUp"
        
        
        # Prepare headers
        headers = {}
        if accesstoken is not None:
            headers["Accesstoken"] = str(accesstoken)
        if channeltype is not None:
            headers["ChannelType"] = str(channeltype)
        if co_relationid is not None:
            headers["Co-Relationid"] = str(co_relationid)
        if initiatingsystem is not None:
            headers["InitiatingSystem"] = str(initiatingsystem)
        if servicemode is not None:
            headers["ServiceMode"] = str(servicemode)
        if uuidseqno is not None:
            headers["UUIDSeqNo"] = str(uuidseqno)
        if entity is not None:
            headers["entity"] = str(entity)
        if languagecode is not None:
            headers["languageCode"] = str(languagecode)
        if referenceid is not None:
            headers["referenceId"] = str(referenceid)
        if requesthash is not None:
            headers["requesthash"] = str(requesthash)
        if userid is not None:
            headers["userId"] = str(userid)
        
        
        return await make_api_request(
            "POST", 
            path, 
            data=data, 
            params=params if params else None, 
            headers=headers if headers else None
        )
    
    
    
    @mcp.tool()
    async def cbcbt6202_mod_follow_up_stat_wrapper_using_put(
        request_body:Dict[str, Any] ,  # ModifyCustomerFollowUp_Resource,
        accesstoken: Optional[str] = None,
        channeltype: Optional[int] = None,
        co_relationid: Optional[int] = None,
        initiatingsystem: Optional[str] = None,
        servicemode: Optional[int] = None,
        uuidseqno: Optional[int] = None,
        entity: Optional[str] = None,
        languagecode: Optional[int] = None,
        referenceid: Optional[str] = None,
        requesthash: Optional[str] = None,
        userid: Optional[int] = None
    ) -> Dict[str, Any]:
        """
        Modify Customer Follow Up
        
        Generated from: PUT /customerManagement/customer/followUp
        Source: swagger_2_0
        Operation ID: CBCBT6202ModFollowUpStatWrapperUsingPUT
        
        
        Authentication: Not required
        
        Parameters:
        - request_body: any (required)
          input
        
        
        
        Headers:
        - Accesstoken: string
          Authorization Token to validation the caller
        - ChannelType: integer
          Channel identifier from where the TXN has originated (Internet, Mobile, ATM, Branch Channel )
        - Co-Relationid: integer
          Unique ID for the service invoked, will be set by the TXN system
        - InitiatingSystem: string
          Indicating the initiated system
        - ServiceMode: integer
          Used for branch channel to indicate the type of customer
        - UUIDSeqNo: integer
          UUID Sequence Number
        - entity: string
          entity
        - languageCode: integer
          languageCode
        - referenceId: string
          Place holder for Token based authentication
        - requesthash: string
          Request payload for hash validation
        - userId: integer
          userId
        
        
        """
        
        
        # Prepare request data
        
        # Single body parameter - send directly
        data = request_body if request_body is not None else {}
        
        
        
        # Prepare query parameters
        params = {}
        
        
        # Replace path parameters in URL
        path = "/customerManagement/customer/followUp"
        
        
        # Prepare headers
        headers = {}
        if accesstoken is not None:
            headers["Accesstoken"] = str(accesstoken)
        if channeltype is not None:
            headers["ChannelType"] = str(channeltype)
        if co_relationid is not None:
            headers["Co-Relationid"] = str(co_relationid)
        if initiatingsystem is not None:
            headers["InitiatingSystem"] = str(initiatingsystem)
        if servicemode is not None:
            headers["ServiceMode"] = str(servicemode)
        if uuidseqno is not None:
            headers["UUIDSeqNo"] = str(uuidseqno)
        if entity is not None:
            headers["entity"] = str(entity)
        if languagecode is not None:
            headers["languageCode"] = str(languagecode)
        if referenceid is not None:
            headers["referenceId"] = str(referenceid)
        if requesthash is not None:
            headers["requesthash"] = str(requesthash)
        if userid is not None:
            headers["userId"] = str(userid)
        
        
        return await make_api_request(
            "PUT", 
            path, 
            data=data, 
            params=params if params else None, 
            headers=headers if headers else None
        )
    
    
    
    @mcp.tool()
    async def brbt6203_auth_follow_up_stat_postusing_put(
        customerid: int,
        request_body:Dict[str, Any] ,  # authFollowUpStat,
        accesstoken: Optional[str] = None,
        channeltype: Optional[int] = None,
        co_relationid: Optional[int] = None,
        initiatingsystem: Optional[str] = None,
        servicemode: Optional[int] = None,
        uuidseqno: Optional[int] = None,
        entity: Optional[str] = None,
        languagecode: Optional[int] = None,
        referenceid: Optional[str] = None,
        requesthash: Optional[str] = None,
        userid: Optional[int] = None
    ) -> Dict[str, Any]:
        """
        Authorize Customer Follow Up
        
        Generated from: PUT /customerManagement/customer/followUp/{customerId}
        Source: swagger_2_0
        Operation ID: BRBT6203AuthFollowUpStat_POSTUsingPUT
        
        
        Authentication: Not required
        
        Parameters:
        - customerId: integer (required)
          Customer Reference
        - request_body: any (required)
          input
        
        
        
        Headers:
        - Accesstoken: string
          Authorization Token to validation the caller
        - ChannelType: integer
          Channel identifier from where the TXN has originated (Internet, Mobile, ATM, Branch Channel )
        - Co-Relationid: integer
          Unique ID for the service invoked, will be set by the TXN system
        - InitiatingSystem: string
          Indicating the initiated system
        - ServiceMode: integer
          Used for branch channel to indicate the type of customer
        - UUIDSeqNo: integer
          UUID Sequence Number
        - entity: string
          entity
        - languageCode: integer
          languageCode
        - referenceId: string
          Place holder for Token based authentication
        - requesthash: string
          Request payload for hash validation
        - userId: integer
          userId
        
        
        """
        
        
        # Prepare request data
        
        # Single body parameter - send directly
        data = request_body if request_body is not None else {}
        
        
        
        # Prepare query parameters
        params = {}
        
        
        # Replace path parameters in URL
        path = "/customerManagement/customer/followUp/{customerId}"
        if customerid is not None:
            path = path.replace("{customerId}", str(customerid))
        
        
        # Prepare headers
        headers = {}
        if accesstoken is not None:
            headers["Accesstoken"] = str(accesstoken)
        if channeltype is not None:
            headers["ChannelType"] = str(channeltype)
        if co_relationid is not None:
            headers["Co-Relationid"] = str(co_relationid)
        if initiatingsystem is not None:
            headers["InitiatingSystem"] = str(initiatingsystem)
        if servicemode is not None:
            headers["ServiceMode"] = str(servicemode)
        if uuidseqno is not None:
            headers["UUIDSeqNo"] = str(uuidseqno)
        if entity is not None:
            headers["entity"] = str(entity)
        if languagecode is not None:
            headers["languageCode"] = str(languagecode)
        if referenceid is not None:
            headers["referenceId"] = str(referenceid)
        if requesthash is not None:
            headers["requesthash"] = str(requesthash)
        if userid is not None:
            headers["userId"] = str(userid)
        
        
        return await make_api_request(
            "PUT", 
            path, 
            data=data, 
            params=params if params else None, 
            headers=headers if headers else None
        )
    
    
    
    @mcp.tool()
    async def brbt6203_del_follow_up_stat_postusing_delete(
        customerid: int,
        request_body:Dict[str, Any] ,  # deleteFollowUpStat,
        accesstoken: Optional[str] = None,
        channeltype: Optional[int] = None,
        co_relationid: Optional[int] = None,
        initiatingsystem: Optional[str] = None,
        servicemode: Optional[int] = None,
        uuidseqno: Optional[int] = None,
        entity: Optional[str] = None,
        languagecode: Optional[int] = None,
        referenceid: Optional[str] = None,
        requesthash: Optional[str] = None,
        userid: Optional[int] = None
    ) -> Dict[str, Any]:
        """
        Delete Customer Follow Up
        
        Generated from: DELETE /customerManagement/customer/followUp/{customerId}
        Source: swagger_2_0
        Operation ID: BRBT6203DelFollowUpStat_POSTUsingDELETE
        
        
        Authentication: Not required
        
        Parameters:
        - customerId: integer (required)
          Customer Reference
        - request_body: any (required)
          input
        
        
        
        Headers:
        - Accesstoken: string
          Authorization Token to validation the caller
        - ChannelType: integer
          Channel identifier from where the TXN has originated (Internet, Mobile, ATM, Branch Channel )
        - Co-Relationid: integer
          Unique ID for the service invoked, will be set by the TXN system
        - InitiatingSystem: string
          Indicating the initiated system
        - ServiceMode: integer
          Used for branch channel to indicate the type of customer
        - UUIDSeqNo: integer
          UUID Sequence Number
        - entity: string
          entity
        - languageCode: integer
          languageCode
        - referenceId: string
          Place holder for Token based authentication
        - requesthash: string
          Request payload for hash validation
        - userId: integer
          userId
        
        
        """
        
        
        # Prepare request data
        
        # Single body parameter - send directly
        data = request_body if request_body is not None else {}
        
        
        
        # Prepare query parameters
        params = {}
        
        
        # Replace path parameters in URL
        path = "/customerManagement/customer/followUp/{customerId}"
        if customerid is not None:
            path = path.replace("{customerId}", str(customerid))
        
        
        # Prepare headers
        headers = {}
        if accesstoken is not None:
            headers["Accesstoken"] = str(accesstoken)
        if channeltype is not None:
            headers["ChannelType"] = str(channeltype)
        if co_relationid is not None:
            headers["Co-Relationid"] = str(co_relationid)
        if initiatingsystem is not None:
            headers["InitiatingSystem"] = str(initiatingsystem)
        if servicemode is not None:
            headers["ServiceMode"] = str(servicemode)
        if uuidseqno is not None:
            headers["UUIDSeqNo"] = str(uuidseqno)
        if entity is not None:
            headers["entity"] = str(entity)
        if languagecode is not None:
            headers["languageCode"] = str(languagecode)
        if referenceid is not None:
            headers["referenceId"] = str(referenceid)
        if requesthash is not None:
            headers["requesthash"] = str(requesthash)
        if userid is not None:
            headers["userId"] = str(userid)
        
        
        return await make_api_request(
            "DELETE", 
            path, 
            data=data, 
            params=params if params else None, 
            headers=headers if headers else None
        )
    
    
    
    @mcp.tool()
    async def brbt5680_create_follow_up_stat_postusing_post(
        request_body:Dict[str, Any] ,  # enterpriseFollowUpModifyResource,
        accesstoken: Optional[str] = None,
        channeltype: Optional[int] = None,
        co_relationid: Optional[int] = None,
        initiatingsystem: Optional[str] = None,
        servicemode: Optional[int] = None,
        uuidseqno: Optional[int] = None,
        entity: Optional[str] = None,
        languagecode: Optional[int] = None,
        referenceid: Optional[str] = None,
        requesthash: Optional[str] = None,
        userid: Optional[int] = None
    ) -> Dict[str, Any]:
        """
        Modify enterprise followup status
        
        Generated from: POST /customerManagement/customer/followupenterprise
        Source: swagger_2_0
        Operation ID: BRBT5680CreateFollowUpStat_POSTUsingPOST
        
        
        Authentication: Not required
        
        Parameters:
        - request_body: any (required)
          input
        
        
        
        Headers:
        - Accesstoken: string
          Authorization token for identification of the caller
        - ChannelType: integer
          Channel identifier from where the TXN has originated (Internet, Mobile, ATM, Branch Channel )
        - Co-Relationid: integer
          Unique ID for the service invoked, will be set by the TXN system
        - InitiatingSystem: string
          Indicating the initiated system
        - ServiceMode: integer
          Used for branch channel to indicate the type of customer
        - UUIDSeqNo: integer
          UUID Sequence Number
        - entity: string
          entity
        - languageCode: integer
          languageCode
        - referenceId: string
          Place holder for Token based authentication
        - requesthash: string
          Request payload for hash validation
        - userId: integer
          userId
        
        
        """
        
        
        # Prepare request data
        
        # Single body parameter - send directly
        data = request_body if request_body is not None else {}
        
        
        
        # Prepare query parameters
        params = {}
        
        
        # Replace path parameters in URL
        path = "/customerManagement/customer/followupenterprise"
        
        
        # Prepare headers
        headers = {}
        if accesstoken is not None:
            headers["Accesstoken"] = str(accesstoken)
        if channeltype is not None:
            headers["ChannelType"] = str(channeltype)
        if co_relationid is not None:
            headers["Co-Relationid"] = str(co_relationid)
        if initiatingsystem is not None:
            headers["InitiatingSystem"] = str(initiatingsystem)
        if servicemode is not None:
            headers["ServiceMode"] = str(servicemode)
        if uuidseqno is not None:
            headers["UUIDSeqNo"] = str(uuidseqno)
        if entity is not None:
            headers["entity"] = str(entity)
        if languagecode is not None:
            headers["languageCode"] = str(languagecode)
        if referenceid is not None:
            headers["referenceId"] = str(referenceid)
        if requesthash is not None:
            headers["requesthash"] = str(requesthash)
        if userid is not None:
            headers["userId"] = str(userid)
        
        
        return await make_api_request(
            "POST", 
            path, 
            data=data, 
            params=params if params else None, 
            headers=headers if headers else None
        )
    
    
    
    @mcp.tool()
    async def bret5704_get_sign_card_postusing_get(
        cardid: Optional[int] = None,
        customerreference: Optional[int] = None,
        pagenum: Optional[int] = None,
        pagesize: Optional[int] = None,
        accesstoken: Optional[str] = None,
        channeltype: Optional[int] = None,
        co_relationid: Optional[int] = None,
        initiatingsystem: Optional[str] = None,
        servicemode: Optional[int] = None,
        uuidseqno: Optional[int] = None,
        entity: Optional[str] = None,
        languagecode: Optional[int] = None,
        referenceid: Optional[str] = None,
        userid: Optional[int] = None
    ) -> Dict[str, Any]:
        """
        Signature View
        
        Generated from: GET /customerManagement/customer/getsignaturecard
        Source: swagger_2_0
        Operation ID: BRET5704GetSignCard_POSTUsingGET
        
        
        Authentication: Not required
        
        Parameters:
        - cardID: integer
          Card ID
        - customerReference: integer
          Customer Reference
        - pageNum: integer
          pageNum
        - pageSize: integer
          pageSize
        
        
        
        Headers:
        - Accesstoken: string
          Authorization token for identification of the caller
        - ChannelType: integer
          Channel identifier from where the TXN has originated (Internet, Mobile, ATM, Branch Channel )
        - Co-Relationid: integer
          Unique ID for the service invoked, will be set by the TXN system
        - InitiatingSystem: string
          Indicating the initiated system
        - ServiceMode: integer
          Used for branch channel to indicate the type of customer
        - UUIDSeqNo: integer
          UUID Sequence Number
        - entity: string
          entity
        - languageCode: integer
          languageCode
        - referenceId: string
          Place holder for Token based authentication
        - userId: integer
          userId
        
        
        """
        
        
        # Prepare query parameters
        params = {}
        if cardid is not None:
            params["cardID"] = cardid
            
        if customerreference is not None:
            params["customerReference"] = customerreference
            
        if pagenum is not None:
            params["pageNum"] = pagenum
            
        if pagesize is not None:
            params["pageSize"] = pagesize
            
        
        
        # Replace path parameters in URL
        path = "/customerManagement/customer/getsignaturecard"
        
        
        # Prepare headers
        headers = {}
        if accesstoken is not None:
            headers["Accesstoken"] = str(accesstoken)
        if channeltype is not None:
            headers["ChannelType"] = str(channeltype)
        if co_relationid is not None:
            headers["Co-Relationid"] = str(co_relationid)
        if initiatingsystem is not None:
            headers["InitiatingSystem"] = str(initiatingsystem)
        if servicemode is not None:
            headers["ServiceMode"] = str(servicemode)
        if uuidseqno is not None:
            headers["UUIDSeqNo"] = str(uuidseqno)
        if entity is not None:
            headers["entity"] = str(entity)
        if languagecode is not None:
            headers["languageCode"] = str(languagecode)
        if referenceid is not None:
            headers["referenceId"] = str(referenceid)
        if userid is not None:
            headers["userId"] = str(userid)
        
        
        return await make_api_request(
            "GET", 
            path, 
            
            params=params if params else None, 
            headers=headers if headers else None
        )
    
    
    
    @mcp.tool()
    async def rstbtcreate_modify_bpidentification_using_put(
        request_body:Dict[str, Any] ,  # MO_CLOS_RSTBTCreateModifyBPIdentification_Resource,
        accesstoken: Optional[str] = None,
        channeltype: Optional[int] = None,
        co_relationid: Optional[int] = None,
        initiatingsystem: Optional[str] = None,
        servicemode: Optional[int] = None,
        uuidseqno: Optional[int] = None,
        entity: Optional[str] = None,
        languagecode: Optional[int] = None,
        referenceid: Optional[str] = None,
        requesthash: Optional[str] = None,
        userid: Optional[int] = None
    ) -> Dict[str, Any]:
        """
        Create Modify Customer Identification
        
        Generated from: PUT /customerManagement/customer/identification
        Source: swagger_2_0
        Operation ID: RSTBTCreateModifyBPIdentificationUsingPUT
        
        
        Authentication: Not required
        
        Parameters:
        - request_body: any (required)
          input
        
        
        
        Headers:
        - Accesstoken: string
          Authorization token for identification of the caller
        - ChannelType: integer
          Channel identifier from where the TXN has originated (Internet, Mobile, ATM, Branch Channel )
        - Co-Relationid: integer
          Unique ID for the service invoked, will be set by the TXN system
        - InitiatingSystem: string
          Indicating the initiated system
        - ServiceMode: integer
          Used for branch channel to indicate the type of customer
        - UUIDSeqNo: integer
          UUID Sequence Number
        - entity: string
          entity
        - languageCode: integer
          languageCode
        - referenceId: string
          Place holder for Token based authentication
        - requesthash: string
          Request payload for hash validation
        - userId: integer
          userId
        
        
        """
        
        
        # Prepare request data
        
        # Single body parameter - send directly
        data = request_body if request_body is not None else {}
        
        
        
        # Prepare query parameters
        params = {}
        
        
        # Replace path parameters in URL
        path = "/customerManagement/customer/identification"
        
        
        # Prepare headers
        headers = {}
        if accesstoken is not None:
            headers["Accesstoken"] = str(accesstoken)
        if channeltype is not None:
            headers["ChannelType"] = str(channeltype)
        if co_relationid is not None:
            headers["Co-Relationid"] = str(co_relationid)
        if initiatingsystem is not None:
            headers["InitiatingSystem"] = str(initiatingsystem)
        if servicemode is not None:
            headers["ServiceMode"] = str(servicemode)
        if uuidseqno is not None:
            headers["UUIDSeqNo"] = str(uuidseqno)
        if entity is not None:
            headers["entity"] = str(entity)
        if languagecode is not None:
            headers["languageCode"] = str(languagecode)
        if referenceid is not None:
            headers["referenceId"] = str(referenceid)
        if requesthash is not None:
            headers["requesthash"] = str(requesthash)
        if userid is not None:
            headers["userId"] = str(userid)
        
        
        return await make_api_request(
            "PUT", 
            path, 
            data=data, 
            params=params if params else None, 
            headers=headers if headers else None
        )
    
    
    
    @mcp.tool()
    async def bret8001_get_bpidntfn_using_get(
        customerid: Optional[int] = None,
        identifiertype: Optional[int] = None,
        identifiervalue: Optional[str] = None,
        accesstoken: Optional[str] = None,
        channeltype: Optional[int] = None,
        co_relationid: Optional[int] = None,
        initiatingsystem: Optional[str] = None,
        servicemode: Optional[int] = None,
        uuidseqno: Optional[int] = None,
        entity: Optional[str] = None,
        languagecode: Optional[int] = None,
        referenceid: Optional[str] = None,
        requesthash: Optional[str] = None,
        userid: Optional[int] = None
    ) -> Dict[str, Any]:
        """
        Fetch Customer Identification Details
        
        Generated from: GET /customerManagement/customer/identificationDetails
        Source: swagger_2_0
        Operation ID: BRET8001GetBPIdntfnUsingGET
        
        
        Authentication: Not required
        
        Parameters:
        - CustomerID: integer
          Customer ID
        - IdentifierType: integer
          Identifier Type (d_BPNationalID) Eg : 45 - Passport , 85 - Birth certificate
        - IdentifierValue: string
          Identification Reference
        
        
        
        Headers:
        - Accesstoken: string
          Authorization Token to validation the caller
        - ChannelType: integer
          Channel identifier from where the TXN has originated (Internet, Mobile, ATM, Branch Channel )
        - Co-Relationid: integer
          Unique ID for the service invoked, will be set by the TXN system
        - InitiatingSystem: string
          Indicating the initiated system
        - ServiceMode: integer
          Used for branch channel to indicate the type of customer
        - UUIDSeqNo: integer
          UUID Sequence Number
        - entity: string
          entity
        - languageCode: integer
          languageCode
        - referenceId: string
          Place holder for Token based authentication
        - requesthash: string
          Request payload for hash validation
        - userId: integer
          userId
        
        
        """
        
        
        # Prepare query parameters
        params = {}
        if customerid is not None:
            params["CustomerID"] = customerid
            
        if identifiertype is not None:
            params["IdentifierType"] = identifiertype
            
        if identifiervalue is not None:
            params["IdentifierValue"] = identifiervalue
            
        
        
        # Replace path parameters in URL
        path = "/customerManagement/customer/identificationDetails"
        
        
        # Prepare headers
        headers = {}
        if accesstoken is not None:
            headers["Accesstoken"] = str(accesstoken)
        if channeltype is not None:
            headers["ChannelType"] = str(channeltype)
        if co_relationid is not None:
            headers["Co-Relationid"] = str(co_relationid)
        if initiatingsystem is not None:
            headers["InitiatingSystem"] = str(initiatingsystem)
        if servicemode is not None:
            headers["ServiceMode"] = str(servicemode)
        if uuidseqno is not None:
            headers["UUIDSeqNo"] = str(uuidseqno)
        if entity is not None:
            headers["entity"] = str(entity)
        if languagecode is not None:
            headers["languageCode"] = str(languagecode)
        if referenceid is not None:
            headers["referenceId"] = str(referenceid)
        if requesthash is not None:
            headers["requesthash"] = str(requesthash)
        if userid is not None:
            headers["userId"] = str(userid)
        
        
        return await make_api_request(
            "GET", 
            path, 
            
            params=params if params else None, 
            headers=headers if headers else None
        )
    
    
    
    @mcp.tool()
    async def bret8002_ftch_bpidntfn_lst_using_get(
        customerid: Optional[int] = None,
        identifiertype: Optional[int] = None,
        identifiervalue: Optional[str] = None,
        pagenum: Optional[int] = None,
        pagesize: Optional[int] = None,
        accesstoken: Optional[str] = None,
        channeltype: Optional[int] = None,
        co_relationid: Optional[int] = None,
        initiatingsystem: Optional[str] = None,
        servicemode: Optional[int] = None,
        uuidseqno: Optional[int] = None,
        entity: Optional[str] = None,
        languagecode: Optional[int] = None,
        referenceid: Optional[str] = None,
        userid: Optional[int] = None
    ) -> Dict[str, Any]:
        """
        Fetch customer identification list
        
        Generated from: GET /customerManagement/customer/identificationList
        Source: swagger_2_0
        Operation ID: BRET8002FtchBPIdntfnLstUsingGET
        
        
        Authentication: Not required
        
        Parameters:
        - CustomerID: integer
          Customer ID
        - IdentifierType: integer
          Identifier Type
        - IdentifierValue: string
          Identifier Value
        - pageNum: integer
          pageNum
        - pageSize: integer
          pageSize
        
        
        
        Headers:
        - Accesstoken: string
          Authorization Token to validation the caller
        - ChannelType: integer
          Channel identifier from where the TXN has originated (Internet, Mobile, ATM, Branch Channel )
        - Co-Relationid: integer
          Unique ID for the service invoked, will be set by the TXN system
        - InitiatingSystem: string
          Indicating the initiated system
        - ServiceMode: integer
          Used for branch channel to indicate the type of customer
        - UUIDSeqNo: integer
          UUID Sequence Number
        - entity: string
          entity
        - languageCode: integer
          languageCode
        - referenceId: string
          Place holder for Token based authentication
        - userId: integer
          userId
        
        
        """
        
        
        # Prepare query parameters
        params = {}
        if customerid is not None:
            params["CustomerID"] = customerid
            
        if identifiertype is not None:
            params["IdentifierType"] = identifiertype
            
        if identifiervalue is not None:
            params["IdentifierValue"] = identifiervalue
            
        if pagenum is not None:
            params["pageNum"] = pagenum
            
        if pagesize is not None:
            params["pageSize"] = pagesize
            
        
        
        # Replace path parameters in URL
        path = "/customerManagement/customer/identificationList"
        
        
        # Prepare headers
        headers = {}
        if accesstoken is not None:
            headers["Accesstoken"] = str(accesstoken)
        if channeltype is not None:
            headers["ChannelType"] = str(channeltype)
        if co_relationid is not None:
            headers["Co-Relationid"] = str(co_relationid)
        if initiatingsystem is not None:
            headers["InitiatingSystem"] = str(initiatingsystem)
        if servicemode is not None:
            headers["ServiceMode"] = str(servicemode)
        if uuidseqno is not None:
            headers["UUIDSeqNo"] = str(uuidseqno)
        if entity is not None:
            headers["entity"] = str(entity)
        if languagecode is not None:
            headers["languageCode"] = str(languagecode)
        if referenceid is not None:
            headers["referenceId"] = str(referenceid)
        if userid is not None:
            headers["userId"] = str(userid)
        
        
        return await make_api_request(
            "GET", 
            path, 
            
            params=params if params else None, 
            headers=headers if headers else None
        )
    
    
    
    @mcp.tool()
    async def cbcbt8001_create_modifyt_bpidntfn_wrapper_using_put(
        request_body:Dict[str, Any] ,  # AmendCustomerID_Resource,
        accesstoken: Optional[str] = None,
        channeltype: Optional[int] = None,
        co_relationid: Optional[int] = None,
        initiatingsystem: Optional[str] = None,
        servicemode: Optional[int] = None,
        uuidseqno: Optional[int] = None,
        entity: Optional[str] = None,
        languagecode: Optional[int] = None,
        referenceid: Optional[str] = None,
        requesthash: Optional[str] = None,
        userid: Optional[int] = None
    ) -> Dict[str, Any]:
        """
        Amend Customer ID Details
        
        Generated from: PUT /customerManagement/customer/identity
        Source: swagger_2_0
        Operation ID: CBCBT8001CreateModifytBPIdntfnWrapperUsingPUT
        
        
        Authentication: Not required
        
        Parameters:
        - request_body: any (required)
          input
        
        
        
        Headers:
        - Accesstoken: string
          Authorization Token to validation the caller
        - ChannelType: integer
          Channel identifier from where the TXN has originated (Internet, Mobile, ATM, Branch Channel )
        - Co-Relationid: integer
          Unique ID for the service invoked, will be set by the TXN system
        - InitiatingSystem: string
          Indicating the initiated system
        - ServiceMode: integer
          Used for branch channel to indicate the type of customer
        - UUIDSeqNo: integer
          UUID Sequence Number
        - entity: string
          entity
        - languageCode: integer
          languageCode
        - referenceId: string
          Place holder for Token based authentication
        - requesthash: string
          Request payload for hash validation
        - userId: integer
          userId
        
        
        """
        
        
        # Prepare request data
        
        # Single body parameter - send directly
        data = request_body if request_body is not None else {}
        
        
        
        # Prepare query parameters
        params = {}
        
        
        # Replace path parameters in URL
        path = "/customerManagement/customer/identity"
        
        
        # Prepare headers
        headers = {}
        if accesstoken is not None:
            headers["Accesstoken"] = str(accesstoken)
        if channeltype is not None:
            headers["ChannelType"] = str(channeltype)
        if co_relationid is not None:
            headers["Co-Relationid"] = str(co_relationid)
        if initiatingsystem is not None:
            headers["InitiatingSystem"] = str(initiatingsystem)
        if servicemode is not None:
            headers["ServiceMode"] = str(servicemode)
        if uuidseqno is not None:
            headers["UUIDSeqNo"] = str(uuidseqno)
        if entity is not None:
            headers["entity"] = str(entity)
        if languagecode is not None:
            headers["languageCode"] = str(languagecode)
        if referenceid is not None:
            headers["referenceId"] = str(referenceid)
        if requesthash is not None:
            headers["requesthash"] = str(requesthash)
        if userid is not None:
            headers["userId"] = str(userid)
        
        
        return await make_api_request(
            "PUT", 
            path, 
            data=data, 
            params=params if params else None, 
            headers=headers if headers else None
        )
    
    
    
    @mcp.tool()
    async def brbt2612_modify_bpsalary_mas_putusing_put(
        request_body:Dict[str, Any] ,  # incomeDetailsResource,
        accesstoken: Optional[str] = None,
        channeltype: Optional[int] = None,
        co_relationid: Optional[int] = None,
        initiatingsystem: Optional[str] = None,
        servicemode: Optional[int] = None,
        uuidseqno: Optional[int] = None,
        entity: Optional[str] = None,
        languagecode: Optional[int] = None,
        referenceid: Optional[str] = None,
        requesthash: Optional[str] = None,
        userid: Optional[int] = None
    ) -> Dict[str, Any]:
        """
        Modify Income Details for Individual Customer
        
        Generated from: PUT /customerManagement/customer/incomeDetails/modify
        Source: swagger_2_0
        Operation ID: BRBT2612ModifyBPSalaryMas_PUTUsingPUT
        
        
        Authentication: Not required
        
        Parameters:
        - request_body: any (required)
          input
        
        
        
        Headers:
        - Accesstoken: string
          Authorization Token to validation the caller
        - ChannelType: integer
          Channel identifier from where the TXN has originated (Internet, Mobile, ATM, Branch Channel )
        - Co-Relationid: integer
          Unique ID for the service invoked, will be set by the TXN system
        - InitiatingSystem: string
          Indicating the initiated system
        - ServiceMode: integer
          Used for branch channel to indicate the type of customer
        - UUIDSeqNo: integer
          UUID Sequence Number
        - entity: string
          entity
        - languageCode: integer
          languageCode
        - referenceId: string
          Place holder forToken based authetication
        - requesthash: string
          Request payload for hash validation
        - userId: integer
          userId
        
        
        """
        
        
        # Prepare request data
        
        # Single body parameter - send directly
        data = request_body if request_body is not None else {}
        
        
        
        # Prepare query parameters
        params = {}
        
        
        # Replace path parameters in URL
        path = "/customerManagement/customer/incomeDetails/modify"
        
        
        # Prepare headers
        headers = {}
        if accesstoken is not None:
            headers["Accesstoken"] = str(accesstoken)
        if channeltype is not None:
            headers["ChannelType"] = str(channeltype)
        if co_relationid is not None:
            headers["Co-Relationid"] = str(co_relationid)
        if initiatingsystem is not None:
            headers["InitiatingSystem"] = str(initiatingsystem)
        if servicemode is not None:
            headers["ServiceMode"] = str(servicemode)
        if uuidseqno is not None:
            headers["UUIDSeqNo"] = str(uuidseqno)
        if entity is not None:
            headers["entity"] = str(entity)
        if languagecode is not None:
            headers["languageCode"] = str(languagecode)
        if referenceid is not None:
            headers["referenceId"] = str(referenceid)
        if requesthash is not None:
            headers["requesthash"] = str(requesthash)
        if userid is not None:
            headers["userId"] = str(userid)
        
        
        return await make_api_request(
            "PUT", 
            path, 
            data=data, 
            params=params if params else None, 
            headers=headers if headers else None
        )
    
    
    
    @mcp.tool()
    async def cbpet0105_bpqbeusing_get(
        customercategory: int,
        pagenum: Optional[int] = None,
        pagesize: Optional[int] = None,
        accesstoken: Optional[str] = None,
        channeltype: Optional[int] = None,
        co_relationid: Optional[int] = None,
        initiatingsystem: Optional[str] = None,
        servicemode: Optional[int] = None,
        uuidseqno: Optional[int] = None,
        entity: Optional[str] = None,
        languagecode: Optional[int] = None,
        referenceid: Optional[str] = None,
        userid: Optional[int] = None
    ) -> Dict[str, Any]:
        """
        Fetch Customer List
        
        Generated from: GET /customerManagement/customer/list/{customerCategory}
        Source: swagger_2_0
        Operation ID: CBPET0105BPQBEUsingGET
        
        
        Authentication: Not required
        
        Parameters:
        - customerCategory: integer (required)
          Enter the customer category(1-Individual,2-Company)
        - pageNum: integer
          pageNum
        - pageSize: integer
          pageSize
        
        
        
        Headers:
        - Accesstoken: string
          Authorization Token to validation the caller
        - ChannelType: integer
          Channel identifier from where the TXN has originated (Internet, Mobile, ATM, Branch Channel )
        - Co-Relationid: integer
          Unique ID for the service invoked, will be set by the TXN system
        - InitiatingSystem: string
          Indicating the initiated system
        - ServiceMode: integer
          Used for branch channel to indicate the type of customer
        - UUIDSeqNo: integer
          UUID Sequence Number
        - entity: string
          entity
        - languageCode: integer
          languageCode
        - referenceId: string
          Place holder for Token based authentication
        - userId: integer
          userId
        
        
        """
        
        
        # Prepare query parameters
        params = {}
        if pagenum is not None:
            params["pageNum"] = pagenum
            
        if pagesize is not None:
            params["pageSize"] = pagesize
            
        
        
        # Replace path parameters in URL
        path = "/customerManagement/customer/list/{customerCategory}"
        if customercategory is not None:
            path = path.replace("{customerCategory}", str(customercategory))
        
        
        # Prepare headers
        headers = {}
        if accesstoken is not None:
            headers["Accesstoken"] = str(accesstoken)
        if channeltype is not None:
            headers["ChannelType"] = str(channeltype)
        if co_relationid is not None:
            headers["Co-Relationid"] = str(co_relationid)
        if initiatingsystem is not None:
            headers["InitiatingSystem"] = str(initiatingsystem)
        if servicemode is not None:
            headers["ServiceMode"] = str(servicemode)
        if uuidseqno is not None:
            headers["UUIDSeqNo"] = str(uuidseqno)
        if entity is not None:
            headers["entity"] = str(entity)
        if languagecode is not None:
            headers["languageCode"] = str(languagecode)
        if referenceid is not None:
            headers["referenceId"] = str(referenceid)
        if userid is not None:
            headers["userId"] = str(userid)
        
        
        return await make_api_request(
            "GET", 
            path, 
            
            params=params if params else None, 
            headers=headers if headers else None
        )
    
    
    
    @mcp.tool()
    async def bret0202_get_misinfo_using_get(
        customerid: Optional[int] = None,
        identifiertype: Optional[int] = None,
        identifiervalue: Optional[str] = None,
        accesstoken: Optional[str] = None,
        channeltype: Optional[int] = None,
        co_relationid: Optional[int] = None,
        initiatingsystem: Optional[str] = None,
        servicemode: Optional[int] = None,
        uuidseqno: Optional[int] = None,
        entity: Optional[str] = None,
        languagecode: Optional[int] = None,
        referenceid: Optional[str] = None,
        userid: Optional[int] = None
    ) -> Dict[str, Any]:
        """
        Fetch Customer Miscellaneous Details
        
        Generated from: GET /customerManagement/customer/miscellaneousDetails
        Source: swagger_2_0
        Operation ID: BRET0202GetMISInfoUsingGET
        
        
        Authentication: Not required
        
        Parameters:
        - CustomerID: integer
          Customer ID
        - IdentifierType: integer
          Identifier Type
        - IdentifierValue: string
          Identifier Value
        
        
        
        Headers:
        - Accesstoken: string
          Authorization Token to validation the caller
        - ChannelType: integer
          Channel identifier from where the TXN has originated (Internet, Mobile, ATM, Branch Channel )
        - Co-Relationid: integer
          Unique ID for the service invoked, will be set by the TXN system
        - InitiatingSystem: string
          Indicating the initiated system
        - ServiceMode: integer
          Used for branch channel to indicate the type of customer
        - UUIDSeqNo: integer
          UUID Sequence Number
        - entity: string
          entity
        - languageCode: integer
          languageCode
        - referenceId: string
          Place holder for Token based authentication
        - userId: integer
          userId
        
        
        """
        
        
        # Prepare query parameters
        params = {}
        if customerid is not None:
            params["CustomerID"] = customerid
            
        if identifiertype is not None:
            params["IdentifierType"] = identifiertype
            
        if identifiervalue is not None:
            params["IdentifierValue"] = identifiervalue
            
        
        
        # Replace path parameters in URL
        path = "/customerManagement/customer/miscellaneousDetails"
        
        
        # Prepare headers
        headers = {}
        if accesstoken is not None:
            headers["Accesstoken"] = str(accesstoken)
        if channeltype is not None:
            headers["ChannelType"] = str(channeltype)
        if co_relationid is not None:
            headers["Co-Relationid"] = str(co_relationid)
        if initiatingsystem is not None:
            headers["InitiatingSystem"] = str(initiatingsystem)
        if servicemode is not None:
            headers["ServiceMode"] = str(servicemode)
        if uuidseqno is not None:
            headers["UUIDSeqNo"] = str(uuidseqno)
        if entity is not None:
            headers["entity"] = str(entity)
        if languagecode is not None:
            headers["languageCode"] = str(languagecode)
        if referenceid is not None:
            headers["referenceId"] = str(referenceid)
        if userid is not None:
            headers["userId"] = str(userid)
        
        
        return await make_api_request(
            "GET", 
            path, 
            
            params=params if params else None, 
            headers=headers if headers else None
        )
    
    
    
    @mcp.tool()
    async def rstbtamend_name_using_put(
        request_body:Dict[str, Any] ,  # amendCustomerNameResource,
        accesstoken: Optional[str] = None,
        channeltype: Optional[int] = None,
        co_relationid: Optional[int] = None,
        initiatingsystem: Optional[str] = None,
        servicemode: Optional[int] = None,
        uuidseqno: Optional[int] = None,
        entity: Optional[str] = None,
        languagecode: Optional[int] = None,
        referenceid: Optional[str] = None,
        requesthash: Optional[str] = None,
        userid: Optional[int] = None
    ) -> Dict[str, Any]:
        """
        Amend Customer Name
        
        Generated from: PUT /customerManagement/customer/name
        Source: swagger_2_0
        Operation ID: RSTBTAmendNameUsingPUT
        
        
        Authentication: Not required
        
        Parameters:
        - request_body: any (required)
          input
        
        
        
        Headers:
        - Accesstoken: string
          Authorization Token to validation the caller
        - ChannelType: integer
          Channel identifier from where the TXN has originated (Internet, Mobile, ATM, Branch Channel )
        - Co-Relationid: integer
          Unique ID for the service invoked, will be set by the TXN system
        - InitiatingSystem: string
          Indicating the initiated system
        - ServiceMode: integer
          Used for branch channel to indicate the type of customer
        - UUIDSeqNo: integer
          UUID Sequence Number
        - entity: string
          entity
        - languageCode: integer
          languageCode
        - referenceId: string
          Place holder for Token based authentication
        - requesthash: string
          Request payload for hash validation
        - userId: integer
          userId
        
        
        """
        
        
        # Prepare request data
        
        # Single body parameter - send directly
        data = request_body if request_body is not None else {}
        
        
        
        # Prepare query parameters
        params = {}
        
        
        # Replace path parameters in URL
        path = "/customerManagement/customer/name"
        
        
        # Prepare headers
        headers = {}
        if accesstoken is not None:
            headers["Accesstoken"] = str(accesstoken)
        if channeltype is not None:
            headers["ChannelType"] = str(channeltype)
        if co_relationid is not None:
            headers["Co-Relationid"] = str(co_relationid)
        if initiatingsystem is not None:
            headers["InitiatingSystem"] = str(initiatingsystem)
        if servicemode is not None:
            headers["ServiceMode"] = str(servicemode)
        if uuidseqno is not None:
            headers["UUIDSeqNo"] = str(uuidseqno)
        if entity is not None:
            headers["entity"] = str(entity)
        if languagecode is not None:
            headers["languageCode"] = str(languagecode)
        if referenceid is not None:
            headers["referenceId"] = str(referenceid)
        if requesthash is not None:
            headers["requesthash"] = str(requesthash)
        if userid is not None:
            headers["userId"] = str(userid)
        
        
        return await make_api_request(
            "PUT", 
            path, 
            data=data, 
            params=params if params else None, 
            headers=headers if headers else None
        )
    
    
    
    @mcp.tool()
    async def bret2011_view_nominee_using_get(
        owneraccounttype: int,
        stausindicator: int,
        grelationid: int,
        subaccountid: int,
        accountreference: Optional[str] = None,
        customerid: Optional[int] = None,
        identifiertype: Optional[int] = None,
        identifiervalue: Optional[str] = None,
        pagenum: Optional[int] = None,
        pagesize: Optional[int] = None,
        accesstoken: Optional[str] = None,
        channeltype: Optional[int] = None,
        co_relationid: Optional[int] = None,
        initiatingsystem: Optional[str] = None,
        servicemode: Optional[int] = None,
        uuidseqno: Optional[int] = None,
        entity: Optional[str] = None,
        languagecode: Optional[int] = None,
        referenceid: Optional[str] = None,
        userid: Optional[int] = None
    ) -> Dict[str, Any]:
        """
        Fetch Customer Nominee Details
        
        Generated from: GET /customerManagement/customer/nomineeDetails
        Source: swagger_2_0
        Operation ID: BRET2011ViewNomineeUsingGET
        
        
        Authentication: Not required
        
        Parameters:
        - AccountReference: string
          AccountReference
        - CustomerID: integer
          Customer ID
        - IdentifierType: integer
          Identifier Type
        - IdentifierValue: string
          Identifier Value
        - OwnerAccountType: integer (required)
          Enter the Owner Account Type(7-MM Deposit Deal:11-Credit Application:17-Product)
        - StausIndicator: integer (required)
          Enter the status indicator value
        - gRelationId: integer (required)
          Enter the status indicator value
        - pageNum: integer
          pageNum
        - pageSize: integer
          pageSize
        - subAccountId: integer (required)
          Enter the status indicator value
        
        
        
        Headers:
        - Accesstoken: string
          Authorization Token to validation the caller
        - ChannelType: integer
          Channel identifier from where the TXN has originated (Internet, Mobile, ATM, Branch Channel )
        - Co-Relationid: integer
          Unique ID for the service invoked, will be set by the TXN system
        - InitiatingSystem: string
          Indicating the initiated system
        - ServiceMode: integer
          Used for branch channel to indicate the type of customer
        - UUIDSeqNo: integer
          UUID Sequence Number
        - entity: string
          entity
        - languageCode: integer
          languageCode
        - referenceId: string
          Place holder for Token based authentication
        - userId: integer
          userId
        
        
        """
        
        
        # Prepare query parameters
        params = {}
        if accountreference is not None:
            params["AccountReference"] = accountreference
            
        if customerid is not None:
            params["CustomerID"] = customerid
            
        if identifiertype is not None:
            params["IdentifierType"] = identifiertype
            
        if identifiervalue is not None:
            params["IdentifierValue"] = identifiervalue
            
        if owneraccounttype is not None:
            params["OwnerAccountType"] = owneraccounttype
            
        if stausindicator is not None:
            params["StausIndicator"] = stausindicator
            
        if grelationid is not None:
            params["gRelationId"] = grelationid
            
        if pagenum is not None:
            params["pageNum"] = pagenum
            
        if pagesize is not None:
            params["pageSize"] = pagesize
            
        if subaccountid is not None:
            params["subAccountId"] = subaccountid
            
        
        
        # Replace path parameters in URL
        path = "/customerManagement/customer/nomineeDetails"
        
        
        # Prepare headers
        headers = {}
        if accesstoken is not None:
            headers["Accesstoken"] = str(accesstoken)
        if channeltype is not None:
            headers["ChannelType"] = str(channeltype)
        if co_relationid is not None:
            headers["Co-Relationid"] = str(co_relationid)
        if initiatingsystem is not None:
            headers["InitiatingSystem"] = str(initiatingsystem)
        if servicemode is not None:
            headers["ServiceMode"] = str(servicemode)
        if uuidseqno is not None:
            headers["UUIDSeqNo"] = str(uuidseqno)
        if entity is not None:
            headers["entity"] = str(entity)
        if languagecode is not None:
            headers["languageCode"] = str(languagecode)
        if referenceid is not None:
            headers["referenceId"] = str(referenceid)
        if userid is not None:
            headers["userId"] = str(userid)
        
        
        return await make_api_request(
            "GET", 
            path, 
            
            params=params if params else None, 
            headers=headers if headers else None
        )
    
    
    
    @mcp.tool()
    async def kfebt0305_auth_notes_memo_tickler_using_put(
        approvalflag: int,
        notesandmemoid: int,
        accesstoken: Optional[str] = None,
        channeltype: Optional[int] = None,
        co_relationid: Optional[int] = None,
        entity: Optional[str] = None,
        initiatingsystem: Optional[str] = None,
        languagecode: Optional[int] = None,
        referenceid: Optional[str] = None,
        servicemode: Optional[int] = None,
        userid: Optional[int] = None,
        uuidseqno: Optional[int] = None
    ) -> Dict[str, Any]:
        """
        Authorize Notes and Memo
        
        Generated from: PUT /customerManagement/customer/notesAndMemo/{notesAndMemoId}/{approvalFlag}
        Source: swagger_2_0
        Operation ID: KFEBT0305AuthNotesMemoTicklerUsingPUT
        
        
        Authentication: Not required
        
        Parameters:
        - approvalFlag: integer (required)
          Authorisation Action : 1- Approve ,2 - Reject 
        - notesAndMemoId: integer (required)
          Notes and Memo Reference
        
        
        
        Headers:
        - Accesstoken: string
          Authorization Token to validation the caller
        - ChannelType: integer
          Channel identifier from where the TXN has originated (Internet, Mobile, ATM, Branch Channel )
        - co-Relationid: integer
          Unique ID for the service invoked, will be set by the TXN system
        - entity: string
          entity
        - initiatingSystem: string
          Indicating the initiated system
        - languageCode: integer
          languageCode
        - referenceId: string
          Place holder for Token based authentication
        - serviceMode: integer
          Used for branch channel to indicate the type of customer
        - userId: integer
          userId
        - uuidSeqNo: integer
          UUID Sequence Number
        
        
        """
        
        
        # Prepare query parameters
        params = {}
        
        
        # Replace path parameters in URL
        path = "/customerManagement/customer/notesAndMemo/{notesAndMemoId}/{approvalFlag}"
        if approvalflag is not None:
            path = path.replace("{approvalFlag}", str(approvalflag))
        if notesandmemoid is not None:
            path = path.replace("{notesAndMemoId}", str(notesandmemoid))
        
        
        # Prepare headers
        headers = {}
        if accesstoken is not None:
            headers["Accesstoken"] = str(accesstoken)
        if channeltype is not None:
            headers["ChannelType"] = str(channeltype)
        if co_relationid is not None:
            headers["co-Relationid"] = str(co_relationid)
        if entity is not None:
            headers["entity"] = str(entity)
        if initiatingsystem is not None:
            headers["initiatingSystem"] = str(initiatingsystem)
        if languagecode is not None:
            headers["languageCode"] = str(languagecode)
        if referenceid is not None:
            headers["referenceId"] = str(referenceid)
        if servicemode is not None:
            headers["serviceMode"] = str(servicemode)
        if userid is not None:
            headers["userId"] = str(userid)
        if uuidseqno is not None:
            headers["uuidSeqNo"] = str(uuidseqno)
        
        
        return await make_api_request(
            "PUT", 
            path, 
            
            params=params if params else None, 
            headers=headers if headers else None
        )
    
    
    
    @mcp.tool()
    async def brbtintl_bpon_hld_intf_taxwrapper_using_post(
        request_body:Dict[str, Any] ,  # customerOnbordingOnholdStatusResource,
        accesstoken: Optional[str] = None,
        channeltype: Optional[int] = None,
        co_relationid: Optional[int] = None,
        initiatingsystem: Optional[str] = None,
        servicemode: Optional[int] = None,
        uuidseqno: Optional[int] = None,
        entity: Optional[str] = None,
        languagecode: Optional[int] = None,
        referenceid: Optional[str] = None,
        requesthash: Optional[str] = None,
        userid: Optional[int] = None
    ) -> Dict[str, Any]:
        """
        Create Individual/Corporate Customer in "OnHold" status
        
        Generated from: POST /customerManagement/customer/onHold
        Source: swagger_2_0
        Operation ID: BRBTIntlBPOnHldIntfTAXWrapperUsingPOST
        
        
        Authentication: Not required
        
        Parameters:
        - request_body: any (required)
          input
        
        
        
        Headers:
        - Accesstoken: string
          Authorization Token to validation the caller
        - ChannelType: integer
          Channel identifier from where the TXN has originated (Internet, Mobile, ATM, Branch Channel )
        - Co-Relationid: integer
          Unique ID for the service invoked, will be set by the TXN system
        - InitiatingSystem: string
          Indicating the initiated system
        - ServiceMode: integer
          Used for branch channel to indicate the type of customer
        - UUIDSeqNo: integer
          UUID Sequence Number
        - entity: string
          entity
        - languageCode: integer
          languageCode
        - referenceId: string
          Place holder for Token based authentication
        - requesthash: string
          Request payload for hash validation
        - userId: integer
          userId
        
        
        """
        
        
        # Prepare request data
        
        # Single body parameter - send directly
        data = request_body if request_body is not None else {}
        
        
        
        # Prepare query parameters
        params = {}
        
        
        # Replace path parameters in URL
        path = "/customerManagement/customer/onHold"
        
        
        # Prepare headers
        headers = {}
        if accesstoken is not None:
            headers["Accesstoken"] = str(accesstoken)
        if channeltype is not None:
            headers["ChannelType"] = str(channeltype)
        if co_relationid is not None:
            headers["Co-Relationid"] = str(co_relationid)
        if initiatingsystem is not None:
            headers["InitiatingSystem"] = str(initiatingsystem)
        if servicemode is not None:
            headers["ServiceMode"] = str(servicemode)
        if uuidseqno is not None:
            headers["UUIDSeqNo"] = str(uuidseqno)
        if entity is not None:
            headers["entity"] = str(entity)
        if languagecode is not None:
            headers["languageCode"] = str(languagecode)
        if referenceid is not None:
            headers["referenceId"] = str(referenceid)
        if requesthash is not None:
            headers["requesthash"] = str(requesthash)
        if userid is not None:
            headers["userId"] = str(userid)
        
        
        return await make_api_request(
            "POST", 
            path, 
            data=data, 
            params=params if params else None, 
            headers=headers if headers else None
        )
    
    
    
    @mcp.tool()
    async def brbtintl_bpon_hld_for_bpchng_taxwrapper_putusing_put(
        request_body:Dict[str, Any] ,  # customerModificationOnholdToOnholdCustStatusResource,
        accesstoken: Optional[str] = None,
        channeltype: Optional[int] = None,
        co_relationid: Optional[int] = None,
        initiatingsystem: Optional[str] = None,
        servicemode: Optional[int] = None,
        uuidseqno: Optional[int] = None,
        entity: Optional[str] = None,
        languagecode: Optional[int] = None,
        referenceid: Optional[str] = None,
        requesthash: Optional[str] = None,
        userid: Optional[int] = None
    ) -> Dict[str, Any]:
        """
        Customer Modification OnholdToOnhold CustomerStatus
        
        Generated from: PUT /customerManagement/customer/onHoldToOnHold
        Source: swagger_2_0
        Operation ID: BRBTIntlBPOnHldForBpchngTAXWrapper_PUTUsingPUT
        
        
        Authentication: Not required
        
        Parameters:
        - request_body: any (required)
          input
        
        
        
        Headers:
        - Accesstoken: string
          Authorization Token to validation the caller
        - ChannelType: integer
          Channel identifier from where the TXN has originated (Internet, Mobile, ATM, Branch Channel )
        - Co-Relationid: integer
          Unique ID for the service invoked, will be set by the TXN system
        - InitiatingSystem: string
          Indicating the initiated system
        - ServiceMode: integer
          Used for branch channel to indicate the type of customer
        - UUIDSeqNo: integer
          UUID Sequence Number
        - entity: string
          entity
        - languageCode: integer
          languageCode
        - referenceId: string
          Place holder for Token based authentication
        - requesthash: string
          Request payload for hash validation
        - userId: integer
          userId
        
        
        """
        
        
        # Prepare request data
        
        # Single body parameter - send directly
        data = request_body if request_body is not None else {}
        
        
        
        # Prepare query parameters
        params = {}
        
        
        # Replace path parameters in URL
        path = "/customerManagement/customer/onHoldToOnHold"
        
        
        # Prepare headers
        headers = {}
        if accesstoken is not None:
            headers["Accesstoken"] = str(accesstoken)
        if channeltype is not None:
            headers["ChannelType"] = str(channeltype)
        if co_relationid is not None:
            headers["Co-Relationid"] = str(co_relationid)
        if initiatingsystem is not None:
            headers["InitiatingSystem"] = str(initiatingsystem)
        if servicemode is not None:
            headers["ServiceMode"] = str(servicemode)
        if uuidseqno is not None:
            headers["UUIDSeqNo"] = str(uuidseqno)
        if entity is not None:
            headers["entity"] = str(entity)
        if languagecode is not None:
            headers["languageCode"] = str(languagecode)
        if referenceid is not None:
            headers["referenceId"] = str(referenceid)
        if requesthash is not None:
            headers["requesthash"] = str(requesthash)
        if userid is not None:
            headers["userId"] = str(userid)
        
        
        return await make_api_request(
            "PUT", 
            path, 
            data=data, 
            params=params if params else None, 
            headers=headers if headers else None
        )
    
    
    
    @mcp.tool()
    async def rstbtamend_personal_details_using_put(
        request_body:Dict[str, Any] ,  # AmendCustomerPersonalDetails_Resource,
        accesstoken: Optional[str] = None,
        channeltype: Optional[int] = None,
        co_relationid: Optional[int] = None,
        initiatingsystem: Optional[str] = None,
        servicemode: Optional[int] = None,
        uuidseqno: Optional[int] = None,
        entity: Optional[str] = None,
        languagecode: Optional[int] = None,
        referenceid: Optional[str] = None,
        requesthash: Optional[str] = None,
        userid: Optional[int] = None
    ) -> Dict[str, Any]:
        """
        Amend Customer Personal Details
        
        Generated from: PUT /customerManagement/customer/personal
        Source: swagger_2_0
        Operation ID: RSTBTAmendPersonalDetailsUsingPUT
        
        
        Authentication: Not required
        
        Parameters:
        - request_body: any (required)
          input
        
        
        
        Headers:
        - Accesstoken: string
          Authorization Token to validation the caller
        - ChannelType: integer
          Channel identifier from where the TXN has originated (Internet, Mobile, ATM, Branch Channel )
        - Co-Relationid: integer
          Unique ID for the service invoked, will be set by the TXN system
        - InitiatingSystem: string
          Indicating the initiated system
        - ServiceMode: integer
          Used for branch channel to indicate the type of customer
        - UUIDSeqNo: integer
          UUID Sequence Number
        - entity: string
          entity
        - languageCode: integer
          languageCode
        - referenceId: string
          Place holder for Token based authentication
        - requesthash: string
          Request payload for hash validation
        - userId: integer
          userId
        
        
        """
        
        
        # Prepare request data
        
        # Single body parameter - send directly
        data = request_body if request_body is not None else {}
        
        
        
        # Prepare query parameters
        params = {}
        
        
        # Replace path parameters in URL
        path = "/customerManagement/customer/personal"
        
        
        # Prepare headers
        headers = {}
        if accesstoken is not None:
            headers["Accesstoken"] = str(accesstoken)
        if channeltype is not None:
            headers["ChannelType"] = str(channeltype)
        if co_relationid is not None:
            headers["Co-Relationid"] = str(co_relationid)
        if initiatingsystem is not None:
            headers["InitiatingSystem"] = str(initiatingsystem)
        if servicemode is not None:
            headers["ServiceMode"] = str(servicemode)
        if uuidseqno is not None:
            headers["UUIDSeqNo"] = str(uuidseqno)
        if entity is not None:
            headers["entity"] = str(entity)
        if languagecode is not None:
            headers["languageCode"] = str(languagecode)
        if referenceid is not None:
            headers["referenceId"] = str(referenceid)
        if requesthash is not None:
            headers["requesthash"] = str(requesthash)
        if userid is not None:
            headers["userId"] = str(userid)
        
        
        return await make_api_request(
            "PUT", 
            path, 
            data=data, 
            params=params if params else None, 
            headers=headers if headers else None
        )
    
    
    
    @mcp.tool()
    async def rstbtupdate_rmusing_put(
        request_body:Dict[str, Any] ,  # MO_CLOS_RSTBTUpdateRM_Resource,
        accesstoken: Optional[str] = None,
        channeltype: Optional[int] = None,
        co_relationid: Optional[int] = None,
        initiatingsystem: Optional[str] = None,
        servicemode: Optional[int] = None,
        uuidseqno: Optional[int] = None,
        entity: Optional[str] = None,
        languagecode: Optional[int] = None,
        referenceid: Optional[str] = None,
        requesthash: Optional[str] = None,
        userid: Optional[int] = None
    ) -> Dict[str, Any]:
        """
        Update Customer RM
        
        Generated from: PUT /customerManagement/customer/relationManager
        Source: swagger_2_0
        Operation ID: RSTBTUpdateRMUsingPUT
        
        
        Authentication: Not required
        
        Parameters:
        - request_body: any (required)
          input
        
        
        
        Headers:
        - Accesstoken: string
          Authorization Token to validation the caller
        - ChannelType: integer
          Channel identifier from where the TXN has originated (Internet, Mobile, ATM, Branch Channel )
        - Co-Relationid: integer
          Unique ID for the service invoked, will be set by the TXN system
        - InitiatingSystem: string
          Indicating the initiated system
        - ServiceMode: integer
          Used for branch channel to indicate the type of customer
        - UUIDSeqNo: integer
          UUID Sequence Number
        - entity: string
          entity
        - languageCode: integer
          languageCode
        - referenceId: string
          Place holder for Token based authentication
        - requesthash: string
          Request payload for hash validation
        - userId: integer
          userId
        
        
        """
        
        
        # Prepare request data
        
        # Single body parameter - send directly
        data = request_body if request_body is not None else {}
        
        
        
        # Prepare query parameters
        params = {}
        
        
        # Replace path parameters in URL
        path = "/customerManagement/customer/relationManager"
        
        
        # Prepare headers
        headers = {}
        if accesstoken is not None:
            headers["Accesstoken"] = str(accesstoken)
        if channeltype is not None:
            headers["ChannelType"] = str(channeltype)
        if co_relationid is not None:
            headers["Co-Relationid"] = str(co_relationid)
        if initiatingsystem is not None:
            headers["InitiatingSystem"] = str(initiatingsystem)
        if servicemode is not None:
            headers["ServiceMode"] = str(servicemode)
        if uuidseqno is not None:
            headers["UUIDSeqNo"] = str(uuidseqno)
        if entity is not None:
            headers["entity"] = str(entity)
        if languagecode is not None:
            headers["languageCode"] = str(languagecode)
        if referenceid is not None:
            headers["referenceId"] = str(referenceid)
        if requesthash is not None:
            headers["requesthash"] = str(requesthash)
        if userid is not None:
            headers["userId"] = str(userid)
        
        
        return await make_api_request(
            "PUT", 
            path, 
            data=data, 
            params=params if params else None, 
            headers=headers if headers else None
        )
    
    
    
    @mcp.tool()
    async def rstbtcreate_modify_delete_bprelation_using_put(
        request_body:Dict[str, Any] ,  # createModifyBPRelationResource,
        accesstoken: Optional[str] = None,
        channeltype: Optional[int] = None,
        co_relationid: Optional[int] = None,
        initiatingsystem: Optional[str] = None,
        servicemode: Optional[int] = None,
        uuidseqno: Optional[int] = None,
        entity: Optional[str] = None,
        languagecode: Optional[int] = None,
        referenceid: Optional[str] = None,
        requesthash: Optional[str] = None,
        userid: Optional[int] = None
    ) -> Dict[str, Any]:
        """
        Create/Modify Customer Relation
        
        Generated from: PUT /customerManagement/customer/relationship
        Source: swagger_2_0
        Operation ID: RSTBTCreateModifyDeleteBPRelationUsingPUT
        
        
        Authentication: Not required
        
        Parameters:
        - request_body: any (required)
          input
        
        
        
        Headers:
        - Accesstoken: string
          Authorization token for identification of the caller
        - ChannelType: integer
          Channel identifier from where the TXN has originated (Internet, Mobile, ATM, Branch Channel )
        - Co-Relationid: integer
          Unique ID for the service invoked, will be set by the TXN system
        - InitiatingSystem: string
          Indicating the initiated system
        - ServiceMode: integer
          Used for branch channel to indicate the type of customer
        - UUIDSeqNo: integer
          UUID Sequence Number
        - entity: string
          entity
        - languageCode: integer
          languageCode
        - referenceId: string
          Place holder for Token based authentication
        - requesthash: string
          Request payload for hash validation
        - userId: integer
          userId
        
        
        """
        
        
        # Prepare request data
        
        # Single body parameter - send directly
        data = request_body if request_body is not None else {}
        
        
        
        # Prepare query parameters
        params = {}
        
        
        # Replace path parameters in URL
        path = "/customerManagement/customer/relationship"
        
        
        # Prepare headers
        headers = {}
        if accesstoken is not None:
            headers["Accesstoken"] = str(accesstoken)
        if channeltype is not None:
            headers["ChannelType"] = str(channeltype)
        if co_relationid is not None:
            headers["Co-Relationid"] = str(co_relationid)
        if initiatingsystem is not None:
            headers["InitiatingSystem"] = str(initiatingsystem)
        if servicemode is not None:
            headers["ServiceMode"] = str(servicemode)
        if uuidseqno is not None:
            headers["UUIDSeqNo"] = str(uuidseqno)
        if entity is not None:
            headers["entity"] = str(entity)
        if languagecode is not None:
            headers["languageCode"] = str(languagecode)
        if referenceid is not None:
            headers["referenceId"] = str(referenceid)
        if requesthash is not None:
            headers["requesthash"] = str(requesthash)
        if userid is not None:
            headers["userId"] = str(userid)
        
        
        return await make_api_request(
            "PUT", 
            path, 
            data=data, 
            params=params if params else None, 
            headers=headers if headers else None
        )
    
    
    
    @mcp.tool()
    async def bret1201_get_bprltn_getusing_get(
        identifiertype: int,
        identifiervalue: str,
        customerid: Optional[int] = None,
        isrelativepep: Optional[int] = None,
        pagenum: Optional[int] = None,
        pagesize: Optional[int] = None,
        relationshipcustomerid: Optional[int] = None,
        entity: Optional[str] = None,
        languagecode: Optional[int] = None,
        userid: Optional[int] = None
    ) -> Dict[str, Any]:
        """
        BRET1201GetBPRltn
        
        Generated from: GET /customerManagement/customer/relationship/fetchRelativeDtlsWithId
        Source: swagger_2_0
        Operation ID: BRET1201GetBPRltn_GETUsingGET
        
        
        Authentication: Not required
        
        Parameters:
        - customerId: integer
          Customer ID
        - identifierType: integer (required)
          ID captured during Onboarding 45-Passport,85-Birth certificate(Domain Name:d_BPNationalID)
        - identifierValue: string (required)
          identifier Value
        - isRelativePep: integer
          to be passed as 1 to return PEP relative details
        - pageNum: integer
          pageNum
        - pageSize: integer
          pageSize
        - relationshipCustomerId: integer
          Customer Id of the relative
        
        
        
        Headers:
        - entity: string
          entity
        - languageCode: integer
          languageCode
        - userId: integer
          userId
        
        
        """
        
        
        # Prepare query parameters
        params = {}
        if customerid is not None:
            params["customerId"] = customerid
            
        if identifiertype is not None:
            params["identifierType"] = identifiertype
            
        if identifiervalue is not None:
            params["identifierValue"] = identifiervalue
            
        if isrelativepep is not None:
            params["isRelativePep"] = isrelativepep
            
        if pagenum is not None:
            params["pageNum"] = pagenum
            
        if pagesize is not None:
            params["pageSize"] = pagesize
            
        if relationshipcustomerid is not None:
            params["relationshipCustomerId"] = relationshipcustomerid
            
        
        
        # Replace path parameters in URL
        path = "/customerManagement/customer/relationship/fetchRelativeDtlsWithId"
        
        
        # Prepare headers
        headers = {}
        if entity is not None:
            headers["entity"] = str(entity)
        if languagecode is not None:
            headers["languageCode"] = str(languagecode)
        if userid is not None:
            headers["userId"] = str(userid)
        
        
        return await make_api_request(
            "GET", 
            path, 
            
            params=params if params else None, 
            headers=headers if headers else None
        )
    
    
    
    @mcp.tool()
    async def bret1201_get_bprltn_lst_using_get(
        customerid: Optional[int] = None,
        identifiertype: Optional[int] = None,
        identifiervalue: Optional[str] = None,
        pagenum: Optional[int] = None,
        pagesize: Optional[int] = None,
        accesstoken: Optional[str] = None,
        channeltype: Optional[int] = None,
        co_relationid: Optional[int] = None,
        initiatingsystem: Optional[str] = None,
        servicemode: Optional[int] = None,
        uuidseqno: Optional[int] = None,
        entity: Optional[str] = None,
        languagecode: Optional[int] = None,
        referenceid: Optional[str] = None,
        userid: Optional[int] = None
    ) -> Dict[str, Any]:
        """
        Fetch Customer Relationship List
        
        Generated from: GET /customerManagement/customer/relationshipList
        Source: swagger_2_0
        Operation ID: BRET1201GetBPRltnLstUsingGET
        
        
        Authentication: Not required
        
        Parameters:
        - CustomerID: integer
          Customer ID
        - IdentifierType: integer
          Identifier Type
        - IdentifierValue: string
          Identifier Value
        - pageNum: integer
          pageNum
        - pageSize: integer
          pageSize
        
        
        
        Headers:
        - Accesstoken: string
          Authorization Token to validation the caller
        - ChannelType: integer
          Channel identifier from where the TXN has originated (Internet, Mobile, ATM, Branch Channel )
        - Co-Relationid: integer
          Unique ID for the service invoked, will be set by the TXN system
        - InitiatingSystem: string
          Indicating the initiated system
        - ServiceMode: integer
          Used for branch channel to indicate the type of customer
        - UUIDSeqNo: integer
          UUID Sequence Number
        - entity: string
          entity
        - languageCode: integer
          languageCode
        - referenceId: string
          Place holder for Token based authentication
        - userId: integer
          userId
        
        
        """
        
        
        # Prepare query parameters
        params = {}
        if customerid is not None:
            params["CustomerID"] = customerid
            
        if identifiertype is not None:
            params["IdentifierType"] = identifiertype
            
        if identifiervalue is not None:
            params["IdentifierValue"] = identifiervalue
            
        if pagenum is not None:
            params["pageNum"] = pagenum
            
        if pagesize is not None:
            params["pageSize"] = pagesize
            
        
        
        # Replace path parameters in URL
        path = "/customerManagement/customer/relationshipList"
        
        
        # Prepare headers
        headers = {}
        if accesstoken is not None:
            headers["Accesstoken"] = str(accesstoken)
        if channeltype is not None:
            headers["ChannelType"] = str(channeltype)
        if co_relationid is not None:
            headers["Co-Relationid"] = str(co_relationid)
        if initiatingsystem is not None:
            headers["InitiatingSystem"] = str(initiatingsystem)
        if servicemode is not None:
            headers["ServiceMode"] = str(servicemode)
        if uuidseqno is not None:
            headers["UUIDSeqNo"] = str(uuidseqno)
        if entity is not None:
            headers["entity"] = str(entity)
        if languagecode is not None:
            headers["languageCode"] = str(languagecode)
        if referenceid is not None:
            headers["referenceId"] = str(referenceid)
        if userid is not None:
            headers["userId"] = str(userid)
        
        
        return await make_api_request(
            "GET", 
            path, 
            
            params=params if params else None, 
            headers=headers if headers else None
        )
    
    
    
    @mcp.tool()
    async def brbt0303_crt_risk_rating_using_post(
        request_body:Dict[str, Any] ,  # createRiskRatingResource,
        accesstoken: Optional[str] = None,
        channeltype: Optional[int] = None,
        co_relationid: Optional[int] = None,
        initiatingsystem: Optional[str] = None,
        servicemode: Optional[int] = None,
        uuidseqno: Optional[int] = None,
        entity: Optional[str] = None,
        languagecode: Optional[int] = None,
        referenceid: Optional[str] = None,
        requesthash: Optional[str] = None,
        userid: Optional[int] = None
    ) -> Dict[str, Any]:
        """
        Create Customer Risk Rating Details
        
        Generated from: POST /customerManagement/customer/riskRating
        Source: swagger_2_0
        Operation ID: BRBT0303CrtRiskRatingUsingPOST
        
        
        Authentication: Not required
        
        Parameters:
        - request_body: any (required)
          input
        
        
        
        Headers:
        - Accesstoken: string
          Authorization Token to validation the caller
        - ChannelType: integer
          Channel identifier from where the TXN has originated (Internet, Mobile, ATM, Branch Channel )
        - Co-Relationid: integer
          Unique ID for the service invoked, will be set by the TXN system
        - InitiatingSystem: string
          Indicating the initiated system
        - ServiceMode: integer
          Used for branch channel to indicate the type of customer
        - UUIDSeqNo: integer
          UUID Sequence Number
        - entity: string
          entity
        - languageCode: integer
          languageCode
        - referenceId: string
          Place holder for Token based authentication
        - requesthash: string
          Request payload for hash validation
        - userId: integer
          userId
        
        
        """
        
        
        # Prepare request data
        
        # Single body parameter - send directly
        data = request_body if request_body is not None else {}
        
        
        
        # Prepare query parameters
        params = {}
        
        
        # Replace path parameters in URL
        path = "/customerManagement/customer/riskRating"
        
        
        # Prepare headers
        headers = {}
        if accesstoken is not None:
            headers["Accesstoken"] = str(accesstoken)
        if channeltype is not None:
            headers["ChannelType"] = str(channeltype)
        if co_relationid is not None:
            headers["Co-Relationid"] = str(co_relationid)
        if initiatingsystem is not None:
            headers["InitiatingSystem"] = str(initiatingsystem)
        if servicemode is not None:
            headers["ServiceMode"] = str(servicemode)
        if uuidseqno is not None:
            headers["UUIDSeqNo"] = str(uuidseqno)
        if entity is not None:
            headers["entity"] = str(entity)
        if languagecode is not None:
            headers["languageCode"] = str(languagecode)
        if referenceid is not None:
            headers["referenceId"] = str(referenceid)
        if requesthash is not None:
            headers["requesthash"] = str(requesthash)
        if userid is not None:
            headers["userId"] = str(userid)
        
        
        return await make_api_request(
            "POST", 
            path, 
            data=data, 
            params=params if params else None, 
            headers=headers if headers else None
        )
    
    
    
    @mcp.tool()
    async def brbt0303_modify_risk_rating_using_put(
        request_body:Dict[str, Any] ,  # modifyRiskRatingResource,
        accesstoken: Optional[str] = None,
        channeltype: Optional[int] = None,
        co_relationid: Optional[int] = None,
        initiatingsystem: Optional[str] = None,
        servicemode: Optional[int] = None,
        uuidseqno: Optional[int] = None,
        entity: Optional[str] = None,
        languagecode: Optional[int] = None,
        referenceid: Optional[str] = None,
        requesthash: Optional[str] = None,
        userid: Optional[int] = None
    ) -> Dict[str, Any]:
        """
        Modify Customer Risk Rating Details
        
        Generated from: PUT /customerManagement/customer/riskRating
        Source: swagger_2_0
        Operation ID: BRBT0303ModifyRiskRatingUsingPUT
        
        
        Authentication: Not required
        
        Parameters:
        - request_body: any (required)
          input
        
        
        
        Headers:
        - Accesstoken: string
          Authorization Token to validation the caller
        - ChannelType: integer
          Channel identifier from where the TXN has originated (Internet, Mobile, ATM, Branch Channel )
        - Co-Relationid: integer
          Unique ID for the service invoked, will be set by the TXN system
        - InitiatingSystem: string
          Indicating the initiated system
        - ServiceMode: integer
          Used for branch channel to indicate the type of customer
        - UUIDSeqNo: integer
          UUID Sequence Number
        - entity: string
          entity
        - languageCode: integer
          languageCode
        - referenceId: string
          Place holder for Token based authentication
        - requesthash: string
          Request payload for hash validation
        - userId: integer
          userId
        
        
        """
        
        
        # Prepare request data
        
        # Single body parameter - send directly
        data = request_body if request_body is not None else {}
        
        
        
        # Prepare query parameters
        params = {}
        
        
        # Replace path parameters in URL
        path = "/customerManagement/customer/riskRating"
        
        
        # Prepare headers
        headers = {}
        if accesstoken is not None:
            headers["Accesstoken"] = str(accesstoken)
        if channeltype is not None:
            headers["ChannelType"] = str(channeltype)
        if co_relationid is not None:
            headers["Co-Relationid"] = str(co_relationid)
        if initiatingsystem is not None:
            headers["InitiatingSystem"] = str(initiatingsystem)
        if servicemode is not None:
            headers["ServiceMode"] = str(servicemode)
        if uuidseqno is not None:
            headers["UUIDSeqNo"] = str(uuidseqno)
        if entity is not None:
            headers["entity"] = str(entity)
        if languagecode is not None:
            headers["languageCode"] = str(languagecode)
        if referenceid is not None:
            headers["referenceId"] = str(referenceid)
        if requesthash is not None:
            headers["requesthash"] = str(requesthash)
        if userid is not None:
            headers["userId"] = str(userid)
        
        
        return await make_api_request(
            "PUT", 
            path, 
            data=data, 
            params=params if params else None, 
            headers=headers if headers else None
        )
    
    
    
    @mcp.tool()
    async def bret0303_get_risk_rating_using_get(
        customerid: Optional[int] = None,
        pagenum: Optional[int] = None,
        pagesize: Optional[int] = None,
        accesstoken: Optional[str] = None,
        channeltype: Optional[int] = None,
        co_relationid: Optional[int] = None,
        initiatingsystem: Optional[str] = None,
        servicemode: Optional[int] = None,
        uuidseqno: Optional[int] = None,
        entity: Optional[str] = None,
        languagecode: Optional[int] = None,
        referenceid: Optional[str] = None,
        userid: Optional[int] = None
    ) -> Dict[str, Any]:
        """
        Fetch Customer Risk Rating Details
        
        Generated from: GET /customerManagement/customer/riskRatingDetails
        Source: swagger_2_0
        Operation ID: BRET0303GetRiskRatingUsingGET
        
        
        Authentication: Not required
        
        Parameters:
        - CustomerID: integer
          Customer ID
        - pageNum: integer
          pageNum
        - pageSize: integer
          pageSize
        
        
        
        Headers:
        - Accesstoken: string
          Authorization Token to validation the caller
        - ChannelType: integer
          Channel identifier from where the TXN has originated (Internet, Mobile, ATM, Branch Channel )
        - Co-Relationid: integer
          Unique ID for the service invoked, will be set by the TXN system
        - InitiatingSystem: string
          Indicating the initiated system
        - ServiceMode: integer
          Used for branch channel to indicate the type of customer
        - UUIDSeqNo: integer
          UUID Sequence Number
        - entity: string
          entity
        - languageCode: integer
          languageCode
        - referenceId: string
          Place holder for Token based authentication
        - userId: integer
          userId
        
        
        """
        
        
        # Prepare query parameters
        params = {}
        if customerid is not None:
            params["CustomerID"] = customerid
            
        if pagenum is not None:
            params["pageNum"] = pagenum
            
        if pagesize is not None:
            params["pageSize"] = pagesize
            
        
        
        # Replace path parameters in URL
        path = "/customerManagement/customer/riskRatingDetails"
        
        
        # Prepare headers
        headers = {}
        if accesstoken is not None:
            headers["Accesstoken"] = str(accesstoken)
        if channeltype is not None:
            headers["ChannelType"] = str(channeltype)
        if co_relationid is not None:
            headers["Co-Relationid"] = str(co_relationid)
        if initiatingsystem is not None:
            headers["InitiatingSystem"] = str(initiatingsystem)
        if servicemode is not None:
            headers["ServiceMode"] = str(servicemode)
        if uuidseqno is not None:
            headers["UUIDSeqNo"] = str(uuidseqno)
        if entity is not None:
            headers["entity"] = str(entity)
        if languagecode is not None:
            headers["languageCode"] = str(languagecode)
        if referenceid is not None:
            headers["referenceId"] = str(referenceid)
        if userid is not None:
            headers["userId"] = str(userid)
        
        
        return await make_api_request(
            "GET", 
            path, 
            
            params=params if params else None, 
            headers=headers if headers else None
        )
    
    
    
    @mcp.tool()
    async def bret0105_bpqbeusing_get(
        customertype: int,
        accountreference: Optional[str] = None,
        businesspartnerreference: Optional[int] = None,
        correspondentroleflag: Optional[int] = None,
        customername: Optional[str] = None,
        email: Optional[str] = None,
        identifiertype: Optional[int] = None,
        identifiervalue: Optional[str] = None,
        mobileno: Optional[str] = None,
        relationalmanager: Optional[str] = None,
        status: Optional[int] = None,
        pagenum: Optional[int] = None,
        pagesize: Optional[int] = None,
        accesstoken: Optional[str] = None,
        channeltype: Optional[int] = None,
        co_relationid: Optional[int] = None,
        initiatingsystem: Optional[str] = None,
        servicemode: Optional[int] = None,
        uuidseqno: Optional[int] = None,
        entity: Optional[str] = None,
        languagecode: Optional[int] = None,
        referenceid: Optional[str] = None,
        userid: Optional[int] = None
    ) -> Dict[str, Any]:
        """
        Provide business partners in the system
        
        Generated from: GET /customerManagement/customer/search
        Source: swagger_2_0
        Operation ID: BRET0105BPQBEUsingGET
        
        
        Authentication: Not required
        
        Parameters:
        - AccountReference: string
          Account number linked to BP
        - BusinessPartnerReference: integer
          This field shows unique reference of the particular Business Partner
        - CorrespondentRoleFlag: integer
          CorrespondentRoleFlag Yes-1 No-2
        - CustomerName: string
          This field shows name of the Business Partner
        - CustomerType: integer (required)
          This field shows Category of Business Partner.1-Individual, 2-Corporate, 3-Bank(Domain Name: d_BPCat)
        - Email: string
          Email
        - IdentifierType: integer
          Identifier Type
        - IdentifierValue: string
          Identifier Value
        - Mobileno: string
          Cell no
        - RelationalManager: string
          Relational manager
        - Status: integer
          This field shows current status  of the Business Partner 1-OnHold, 4-Active, 6-Close(Domain Name: d_BPStat)
        - pageNum: integer
          pageNum
        - pageSize: integer
          pageSize
        
        
        
        Headers:
        - Accesstoken: string
          Authorization Token to validation the caller
        - ChannelType: integer
          Channel identifier from where the Transaction has originated (Internet, Mobile, ATM, Branch Channel )
        - Co-Relationid: integer
          Unique ID for the service invoked, will be set by the Transaction system
        - InitiatingSystem: string
          Indicating the initiated system
        - ServiceMode: integer
          Used for branch channel to indicate the type of customer
        - UUIDSeqNo: integer
          UUID Sequence Number
        - entity: string
          entity
        - languageCode: integer
          languageCode
        - referenceId: string
          Place holder for Token based authentication
        - userId: integer
          userId
        
        
        """
        
        
        # Prepare query parameters
        params = {}
        if accountreference is not None:
            params["AccountReference"] = accountreference
            
        if businesspartnerreference is not None:
            params["BusinessPartnerReference"] = businesspartnerreference
            
        if correspondentroleflag is not None:
            params["CorrespondentRoleFlag"] = correspondentroleflag
            
        if customername is not None:
            params["CustomerName"] = customername
            
        if customertype is not None:
            params["CustomerType"] = customertype
            
        if email is not None:
            params["Email"] = email
            
        if identifiertype is not None:
            params["IdentifierType"] = identifiertype
            
        if identifiervalue is not None:
            params["IdentifierValue"] = identifiervalue
            
        if mobileno is not None:
            params["Mobileno"] = mobileno
            
        if relationalmanager is not None:
            params["RelationalManager"] = relationalmanager
            
        if status is not None:
            params["Status"] = status
            
        if pagenum is not None:
            params["pageNum"] = pagenum
            
        if pagesize is not None:
            params["pageSize"] = pagesize
            
        
        
        # Replace path parameters in URL
        path = "/customerManagement/customer/search"
        
        
        # Prepare headers
        headers = {}
        if accesstoken is not None:
            headers["Accesstoken"] = str(accesstoken)
        if channeltype is not None:
            headers["ChannelType"] = str(channeltype)
        if co_relationid is not None:
            headers["Co-Relationid"] = str(co_relationid)
        if initiatingsystem is not None:
            headers["InitiatingSystem"] = str(initiatingsystem)
        if servicemode is not None:
            headers["ServiceMode"] = str(servicemode)
        if uuidseqno is not None:
            headers["UUIDSeqNo"] = str(uuidseqno)
        if entity is not None:
            headers["entity"] = str(entity)
        if languagecode is not None:
            headers["languageCode"] = str(languagecode)
        if referenceid is not None:
            headers["referenceId"] = str(referenceid)
        if userid is not None:
            headers["userId"] = str(userid)
        
        
        return await make_api_request(
            "GET", 
            path, 
            
            params=params if params else None, 
            headers=headers if headers else None
        )
    
    
    
    @mcp.tool()
    async def bret5705_get_sign_card_list_intf_using_get(
        leveltype: int,
        customerid: Optional[int] = None,
        identifiertype: Optional[int] = None,
        identifiervalue: Optional[str] = None,
        accesstoken: Optional[str] = None,
        channeltype: Optional[int] = None,
        co_relationid: Optional[int] = None,
        initiatingsystem: Optional[str] = None,
        servicemode: Optional[int] = None,
        uuidseqno: Optional[int] = None,
        entity: Optional[str] = None,
        languagecode: Optional[int] = None,
        referenceid: Optional[str] = None,
        userid: Optional[int] = None
    ) -> Dict[str, Any]:
        """
        Fetch Customer Signature List
        
        Generated from: GET /customerManagement/customer/signatureList
        Source: swagger_2_0
        Operation ID: BRET5705GetSignCardListIntfUsingGET
        
        
        Authentication: Not required
        
        Parameters:
        - CustomerID: integer
          Enter the customer identification number
        - IdentifierType: integer
          Identifier Type
        - IdentifierValue: string
          Identifier Value
        - LevelType: integer (required)
          Enter LevelType(41-BP:42-Portfolio:44-Account:45-LOC)
        
        
        
        Headers:
        - Accesstoken: string
          Authorization Token to validation the caller
        - ChannelType: integer
          Channel identifier from where the TXN has originated (Internet, Mobile, ATM, Branch Channel )
        - Co-Relationid: integer
          Unique ID for the service invoked, will be set by the TXN system
        - InitiatingSystem: string
          Indicating the initiated system
        - ServiceMode: integer
          Used for branch channel to indicate the type of customer
        - UUIDSeqNo: integer
          UUID Sequence Number
        - entity: string
          entity
        - languageCode: integer
          languageCode
        - referenceId: string
          Place holder for Token based authentication
        - userId: integer
          userId
        
        
        """
        
        
        # Prepare query parameters
        params = {}
        if customerid is not None:
            params["CustomerID"] = customerid
            
        if identifiertype is not None:
            params["IdentifierType"] = identifiertype
            
        if identifiervalue is not None:
            params["IdentifierValue"] = identifiervalue
            
        if leveltype is not None:
            params["LevelType"] = leveltype
            
        
        
        # Replace path parameters in URL
        path = "/customerManagement/customer/signatureList"
        
        
        # Prepare headers
        headers = {}
        if accesstoken is not None:
            headers["Accesstoken"] = str(accesstoken)
        if channeltype is not None:
            headers["ChannelType"] = str(channeltype)
        if co_relationid is not None:
            headers["Co-Relationid"] = str(co_relationid)
        if initiatingsystem is not None:
            headers["InitiatingSystem"] = str(initiatingsystem)
        if servicemode is not None:
            headers["ServiceMode"] = str(servicemode)
        if uuidseqno is not None:
            headers["UUIDSeqNo"] = str(uuidseqno)
        if entity is not None:
            headers["entity"] = str(entity)
        if languagecode is not None:
            headers["languageCode"] = str(languagecode)
        if referenceid is not None:
            headers["referenceId"] = str(referenceid)
        if userid is not None:
            headers["userId"] = str(userid)
        
        
        return await make_api_request(
            "GET", 
            path, 
            
            params=params if params else None, 
            headers=headers if headers else None
        )
    
    
    
    @mcp.tool()
    async def bret0103_gt_bpdtls_taxusing_get(
        customerid: Optional[int] = None,
        identifiertype: Optional[int] = None,
        identifiervalue: Optional[str] = None,
        accesstoken: Optional[str] = None,
        channeltype: Optional[int] = None,
        co_relationid: Optional[int] = None,
        initiatingsystem: Optional[str] = None,
        servicemode: Optional[int] = None,
        uuidseqno: Optional[int] = None,
        entity: Optional[str] = None,
        languagecode: Optional[int] = None,
        referenceid: Optional[str] = None,
        userid: Optional[int] = None
    ) -> Dict[str, Any]:
        """
        Fetch Customer Tax Details
        
        Generated from: GET /customerManagement/customer/taxDetails
        Source: swagger_2_0
        Operation ID: BRET0103GtBPDtlsTAXUsingGET
        
        
        Authentication: Not required
        
        Parameters:
        - CustomerID: integer
          Customer ID
        - IdentifierType: integer
          Identifier Type
        - IdentifierValue: string
          Identifier Value
        
        
        
        Headers:
        - Accesstoken: string
          Authorization Token to validation the caller
        - ChannelType: integer
          Channel identifier from where the TXN has originated (Internet, Mobile, ATM, Branch Channel )
        - Co-Relationid: integer
          Unique ID for the service invoked, will be set by the TXN system
        - InitiatingSystem: string
          Indicating the initiated system
        - ServiceMode: integer
          Used for branch channel to indicate the type of customer
        - UUIDSeqNo: integer
          UUID Sequence Number
        - entity: string
          entity
        - languageCode: integer
          languageCode
        - referenceId: string
          Place holder for Token based authentication
        - userId: integer
          userId
        
        
        """
        
        
        # Prepare query parameters
        params = {}
        if customerid is not None:
            params["CustomerID"] = customerid
            
        if identifiertype is not None:
            params["IdentifierType"] = identifiertype
            
        if identifiervalue is not None:
            params["IdentifierValue"] = identifiervalue
            
        
        
        # Replace path parameters in URL
        path = "/customerManagement/customer/taxDetails"
        
        
        # Prepare headers
        headers = {}
        if accesstoken is not None:
            headers["Accesstoken"] = str(accesstoken)
        if channeltype is not None:
            headers["ChannelType"] = str(channeltype)
        if co_relationid is not None:
            headers["Co-Relationid"] = str(co_relationid)
        if initiatingsystem is not None:
            headers["InitiatingSystem"] = str(initiatingsystem)
        if servicemode is not None:
            headers["ServiceMode"] = str(servicemode)
        if uuidseqno is not None:
            headers["UUIDSeqNo"] = str(uuidseqno)
        if entity is not None:
            headers["entity"] = str(entity)
        if languagecode is not None:
            headers["languageCode"] = str(languagecode)
        if referenceid is not None:
            headers["referenceId"] = str(referenceid)
        if userid is not None:
            headers["userId"] = str(userid)
        
        
        return await make_api_request(
            "GET", 
            path, 
            
            params=params if params else None, 
            headers=headers if headers else None
        )
    
    
    
    @mcp.tool()
    async def bret4040_ftch_bp_tax_info_hstry_using_get(
        customerid: Optional[int] = None,
        identifiertype: Optional[int] = None,
        identifiervalue: Optional[str] = None,
        accesstoken: Optional[str] = None,
        channeltype: Optional[int] = None,
        co_relationid: Optional[int] = None,
        initiatingsystem: Optional[str] = None,
        servicemode: Optional[int] = None,
        uuidseqno: Optional[int] = None,
        entity: Optional[str] = None,
        languagecode: Optional[int] = None,
        referenceid: Optional[str] = None,
        userid: Optional[int] = None
    ) -> Dict[str, Any]:
        """
        Fetch Customer Tax History Details 
        
        Generated from: GET /customerManagement/customer/taxHistoryDetails
        Source: swagger_2_0
        Operation ID: BRET4040FtchBpTaxInfoHstryUsingGET
        
        
        Authentication: Not required
        
        Parameters:
        - CustomerID: integer
          Customer ID
        - IdentifierType: integer
          Identifier Type
        - IdentifierValue: string
          Identifier Value
        
        
        
        Headers:
        - Accesstoken: string
          Authorization Token to validation the caller
        - ChannelType: integer
          Channel identifier from where the TXN has originated (Internet, Mobile, ATM, Branch Channel )
        - Co-Relationid: integer
          Unique ID for the service invoked, will be set by the TXN system
        - InitiatingSystem: string
          Indicating the initiated system
        - ServiceMode: integer
          Used for branch channel to indicate the type of customer
        - UUIDSeqNo: integer
          UUID Sequence Number
        - entity: string
          entity
        - languageCode: integer
          languageCode
        - referenceId: string
          Place holder for Token based authentication
        - userId: integer
          userId
        
        
        """
        
        
        # Prepare query parameters
        params = {}
        if customerid is not None:
            params["CustomerID"] = customerid
            
        if identifiertype is not None:
            params["IdentifierType"] = identifiertype
            
        if identifiervalue is not None:
            params["IdentifierValue"] = identifiervalue
            
        
        
        # Replace path parameters in URL
        path = "/customerManagement/customer/taxHistoryDetails"
        
        
        # Prepare headers
        headers = {}
        if accesstoken is not None:
            headers["Accesstoken"] = str(accesstoken)
        if channeltype is not None:
            headers["ChannelType"] = str(channeltype)
        if co_relationid is not None:
            headers["Co-Relationid"] = str(co_relationid)
        if initiatingsystem is not None:
            headers["InitiatingSystem"] = str(initiatingsystem)
        if servicemode is not None:
            headers["ServiceMode"] = str(servicemode)
        if uuidseqno is not None:
            headers["UUIDSeqNo"] = str(uuidseqno)
        if entity is not None:
            headers["entity"] = str(entity)
        if languagecode is not None:
            headers["languageCode"] = str(languagecode)
        if referenceid is not None:
            headers["referenceId"] = str(referenceid)
        if userid is not None:
            headers["userId"] = str(userid)
        
        
        return await make_api_request(
            "GET", 
            path, 
            
            params=params if params else None, 
            headers=headers if headers else None
        )
    
    
    
    @mcp.tool()
    async def bret0807_drv_tax_info_using_get(
        country: str,
        customercategory: int,
        customersubtype: int,
        pagenum: Optional[int] = None,
        pagesize: Optional[int] = None,
        accesstoken: Optional[str] = None,
        channeltype: Optional[int] = None,
        co_relationid: Optional[int] = None,
        initiatingsystem: Optional[str] = None,
        servicemode: Optional[int] = None,
        uuidseqno: Optional[int] = None,
        entity: Optional[str] = None,
        languagecode: Optional[int] = None,
        referenceid: Optional[str] = None,
        userid: Optional[int] = None
    ) -> Dict[str, Any]:
        """
        Derive Customer Tax Category
        
        Generated from: GET /customerManagement/customer/taxInformation
        Source: swagger_2_0
        Operation ID: BRET0807DrvTaxInfoUsingGET
        
        
        Authentication: Not required
        
        Parameters:
        - Country: string (required)
          Enter the country code
        - CustomerCategory: integer (required)
          Enter the category of the customer(1-Individual:2-Company:3-Bank)
        - CustomerSubType: integer (required)
          Enter the sub type of the customer (d_BPSubCtgry) Eg : 46 - Individual 48 - Corporate
        - pageNum: integer
          pageNum
        - pageSize: integer
          pageSize
        
        
        
        Headers:
        - Accesstoken: string
          Authorization Token to validation the caller
        - ChannelType: integer
          Channel identifier from where the TXN has originated (Internet, Mobile, ATM, Branch Channel )
        - Co-Relationid: integer
          Unique ID for the service invoked, will be set by the TXN system
        - InitiatingSystem: string
          Indicating the initiated system
        - ServiceMode: integer
          Used for branch channel to indicate the type of customer
        - UUIDSeqNo: integer
          UUID Sequence Number
        - entity: string
          entity
        - languageCode: integer
          languageCode
        - referenceId: string
          Place holder for Token based authentication
        - userId: integer
          userId
        
        
        """
        
        
        # Prepare query parameters
        params = {}
        if country is not None:
            params["Country"] = country
            
        if customercategory is not None:
            params["CustomerCategory"] = customercategory
            
        if customersubtype is not None:
            params["CustomerSubType"] = customersubtype
            
        if pagenum is not None:
            params["pageNum"] = pagenum
            
        if pagesize is not None:
            params["pageSize"] = pagesize
            
        
        
        # Replace path parameters in URL
        path = "/customerManagement/customer/taxInformation"
        
        
        # Prepare headers
        headers = {}
        if accesstoken is not None:
            headers["Accesstoken"] = str(accesstoken)
        if channeltype is not None:
            headers["ChannelType"] = str(channeltype)
        if co_relationid is not None:
            headers["Co-Relationid"] = str(co_relationid)
        if initiatingsystem is not None:
            headers["InitiatingSystem"] = str(initiatingsystem)
        if servicemode is not None:
            headers["ServiceMode"] = str(servicemode)
        if uuidseqno is not None:
            headers["UUIDSeqNo"] = str(uuidseqno)
        if entity is not None:
            headers["entity"] = str(entity)
        if languagecode is not None:
            headers["languageCode"] = str(languagecode)
        if referenceid is not None:
            headers["referenceId"] = str(referenceid)
        if userid is not None:
            headers["userId"] = str(userid)
        
        
        return await make_api_request(
            "GET", 
            path, 
            
            params=params if params else None, 
            headers=headers if headers else None
        )
    
    
    
    @mcp.tool()
    async def rstetview_customer_details_using_get(
        customerid: int,
        pagenum: Optional[int] = None,
        pagesize: Optional[int] = None,
        accesstoken: Optional[str] = None,
        channeltype: Optional[int] = None,
        co_relationid: Optional[int] = None,
        initiatingsystem: Optional[str] = None,
        servicemode: Optional[int] = None,
        uuidseqno: Optional[int] = None,
        entity: Optional[str] = None,
        languagecode: Optional[int] = None,
        referenceid: Optional[str] = None,
        userid: Optional[int] = None
    ) -> Dict[str, Any]:
        """
        Customer Details
        
        Generated from: GET /customerManagement/customer/viewDetails
        Source: swagger_2_0
        Operation ID: RSTETViewCustomerDetailsUsingGET
        
        
        Authentication: Not required
        
        Parameters:
        - CustomerID: integer (required)
          Enter the customer ID
        - pageNum: integer
          pageNum
        - pageSize: integer
          pageSize
        
        
        
        Headers:
        - Accesstoken: string
          Authorization token for identification of the caller
        - ChannelType: integer
          Channel identifier from where the TXN has originated (Internet, Mobile, ATM, Branch Channel )
        - Co-Relationid: integer
          Unique ID for the service invoked, will be set by the TXN system
        - InitiatingSystem: string
          Indicating the initiated system
        - ServiceMode: integer
          Used for branch channel to indicate the type of customer
        - UUIDSeqNo: integer
          UUID Sequence Number
        - entity: string
          entity
        - languageCode: integer
          languageCode
        - referenceId: string
          Place holder for Token based authentication
        - userId: integer
          userId
        
        
        """
        
        
        # Prepare query parameters
        params = {}
        if customerid is not None:
            params["CustomerID"] = customerid
            
        if pagenum is not None:
            params["pageNum"] = pagenum
            
        if pagesize is not None:
            params["pageSize"] = pagesize
            
        
        
        # Replace path parameters in URL
        path = "/customerManagement/customer/viewDetails"
        
        
        # Prepare headers
        headers = {}
        if accesstoken is not None:
            headers["Accesstoken"] = str(accesstoken)
        if channeltype is not None:
            headers["ChannelType"] = str(channeltype)
        if co_relationid is not None:
            headers["Co-Relationid"] = str(co_relationid)
        if initiatingsystem is not None:
            headers["InitiatingSystem"] = str(initiatingsystem)
        if servicemode is not None:
            headers["ServiceMode"] = str(servicemode)
        if uuidseqno is not None:
            headers["UUIDSeqNo"] = str(uuidseqno)
        if entity is not None:
            headers["entity"] = str(entity)
        if languagecode is not None:
            headers["languageCode"] = str(languagecode)
        if referenceid is not None:
            headers["referenceId"] = str(referenceid)
        if userid is not None:
            headers["userId"] = str(userid)
        
        
        return await make_api_request(
            "GET", 
            path, 
            
            params=params if params else None, 
            headers=headers if headers else None
        )
    
    
    
    @mcp.tool()
    async def brbt0160_moh_bpmpa_using_put(
        customerid: int,
        accesstoken: Optional[str] = None,
        channeltype: Optional[int] = None,
        co_relationid: Optional[int] = None,
        initiatingsystem: Optional[str] = None,
        servicemode: Optional[int] = None,
        uuidseqno: Optional[int] = None,
        entity: Optional[str] = None,
        languagecode: Optional[int] = None,
        referenceid: Optional[str] = None,
        userid: Optional[int] = None
    ) -> Dict[str, Any]:
        """
        Customer Status Change from Active Modified Onhold to Active Modified Pending Authorisation
        
        Generated from: PUT /customerManagement/customer/{customerId}/activeModifiedPendingAuth
        Source: swagger_2_0
        Operation ID: BRBT0160MohBPMpaUsingPUT
        
        
        Authentication: Not required
        
        Parameters:
        - customerId: integer (required)
          Customer Reference
        
        
        
        Headers:
        - Accesstoken: string
          Authorization token for identification of the caller
        - ChannelType: integer
          Channel identifier from where the TXN has originated (Internet, Mobile, ATM, Branch Channel )
        - Co-Relationid: integer
          Unique ID for the service invoked, will be set by the TXN system
        - InitiatingSystem: string
          Indicating the initiated system
        - ServiceMode: integer
          Used for branch channel to indicate the type of customer
        - UUIDSeqNo: integer
          UUID Sequence Number
        - entity: string
          entity
        - languageCode: integer
          languageCode
        - referenceId: string
          Place holder for Token based authentication
        - userId: integer
          userId
        
        
        """
        
        
        # Prepare query parameters
        params = {}
        
        
        # Replace path parameters in URL
        path = "/customerManagement/customer/{customerId}/activeModifiedPendingAuth"
        if customerid is not None:
            path = path.replace("{customerId}", str(customerid))
        
        
        # Prepare headers
        headers = {}
        if accesstoken is not None:
            headers["Accesstoken"] = str(accesstoken)
        if channeltype is not None:
            headers["ChannelType"] = str(channeltype)
        if co_relationid is not None:
            headers["Co-Relationid"] = str(co_relationid)
        if initiatingsystem is not None:
            headers["InitiatingSystem"] = str(initiatingsystem)
        if servicemode is not None:
            headers["ServiceMode"] = str(servicemode)
        if uuidseqno is not None:
            headers["UUIDSeqNo"] = str(uuidseqno)
        if entity is not None:
            headers["entity"] = str(entity)
        if languagecode is not None:
            headers["languageCode"] = str(languagecode)
        if referenceid is not None:
            headers["referenceId"] = str(referenceid)
        if userid is not None:
            headers["userId"] = str(userid)
        
        
        return await make_api_request(
            "PUT", 
            path, 
            
            params=params if params else None, 
            headers=headers if headers else None
        )
    
    
    
    @mcp.tool()
    async def brbtactv_bpmoh_for_bpchng_using_put(
        customerid: int,
        accesstoken: Optional[str] = None,
        channeltype: Optional[int] = None,
        co_relationid: Optional[int] = None,
        initiatingsystem: Optional[str] = None,
        servicemode: Optional[int] = None,
        uuidseqno: Optional[int] = None,
        entity: Optional[str] = None,
        languagecode: Optional[int] = None,
        referenceid: Optional[str] = None,
        userid: Optional[int] = None
    ) -> Dict[str, Any]:
        """
        Customer Status Change from Active to ActiveModifiedOnHold
        
        Generated from: PUT /customerManagement/customer/{customerId}/activeToActiveModifiedOnHold
        Source: swagger_2_0
        Operation ID: BRBTActvBPMohForBPChngUsingPUT
        
        
        Authentication: Not required
        
        Parameters:
        - customerId: integer (required)
          Customer Reference
        
        
        
        Headers:
        - Accesstoken: string
          Authorization token for identification of the caller
        - ChannelType: integer
          Channel identifier from where the TXN has originated (Internet, Mobile, ATM, Branch Channel )
        - Co-Relationid: integer
          Unique ID for the service invoked, will be set by the TXN system
        - InitiatingSystem: string
          Indicating the initiated system
        - ServiceMode: integer
          Used for branch channel to indicate the type of customer
        - UUIDSeqNo: integer
          UUID Sequence Number
        - entity: string
          entity
        - languageCode: integer
          languageCode
        - referenceId: string
          Place holder for Token based authentication
        - userId: integer
          userId
        
        
        """
        
        
        # Prepare query parameters
        params = {}
        
        
        # Replace path parameters in URL
        path = "/customerManagement/customer/{customerId}/activeToActiveModifiedOnHold"
        if customerid is not None:
            path = path.replace("{customerId}", str(customerid))
        
        
        # Prepare headers
        headers = {}
        if accesstoken is not None:
            headers["Accesstoken"] = str(accesstoken)
        if channeltype is not None:
            headers["ChannelType"] = str(channeltype)
        if co_relationid is not None:
            headers["Co-Relationid"] = str(co_relationid)
        if initiatingsystem is not None:
            headers["InitiatingSystem"] = str(initiatingsystem)
        if servicemode is not None:
            headers["ServiceMode"] = str(servicemode)
        if uuidseqno is not None:
            headers["UUIDSeqNo"] = str(uuidseqno)
        if entity is not None:
            headers["entity"] = str(entity)
        if languagecode is not None:
            headers["languageCode"] = str(languagecode)
        if referenceid is not None:
            headers["referenceId"] = str(referenceid)
        if userid is not None:
            headers["userId"] = str(userid)
        
        
        return await make_api_request(
            "PUT", 
            path, 
            
            params=params if params else None, 
            headers=headers if headers else None
        )
    
    
    
    @mcp.tool()
    async def brbtcreate_modify_comm_dtls_using_put(
        customerid: int,
        request_body:Dict[str, Any] ,  # communicationDetailsResource,
        accesstoken: Optional[str] = None,
        channeltype: Optional[int] = None,
        co_relationid: Optional[int] = None,
        initiatingsystem: Optional[str] = None,
        servicemode: Optional[int] = None,
        uuidseqno: Optional[int] = None,
        entity: Optional[str] = None,
        languagecode: Optional[int] = None,
        referenceid: Optional[str] = None,
        requesthash: Optional[str] = None,
        userid: Optional[int] = None
    ) -> Dict[str, Any]:
        """
        Create or modify the existing Customer Communication/Address Details
        
        Generated from: PUT /customerManagement/customer/{customerId}/communicationDetails
        Source: swagger_2_0
        Operation ID: BRBTCreateModifyCommDtlsUsingPUT
        
        
        Authentication: Not required
        
        Parameters:
        - customerId: integer (required)
          Customer Reference
        - request_body: any (required)
          input
        
        
        
        Headers:
        - Accesstoken: string
          Authorization token for identification of the caller
        - ChannelType: integer
          Channel identifier from where the TXN has originated (Internet, Mobile, ATM, Branch Channel )
        - Co-Relationid: integer
          Unique ID for the service invoked, will be set by the TXN system
        - InitiatingSystem: string
          Indicating the initiated system
        - ServiceMode: integer
          Used for branch channel to indicate the type of customer
        - UUIDSeqNo: integer
          UUID Sequence Number
        - entity: string
          entity
        - languageCode: integer
          languageCode
        - referenceId: string
          Place holder for Token based authentication
        - requesthash: string
          Request payload for hash validation
        - userId: integer
          userId
        
        
        """
        
        
        # Prepare request data
        
        # Single body parameter - send directly
        data = request_body if request_body is not None else {}
        
        
        
        # Prepare query parameters
        params = {}
        
        
        # Replace path parameters in URL
        path = "/customerManagement/customer/{customerId}/communicationDetails"
        if customerid is not None:
            path = path.replace("{customerId}", str(customerid))
        
        
        # Prepare headers
        headers = {}
        if accesstoken is not None:
            headers["Accesstoken"] = str(accesstoken)
        if channeltype is not None:
            headers["ChannelType"] = str(channeltype)
        if co_relationid is not None:
            headers["Co-Relationid"] = str(co_relationid)
        if initiatingsystem is not None:
            headers["InitiatingSystem"] = str(initiatingsystem)
        if servicemode is not None:
            headers["ServiceMode"] = str(servicemode)
        if uuidseqno is not None:
            headers["UUIDSeqNo"] = str(uuidseqno)
        if entity is not None:
            headers["entity"] = str(entity)
        if languagecode is not None:
            headers["languageCode"] = str(languagecode)
        if referenceid is not None:
            headers["referenceId"] = str(referenceid)
        if requesthash is not None:
            headers["requesthash"] = str(requesthash)
        if userid is not None:
            headers["userId"] = str(userid)
        
        
        return await make_api_request(
            "PUT", 
            path, 
            data=data, 
            params=params if params else None, 
            headers=headers if headers else None
        )
    
    
    
    @mcp.tool()
    async def brbt0303_mod_contact_dtls_postusing_put(
        customerid: int,
        request_body:Dict[str, Any] ,  # contactDetailsModifiedOnHoldRequest,
        accesstoken: Optional[str] = None,
        channeltype: Optional[int] = None,
        co_relationid: Optional[int] = None,
        initiatingsystem: Optional[str] = None,
        servicemode: Optional[int] = None,
        uuidseqno: Optional[int] = None,
        entity: Optional[str] = None,
        languagecode: Optional[int] = None,
        referenceid: Optional[str] = None,
        userid: Optional[int] = None
    ) -> Dict[str, Any]:
        """
        Modifies the Contact Details of Customer in Modified OnHold
        
        Generated from: PUT /customerManagement/customer/{customerId}/contactDetailsModifiedOnHold
        Source: swagger_2_0
        Operation ID: BRBT0303ModContactDtls_POSTUsingPUT
        
        
        Authentication: Not required
        
        Parameters:
        - customerId: integer (required)
          Customer Reference
        - request_body: any (required)
          input
        
        
        
        Headers:
        - Accesstoken: string
          Authorization token for identification of the caller
        - ChannelType: integer
          Channel identifier from where the TXN has originated (Internet, Mobile, ATM, Branch Channel )
        - Co-Relationid: integer
          Unique ID for the service invoked, will be set by the TXN system
        - InitiatingSystem: string
          Indicating the initiated system
        - ServiceMode: integer
          Used for branch channel to indicate the type of customer
        - UUIDSeqNo: integer
          UUID Sequence Number
        - entity: string
          entity
        - languageCode: integer
          languageCode
        - referenceId: string
          Place holder for Token based authentication
        - userId: integer
          userId
        
        
        """
        
        
        # Prepare request data
        
        # Single body parameter - send directly
        data = request_body if request_body is not None else {}
        
        
        
        # Prepare query parameters
        params = {}
        
        
        # Replace path parameters in URL
        path = "/customerManagement/customer/{customerId}/contactDetailsModifiedOnHold"
        if customerid is not None:
            path = path.replace("{customerId}", str(customerid))
        
        
        # Prepare headers
        headers = {}
        if accesstoken is not None:
            headers["Accesstoken"] = str(accesstoken)
        if channeltype is not None:
            headers["ChannelType"] = str(channeltype)
        if co_relationid is not None:
            headers["Co-Relationid"] = str(co_relationid)
        if initiatingsystem is not None:
            headers["InitiatingSystem"] = str(initiatingsystem)
        if servicemode is not None:
            headers["ServiceMode"] = str(servicemode)
        if uuidseqno is not None:
            headers["UUIDSeqNo"] = str(uuidseqno)
        if entity is not None:
            headers["entity"] = str(entity)
        if languagecode is not None:
            headers["languageCode"] = str(languagecode)
        if referenceid is not None:
            headers["referenceId"] = str(referenceid)
        if userid is not None:
            headers["userId"] = str(userid)
        
        
        return await make_api_request(
            "PUT", 
            path, 
            data=data, 
            params=params if params else None, 
            headers=headers if headers else None
        )
    
    
    
    @mcp.tool()
    async def bret1592_fetch_retails_fatca_details1_using_get(
        customerid: int,
        pagenum: Optional[int] = None,
        pagesize: Optional[int] = None,
        accesstoken: Optional[str] = None,
        channeltype: Optional[int] = None,
        co_relationid: Optional[int] = None,
        initiatingsystem: Optional[str] = None,
        servicemode: Optional[int] = None,
        uuidseqno: Optional[int] = None,
        entity: Optional[str] = None,
        languagecode: Optional[int] = None,
        referenceid: Optional[str] = None,
        userid: Optional[int] = None
    ) -> Dict[str, Any]:
        """
        Fetch Corporate Fatca Details
        
        Generated from: GET /customerManagement/customer/{customerId}/fatcaDetails/corporate
        Source: swagger_2_0
        Operation ID: BRET1592FetchRetailsFatcaDetails1UsingGET
        
        
        Authentication: Not required
        
        Parameters:
        - customerId: integer (required)
          Customer Reference
        - pageNum: integer
          pageNum
        - pageSize: integer
          pageSize
        
        
        
        Headers:
        - Accesstoken: string
          Authorization token for identification of the caller
        - ChannelType: integer
          Channel identifier from where the TXN has originated (Internet, Mobile, ATM, Branch Channel )
        - Co-Relationid: integer
          Unique ID for the service invoked, will be set by the TXN system
        - InitiatingSystem: string
          Indicating the initiated system
        - ServiceMode: integer
          Used for branch channel to indicate the type of customer
        - UUIDSeqNo: integer
          UUID Sequence Number
        - entity: string
          entity
        - languageCode: integer
          languageCode
        - referenceId: string
          Place holder for Token based authentication
        - userId: integer
          userId
        
        
        """
        
        
        # Prepare query parameters
        params = {}
        if pagenum is not None:
            params["pageNum"] = pagenum
            
        if pagesize is not None:
            params["pageSize"] = pagesize
            
        
        
        # Replace path parameters in URL
        path = "/customerManagement/customer/{customerId}/fatcaDetails/corporate"
        if customerid is not None:
            path = path.replace("{customerId}", str(customerid))
        
        
        # Prepare headers
        headers = {}
        if accesstoken is not None:
            headers["Accesstoken"] = str(accesstoken)
        if channeltype is not None:
            headers["ChannelType"] = str(channeltype)
        if co_relationid is not None:
            headers["Co-Relationid"] = str(co_relationid)
        if initiatingsystem is not None:
            headers["InitiatingSystem"] = str(initiatingsystem)
        if servicemode is not None:
            headers["ServiceMode"] = str(servicemode)
        if uuidseqno is not None:
            headers["UUIDSeqNo"] = str(uuidseqno)
        if entity is not None:
            headers["entity"] = str(entity)
        if languagecode is not None:
            headers["languageCode"] = str(languagecode)
        if referenceid is not None:
            headers["referenceId"] = str(referenceid)
        if userid is not None:
            headers["userId"] = str(userid)
        
        
        return await make_api_request(
            "GET", 
            path, 
            
            params=params if params else None, 
            headers=headers if headers else None
        )
    
    
    
    @mcp.tool()
    async def bret1592_fetch_retails_fatca_details_using_get(
        customerid: int,
        pagenum: Optional[int] = None,
        pagesize: Optional[int] = None,
        accesstoken: Optional[str] = None,
        channeltype: Optional[int] = None,
        co_relationid: Optional[int] = None,
        initiatingsystem: Optional[str] = None,
        servicemode: Optional[int] = None,
        uuidseqno: Optional[int] = None,
        entity: Optional[str] = None,
        languagecode: Optional[int] = None,
        referenceid: Optional[str] = None,
        userid: Optional[int] = None
    ) -> Dict[str, Any]:
        """
        Fetch Retail Fatca Details
        
        Generated from: GET /customerManagement/customer/{customerId}/fatcaDetails/retail
        Source: swagger_2_0
        Operation ID: BRET1592FetchRetailsFatcaDetailsUsingGET
        
        
        Authentication: Not required
        
        Parameters:
        - customerId: integer (required)
          Customer Reference
        - pageNum: integer
          pageNum
        - pageSize: integer
          pageSize
        
        
        
        Headers:
        - Accesstoken: string
          Authorization token for identification of the caller
        - ChannelType: integer
          Channel identifier from where the TXN has originated (Internet, Mobile, ATM, Branch Channel )
        - Co-Relationid: integer
          Unique ID for the service invoked, will be set by the TXN system
        - InitiatingSystem: string
          Indicating the initiated system
        - ServiceMode: integer
          Used for branch channel to indicate the type of customer
        - UUIDSeqNo: integer
          UUID Sequence Number
        - entity: string
          entity
        - languageCode: integer
          languageCode
        - referenceId: string
          Place holder for Token based authentication
        - userId: integer
          userId
        
        
        """
        
        
        # Prepare query parameters
        params = {}
        if pagenum is not None:
            params["pageNum"] = pagenum
            
        if pagesize is not None:
            params["pageSize"] = pagesize
            
        
        
        # Replace path parameters in URL
        path = "/customerManagement/customer/{customerId}/fatcaDetails/retail"
        if customerid is not None:
            path = path.replace("{customerId}", str(customerid))
        
        
        # Prepare headers
        headers = {}
        if accesstoken is not None:
            headers["Accesstoken"] = str(accesstoken)
        if channeltype is not None:
            headers["ChannelType"] = str(channeltype)
        if co_relationid is not None:
            headers["Co-Relationid"] = str(co_relationid)
        if initiatingsystem is not None:
            headers["InitiatingSystem"] = str(initiatingsystem)
        if servicemode is not None:
            headers["ServiceMode"] = str(servicemode)
        if uuidseqno is not None:
            headers["UUIDSeqNo"] = str(uuidseqno)
        if entity is not None:
            headers["entity"] = str(entity)
        if languagecode is not None:
            headers["languageCode"] = str(languagecode)
        if referenceid is not None:
            headers["referenceId"] = str(referenceid)
        if userid is not None:
            headers["userId"] = str(userid)
        
        
        return await make_api_request(
            "GET", 
            path, 
            
            params=params if params else None, 
            headers=headers if headers else None
        )
    
    
    
    @mcp.tool()
    async def brbt8001_create_modifyt_bpidntfn_putusing_put(
        customerid: int,
        request_body:Dict[str, Any] ,  # identificationDetailsModifiedOnHoldResource,
        accesstoken: Optional[str] = None,
        channeltype: Optional[int] = None,
        co_relationid: Optional[int] = None,
        initiatingsystem: Optional[str] = None,
        servicemode: Optional[int] = None,
        uuidseqno: Optional[int] = None,
        entity: Optional[str] = None,
        languagecode: Optional[int] = None,
        referenceid: Optional[str] = None,
        requesthash: Optional[str] = None,
        userid: Optional[int] = None
    ) -> Dict[str, Any]:
        """
        Create or Modify Customer Identification Detail in Modified OnHold Status
        
        Generated from: PUT /customerManagement/customer/{customerId}/identificationDetail/modifiedOnHold
        Source: swagger_2_0
        Operation ID: BRBT8001CreateModifytBPIdntfn_PUTUsingPUT
        
        
        Authentication: Not required
        
        Parameters:
        - customerId: integer (required)
          Customer Reference
        - request_body: any (required)
          input
        
        
        
        Headers:
        - Accesstoken: string
          Authorization Token to validation the caller
        - ChannelType: integer
          Channel identifier from where the TXN has originated (Internet, Mobile, ATM, Branch Channel )
        - Co-Relationid: integer
          Unique ID for the service invoked, will be set by the TXN system
        - InitiatingSystem: string
          Indicating the initiated system
        - ServiceMode: integer
          Used for branch channel to indicate the type of customer
        - UUIDSeqNo: integer
          UUID Sequence Number
        - entity: string
          entity
        - languageCode: integer
          languageCode
        - referenceId: string
          Place holder for Token based authentication
        - requesthash: string
          Request payload for hash validation
        - userId: integer
          userId
        
        
        """
        
        
        # Prepare request data
        
        # Single body parameter - send directly
        data = request_body if request_body is not None else {}
        
        
        
        # Prepare query parameters
        params = {}
        
        
        # Replace path parameters in URL
        path = "/customerManagement/customer/{customerId}/identificationDetail/modifiedOnHold"
        if customerid is not None:
            path = path.replace("{customerId}", str(customerid))
        
        
        # Prepare headers
        headers = {}
        if accesstoken is not None:
            headers["Accesstoken"] = str(accesstoken)
        if channeltype is not None:
            headers["ChannelType"] = str(channeltype)
        if co_relationid is not None:
            headers["Co-Relationid"] = str(co_relationid)
        if initiatingsystem is not None:
            headers["InitiatingSystem"] = str(initiatingsystem)
        if servicemode is not None:
            headers["ServiceMode"] = str(servicemode)
        if uuidseqno is not None:
            headers["UUIDSeqNo"] = str(uuidseqno)
        if entity is not None:
            headers["entity"] = str(entity)
        if languagecode is not None:
            headers["languageCode"] = str(languagecode)
        if referenceid is not None:
            headers["referenceId"] = str(referenceid)
        if requesthash is not None:
            headers["requesthash"] = str(requesthash)
        if userid is not None:
            headers["userId"] = str(userid)
        
        
        return await make_api_request(
            "PUT", 
            path, 
            data=data, 
            params=params if params else None, 
            headers=headers if headers else None
        )
    
    
    
    @mcp.tool()
    async def brbtmoh_bpmoh_for_bpchng_tax_putusing_put(
        customerid: int,
        request_body:Dict[str, Any] ,  # customerDetailModifyResource,
        accesstoken: Optional[str] = None,
        channeltype: Optional[int] = None,
        co_relationid: Optional[int] = None,
        initiatingsystem: Optional[str] = None,
        servicemode: Optional[int] = None,
        uuidseqno: Optional[int] = None,
        entity: Optional[str] = None,
        languagecode: Optional[int] = None,
        referenceid: Optional[str] = None,
        requesthash: Optional[str] = None,
        userid: Optional[int] = None
    ) -> Dict[str, Any]:
        """
        Customer Detail Modification
        
        Generated from: PUT /customerManagement/customer/{customerId}/modifyOnHoldCustomerDetails
        Source: swagger_2_0
        Operation ID: BRBTMohBPMohForBPChngTAX_PUTUsingPUT
        
        
        Authentication: Not required
        
        Parameters:
        - customerId: integer (required)
          Customer Reference
        - request_body: any (required)
          input
        
        
        
        Headers:
        - Accesstoken: string
          Authorization Token to validation the caller
        - ChannelType: integer
          Channel identifier from where the TXN has originated (Internet, Mobile, ATM, Branch Channel )
        - Co-Relationid: integer
          Unique ID for the service invoked, will be set by the TXN system
        - InitiatingSystem: string
          Indicating the initiated system
        - ServiceMode: integer
          Used for branch channel to indicate the type of customer
        - UUIDSeqNo: integer
          UUID Sequence Number
        - entity: string
          entity
        - languageCode: integer
          languageCode
        - referenceId: string
          Place holder for Token based authentication
        - requesthash: string
          Request payload for hash validation
        - userId: integer
          userId
        
        
        """
        
        
        # Prepare request data
        
        # Single body parameter - send directly
        data = request_body if request_body is not None else {}
        
        
        
        # Prepare query parameters
        params = {}
        
        
        # Replace path parameters in URL
        path = "/customerManagement/customer/{customerId}/modifyOnHoldCustomerDetails"
        if customerid is not None:
            path = path.replace("{customerId}", str(customerid))
        
        
        # Prepare headers
        headers = {}
        if accesstoken is not None:
            headers["Accesstoken"] = str(accesstoken)
        if channeltype is not None:
            headers["ChannelType"] = str(channeltype)
        if co_relationid is not None:
            headers["Co-Relationid"] = str(co_relationid)
        if initiatingsystem is not None:
            headers["InitiatingSystem"] = str(initiatingsystem)
        if servicemode is not None:
            headers["ServiceMode"] = str(servicemode)
        if uuidseqno is not None:
            headers["UUIDSeqNo"] = str(uuidseqno)
        if entity is not None:
            headers["entity"] = str(entity)
        if languagecode is not None:
            headers["languageCode"] = str(languagecode)
        if referenceid is not None:
            headers["referenceId"] = str(referenceid)
        if requesthash is not None:
            headers["requesthash"] = str(requesthash)
        if userid is not None:
            headers["userId"] = str(userid)
        
        
        return await make_api_request(
            "PUT", 
            path, 
            data=data, 
            params=params if params else None, 
            headers=headers if headers else None
        )
    
    
    
    @mcp.tool()
    async def kfebt0305_create_notes_memo_tickler_using_post(
        customerid: int,
        request_body:Dict[str, Any] ,  # notesAndMemoResource,
        accesstoken: Optional[str] = None,
        channeltype: Optional[int] = None,
        co_relationid: Optional[int] = None,
        entity: Optional[str] = None,
        initiatingsystem: Optional[str] = None,
        languagecode: Optional[int] = None,
        referenceid: Optional[str] = None,
        requesthash: Optional[str] = None,
        servicemode: Optional[int] = None,
        userid: Optional[int] = None,
        uuidseqno: Optional[int] = None
    ) -> Dict[str, Any]:
        """
        Create Notes and Memo
        
        Generated from: POST /customerManagement/customer/{customerId}/notesMemo
        Source: swagger_2_0
        Operation ID: KFEBT0305CreateNotesMemoTicklerUsingPOST
        
        
        Authentication: Not required
        
        Parameters:
        - customerId: integer (required)
          Customer Reference
        - request_body: any (required)
          input
        
        
        
        Headers:
        - Accesstoken: string
          Authorization Token to validation the caller
        - ChannelType: integer
          Channel identifier from where the TXN has originated (Internet, Mobile, ATM, Branch Channel )
        - co-Relationid: integer
          Unique ID for the service invoked, will be set by the TXN system
        - entity: string
          entity
        - initiatingSystem: string
          Indicating the initiated system
        - languageCode: integer
          languageCode
        - referenceId: string
          Place holder for Token based authentication
        - requesthash: string
          Request payload for hash validation
        - serviceMode: integer
          Used for branch channel to indicate the type of customer
        - userId: integer
          userId
        - uuidSeqNo: integer
          UUID Sequence Number
        
        
        """
        
        
        # Prepare request data
        
        # Single body parameter - send directly
        data = request_body if request_body is not None else {}
        
        
        
        # Prepare query parameters
        params = {}
        
        
        # Replace path parameters in URL
        path = "/customerManagement/customer/{customerId}/notesMemo"
        if customerid is not None:
            path = path.replace("{customerId}", str(customerid))
        
        
        # Prepare headers
        headers = {}
        if accesstoken is not None:
            headers["Accesstoken"] = str(accesstoken)
        if channeltype is not None:
            headers["ChannelType"] = str(channeltype)
        if co_relationid is not None:
            headers["co-Relationid"] = str(co_relationid)
        if entity is not None:
            headers["entity"] = str(entity)
        if initiatingsystem is not None:
            headers["initiatingSystem"] = str(initiatingsystem)
        if languagecode is not None:
            headers["languageCode"] = str(languagecode)
        if referenceid is not None:
            headers["referenceId"] = str(referenceid)
        if requesthash is not None:
            headers["requesthash"] = str(requesthash)
        if servicemode is not None:
            headers["serviceMode"] = str(servicemode)
        if userid is not None:
            headers["userId"] = str(userid)
        if uuidseqno is not None:
            headers["uuidSeqNo"] = str(uuidseqno)
        
        
        return await make_api_request(
            "POST", 
            path, 
            data=data, 
            params=params if params else None, 
            headers=headers if headers else None
        )
    
    
    
    @mcp.tool()
    async def brbt0105_onhld_bppndng_auth_postusing_put(
        customerid: int,
        accesstoken: Optional[str] = None,
        channeltype: Optional[int] = None,
        co_relationid: Optional[int] = None,
        initiatingsystem: Optional[str] = None,
        servicemode: Optional[int] = None,
        uuidseqno: Optional[int] = None,
        entity: Optional[str] = None,
        languagecode: Optional[int] = None,
        userid: Optional[int] = None
    ) -> Dict[str, Any]:
        """
        Customer Status Change from Onhold To PendngAuth Status
        
        Generated from: PUT /customerManagement/customer/{customerId}/onHoldToPendingAuth
        Source: swagger_2_0
        Operation ID: BRBT0105OnhldBPPndngAuth_POSTUsingPUT
        
        
        Authentication: Not required
        
        Parameters:
        - customerId: integer (required)
          Customer ID
        
        
        
        Headers:
        - Accesstoken: string
          Authorization token for identification of the caller
        - ChannelType: integer
          Channel identifier from where the TXN has originated (Internet, Mobile, ATM, Branch Channel )
        - Co-Relationid: integer
          Unique ID for the service invoked, will be set by the TXN system
        - InitiatingSystem: string
          Indicating the initiated system
        - ServiceMode: integer
          Used for branch channel to indicate the type of customer
        - UUIDSeqNo: integer
          UUID Sequence Number
        - entity: string
          entity
        - languageCode: integer
          languageCode
        - userId: integer
          userId
        
        
        """
        
        
        # Prepare query parameters
        params = {}
        
        
        # Replace path parameters in URL
        path = "/customerManagement/customer/{customerId}/onHoldToPendingAuth"
        if customerid is not None:
            path = path.replace("{customerId}", str(customerid))
        
        
        # Prepare headers
        headers = {}
        if accesstoken is not None:
            headers["Accesstoken"] = str(accesstoken)
        if channeltype is not None:
            headers["ChannelType"] = str(channeltype)
        if co_relationid is not None:
            headers["Co-Relationid"] = str(co_relationid)
        if initiatingsystem is not None:
            headers["InitiatingSystem"] = str(initiatingsystem)
        if servicemode is not None:
            headers["ServiceMode"] = str(servicemode)
        if uuidseqno is not None:
            headers["UUIDSeqNo"] = str(uuidseqno)
        if entity is not None:
            headers["entity"] = str(entity)
        if languagecode is not None:
            headers["languageCode"] = str(languagecode)
        if userid is not None:
            headers["userId"] = str(userid)
        
        
        return await make_api_request(
            "PUT", 
            path, 
            
            params=params if params else None, 
            headers=headers if headers else None
        )
    
    
    
    @mcp.tool()
    async def brbt0108_pndng_auth_bpactv_postusing_put(
        customerid: int,
        accesstoken: Optional[str] = None,
        channeltype: Optional[int] = None,
        co_relationid: Optional[int] = None,
        initiatingsystem: Optional[str] = None,
        servicemode: Optional[int] = None,
        uuidseqno: Optional[int] = None,
        entity: Optional[str] = None,
        languagecode: Optional[int] = None,
        userid: Optional[int] = None
    ) -> Dict[str, Any]:
        """
        Customer StatusChange from PendingAuth Status
        
        Generated from: PUT /customerManagement/customer/{customerId}/pendingAuthToActive
        Source: swagger_2_0
        Operation ID: BRBT0108PndngAuthBPActv_POSTUsingPUT
        
        
        Authentication: Not required
        
        Parameters:
        - customerId: integer (required)
          Customer ID
        
        
        
        Headers:
        - Accesstoken: string
          Authorization token for identification of the caller
        - ChannelType: integer
          Channel identifier from where the TXN has originated (Internet, Mobile, ATM, Branch Channel )
        - Co-Relationid: integer
          Unique ID for the service invoked, will be set by the TXN system
        - InitiatingSystem: string
          Indicating the initiated system
        - ServiceMode: integer
          Used for branch channel to indicate the type of customer
        - UUIDSeqNo: integer
          UUID Sequence Number
        - entity: string
          entity
        - languageCode: integer
          languageCode
        - userId: integer
          userId
        
        
        """
        
        
        # Prepare query parameters
        params = {}
        
        
        # Replace path parameters in URL
        path = "/customerManagement/customer/{customerId}/pendingAuthToActive"
        if customerid is not None:
            path = path.replace("{customerId}", str(customerid))
        
        
        # Prepare headers
        headers = {}
        if accesstoken is not None:
            headers["Accesstoken"] = str(accesstoken)
        if channeltype is not None:
            headers["ChannelType"] = str(channeltype)
        if co_relationid is not None:
            headers["Co-Relationid"] = str(co_relationid)
        if initiatingsystem is not None:
            headers["InitiatingSystem"] = str(initiatingsystem)
        if servicemode is not None:
            headers["ServiceMode"] = str(servicemode)
        if uuidseqno is not None:
            headers["UUIDSeqNo"] = str(uuidseqno)
        if entity is not None:
            headers["entity"] = str(entity)
        if languagecode is not None:
            headers["languageCode"] = str(languagecode)
        if userid is not None:
            headers["userId"] = str(userid)
        
        
        return await make_api_request(
            "PUT", 
            path, 
            
            params=params if params else None, 
            headers=headers if headers else None
        )
    
    
    
    @mcp.tool()
    async def brbt0107_pndng_auth_bprjct_using_put(
        customerid: int,
        accesstoken: Optional[str] = None,
        channeltype: Optional[int] = None,
        co_relationid: Optional[int] = None,
        initiatingsystem: Optional[str] = None,
        servicemode: Optional[int] = None,
        uuidseqno: Optional[int] = None,
        entity: Optional[str] = None,
        languagecode: Optional[int] = None,
        referenceid: Optional[str] = None,
        userid: Optional[int] = None
    ) -> Dict[str, Any]:
        """
        Customer Status Change from PendingAuth to Reject
        
        Generated from: PUT /customerManagement/customer/{customerId}/pendingAuthToReject
        Source: swagger_2_0
        Operation ID: BRBT0107PndngAuthBPRjctUsingPUT
        
        
        Authentication: Not required
        
        Parameters:
        - customerId: integer (required)
          Customer Reference
        
        
        
        Headers:
        - Accesstoken: string
          Authorization token for identification of the caller
        - ChannelType: integer
          Channel identifier from where the TXN has originated (Internet, Mobile, ATM, Branch Channel )
        - Co-Relationid: integer
          Unique ID for the service invoked, will be set by the TXN system
        - InitiatingSystem: string
          Indicating the initiated system
        - ServiceMode: integer
          Used for branch channel to indicate the type of customer
        - UUIDSeqNo: integer
          UUID Sequence Number
        - entity: string
          entity
        - languageCode: integer
          languageCode
        - referenceId: string
          Place holder for Token based authentication
        - userId: integer
          userId
        
        
        """
        
        
        # Prepare query parameters
        params = {}
        
        
        # Replace path parameters in URL
        path = "/customerManagement/customer/{customerId}/pendingAuthToReject"
        if customerid is not None:
            path = path.replace("{customerId}", str(customerid))
        
        
        # Prepare headers
        headers = {}
        if accesstoken is not None:
            headers["Accesstoken"] = str(accesstoken)
        if channeltype is not None:
            headers["ChannelType"] = str(channeltype)
        if co_relationid is not None:
            headers["Co-Relationid"] = str(co_relationid)
        if initiatingsystem is not None:
            headers["InitiatingSystem"] = str(initiatingsystem)
        if servicemode is not None:
            headers["ServiceMode"] = str(servicemode)
        if uuidseqno is not None:
            headers["UUIDSeqNo"] = str(uuidseqno)
        if entity is not None:
            headers["entity"] = str(entity)
        if languagecode is not None:
            headers["languageCode"] = str(languagecode)
        if referenceid is not None:
            headers["referenceId"] = str(referenceid)
        if userid is not None:
            headers["userId"] = str(userid)
        
        
        return await make_api_request(
            "PUT", 
            path, 
            
            params=params if params else None, 
            headers=headers if headers else None
        )
    
    
    
    @mcp.tool()
    async def brbt0801_set_up_bproles_using_put(
        customerid: int,
        customerroletype: int,
        request_body:Dict[str, Any] ,  # customerRolesResource,
        accesstoken: Optional[str] = None,
        channeltype: Optional[int] = None,
        co_relationid: Optional[int] = None,
        initiatingsystem: Optional[str] = None,
        servicemode: Optional[int] = None,
        uuidseqno: Optional[int] = None,
        entity: Optional[str] = None,
        languagecode: Optional[int] = None,
        referenceid: Optional[str] = None,
        requesthash: Optional[str] = None,
        userid: Optional[int] = None
    ) -> Dict[str, Any]:
        """
        Create or modify or delete customer roles of existing customer
        
        Generated from: PUT /customerManagement/customer/{customerId}/role/{customerRoleType}
        Source: swagger_2_0
        Operation ID: BRBT0801SetUpBPRolesUsingPUT
        
        
        Authentication: Not required
        
        Parameters:
        - customerId: integer (required)
          Customer Reference
        - customerRoleType: integer (required)
          Type of Roles (Domain Name: d_BPRole) Eg : 1 - Customer, 2 - Vendor, 4 - Employee, 18 - Agent, 31 - Lessor
        - request_body: any (required)
          input
        
        
        
        Headers:
        - Accesstoken: string
          Authorization token for identification of the caller
        - ChannelType: integer
          Channel identifier from where the TXN has originated (Internet, Mobile, ATM, Branch Channel )
        - Co-Relationid: integer
          Unique ID for the service invoked, will be set by the TXN system
        - InitiatingSystem: string
          Indicating the initiated system
        - ServiceMode: integer
          Used for branch channel to indicate the type of customer
        - UUIDSeqNo: integer
          UUID Sequence Number
        - entity: string
          entity
        - languageCode: integer
          languageCode
        - referenceId: string
          Place holder for Token based authentication
        - requesthash: string
          Request payload for hash validation
        - userId: integer
          userId
        
        
        """
        
        
        # Prepare request data
        
        # Single body parameter - send directly
        data = request_body if request_body is not None else {}
        
        
        
        # Prepare query parameters
        params = {}
        
        
        # Replace path parameters in URL
        path = "/customerManagement/customer/{customerId}/role/{customerRoleType}"
        if customerid is not None:
            path = path.replace("{customerId}", str(customerid))
        if customerroletype is not None:
            path = path.replace("{customerRoleType}", str(customerroletype))
        
        
        # Prepare headers
        headers = {}
        if accesstoken is not None:
            headers["Accesstoken"] = str(accesstoken)
        if channeltype is not None:
            headers["ChannelType"] = str(channeltype)
        if co_relationid is not None:
            headers["Co-Relationid"] = str(co_relationid)
        if initiatingsystem is not None:
            headers["InitiatingSystem"] = str(initiatingsystem)
        if servicemode is not None:
            headers["ServiceMode"] = str(servicemode)
        if uuidseqno is not None:
            headers["UUIDSeqNo"] = str(uuidseqno)
        if entity is not None:
            headers["entity"] = str(entity)
        if languagecode is not None:
            headers["languageCode"] = str(languagecode)
        if referenceid is not None:
            headers["referenceId"] = str(referenceid)
        if requesthash is not None:
            headers["requesthash"] = str(requesthash)
        if userid is not None:
            headers["userId"] = str(userid)
        
        
        return await make_api_request(
            "PUT", 
            path, 
            data=data, 
            params=params if params else None, 
            headers=headers if headers else None
        )
    
    
    
    @mcp.tool()
    async def brbt0161_mpa_bpactv_new_using_put(
        authorizationindicator: int,
        customerid: int,
        accesstoken: Optional[str] = None,
        channeltype: Optional[int] = None,
        co_relationid: Optional[int] = None,
        entity: Optional[str] = None,
        initiatingsystem: Optional[str] = None,
        languagecode: Optional[int] = None,
        referenceid: Optional[str] = None,
        servicemode: Optional[int] = None,
        userid: Optional[int] = None,
        uuidseqno: Optional[int] = None
    ) -> Dict[str, Any]:
        """
        Customer Status Change from Active Pending Authorization to Active
        
        Generated from: PUT /customerManagement/customer/{customerId}/{authorizationIndicator}/activePendingAuthToActive
        Source: swagger_2_0
        Operation ID: BRBT0161MpaBPActvNewUsingPUT
        
        
        Authentication: Not required
        
        Parameters:
        - authorizationIndicator: integer (required)
           Authorization Indicator Flag.(Domain Name :d_VerAuthFlg) Possible Values : 1 - Authorized, 2 - Rejected
        - customerId: integer (required)
          Customer Reference
        
        
        
        Headers:
        - Accesstoken: string
          Authorization Token to validation the caller
        - ChannelType: integer
          Channel identifier from where the TXN has originated (Internet, Mobile, ATM, Branch Channel )
        - co-Relationid: integer
          Unique ID for the service invoked, will be set by the TXN system
        - entity: string
          entity
        - initiatingSystem: string
          Indicating the initiated system
        - languageCode: integer
          languageCode
        - referenceId: string
          Place holder for Token based authentication
        - serviceMode: integer
          Used for branch channel to indicate the type of customer
        - userId: integer
          userId
        - uuidSeqNo: integer
          UUID Sequence Number
        
        
        """
        
        
        # Prepare query parameters
        params = {}
        
        
        # Replace path parameters in URL
        path = "/customerManagement/customer/{customerId}/{authorizationIndicator}/activePendingAuthToActive"
        if authorizationindicator is not None:
            path = path.replace("{authorizationIndicator}", str(authorizationindicator))
        if customerid is not None:
            path = path.replace("{customerId}", str(customerid))
        
        
        # Prepare headers
        headers = {}
        if accesstoken is not None:
            headers["Accesstoken"] = str(accesstoken)
        if channeltype is not None:
            headers["ChannelType"] = str(channeltype)
        if co_relationid is not None:
            headers["co-Relationid"] = str(co_relationid)
        if entity is not None:
            headers["entity"] = str(entity)
        if initiatingsystem is not None:
            headers["initiatingSystem"] = str(initiatingsystem)
        if languagecode is not None:
            headers["languageCode"] = str(languagecode)
        if referenceid is not None:
            headers["referenceId"] = str(referenceid)
        if servicemode is not None:
            headers["serviceMode"] = str(servicemode)
        if userid is not None:
            headers["userId"] = str(userid)
        if uuidseqno is not None:
            headers["uuidSeqNo"] = str(uuidseqno)
        
        
        return await make_api_request(
            "PUT", 
            path, 
            
            params=params if params else None, 
            headers=headers if headers else None
        )
    
    
    
    @mcp.tool()
    async def brbt3197_pndng_auth_bpclsd_postusing_put(
        authorizationindicator: int,
        customerid: int,
        accesstoken: Optional[str] = None,
        channeltype: Optional[int] = None,
        co_relationid: Optional[int] = None,
        entity: Optional[str] = None,
        initiatingsystem: Optional[str] = None,
        languagecode: Optional[int] = None,
        referenceid: Optional[str] = None,
        servicemode: Optional[int] = None,
        userid: Optional[int] = None,
        uuidseqno: Optional[int] = None
    ) -> Dict[str, Any]:
        """
        Customer Status Change from Pending Closure to Closed
        
        Generated from: PUT /customerManagement/customer/{customerId}/{authorizationIndicator}/pendingClosureToClosed
        Source: swagger_2_0
        Operation ID: BRBT3197PndngAuthBPClsd_POSTUsingPUT
        
        
        Authentication: Not required
        
        Parameters:
        - authorizationIndicator: integer (required)
           Authorization Indicator Flag.(Domain Name :d_VerAuthFlg) Possible Values : 1 - Authorized, 2 - Rejected
        - customerId: integer (required)
          Customer Reference
        
        
        
        Headers:
        - Accesstoken: string
          Authorization Token to validation the caller
        - ChannelType: integer
          Channel identifier from where the TXN has originated (Internet, Mobile, ATM, Branch Channel )
        - co-Relationid: integer
          Unique ID for the service invoked, will be set by the TXN system
        - entity: string
          entity
        - initiatingSystem: string
          Indicating the initiated system
        - languageCode: integer
          languageCode
        - referenceId: string
          Place holder for Token based authentication
        - serviceMode: integer
          Used for branch channel to indicate the type of customer
        - userId: integer
          userId
        - uuidSeqNo: integer
          UUID Sequence Number
        
        
        """
        
        
        # Prepare query parameters
        params = {}
        
        
        # Replace path parameters in URL
        path = "/customerManagement/customer/{customerId}/{authorizationIndicator}/pendingClosureToClosed"
        if authorizationindicator is not None:
            path = path.replace("{authorizationIndicator}", str(authorizationindicator))
        if customerid is not None:
            path = path.replace("{customerId}", str(customerid))
        
        
        # Prepare headers
        headers = {}
        if accesstoken is not None:
            headers["Accesstoken"] = str(accesstoken)
        if channeltype is not None:
            headers["ChannelType"] = str(channeltype)
        if co_relationid is not None:
            headers["co-Relationid"] = str(co_relationid)
        if entity is not None:
            headers["entity"] = str(entity)
        if initiatingsystem is not None:
            headers["initiatingSystem"] = str(initiatingsystem)
        if languagecode is not None:
            headers["languageCode"] = str(languagecode)
        if referenceid is not None:
            headers["referenceId"] = str(referenceid)
        if servicemode is not None:
            headers["serviceMode"] = str(servicemode)
        if userid is not None:
            headers["userId"] = str(userid)
        if uuidseqno is not None:
            headers["uuidSeqNo"] = str(uuidseqno)
        
        
        return await make_api_request(
            "PUT", 
            path, 
            
            params=params if params else None, 
            headers=headers if headers else None
        )
    
    
    
    @mcp.tool()
    async def brbt0303_auth_risk_rating_using_put(
        customerreference: int,
        accesstoken: Optional[str] = None,
        channeltype: Optional[int] = None,
        entity: Optional[str] = None,
        languagecode: Optional[int] = None,
        userid: Optional[int] = None
    ) -> Dict[str, Any]:
        """
        authorise modified riskRating of the customer
        
        Generated from: PUT /customerManagement/customer/{customerReference}/authRiskRating
        Source: swagger_2_0
        Operation ID: BRBT0303AuthRiskRatingUsingPUT
        
        
        Authentication: Not required
        
        Parameters:
        - customerReference: integer (required)
          Customer Reference
        
        
        
        Headers:
        - Accesstoken: string
          Authorization token for identification of the caller
        - ChannelType: integer
          Channel identifier from where the TXN has originated (Internet, Mobile, ATM, Branch Channel )
        - entity: string
          entity
        - languageCode: integer
          languageCode
        - userId: integer
          userId
        
        
        """
        
        
        # Prepare query parameters
        params = {}
        
        
        # Replace path parameters in URL
        path = "/customerManagement/customer/{customerReference}/authRiskRating"
        if customerreference is not None:
            path = path.replace("{customerReference}", str(customerreference))
        
        
        # Prepare headers
        headers = {}
        if accesstoken is not None:
            headers["Accesstoken"] = str(accesstoken)
        if channeltype is not None:
            headers["ChannelType"] = str(channeltype)
        if entity is not None:
            headers["entity"] = str(entity)
        if languagecode is not None:
            headers["languageCode"] = str(languagecode)
        if userid is not None:
            headers["userId"] = str(userid)
        
        
        return await make_api_request(
            "PUT", 
            path, 
            
            params=params if params else None, 
            headers=headers if headers else None
        )
    
    
    
    @mcp.tool()
    async def bret0803_get_cstmr_elgblty_using_get(
        customerid: int,
        eligiblitytype: int,
        pagenum: Optional[int] = None,
        pagesize: Optional[int] = None,
        accesstoken: Optional[str] = None,
        channeltype: Optional[int] = None,
        co_relationid: Optional[int] = None,
        initiatingsystem: Optional[str] = None,
        servicemode: Optional[int] = None,
        uuidseqno: Optional[int] = None,
        entity: Optional[str] = None,
        languagecode: Optional[int] = None,
        referenceid: Optional[str] = None,
        userid: Optional[int] = None
    ) -> Dict[str, Any]:
        """
        Get All Customer Eligiblity
        
        Generated from: GET /customerManagement/customerEligibilty/{customerId}/{eligiblityType}
        Source: swagger_2_0
        Operation ID: BRET0803GetCstmrElgbltyUsingGET
        
        
        Authentication: Not required
        
        Parameters:
        - customerId: integer (required)
          customerId of the Customer
        - eligiblityType: integer (required)
          (domain : d_EligibilityTypes)  Eg :  1 - Segment , 2- AcntType , 3 - All 
        - pageNum: integer
          pageNum
        - pageSize: integer
          pageSize
        
        
        
        Headers:
        - Accesstoken: string
          Authorization token for identification of the caller
        - ChannelType: integer
          Channel identifier from where the transaction has originated (Internet, Mobile, ATM, Branch Channel )
        - Co-Relationid: integer
          Unique ID for the service invoked, will be set by the transaction system
        - InitiatingSystem: string
          Indicating the initiated system
        - ServiceMode: integer
          Used for branch channel to indicate the type of customer
        - UUIDSeqNo: integer
          UUID Sequence Number
        - entity: string
          entity
        - languageCode: integer
          languageCode
        - referenceId: string
          Place holder for Token based authentication
        - userId: integer
          userId
        
        
        """
        
        
        # Prepare query parameters
        params = {}
        if pagenum is not None:
            params["pageNum"] = pagenum
            
        if pagesize is not None:
            params["pageSize"] = pagesize
            
        
        
        # Replace path parameters in URL
        path = "/customerManagement/customerEligibilty/{customerId}/{eligiblityType}"
        if customerid is not None:
            path = path.replace("{customerId}", str(customerid))
        if eligiblitytype is not None:
            path = path.replace("{eligiblityType}", str(eligiblitytype))
        
        
        # Prepare headers
        headers = {}
        if accesstoken is not None:
            headers["Accesstoken"] = str(accesstoken)
        if channeltype is not None:
            headers["ChannelType"] = str(channeltype)
        if co_relationid is not None:
            headers["Co-Relationid"] = str(co_relationid)
        if initiatingsystem is not None:
            headers["InitiatingSystem"] = str(initiatingsystem)
        if servicemode is not None:
            headers["ServiceMode"] = str(servicemode)
        if uuidseqno is not None:
            headers["UUIDSeqNo"] = str(uuidseqno)
        if entity is not None:
            headers["entity"] = str(entity)
        if languagecode is not None:
            headers["languageCode"] = str(languagecode)
        if referenceid is not None:
            headers["referenceId"] = str(referenceid)
        if userid is not None:
            headers["userId"] = str(userid)
        
        
        return await make_api_request(
            "GET", 
            path, 
            
            params=params if params else None, 
            headers=headers if headers else None
        )
    
    
    
    @mcp.tool()
    async def kfeet0305_fetch_notes_memo_tickler_postusing_get(
        businessarea: Optional[int] = None,
        businessreference: Optional[str] = None,
        notesandmemoid: Optional[int] = None,
        pagenum: Optional[int] = None,
        pagesize: Optional[int] = None,
        accesstoken: Optional[str] = None,
        channeltype: Optional[int] = None,
        entity: Optional[str] = None,
        languagecode: Optional[int] = None,
        userid: Optional[int] = None
    ) -> Dict[str, Any]:
        """
        fetch Notes and Memo created for a particular Business area specified or for the given NotesandMemoID
        
        Generated from: GET /customerManagement/customerManagement/customer/notesMemo
        Source: swagger_2_0
        Operation ID: KFEET0305FetchNotesMemoTickler_POSTUsingGET
        
        
        Authentication: Not required
        
        Parameters:
        - businessArea: integer
          Business Area for which the Notes and Memo was created. It could be Loan, Customer, Collateral, Deposit, CASA or Limit, This field is conditionally mandatory i.e., this field is mandatory only when NotesandMemoID field is blank ( eg: 1-Loan, 2-Collateral, 3-Customer, 4-Deposit, 5-Account, 6-Limit )
        - businessReference: string
          Reference number of the corresponding Business Area. This field is conditionally mandatory i.e., this field is mandatory only when Business Area is NOT blank
        - notesAndMemoId: integer
          Unique reference number generated in BaNCS to identify a NotesandMemo created. This field is conditionally mandatory i.e., this field is mandatory only when Business Area is blank
        - pageNum: integer
          pageNum
        - pageSize: integer
          pageSize
        
        
        
        Headers:
        - Accesstoken: string
          Authorization token for identification of the caller
        - ChannelType: integer
          Channel identifier from where the TXN has originated (Internet, Mobile, ATM, Branch Channel )
        - entity: string
          entity
        - languageCode: integer
          languageCode
        - userId: integer
          userId
        
        
        """
        
        
        # Prepare query parameters
        params = {}
        if businessarea is not None:
            params["businessArea"] = businessarea
            
        if businessreference is not None:
            params["businessReference"] = businessreference
            
        if notesandmemoid is not None:
            params["notesAndMemoId"] = notesandmemoid
            
        if pagenum is not None:
            params["pageNum"] = pagenum
            
        if pagesize is not None:
            params["pageSize"] = pagesize
            
        
        
        # Replace path parameters in URL
        path = "/customerManagement/customerManagement/customer/notesMemo"
        
        
        # Prepare headers
        headers = {}
        if accesstoken is not None:
            headers["Accesstoken"] = str(accesstoken)
        if channeltype is not None:
            headers["ChannelType"] = str(channeltype)
        if entity is not None:
            headers["entity"] = str(entity)
        if languagecode is not None:
            headers["languageCode"] = str(languagecode)
        if userid is not None:
            headers["userId"] = str(userid)
        
        
        return await make_api_request(
            "GET", 
            path, 
            
            params=params if params else None, 
            headers=headers if headers else None
        )
    
    
    
    @mcp.tool()
    async def rstbtquick_customer_onboarding_wth_mnr_using_post(
        request_body:Dict[str, Any] ,  # CustomerOnboardingWthMnrResource,
        accesstoken: Optional[str] = None,
        channeltype: Optional[int] = None,
        co_relationid: Optional[int] = None,
        initiatingsystem: Optional[str] = None,
        servicemode: Optional[int] = None,
        uuidseqno: Optional[int] = None,
        entity: Optional[str] = None,
        languagecode: Optional[int] = None,
        referenceid: Optional[str] = None,
        requesthash: Optional[str] = None,
        userid: Optional[int] = None
    ) -> Dict[str, Any]:
        """
        Create Customer With Relations
        
        Generated from: POST /customerManagement/customerWithRelations
        Source: swagger_2_0
        Operation ID: RSTBTQuickCustomerOnboardingWthMnrUsingPOST
        
        
        Authentication: Not required
        
        Parameters:
        - request_body: any (required)
          input
        
        
        
        Headers:
        - Accesstoken: string
          Authorization Token to validation the caller
        - ChannelType: integer
          Channel identifier from where the TXN has originated (Internet, Mobile, ATM, Branch Channel )
        - Co-Relationid: integer
          Unique ID for the service invoked, will be set by the TXN system
        - InitiatingSystem: string
          Indicating the initiated system
        - ServiceMode: integer
          Used for branch channel to indicate the type of customer
        - UUIDSeqNo: integer
          UUID Sequence Number
        - entity: string
          entity
        - languageCode: integer
          languageCode
        - referenceId: string
          Place holder forToken based authetication
        - requesthash: string
          Request payload for hash validation
        - userId: integer
          userId
        
        
        """
        
        
        # Prepare request data
        
        # Single body parameter - send directly
        data = request_body if request_body is not None else {}
        
        
        
        # Prepare query parameters
        params = {}
        
        
        # Replace path parameters in URL
        path = "/customerManagement/customerWithRelations"
        
        
        # Prepare headers
        headers = {}
        if accesstoken is not None:
            headers["Accesstoken"] = str(accesstoken)
        if channeltype is not None:
            headers["ChannelType"] = str(channeltype)
        if co_relationid is not None:
            headers["Co-Relationid"] = str(co_relationid)
        if initiatingsystem is not None:
            headers["InitiatingSystem"] = str(initiatingsystem)
        if servicemode is not None:
            headers["ServiceMode"] = str(servicemode)
        if uuidseqno is not None:
            headers["UUIDSeqNo"] = str(uuidseqno)
        if entity is not None:
            headers["entity"] = str(entity)
        if languagecode is not None:
            headers["languageCode"] = str(languagecode)
        if referenceid is not None:
            headers["referenceId"] = str(referenceid)
        if requesthash is not None:
            headers["requesthash"] = str(requesthash)
        if userid is not None:
            headers["userId"] = str(userid)
        
        
        return await make_api_request(
            "POST", 
            path, 
            data=data, 
            params=params if params else None, 
            headers=headers if headers else None
        )
    
    
    
    @mcp.tool()
    async def bret8005_get_bpfrm_idntfn_using_get(
        identifiertype: int,
        identifiervalue: str,
        bpcategory: Optional[int] = None,
        comapnyname: Optional[str] = None,
        dateofbirth: Optional[str] = None,
        firstname: Optional[str] = None,
        lastname: Optional[str] = None,
        statuscheckflag: Optional[str] = None,
        accesstoken: Optional[str] = None,
        channeltype: Optional[int] = None,
        co_relationid: Optional[int] = None,
        initiatingsystem: Optional[str] = None,
        servicemode: Optional[int] = None,
        uuidseqno: Optional[int] = None,
        entity: Optional[str] = None,
        languagecode: Optional[int] = None,
        referenceid: Optional[str] = None,
        userid: Optional[int] = None
    ) -> Dict[str, Any]:
        """
        De Dupe Validation
        
        Generated from: GET /customerManagement/deDupeValidate/{identifierType}/{identifierValue}
        Source: swagger_2_0
        Operation ID: BRET8005GetBPfrmIdntfnUsingGET
        
        
        Authentication: Not required
        
        Parameters:
        - BPcategory: integer
          Enter the BP Category of the customer(Individual:1 Company:2)
        - ComapnyName: string
          Enter the Name of Company
        - DateOfBirth: string
          Enter the Date of birth or origin of customer
        - FirstName: string
          Enter the First Name of customer
        - LastName: string
          Enter the Last Name of the customer
        - identifierType: integer (required)
          Enter the Identifier type(Domain:d_BPNationalID 75: Registered Company ID Number,99: Aadhaar,64: PAN,65: Driving Licence)
        - identifierValue: string (required)
          Enter the Identifier value
        - statusCheckFlag: string
          If (1:API will return the details ofActive orInactive BP)(null:API will return the bpRefId ofonly Active BP)
        
        
        
        Headers:
        - Accesstoken: string
          Authorization Token to validation the caller
        - ChannelType: integer
          Channel identifier from where the TXN has originated (Internet, Mobile, ATM, Branch Channel )
        - Co-Relationid: integer
          Unique ID for the service invoked, will be set by the TXN system
        - InitiatingSystem: string
          Indicating the initiated system
        - ServiceMode: integer
          Used for branch channel to indicate the type of customer
        - UUIDSeqNo: integer
          UUID Sequence Number
        - entity: string
          entity
        - languageCode: integer
          languageCode
        - referenceId: string
          Place holder for Token based authentication
        - userId: integer
          userId
        
        
        """
        
        
        # Prepare query parameters
        params = {}
        if bpcategory is not None:
            params["BPcategory"] = bpcategory
            
        if comapnyname is not None:
            params["ComapnyName"] = comapnyname
            
        if dateofbirth is not None:
            params["DateOfBirth"] = dateofbirth
            
        if firstname is not None:
            params["FirstName"] = firstname
            
        if lastname is not None:
            params["LastName"] = lastname
            
        if statuscheckflag is not None:
            params["statusCheckFlag"] = statuscheckflag
            
        
        
        # Replace path parameters in URL
        path = "/customerManagement/deDupeValidate/{identifierType}/{identifierValue}"
        if identifiertype is not None:
            path = path.replace("{identifierType}", str(identifiertype))
        if identifiervalue is not None:
            path = path.replace("{identifierValue}", str(identifiervalue))
        
        
        # Prepare headers
        headers = {}
        if accesstoken is not None:
            headers["Accesstoken"] = str(accesstoken)
        if channeltype is not None:
            headers["ChannelType"] = str(channeltype)
        if co_relationid is not None:
            headers["Co-Relationid"] = str(co_relationid)
        if initiatingsystem is not None:
            headers["InitiatingSystem"] = str(initiatingsystem)
        if servicemode is not None:
            headers["ServiceMode"] = str(servicemode)
        if uuidseqno is not None:
            headers["UUIDSeqNo"] = str(uuidseqno)
        if entity is not None:
            headers["entity"] = str(entity)
        if languagecode is not None:
            headers["languageCode"] = str(languagecode)
        if referenceid is not None:
            headers["referenceId"] = str(referenceid)
        if userid is not None:
            headers["userId"] = str(userid)
        
        
        return await make_api_request(
            "GET", 
            path, 
            
            params=params if params else None, 
            headers=headers if headers else None
        )
    
    
    
    @mcp.tool()
    async def bret2021_get_doc_upload_postusing_get(
        documenttype: int,
        levelreference: int,
        leveltype: int,
        accesstoken: Optional[str] = None,
        channeltype: Optional[int] = None,
        co_relationid: Optional[int] = None,
        initiatingsystem: Optional[str] = None,
        servicemode: Optional[int] = None,
        uuidseqno: Optional[int] = None,
        entity: Optional[str] = None,
        languagecode: Optional[int] = None,
        referenceid: Optional[str] = None,
        userid: Optional[int] = None
    ) -> Dict[str, Any]:
        """
        This API is used to fetch the uploaded document information
        
        Generated from: GET /customerManagement/fetchDocumentUpload
        Source: swagger_2_0
        Operation ID: BRET2021GetDocUpload_POSTUsingGET
        
        
        Authentication: Not required
        
        Parameters:
        - documentType: integer (required)
          Type of the Document [Domain:- d_RcvDocCode]
        - levelReference: integer (required)
          Level Reference [BP_ID in case of Customer and POS_ID i case of Account]
        - levelType: integer (required)
          Level at which Document is uploaded [Account-43/Customer-41]
        
        
        
        Headers:
        - Accesstoken: string
          Authorization token for identification of the caller
        - ChannelType: integer
          Channel identifier from where the TXN has originated (Internet, Mobile, ATM, Branch Channel )
        - Co-Relationid: integer
          Unique ID for the service invoked, will be set by the TXN system
        - InitiatingSystem: string
          Indicating the initiated system
        - ServiceMode: integer
          Used for branch channel to indicate the type of customer
        - UUIDSeqNo: integer
          UUID Sequence Number
        - entity: string
          entity
        - languageCode: integer
          languageCode
        - referenceId: string
          Place holder for Token based authentication
        - userId: integer
          userId
        
        
        """
        
        
        # Prepare query parameters
        params = {}
        if documenttype is not None:
            params["documentType"] = documenttype
            
        if levelreference is not None:
            params["levelReference"] = levelreference
            
        if leveltype is not None:
            params["levelType"] = leveltype
            
        
        
        # Replace path parameters in URL
        path = "/customerManagement/fetchDocumentUpload"
        
        
        # Prepare headers
        headers = {}
        if accesstoken is not None:
            headers["Accesstoken"] = str(accesstoken)
        if channeltype is not None:
            headers["ChannelType"] = str(channeltype)
        if co_relationid is not None:
            headers["Co-Relationid"] = str(co_relationid)
        if initiatingsystem is not None:
            headers["InitiatingSystem"] = str(initiatingsystem)
        if servicemode is not None:
            headers["ServiceMode"] = str(servicemode)
        if uuidseqno is not None:
            headers["UUIDSeqNo"] = str(uuidseqno)
        if entity is not None:
            headers["entity"] = str(entity)
        if languagecode is not None:
            headers["languageCode"] = str(languagecode)
        if referenceid is not None:
            headers["referenceId"] = str(referenceid)
        if userid is not None:
            headers["userId"] = str(userid)
        
        
        return await make_api_request(
            "GET", 
            path, 
            
            params=params if params else None, 
            headers=headers if headers else None
        )
    
    
    
    @mcp.tool()
    async def bret6302_get_subscrp_list_getusing_get(
        customerreference: str,
        accountreference: Optional[str] = None,
        branchid: Optional[str] = None,
        language: Optional[int] = None,
        pagenum: Optional[int] = None,
        pagesize: Optional[int] = None,
        subscriptionidrestartkey: Optional[int] = None,
        accesstoken: Optional[str] = None,
        channeltype: Optional[int] = None,
        co_relationid: Optional[int] = None,
        initiatingsystem: Optional[str] = None,
        servicemode: Optional[int] = None,
        uuidseqno: Optional[int] = None,
        entity: Optional[str] = None,
        languagecode: Optional[int] = None,
        referenceid: Optional[str] = None,
        requesthash: Optional[str] = None,
        userid: Optional[int] = None
    ) -> Dict[str, Any]:
        """
        This API fetches list of Reports subscribed
        
        Generated from: GET /customerManagement/list/reportSubscription
        Source: swagger_2_0
        Operation ID: BRET6302GetSubscrpList_GETUsingGET
        
        
        Authentication: Not required
        
        Parameters:
        - accountreference: string
          accountreference
        - branchId: string
          branch Id
        - customerReference: string (required)
          Unique customer reference
        - language: integer
          language
        - pageNum: integer
          pageNum
        - pageSize: integer
          pageSize
        - subscriptionIdRestartKey: integer
          subscriptionIdRestartKey
        
        
        
        Headers:
        - Accesstoken: string
          Authorization token for identification of the caller
        - ChannelType: integer
          Channel identifier from where the TXN has originated (Internet, Mobile, ATM, Branch Channel )
        - Co-Relationid: integer
          Unique ID for the service invoked, will be set by the TXN system
        - InitiatingSystem: string
          Indicating the initiated system
        - ServiceMode: integer
          Used for branch channel to indicate the type of customer
        - UUIDSeqNo: integer
          UUID Sequence Number
        - entity: string
          entity
        - languageCode: integer
          languageCode
        - referenceId: string
          Place holder for Token based authentication
        - requesthash: string
          Request payload for hash validation
        - userId: integer
          userId
        
        
        """
        
        
        # Prepare query parameters
        params = {}
        if accountreference is not None:
            params["accountreference"] = accountreference
            
        if branchid is not None:
            params["branchId"] = branchid
            
        if customerreference is not None:
            params["customerReference"] = customerreference
            
        if language is not None:
            params["language"] = language
            
        if pagenum is not None:
            params["pageNum"] = pagenum
            
        if pagesize is not None:
            params["pageSize"] = pagesize
            
        if subscriptionidrestartkey is not None:
            params["subscriptionIdRestartKey"] = subscriptionidrestartkey
            
        
        
        # Replace path parameters in URL
        path = "/customerManagement/list/reportSubscription"
        
        
        # Prepare headers
        headers = {}
        if accesstoken is not None:
            headers["Accesstoken"] = str(accesstoken)
        if channeltype is not None:
            headers["ChannelType"] = str(channeltype)
        if co_relationid is not None:
            headers["Co-Relationid"] = str(co_relationid)
        if initiatingsystem is not None:
            headers["InitiatingSystem"] = str(initiatingsystem)
        if servicemode is not None:
            headers["ServiceMode"] = str(servicemode)
        if uuidseqno is not None:
            headers["UUIDSeqNo"] = str(uuidseqno)
        if entity is not None:
            headers["entity"] = str(entity)
        if languagecode is not None:
            headers["languageCode"] = str(languagecode)
        if referenceid is not None:
            headers["referenceId"] = str(referenceid)
        if requesthash is not None:
            headers["requesthash"] = str(requesthash)
        if userid is not None:
            headers["userId"] = str(userid)
        
        
        return await make_api_request(
            "GET", 
            path, 
            
            params=params if params else None, 
            headers=headers if headers else None
        )
    
    
    
    @mcp.tool()
    async def rstbt2310_modify_customer_wusing_post(
        request_body:Dict[str, Any] ,  # CustomerModifyResource,
        accesstoken: Optional[str] = None,
        channeltype: Optional[int] = None,
        co_relationid: Optional[int] = None,
        initiatingsystem: Optional[str] = None,
        servicemode: Optional[int] = None,
        uuidseqno: Optional[int] = None,
        entity: Optional[str] = None,
        languagecode: Optional[int] = None,
        userid: Optional[int] = None
    ) -> Dict[str, Any]:
        """
        Customer Details Modification
        
        Generated from: POST /customerManagement/modifyCustomerDetails
        Source: swagger_2_0
        Operation ID: RSTBT2310ModifyCustomerWUsingPOST
        
        
        Authentication: Not required
        
        Parameters:
        - request_body: any (required)
          input
        
        
        
        Headers:
        - Accesstoken: string
          Authorization Token to validation the caller
        - ChannelType: integer
          Channel identifier from where the TXN has originated (Internet, Mobile, ATM, Branch Channel )
        - Co-Relationid: integer
          Unique ID for the service invoked, will be set by the TXN system
        - InitiatingSystem: string
          Indicating the initiated system
        - ServiceMode: integer
          Used for branch channel to indicate the type of customer
        - UUIDSeqNo: integer
          UUID Sequence Number
        - entity: string
          entity
        - languageCode: integer
          languageCode
        - userId: integer
          userId
        
        
        """
        
        
        # Prepare request data
        
        # Single body parameter - send directly
        data = request_body if request_body is not None else {}
        
        
        
        # Prepare query parameters
        params = {}
        
        
        # Replace path parameters in URL
        path = "/customerManagement/modifyCustomerDetails"
        
        
        # Prepare headers
        headers = {}
        if accesstoken is not None:
            headers["Accesstoken"] = str(accesstoken)
        if channeltype is not None:
            headers["ChannelType"] = str(channeltype)
        if co_relationid is not None:
            headers["Co-Relationid"] = str(co_relationid)
        if initiatingsystem is not None:
            headers["InitiatingSystem"] = str(initiatingsystem)
        if servicemode is not None:
            headers["ServiceMode"] = str(servicemode)
        if uuidseqno is not None:
            headers["UUIDSeqNo"] = str(uuidseqno)
        if entity is not None:
            headers["entity"] = str(entity)
        if languagecode is not None:
            headers["languageCode"] = str(languagecode)
        if userid is not None:
            headers["userId"] = str(userid)
        
        
        return await make_api_request(
            "POST", 
            path, 
            data=data, 
            params=params if params else None, 
            headers=headers if headers else None
        )
    
    
    
    @mcp.tool()
    async def brbtcreate_mdfy_notifcn_subscrptn_postusing_post(
        request_body:Dict[str, Any] ,  # CreateMdfyNotifcnSubscrptnResource,
        accesstoken: Optional[str] = None,
        channeltype: Optional[int] = None,
        co_relationid: Optional[int] = None,
        initiatingsystem: Optional[str] = None,
        servicemode: Optional[int] = None,
        uuidseqno: Optional[int] = None,
        entity: Optional[str] = None,
        languagecode: Optional[int] = None,
        referenceid: Optional[str] = None,
        requesthash: Optional[str] = None,
        userid: Optional[int] = None
    ) -> Dict[str, Any]:
        """
        This API is to create modify Notification Subscription
        
        Generated from: POST /customerManagement/notification/createModify
        Source: swagger_2_0
        Operation ID: BRBTCreateMdfyNotifcnSubscrptn_POSTUsingPOST
        
        
        Authentication: Not required
        
        Parameters:
        - request_body: any (required)
          input
        
        
        
        Headers:
        - Accesstoken: string
          Authorization token for identification of the caller
        - ChannelType: integer
          Channel identifier from where the TXN has originated (Internet, Mobile, ATM, Branch Channel )
        - Co-Relationid: integer
          Unique ID for the service invoked, will be set by the TXN system
        - InitiatingSystem: string
          Indicating the initiated system
        - ServiceMode: integer
          Used for branch channel to indicate the type of customer
        - UUIDSeqNo: integer
          UUID Sequence Number
        - entity: string
          entity
        - languageCode: integer
          languageCode
        - referenceId: string
          Place holder for Token based authentication
        - requesthash: string
          Request payload for hash validation
        - userId: integer
          userId
        
        
        """
        
        
        # Prepare request data
        
        # Single body parameter - send directly
        data = request_body if request_body is not None else {}
        
        
        
        # Prepare query parameters
        params = {}
        
        
        # Replace path parameters in URL
        path = "/customerManagement/notification/createModify"
        
        
        # Prepare headers
        headers = {}
        if accesstoken is not None:
            headers["Accesstoken"] = str(accesstoken)
        if channeltype is not None:
            headers["ChannelType"] = str(channeltype)
        if co_relationid is not None:
            headers["Co-Relationid"] = str(co_relationid)
        if initiatingsystem is not None:
            headers["InitiatingSystem"] = str(initiatingsystem)
        if servicemode is not None:
            headers["ServiceMode"] = str(servicemode)
        if uuidseqno is not None:
            headers["UUIDSeqNo"] = str(uuidseqno)
        if entity is not None:
            headers["entity"] = str(entity)
        if languagecode is not None:
            headers["languageCode"] = str(languagecode)
        if referenceid is not None:
            headers["referenceId"] = str(referenceid)
        if requesthash is not None:
            headers["requesthash"] = str(requesthash)
        if userid is not None:
            headers["userId"] = str(userid)
        
        
        return await make_api_request(
            "POST", 
            path, 
            data=data, 
            params=params if params else None, 
            headers=headers if headers else None
        )
    
    
    
    @mcp.tool()
    async def bretget_notifcn_subscrptn_getusing_get(
        customerreference: int,
        accesstoken: Optional[str] = None,
        channeltype: Optional[int] = None,
        co_relationid: Optional[int] = None,
        initiatingsystem: Optional[str] = None,
        servicemode: Optional[int] = None,
        uuidseqno: Optional[int] = None,
        entity: Optional[str] = None,
        languagecode: Optional[int] = None,
        referenceid: Optional[str] = None,
        requesthash: Optional[str] = None,
        userid: Optional[int] = None
    ) -> Dict[str, Any]:
        """
        This API is used to list the Alert Subscriptions
        
        Generated from: GET /customerManagement/notificationSubscription/list
        Source: swagger_2_0
        Operation ID: BRETGetNotifcnSubscrptn_GETUsingGET
        
        
        Authentication: Not required
        
        Parameters:
        - customerReference: integer (required)
          customerReference
        
        
        
        Headers:
        - Accesstoken: string
          Authorization token for identification of the caller
        - ChannelType: integer
          Channel identifier from where the TXN has originated (Internet, Mobile, ATM, Branch Channel )
        - Co-Relationid: integer
          Unique ID for the service invoked, will be set by the TXN system
        - InitiatingSystem: string
          Indicating the initiated system
        - ServiceMode: integer
          Used for branch channel to indicate the type of customer
        - UUIDSeqNo: integer
          UUID Sequence Number
        - entity: string
          entity
        - languageCode: integer
          languageCode
        - referenceId: string
          Place holder for Token based authentication
        - requesthash: string
          Request payload for hash validation
        - userId: integer
          userId
        
        
        """
        
        
        # Prepare query parameters
        params = {}
        if customerreference is not None:
            params["customerReference"] = customerreference
            
        
        
        # Replace path parameters in URL
        path = "/customerManagement/notificationSubscription/list"
        
        
        # Prepare headers
        headers = {}
        if accesstoken is not None:
            headers["Accesstoken"] = str(accesstoken)
        if channeltype is not None:
            headers["ChannelType"] = str(channeltype)
        if co_relationid is not None:
            headers["Co-Relationid"] = str(co_relationid)
        if initiatingsystem is not None:
            headers["InitiatingSystem"] = str(initiatingsystem)
        if servicemode is not None:
            headers["ServiceMode"] = str(servicemode)
        if uuidseqno is not None:
            headers["UUIDSeqNo"] = str(uuidseqno)
        if entity is not None:
            headers["entity"] = str(entity)
        if languagecode is not None:
            headers["languageCode"] = str(languagecode)
        if referenceid is not None:
            headers["referenceId"] = str(referenceid)
        if requesthash is not None:
            headers["requesthash"] = str(requesthash)
        if userid is not None:
            headers["userId"] = str(userid)
        
        
        return await make_api_request(
            "GET", 
            path, 
            
            params=params if params else None, 
            headers=headers if headers else None
        )
    
    
    
    @mcp.tool()
    async def brbt6301_intl_subscrp_actv_postusing_post(
        request_body:Dict[str, Any] ,  # SubscrpActvResource,
        accesstoken: Optional[str] = None,
        channeltype: Optional[int] = None,
        co_relationid: Optional[int] = None,
        initiatingsystem: Optional[str] = None,
        servicemode: Optional[int] = None,
        uuidseqno: Optional[int] = None,
        entity: Optional[str] = None,
        languagecode: Optional[int] = None,
        referenceid: Optional[str] = None,
        requesthash: Optional[str] = None,
        userid: Optional[int] = None
    ) -> Dict[str, Any]:
        """
        This API used to subscribe Reports
        
        Generated from: POST /customerManagement/reports/subscription
        Source: swagger_2_0
        Operation ID: BRBT6301IntlSubscrpActv_POSTUsingPOST
        
        
        Authentication: Not required
        
        Parameters:
        - request_body: any (required)
          input
        
        
        
        Headers:
        - Accesstoken: string
          Authorization token for identification of the caller
        - ChannelType: integer
          Channel identifier from where the TXN has originated (Internet, Mobile, ATM, Branch Channel )
        - Co-Relationid: integer
          Unique ID for the service invoked, will be set by the TXN system
        - InitiatingSystem: string
          Indicating the initiated system
        - ServiceMode: integer
          Used for branch channel to indicate the type of customer
        - UUIDSeqNo: integer
          UUID Sequence Number
        - entity: string
          entity
        - languageCode: integer
          languageCode
        - referenceId: string
          Place holder for Token based authentication
        - requesthash: string
          Request payload for hash validation
        - userId: integer
          userId
        
        
        """
        
        
        # Prepare request data
        
        # Single body parameter - send directly
        data = request_body if request_body is not None else {}
        
        
        
        # Prepare query parameters
        params = {}
        
        
        # Replace path parameters in URL
        path = "/customerManagement/reports/subscription"
        
        
        # Prepare headers
        headers = {}
        if accesstoken is not None:
            headers["Accesstoken"] = str(accesstoken)
        if channeltype is not None:
            headers["ChannelType"] = str(channeltype)
        if co_relationid is not None:
            headers["Co-Relationid"] = str(co_relationid)
        if initiatingsystem is not None:
            headers["InitiatingSystem"] = str(initiatingsystem)
        if servicemode is not None:
            headers["ServiceMode"] = str(servicemode)
        if uuidseqno is not None:
            headers["UUIDSeqNo"] = str(uuidseqno)
        if entity is not None:
            headers["entity"] = str(entity)
        if languagecode is not None:
            headers["languageCode"] = str(languagecode)
        if referenceid is not None:
            headers["referenceId"] = str(referenceid)
        if requesthash is not None:
            headers["requesthash"] = str(requesthash)
        if userid is not None:
            headers["userId"] = str(userid)
        
        
        return await make_api_request(
            "POST", 
            path, 
            data=data, 
            params=params if params else None, 
            headers=headers if headers else None
        )
    
    
    
    @mcp.tool()
    async def brbt6313_actv_subscrp_pnd_cncl_postusing_post(
        request_body:Dict[str, Any] ,  # ActvSubscrpPndCnclResource,
        accesstoken: Optional[str] = None,
        channeltype: Optional[int] = None,
        co_relationid: Optional[int] = None,
        initiatingsystem: Optional[str] = None,
        servicemode: Optional[int] = None,
        uuidseqno: Optional[int] = None,
        entity: Optional[str] = None,
        languagecode: Optional[int] = None,
        referenceid: Optional[str] = None,
        requesthash: Optional[str] = None,
        userid: Optional[int] = None
    ) -> Dict[str, Any]:
        """
        This API is to cancel Reports Subscription
        
        Generated from: POST /customerManagement/reportsSubscription/cancel
        Source: swagger_2_0
        Operation ID: BRBT6313ActvSubscrpPndCncl_POSTUsingPOST
        
        
        Authentication: Not required
        
        Parameters:
        - request_body: any (required)
          input
        
        
        
        Headers:
        - Accesstoken: string
          Authorization token for identification of the caller
        - ChannelType: integer
          Channel identifier from where the TXN has originated (Internet, Mobile, ATM, Branch Channel )
        - Co-Relationid: integer
          Unique ID for the service invoked, will be set by the TXN system
        - InitiatingSystem: string
          Indicating the initiated system
        - ServiceMode: integer
          Used for branch channel to indicate the type of customer
        - UUIDSeqNo: integer
          UUID Sequence Number
        - entity: string
          entity
        - languageCode: integer
          languageCode
        - referenceId: string
          Place holder for Token based authentication
        - requesthash: string
          Request payload for hash validation
        - userId: integer
          userId
        
        
        """
        
        
        # Prepare request data
        
        # Single body parameter - send directly
        data = request_body if request_body is not None else {}
        
        
        
        # Prepare query parameters
        params = {}
        
        
        # Replace path parameters in URL
        path = "/customerManagement/reportsSubscription/cancel"
        
        
        # Prepare headers
        headers = {}
        if accesstoken is not None:
            headers["Accesstoken"] = str(accesstoken)
        if channeltype is not None:
            headers["ChannelType"] = str(channeltype)
        if co_relationid is not None:
            headers["Co-Relationid"] = str(co_relationid)
        if initiatingsystem is not None:
            headers["InitiatingSystem"] = str(initiatingsystem)
        if servicemode is not None:
            headers["ServiceMode"] = str(servicemode)
        if uuidseqno is not None:
            headers["UUIDSeqNo"] = str(uuidseqno)
        if entity is not None:
            headers["entity"] = str(entity)
        if languagecode is not None:
            headers["languageCode"] = str(languagecode)
        if referenceid is not None:
            headers["referenceId"] = str(referenceid)
        if requesthash is not None:
            headers["requesthash"] = str(requesthash)
        if userid is not None:
            headers["userId"] = str(userid)
        
        
        return await make_api_request(
            "POST", 
            path, 
            data=data, 
            params=params if params else None, 
            headers=headers if headers else None
        )
    
    
    
    @mcp.tool()
    async def depet0101_fetch_doc_iden_lst_postusing_get(
        customerreference: Optional[int] = None,
        latestassessmentyear: Optional[str] = None,
        pagenum: Optional[int] = None,
        pagesize: Optional[int] = None,
        uinnumber: Optional[str] = None,
        accesstoken: Optional[str] = None,
        channeltype: Optional[int] = None,
        co_relationid: Optional[int] = None,
        initiatingsystem: Optional[str] = None,
        servicemode: Optional[int] = None,
        uuidseqno: Optional[int] = None,
        entity: Optional[str] = None,
        languagecode: Optional[int] = None,
        referenceid: Optional[str] = None,
        userid: Optional[int] = None
    ) -> Dict[str, Any]:
        """
        fetch documents
        
        Generated from: GET /deposits/15GH/fetch
        Source: swagger_2_0
        Operation ID: DEPET0101FetchDocIdenLst_POSTUsingGET
        
        
        Authentication: Not required
        
        Parameters:
        - customerReference: integer
          Customer Reference
        - latestAssessmentYear: string
          Latest Assessment Year
        - pageNum: integer
          pageNum
        - pageSize: integer
          pageSize
        - uinNumber: string
          UIN Number
        
        
        
        Headers:
        - Accesstoken: string
          Authorization token for identification of the caller
        - ChannelType: integer
          Channel identifier from where the TXN has originated (Internet, Mobile, ATM, Branch Channel )
        - Co-Relationid: integer
          Unique ID for the service invoked, will be set by the TXN system
        - InitiatingSystem: string
          Indicating the initiated system
        - ServiceMode: integer
          Used for branch channel to indicate the type of customer
        - UUIDSeqNo: integer
          UUID Sequence Number
        - entity: string
          entity
        - languageCode: integer
          languageCode
        - referenceId: string
          Place holder for Token based authentication
        - userId: integer
          userId
        
        
        """
        
        
        # Prepare query parameters
        params = {}
        if customerreference is not None:
            params["customerReference"] = customerreference
            
        if latestassessmentyear is not None:
            params["latestAssessmentYear"] = latestassessmentyear
            
        if pagenum is not None:
            params["pageNum"] = pagenum
            
        if pagesize is not None:
            params["pageSize"] = pagesize
            
        if uinnumber is not None:
            params["uinNumber"] = uinnumber
            
        
        
        # Replace path parameters in URL
        path = "/deposits/15GH/fetch"
        
        
        # Prepare headers
        headers = {}
        if accesstoken is not None:
            headers["Accesstoken"] = str(accesstoken)
        if channeltype is not None:
            headers["ChannelType"] = str(channeltype)
        if co_relationid is not None:
            headers["Co-Relationid"] = str(co_relationid)
        if initiatingsystem is not None:
            headers["InitiatingSystem"] = str(initiatingsystem)
        if servicemode is not None:
            headers["ServiceMode"] = str(servicemode)
        if uuidseqno is not None:
            headers["UUIDSeqNo"] = str(uuidseqno)
        if entity is not None:
            headers["entity"] = str(entity)
        if languagecode is not None:
            headers["languageCode"] = str(languagecode)
        if referenceid is not None:
            headers["referenceId"] = str(referenceid)
        if userid is not None:
            headers["userId"] = str(userid)
        
        
        return await make_api_request(
            "GET", 
            path, 
            
            params=params if params else None, 
            headers=headers if headers else None
        )
    
    
    
    @mcp.tool()
    async def depet0101_get_doc_iden_lst_postusing_get(
        customerreference: int,
        uinnumber: str,
        accesstoken: Optional[str] = None,
        channeltype: Optional[int] = None,
        co_relationid: Optional[int] = None,
        initiatingsystem: Optional[str] = None,
        servicemode: Optional[int] = None,
        uuidseqno: Optional[int] = None,
        entity: Optional[str] = None,
        languagecode: Optional[int] = None,
        referenceid: Optional[str] = None,
        userid: Optional[int] = None
    ) -> Dict[str, Any]:
        """
        get documents
        
        Generated from: GET /deposits/15GH/{customerReference}/{uinNumber}
        Source: swagger_2_0
        Operation ID: DEPET0101GetDocIdenLst_POSTUsingGET
        
        
        Authentication: Not required
        
        Parameters:
        - customerReference: integer (required)
          Customer Reference
        - uinNumber: string (required)
          UIN Number
        
        
        
        Headers:
        - Accesstoken: string
          Authorization token for identification of the caller
        - ChannelType: integer
          Channel identifier from where the TXN has originated (Internet, Mobile, ATM, Branch Channel )
        - Co-Relationid: integer
          Unique ID for the service invoked, will be set by the TXN system
        - InitiatingSystem: string
          Indicating the initiated system
        - ServiceMode: integer
          Used for branch channel to indicate the type of customer
        - UUIDSeqNo: integer
          UUID Sequence Number
        - entity: string
          entity
        - languageCode: integer
          languageCode
        - referenceId: string
          Place holder for Token based authentication
        - userId: integer
          userId
        
        
        """
        
        
        # Prepare query parameters
        params = {}
        
        
        # Replace path parameters in URL
        path = "/deposits/15GH/{customerReference}/{uinNumber}"
        if customerreference is not None:
            path = path.replace("{customerReference}", str(customerreference))
        if uinnumber is not None:
            path = path.replace("{uinNumber}", str(uinnumber))
        
        
        # Prepare headers
        headers = {}
        if accesstoken is not None:
            headers["Accesstoken"] = str(accesstoken)
        if channeltype is not None:
            headers["ChannelType"] = str(channeltype)
        if co_relationid is not None:
            headers["Co-Relationid"] = str(co_relationid)
        if initiatingsystem is not None:
            headers["InitiatingSystem"] = str(initiatingsystem)
        if servicemode is not None:
            headers["ServiceMode"] = str(servicemode)
        if uuidseqno is not None:
            headers["UUIDSeqNo"] = str(uuidseqno)
        if entity is not None:
            headers["entity"] = str(entity)
        if languagecode is not None:
            headers["languageCode"] = str(languagecode)
        if referenceid is not None:
            headers["referenceId"] = str(referenceid)
        if userid is not None:
            headers["userId"] = str(userid)
        
        
        return await make_api_request(
            "GET", 
            path, 
            
            params=params if params else None, 
            headers=headers if headers else None
        )
    
    
    
    @mcp.tool()
    async def depbt0712_auth_mtrd_dl_postusing_post(
        request_body:Dict[str, Any] ,  # DEP_DEAL_DEPBT0712AuthMtrdDl_Resource,
        co_relationid: Optional[int] = None,
        initiatingsystem: Optional[str] = None,
        servicemode: Optional[int] = None,
        uuidseqno: Optional[int] = None,
        entity: Optional[str] = None,
        languagecode: Optional[int] = None,
        referenceid: Optional[str] = None,
        requesthash: Optional[str] = None,
        userid: Optional[int] = None
    ) -> Dict[str, Any]:
        """
        Authorize Renewal Of Matured Deposit
        
        Generated from: POST /deposits/authMaturedDepositAccount
        Source: swagger_2_0
        Operation ID: DEPBT0712AuthMtrdDl_POSTUsingPOST
        
        
        Authentication: Not required
        
        Parameters:
        - request_body: any (required)
          input
        
        
        
        Headers:
        - Co-Relationid: integer
          Unique ID for the service invoked, will be set by the TXN system
        - InitiatingSystem: string
          Indicating the initiated system
        - ServiceMode: integer
          Used for branch channel to indicate the type of customer
        - UUIDSeqNo: integer
          UUID Sequence Number
        - entity: string
          entity
        - languageCode: integer
          languageCode
        - referenceId: string
          Place holder for Token based authentication
        - requesthash: string
          Request payload for hash validation
        - userId: integer
          userId
        
        
        """
        
        
        # Prepare request data
        
        # Single body parameter - send directly
        data = request_body if request_body is not None else {}
        
        
        
        # Prepare query parameters
        params = {}
        
        
        # Replace path parameters in URL
        path = "/deposits/authMaturedDepositAccount"
        
        
        # Prepare headers
        headers = {}
        if co_relationid is not None:
            headers["Co-Relationid"] = str(co_relationid)
        if initiatingsystem is not None:
            headers["InitiatingSystem"] = str(initiatingsystem)
        if servicemode is not None:
            headers["ServiceMode"] = str(servicemode)
        if uuidseqno is not None:
            headers["UUIDSeqNo"] = str(uuidseqno)
        if entity is not None:
            headers["entity"] = str(entity)
        if languagecode is not None:
            headers["languageCode"] = str(languagecode)
        if referenceid is not None:
            headers["referenceId"] = str(referenceid)
        if requesthash is not None:
            headers["requesthash"] = str(requesthash)
        if userid is not None:
            headers["userId"] = str(userid)
        
        
        return await make_api_request(
            "POST", 
            path, 
            data=data, 
            params=params if params else None, 
            headers=headers if headers else None
        )
    
    
    
    @mcp.tool()
    async def depet0407_fetch_deal_erl_mtrty_postusing_get(
        accountreference: str,
        entity: Optional[str] = None,
        languagecode: Optional[int] = None,
        userid: Optional[int] = None
    ) -> Dict[str, Any]:
        """
        This service is used to Fetch Deal Early Maturity
        
        Generated from: GET /deposits/dealEarlyMaturity
        Source: swagger_2_0
        Operation ID: DEPET0407FetchDealErlMtrty_POSTUsingGET
        
        
        Authentication: Not required
        
        Parameters:
        - accountReference: string (required)
          TD Account Number
        
        
        
        Headers:
        - entity: string
          entity
        - languageCode: integer
          languageCode
        - userId: integer
          userId
        
        
        """
        
        
        # Prepare query parameters
        params = {}
        if accountreference is not None:
            params["accountReference"] = accountreference
            
        
        
        # Replace path parameters in URL
        path = "/deposits/dealEarlyMaturity"
        
        
        # Prepare headers
        headers = {}
        if entity is not None:
            headers["entity"] = str(entity)
        if languagecode is not None:
            headers["languageCode"] = str(languagecode)
        if userid is not None:
            headers["userId"] = str(userid)
        
        
        return await make_api_request(
            "GET", 
            path, 
            
            params=params if params else None, 
            headers=headers if headers else None
        )
    
    
    
    @mcp.tool()
    async def depet0401_get_deal_evnt_lst_postusing_get(
        dealid: int,
        dealtype: int,
        eventpurpose: Optional[int] = None,
        pagenum: Optional[int] = None,
        pagesize: Optional[int] = None,
        pendingflag: Optional[int] = None,
        accesstoken: Optional[str] = None,
        channeltype: Optional[int] = None,
        co_relationid: Optional[int] = None,
        initiatingsystem: Optional[str] = None,
        servicemode: Optional[int] = None,
        uuidseqno: Optional[int] = None,
        entity: Optional[str] = None,
        languagecode: Optional[int] = None,
        referenceid: Optional[str] = None,
        userid: Optional[int] = None
    ) -> Dict[str, Any]:
        """
        Get All Deal Event List
        
        Generated from: GET /deposits/dealEventList/{dealId}/{dealType}
        Source: swagger_2_0
        Operation ID: DEPET0401GetDealEvntLst_POSTUsingGET
        
        
        Authentication: Not required
        
        Parameters:
        - dealId: integer (required)
          DealId of the Deposit
        - dealType: integer (required)
          (domain : d_PosTyp)  Eg :  551 - DepositTxn , 511 - Bill Order Return ,  555 - Crypto Wallet 
        - eventPurpose: integer
          Event Purpose
        - pageNum: integer
          pageNum
        - pageSize: integer
          pageSize
        - pendingFlag: integer
          Pending Flag
        
        
        
        Headers:
        - Accesstoken: string
          Authorization token for identification of the caller
        - ChannelType: integer
          Channel identifier from where the transaction has originated (Internet, Mobile, ATM, Branch Channel )
        - Co-Relationid: integer
          Unique ID for the service invoked, will be set by the transaction system
        - InitiatingSystem: string
          Indicating the initiated system
        - ServiceMode: integer
          Used for branch channel to indicate the type of customer
        - UUIDSeqNo: integer
          UUID Sequence Number
        - entity: string
          entity
        - languageCode: integer
          languageCode
        - referenceId: string
          Place holder for Token based authentication
        - userId: integer
          userId
        
        
        """
        
        
        # Prepare query parameters
        params = {}
        if eventpurpose is not None:
            params["eventPurpose"] = eventpurpose
            
        if pagenum is not None:
            params["pageNum"] = pagenum
            
        if pagesize is not None:
            params["pageSize"] = pagesize
            
        if pendingflag is not None:
            params["pendingFlag"] = pendingflag
            
        
        
        # Replace path parameters in URL
        path = "/deposits/dealEventList/{dealId}/{dealType}"
        if dealid is not None:
            path = path.replace("{dealId}", str(dealid))
        if dealtype is not None:
            path = path.replace("{dealType}", str(dealtype))
        
        
        # Prepare headers
        headers = {}
        if accesstoken is not None:
            headers["Accesstoken"] = str(accesstoken)
        if channeltype is not None:
            headers["ChannelType"] = str(channeltype)
        if co_relationid is not None:
            headers["Co-Relationid"] = str(co_relationid)
        if initiatingsystem is not None:
            headers["InitiatingSystem"] = str(initiatingsystem)
        if servicemode is not None:
            headers["ServiceMode"] = str(servicemode)
        if uuidseqno is not None:
            headers["UUIDSeqNo"] = str(uuidseqno)
        if entity is not None:
            headers["entity"] = str(entity)
        if languagecode is not None:
            headers["languageCode"] = str(languagecode)
        if referenceid is not None:
            headers["referenceId"] = str(referenceid)
        if userid is not None:
            headers["userId"] = str(userid)
        
        
        return await make_api_request(
            "GET", 
            path, 
            
            params=params if params else None, 
            headers=headers if headers else None
        )
    
    
    
    @mcp.tool()
    async def depbt0711_mtrd_dl_on_hld_postusing_post(
        request_body:Dict[str, Any] ,  # DEP_DEAL_DEPBT0711MtrdDlOnHld_Resource
    ) -> Dict[str, Any]:
        """
        DEPBT0711MtrdDlOnHld
        
        Generated from: POST /deposits/depbt0711mtrddlonhld
        Source: swagger_2_0
        Operation ID: DEPBT0711MtrdDlOnHld_POSTUsingPOST
        
        
        Authentication: Not required
        
        Parameters:
        - request_body: any (required)
          input
        
        
        
        """
        
        
        # Prepare request data
        
        # Single body parameter - send directly
        data = request_body if request_body is not None else {}
        
        
        
        # Prepare query parameters
        params = {}
        
        
        # Replace path parameters in URL
        path = "/deposits/depbt0711mtrddlonhld"
        
        
        # Prepare headers
        headers = {}
        
        
        return await make_api_request(
            "POST", 
            path, 
            data=data, 
            params=params if params else None, 
            headers=headers if headers else None
        )
    
    
    
    @mcp.tool()
    async def depbt0718_pndg_auth_postusing_post(
        request_body:Dict[str, Any] ,  # DEP_DEAL_DEPBT0718PndgAuth_Resource
    ) -> Dict[str, Any]:
        """
        DEPBT0718PndgAuth
        
        Generated from: POST /deposits/depbt0718pndgauth
        Source: swagger_2_0
        Operation ID: DEPBT0718PndgAuth_POSTUsingPOST
        
        
        Authentication: Not required
        
        Parameters:
        - request_body: any (required)
          input
        
        
        
        """
        
        
        # Prepare request data
        
        # Single body parameter - send directly
        data = request_body if request_body is not None else {}
        
        
        
        # Prepare query parameters
        params = {}
        
        
        # Replace path parameters in URL
        path = "/deposits/depbt0718pndgauth"
        
        
        # Prepare headers
        headers = {}
        
        
        return await make_api_request(
            "POST", 
            path, 
            data=data, 
            params=params if params else None, 
            headers=headers if headers else None
        )
    
    
    
    @mcp.tool()
    async def depet0716_intrst_rt_drvtn_postusing_post(
        request_body:Dict[str, Any] ,  # DEP_DEAL_DEPET0716IntrstRtDrvtn_Resource
    ) -> Dict[str, Any]:
        """
        DEPET0716IntrstRtDrvtn
        
        Generated from: POST /deposits/depet0716intrstrtdrvtn
        Source: swagger_2_0
        Operation ID: DEPET0716IntrstRtDrvtn_POSTUsingPOST
        
        
        Authentication: Not required
        
        Parameters:
        - request_body: any (required)
          input
        
        
        
        """
        
        
        # Prepare request data
        
        # Single body parameter - send directly
        data = request_body if request_body is not None else {}
        
        
        
        # Prepare query parameters
        params = {}
        
        
        # Replace path parameters in URL
        path = "/deposits/depet0716intrstrtdrvtn"
        
        
        # Prepare headers
        headers = {}
        
        
        return await make_api_request(
            "POST", 
            path, 
            data=data, 
            params=params if params else None, 
            headers=headers if headers else None
        )
    
    
    
    @mcp.tool()
    async def amet8290_acnt_bal_statmnt_using_get_1(
        depositaccountreference: str,
        balancetype: Optional[int] = None,
        fromdate: Optional[str] = None,
        movementdescription: Optional[str] = None,
        order: Optional[int] = None,
        pagenum: Optional[int] = None,
        pagesize: Optional[int] = None,
        todate: Optional[str] = None,
        transactionid: Optional[str] = None,
        transactiontype: Optional[int] = None,
        accesstoken: Optional[str] = None,
        channeltype: Optional[int] = None,
        co_relationid: Optional[int] = None,
        initiatingsystem: Optional[str] = None,
        servicemode: Optional[int] = None,
        uuidseqno: Optional[int] = None,
        entity: Optional[str] = None,
        languagecode: Optional[int] = None,
        referenceid: Optional[str] = None,
        userid: Optional[int] = None
    ) -> Dict[str, Any]:
        """
        This service fetches deposit account statement
        
        Generated from: GET /deposits/deposit/statement/{depositAccountReference}
        Source: swagger_2_0
        Operation ID: AMET8290AcntBalStatmntUsingGET_1
        
        
        Authentication: Not required
        
        Parameters:
        - balanceType: integer
          BalanceType -  Indicates Type of Balance. 1-Value Date, 2-Transaction Date, 3-Accounting Date
        - depositAccountReference: string (required)
          Enter the deposit reference number
        - fromDate: string
          Date from which Statement has to be generated (Date format : YYYYMMDD)
        - movementDescription: string
          Movement Description
        - order: integer
          Order
        - pageNum: integer
          pageNum
        - pageSize: integer
          pageSize
        - toDate: string
          Date till which Statement has to be generated (Date format : YYYYMMDD)
        - transactionId: string
          Transaction Id
        - transactionType: integer
          TransactionType - Indicates the type of transcation done. 1-Credit, 2-Debit
        
        
        
        Headers:
        - Accesstoken: string
          Authorization token for identification of the caller
        - ChannelType: integer
          Channel identifier from where the TXN has originated (Internet, Mobile, ATM, Branch Channel )
        - Co-Relationid: integer
          Unique ID for the service invoked, will be set by the TXN system
        - InitiatingSystem: string
          Indicating the initiated system
        - ServiceMode: integer
          Used for branch channel to indicate the type of customer
        - UUIDSeqNo: integer
          UUID Sequence Number
        - entity: string
          entity
        - languageCode: integer
          languageCode
        - referenceId: string
          Place holder for Token based authentication
        - userId: integer
          userId
        
        
        """
        
        
        # Prepare query parameters
        params = {}
        if balancetype is not None:
            params["balanceType"] = balancetype
            
        if fromdate is not None:
            params["fromDate"] = fromdate
            
        if movementdescription is not None:
            params["movementDescription"] = movementdescription
            
        if order is not None:
            params["order"] = order
            
        if pagenum is not None:
            params["pageNum"] = pagenum
            
        if pagesize is not None:
            params["pageSize"] = pagesize
            
        if todate is not None:
            params["toDate"] = todate
            
        if transactionid is not None:
            params["transactionId"] = transactionid
            
        if transactiontype is not None:
            params["transactionType"] = transactiontype
            
        
        
        # Replace path parameters in URL
        path = "/deposits/deposit/statement/{depositAccountReference}"
        if depositaccountreference is not None:
            path = path.replace("{depositAccountReference}", str(depositaccountreference))
        
        
        # Prepare headers
        headers = {}
        if accesstoken is not None:
            headers["Accesstoken"] = str(accesstoken)
        if channeltype is not None:
            headers["ChannelType"] = str(channeltype)
        if co_relationid is not None:
            headers["Co-Relationid"] = str(co_relationid)
        if initiatingsystem is not None:
            headers["InitiatingSystem"] = str(initiatingsystem)
        if servicemode is not None:
            headers["ServiceMode"] = str(servicemode)
        if uuidseqno is not None:
            headers["UUIDSeqNo"] = str(uuidseqno)
        if entity is not None:
            headers["entity"] = str(entity)
        if languagecode is not None:
            headers["languageCode"] = str(languagecode)
        if referenceid is not None:
            headers["referenceId"] = str(referenceid)
        if userid is not None:
            headers["userId"] = str(userid)
        
        
        return await make_api_request(
            "GET", 
            path, 
            
            params=params if params else None, 
            headers=headers if headers else None
        )
    
    
    
    @mcp.tool()
    async def depet0203_get_deal_lst_postusing_get_1(
        accountreference: Optional[str] = None,
        currency: Optional[str] = None,
        customerid: Optional[str] = None,
        erroroverride: Optional[int] = None,
        identifiertype: Optional[int] = None,
        identifiervalue: Optional[str] = None,
        pagenum: Optional[int] = None,
        pagesize: Optional[int] = None,
        accesstoken: Optional[str] = None,
        channeltype: Optional[int] = None,
        co_relationid: Optional[int] = None,
        initiatingsystem: Optional[str] = None,
        servicemode: Optional[int] = None,
        uuidseqno: Optional[int] = None,
        entity: Optional[str] = None,
        languagecode: Optional[int] = None,
        referenceid: Optional[str] = None,
        userid: Optional[int] = None
    ) -> Dict[str, Any]:
        """
        Fetch Deposit List
        
        Generated from: GET /deposits/depositList
        Source: swagger_2_0
        Operation ID: DEPET0203GetDealLst_POSTUsingGET_1
        
        
        Authentication: Not required
        
        Parameters:
        - AccountReference: string
          Enter Account Reference provided to Customer
        - Currency: string
          Enter the currency code
        - CustomerID: string
          Enter the Customer ID
        - ErrorOverRide: integer
          To override error enter 1
        - IdentifierType: integer
          Identifier Type
        - IdentifierValue: string
          Identifier Value
        - pageNum: integer
          pageNum
        - pageSize: integer
          pageSize
        
        
        
        Headers:
        - Accesstoken: string
          Authorization token for identification of the caller
        - ChannelType: integer
          Channel identifier from where the TXN has originated (Internet, Mobile, ATM, Branch Channel ) 
        - Co-Relationid: integer
          Unique ID for the service invoked, will be set by the TXN system
        - InitiatingSystem: string
          Indicating the initiated system
        - ServiceMode: integer
          Used for branch channel to indicate the type of customer
        - UUIDSeqNo: integer
          UUID Sequence Number
        - entity: string
          entity
        - languageCode: integer
          languageCode
        - referenceId: string
          Place holder for Token based authentication
        - userId: integer
          userId
        
        
        """
        
        
        # Prepare query parameters
        params = {}
        if accountreference is not None:
            params["AccountReference"] = accountreference
            
        if currency is not None:
            params["Currency"] = currency
            
        if customerid is not None:
            params["CustomerID"] = customerid
            
        if erroroverride is not None:
            params["ErrorOverRide"] = erroroverride
            
        if identifiertype is not None:
            params["IdentifierType"] = identifiertype
            
        if identifiervalue is not None:
            params["IdentifierValue"] = identifiervalue
            
        if pagenum is not None:
            params["pageNum"] = pagenum
            
        if pagesize is not None:
            params["pageSize"] = pagesize
            
        
        
        # Replace path parameters in URL
        path = "/deposits/depositList"
        
        
        # Prepare headers
        headers = {}
        if accesstoken is not None:
            headers["Accesstoken"] = str(accesstoken)
        if channeltype is not None:
            headers["ChannelType"] = str(channeltype)
        if co_relationid is not None:
            headers["Co-Relationid"] = str(co_relationid)
        if initiatingsystem is not None:
            headers["InitiatingSystem"] = str(initiatingsystem)
        if servicemode is not None:
            headers["ServiceMode"] = str(servicemode)
        if uuidseqno is not None:
            headers["UUIDSeqNo"] = str(uuidseqno)
        if entity is not None:
            headers["entity"] = str(entity)
        if languagecode is not None:
            headers["languageCode"] = str(languagecode)
        if referenceid is not None:
            headers["referenceId"] = str(referenceid)
        if userid is not None:
            headers["userId"] = str(userid)
        
        
        return await make_api_request(
            "GET", 
            path, 
            
            params=params if params else None, 
            headers=headers if headers else None
        )
    
    
    
    @mcp.tool()
    async def cbcet0500_get_product_lst_getusing_get(
        currency: str,
        customerreference: int,
        customertype: int,
        depositamount: float,
        deposittype: int,
        period: int,
        periodfrequency: int,
        depositfrequency: Optional[int] = None,
        pagenum: Optional[int] = None,
        pagesize: Optional[int] = None,
        period2: Optional[int] = None,
        periodfrequency2: Optional[int] = None,
        accesstoken: Optional[str] = None,
        channeltype: Optional[int] = None,
        co_relationid: Optional[int] = None,
        initiatingsystem: Optional[str] = None,
        servicemode: Optional[int] = None,
        uuidseqno: Optional[int] = None,
        entity: Optional[str] = None,
        languagecode: Optional[int] = None,
        referenceid: Optional[str] = None,
        userid: Optional[int] = None
    ) -> Dict[str, Any]:
        """
        This API is used to select product for Term and Recurring Deposits
        
        Generated from: GET /deposits/deposits
        Source: swagger_2_0
        Operation ID: CBCET0500GetProductLst_GETUsingGET
        
        
        Authentication: Not required
        
        Parameters:
        - currency: string (required)
          Currency
        - customerReference: integer (required)
          Customer Reference
        - customerType: integer (required)
          Customer Typr Individual->1
        - depositAmount: number (required)
          Deposit Amount
        - depositFrequency: integer
          Frequency Of Deposit For Term Deposit NA, For Recurring Deposit monthly->3 Quarterly->5 Half Yearly->7 Yearl->9
        - depositType: integer (required)
          Deposit Type Term Deposit -> 221 Recurring Deposit -> 247
        - pageNum: integer
          pageNum
        - pageSize: integer
          pageSize
        - period: integer (required)
          Period
        - period2: integer
          Period
        - periodFrequency: integer (required)
          Frequency of Period, For Term Deposit year -> 8 month ->4 days ->1 For Recurring Deposit, if Deposit Frequency is Monthly,Quarterly and Half Yearly Month->4 ,if Deposit Frequency is Yearly Year->8
        - periodFrequency2: integer
          For Term Deposit, if period is year than  Month->4 Days->1, if period is month than Days->1, if period is days NA, For Recurring Deposit NA
        
        
        
        Headers:
        - Accesstoken: string
          Authorization Token to validation the caller
        - ChannelType: integer
          Channel identifier from where the TXN has originated (Internet, Mobile, ATM, Branch Channel )
        - Co-Relationid: integer
          Unique ID for the service invoked, will be set by the TXN system
        - InitiatingSystem: string
          Indicating the initiated system
        - ServiceMode: integer
          Used for branch channel to indicate the type of customer
        - UUIDSeqNo: integer
          UUID Sequence Number
        - entity: string
          entity
        - languageCode: integer
          languageCode
        - referenceId: string
          Place holder for Token based authentication
        - userId: integer
          userId
        
        
        """
        
        
        # Prepare query parameters
        params = {}
        if currency is not None:
            params["currency"] = currency
            
        if customerreference is not None:
            params["customerReference"] = customerreference
            
        if customertype is not None:
            params["customerType"] = customertype
            
        if depositamount is not None:
            params["depositAmount"] = depositamount
            
        if depositfrequency is not None:
            params["depositFrequency"] = depositfrequency
            
        if deposittype is not None:
            params["depositType"] = deposittype
            
        if pagenum is not None:
            params["pageNum"] = pagenum
            
        if pagesize is not None:
            params["pageSize"] = pagesize
            
        if period is not None:
            params["period"] = period
            
        if period2 is not None:
            params["period2"] = period2
            
        if periodfrequency is not None:
            params["periodFrequency"] = periodfrequency
            
        if periodfrequency2 is not None:
            params["periodFrequency2"] = periodfrequency2
            
        
        
        # Replace path parameters in URL
        path = "/deposits/deposits"
        
        
        # Prepare headers
        headers = {}
        if accesstoken is not None:
            headers["Accesstoken"] = str(accesstoken)
        if channeltype is not None:
            headers["ChannelType"] = str(channeltype)
        if co_relationid is not None:
            headers["Co-Relationid"] = str(co_relationid)
        if initiatingsystem is not None:
            headers["InitiatingSystem"] = str(initiatingsystem)
        if servicemode is not None:
            headers["ServiceMode"] = str(servicemode)
        if uuidseqno is not None:
            headers["UUIDSeqNo"] = str(uuidseqno)
        if entity is not None:
            headers["entity"] = str(entity)
        if languagecode is not None:
            headers["languageCode"] = str(languagecode)
        if referenceid is not None:
            headers["referenceId"] = str(referenceid)
        if userid is not None:
            headers["userId"] = str(userid)
        
        
        return await make_api_request(
            "GET", 
            path, 
            
            params=params if params else None, 
            headers=headers if headers else None
        )
    
    
    
    @mcp.tool()
    async def depet6276_dep_goal_cal_getusing_get(
        calculatortype: int,
        customercategory: int,
        depositamount: float,
        depositamountcurrency: str,
        deposittype: int,
        instrumentid: int,
        period: int,
        periodfrequency: int,
        customersubcategory: Optional[int] = None,
        depositfrequency: Optional[int] = None,
        pagenum: Optional[int] = None,
        pagesize: Optional[int] = None,
        period2: Optional[int] = None,
        periodfrequency2: Optional[int] = None,
        taxcategory: Optional[int] = None,
        accesstoken: Optional[str] = None,
        channeltype: Optional[int] = None,
        co_relationid: Optional[int] = None,
        initiatingsystem: Optional[str] = None,
        servicemode: Optional[int] = None,
        uuidseqno: Optional[int] = None,
        entity: Optional[str] = None,
        languagecode: Optional[int] = None,
        referenceid: Optional[str] = None,
        userid: Optional[int] = None
    ) -> Dict[str, Any]:
        """
        Calculate Maturity/Instalment Amount
        
        Generated from: GET /deposits/deposits/maturityGoalCalculator
        Source: swagger_2_0
        Operation ID: DEPET6276DepGoalCal_GETUsingGET
        
        
        Authentication: Not required
        
        Parameters:
        - calculatorType: integer (required)
          Calculator Type
        - customerCategory: integer (required)
          Customer Type Individual->1 Company->2
        - customerSubCategory: integer
          Customer Sub Category
        - depositAmount: number (required)
          Deposit Amount
        - depositAmountCurrency: string (required)
          Deposit Amount Currency
        - depositFrequency: integer
          Deposit Frequency Monthly->3 Half Yearly->7 Quarterly->5 Yearly->9
        - depositType: integer (required)
          Deposit Type Term Deposit -> 221 Recurring Deposit -> 247
        - instrumentID: integer (required)
          Instrument ID
        - pageNum: integer
          pageNum
        - pageSize: integer
          pageSize
        - period: integer (required)
          Period
        - period2: integer
          Period
        - periodFrequency: integer (required)
          Frequency of Period, For Term Deposit year -> 8 month ->4 days ->1 For Recurring Deposit, if Deposit Frequency is Monthly,Quarterly and Half Yearly Month->4 ,if Deposit Frequency is Yearly Year->8
        - periodFrequency2: integer
          For Term Deposit, if period is year than  Month->4 Days->1, if period is month than Days->1, if period is days NA, For Recurring Deposit NA
        - taxCategory: integer
          Tax Category
        
        
        
        Headers:
        - Accesstoken: string
          Authorization token for identification of the caller
        - ChannelType: integer
          Channel identifier from where the TXN has originated (Internet, Mobile, ATM, Branch Channel )
        - Co-Relationid: integer
          Unique ID for the service invoked, will be set by the TXN system
        - InitiatingSystem: string
          Indicating the initiated system
        - ServiceMode: integer
          Used for branch channel to indicate the type of customer
        - UUIDSeqNo: integer
          UUID Sequence Number
        - entity: string
          entity
        - languageCode: integer
          languageCode
        - referenceId: string
          Place holder for Token based authentication
        - userId: integer
          userId
        
        
        """
        
        
        # Prepare query parameters
        params = {}
        if calculatortype is not None:
            params["calculatorType"] = calculatortype
            
        if customercategory is not None:
            params["customerCategory"] = customercategory
            
        if customersubcategory is not None:
            params["customerSubCategory"] = customersubcategory
            
        if depositamount is not None:
            params["depositAmount"] = depositamount
            
        if depositamountcurrency is not None:
            params["depositAmountCurrency"] = depositamountcurrency
            
        if depositfrequency is not None:
            params["depositFrequency"] = depositfrequency
            
        if deposittype is not None:
            params["depositType"] = deposittype
            
        if instrumentid is not None:
            params["instrumentID"] = instrumentid
            
        if pagenum is not None:
            params["pageNum"] = pagenum
            
        if pagesize is not None:
            params["pageSize"] = pagesize
            
        if period is not None:
            params["period"] = period
            
        if period2 is not None:
            params["period2"] = period2
            
        if periodfrequency is not None:
            params["periodFrequency"] = periodfrequency
            
        if periodfrequency2 is not None:
            params["periodFrequency2"] = periodfrequency2
            
        if taxcategory is not None:
            params["taxCategory"] = taxcategory
            
        
        
        # Replace path parameters in URL
        path = "/deposits/deposits/maturityGoalCalculator"
        
        
        # Prepare headers
        headers = {}
        if accesstoken is not None:
            headers["Accesstoken"] = str(accesstoken)
        if channeltype is not None:
            headers["ChannelType"] = str(channeltype)
        if co_relationid is not None:
            headers["Co-Relationid"] = str(co_relationid)
        if initiatingsystem is not None:
            headers["InitiatingSystem"] = str(initiatingsystem)
        if servicemode is not None:
            headers["ServiceMode"] = str(servicemode)
        if uuidseqno is not None:
            headers["UUIDSeqNo"] = str(uuidseqno)
        if entity is not None:
            headers["entity"] = str(entity)
        if languagecode is not None:
            headers["languageCode"] = str(languagecode)
        if referenceid is not None:
            headers["referenceId"] = str(referenceid)
        if userid is not None:
            headers["userId"] = str(userid)
        
        
        return await make_api_request(
            "GET", 
            path, 
            
            params=params if params else None, 
            headers=headers if headers else None
        )
    
    
    
    @mcp.tool()
    async def depet6276_depst_prdt_getusing_get(
        calculatortype: int,
        customertype: int,
        depositgoalamount: float,
        depositgoalamountcurrency: str,
        deposittype: int,
        period: int,
        periodfrequency: int,
        customersubtype: Optional[int] = None,
        depositfrequency: Optional[int] = None,
        pagenum: Optional[int] = None,
        pagesize: Optional[int] = None,
        period2: Optional[int] = None,
        periodfrequency2: Optional[int] = None,
        taxcategory: Optional[int] = None,
        accesstoken: Optional[str] = None,
        channeltype: Optional[int] = None,
        co_relationid: Optional[int] = None,
        initiatingsystem: Optional[str] = None,
        servicemode: Optional[int] = None,
        uuidseqno: Optional[int] = None,
        entity: Optional[str] = None,
        languagecode: Optional[int] = None,
        referenceid: Optional[str] = None,
        userid: Optional[int] = None
    ) -> Dict[str, Any]:
        """
        This API is to fetch product list for Term and Recurring Deposits
        
        Generated from: GET /deposits/deposits/productList
        Source: swagger_2_0
        Operation ID: DEPET6276DepstPrdt_GETUsingGET
        
        
        Authentication: Not required
        
        Parameters:
        - calculatorType: integer (required)
          Calculator Type
        - customerSubType: integer
          Customer Sub Type 
        - customerType: integer (required)
          Customer Type Individual->1 Company->2
        - depositFrequency: integer
          Frequency Of Deposit For Term Deposit NA, For Recurring Deposit monthly->3 Quarterly->5 Half Yearly->7 Yearl->9
        - depositGoalAmount: number (required)
          Deposit Amount or Goal Amount
        - depositGoalAmountCurrency: string (required)
          Currency
        - depositType: integer (required)
          Deposit Type Term Deposit -> 221 Recurring Deposit -> 247
        - pageNum: integer
          pageNum
        - pageSize: integer
          pageSize
        - period: integer (required)
          Period
        - period2: integer
          Period
        - periodFrequency: integer (required)
          Frequency of Period, For Term Deposit year -> 8 month ->4 days ->1 For Recurring Deposit, if Deposit Frequency is Monthly,Quarterly and Half Yearly Month->4 ,if Deposit Frequency is Yearly Year->8
        - periodFrequency2: integer
          For Term Deposit, if period is year than  Month->4 Days->1, if period is month than Days->1, if period is days NA, For Recurring Deposit NA
        - taxCategory: integer
          Tax Category
        
        
        
        Headers:
        - Accesstoken: string
          Authorization token for identification of the caller
        - ChannelType: integer
          Channel identifier from where the TXN has originated (Internet, Mobile, ATM, Branch Channel )
        - Co-Relationid: integer
          Unique ID for the service invoked, will be set by the TXN system
        - InitiatingSystem: string
          Indicating the initiated system
        - ServiceMode: integer
          Used for branch channel to indicate the type of customer
        - UUIDSeqNo: integer
          UUID Sequence Number
        - entity: string
          entity
        - languageCode: integer
          languageCode
        - referenceId: string
          Place holder for Token based authentication
        - userId: integer
          userId
        
        
        """
        
        
        # Prepare query parameters
        params = {}
        if calculatortype is not None:
            params["calculatorType"] = calculatortype
            
        if customersubtype is not None:
            params["customerSubType"] = customersubtype
            
        if customertype is not None:
            params["customerType"] = customertype
            
        if depositfrequency is not None:
            params["depositFrequency"] = depositfrequency
            
        if depositgoalamount is not None:
            params["depositGoalAmount"] = depositgoalamount
            
        if depositgoalamountcurrency is not None:
            params["depositGoalAmountCurrency"] = depositgoalamountcurrency
            
        if deposittype is not None:
            params["depositType"] = deposittype
            
        if pagenum is not None:
            params["pageNum"] = pagenum
            
        if pagesize is not None:
            params["pageSize"] = pagesize
            
        if period is not None:
            params["period"] = period
            
        if period2 is not None:
            params["period2"] = period2
            
        if periodfrequency is not None:
            params["periodFrequency"] = periodfrequency
            
        if periodfrequency2 is not None:
            params["periodFrequency2"] = periodfrequency2
            
        if taxcategory is not None:
            params["taxCategory"] = taxcategory
            
        
        
        # Replace path parameters in URL
        path = "/deposits/deposits/productList"
        
        
        # Prepare headers
        headers = {}
        if accesstoken is not None:
            headers["Accesstoken"] = str(accesstoken)
        if channeltype is not None:
            headers["ChannelType"] = str(channeltype)
        if co_relationid is not None:
            headers["Co-Relationid"] = str(co_relationid)
        if initiatingsystem is not None:
            headers["InitiatingSystem"] = str(initiatingsystem)
        if servicemode is not None:
            headers["ServiceMode"] = str(servicemode)
        if uuidseqno is not None:
            headers["UUIDSeqNo"] = str(uuidseqno)
        if entity is not None:
            headers["entity"] = str(entity)
        if languagecode is not None:
            headers["languageCode"] = str(languagecode)
        if referenceid is not None:
            headers["referenceId"] = str(referenceid)
        if userid is not None:
            headers["userId"] = str(userid)
        
        
        return await make_api_request(
            "GET", 
            path, 
            
            params=params if params else None, 
            headers=headers if headers else None
        )
    
    
    
    @mcp.tool()
    async def depbt0409_ibcreate_deal_erl_mtrty_postusing_post(
        request_body:Dict[str, Any] ,  # CreateEarlyMaturityClosure_Resource,
        accesstoken: Optional[str] = None,
        channeltype: Optional[int] = None,
        co_relationid: Optional[int] = None,
        initiatingsystem: Optional[str] = None,
        servicemode: Optional[int] = None,
        uuidseqno: Optional[int] = None,
        entity: Optional[str] = None,
        languagecode: Optional[int] = None,
        referenceid: Optional[str] = None,
        requesthash: Optional[str] = None,
        userid: Optional[int] = None
    ) -> Dict[str, Any]:
        """
        Create Early Maturity Closure
        
        Generated from: POST /deposits/earlyMaturityClosure
        Source: swagger_2_0
        Operation ID: DEPBT0409IBCreateDealErlMtrty_POSTUsingPOST
        
        
        Authentication: Not required
        
        Parameters:
        - request_body: any (required)
          input
        
        
        
        Headers:
        - Accesstoken: string
          Authorization token for identification of the caller
        - ChannelType: integer
          Channel identifier from where the TXN has originated (Internet, Mobile, ATM, Branch Channel )
        - Co-Relationid: integer
          Unique ID for the service invoked, will be set by the TXN system
        - InitiatingSystem: string
          Indicating the initiated system
        - ServiceMode: integer
          Used for branch channel to indicate the type of customer
        - UUIDSeqNo: integer
          UUID Sequence Number
        - entity: string
          entity
        - languageCode: integer
          languageCode
        - referenceId: string
          Place holder for Token based authentication
        - requesthash: string
          Request payload for hash validation
        - userId: integer
          userId
        
        
        """
        
        
        # Prepare request data
        
        # Single body parameter - send directly
        data = request_body if request_body is not None else {}
        
        
        
        # Prepare query parameters
        params = {}
        
        
        # Replace path parameters in URL
        path = "/deposits/earlyMaturityClosure"
        
        
        # Prepare headers
        headers = {}
        if accesstoken is not None:
            headers["Accesstoken"] = str(accesstoken)
        if channeltype is not None:
            headers["ChannelType"] = str(channeltype)
        if co_relationid is not None:
            headers["Co-Relationid"] = str(co_relationid)
        if initiatingsystem is not None:
            headers["InitiatingSystem"] = str(initiatingsystem)
        if servicemode is not None:
            headers["ServiceMode"] = str(servicemode)
        if uuidseqno is not None:
            headers["UUIDSeqNo"] = str(uuidseqno)
        if entity is not None:
            headers["entity"] = str(entity)
        if languagecode is not None:
            headers["languageCode"] = str(languagecode)
        if referenceid is not None:
            headers["referenceId"] = str(referenceid)
        if requesthash is not None:
            headers["requesthash"] = str(requesthash)
        if userid is not None:
            headers["userId"] = str(userid)
        
        
        return await make_api_request(
            "POST", 
            path, 
            data=data, 
            params=params if params else None, 
            headers=headers if headers else None
        )
    
    
    
    @mcp.tool()
    async def depbt0410_auth_deal_erl_mtrty_postusing_post(
        request_body:Dict[str, Any] ,  # AuthDealErlMtrty_Resource,
        accesstoken: Optional[str] = None,
        channeltype: Optional[int] = None,
        co_relationid: Optional[int] = None,
        initiatingsystem: Optional[str] = None,
        servicemode: Optional[int] = None,
        uuidseqno: Optional[int] = None,
        entity: Optional[str] = None,
        languagecode: Optional[int] = None,
        referenceid: Optional[str] = None,
        requesthash: Optional[str] = None,
        userid: Optional[int] = None
    ) -> Dict[str, Any]:
        """
        Authorize Early Maturity Closure
        
        Generated from: POST /deposits/earlyMaturityClosure/Auth
        Source: swagger_2_0
        Operation ID: DEPBT0410AuthDealErlMtrty_POSTUsingPOST
        
        
        Authentication: Not required
        
        Parameters:
        - request_body: any (required)
          input
        
        
        
        Headers:
        - Accesstoken: string
          Authorization token for identification of the caller
        - ChannelType: integer
          Channel identifier from where the TXN has originated (Internet, Mobile, ATM, Branch Channel )
        - Co-Relationid: integer
          Unique ID for the service invoked, will be set by the TXN system
        - InitiatingSystem: string
          Indicating the initiated system
        - ServiceMode: integer
          Used for branch channel to indicate the type of customer
        - UUIDSeqNo: integer
          UUID Sequence Number
        - entity: string
          entity
        - languageCode: integer
          languageCode
        - referenceId: string
          Place holder for Token based authentication
        - requesthash: string
          Request payload for hash validation
        - userId: integer
          userId
        
        
        """
        
        
        # Prepare request data
        
        # Single body parameter - send directly
        data = request_body if request_body is not None else {}
        
        
        
        # Prepare query parameters
        params = {}
        
        
        # Replace path parameters in URL
        path = "/deposits/earlyMaturityClosure/Auth"
        
        
        # Prepare headers
        headers = {}
        if accesstoken is not None:
            headers["Accesstoken"] = str(accesstoken)
        if channeltype is not None:
            headers["ChannelType"] = str(channeltype)
        if co_relationid is not None:
            headers["Co-Relationid"] = str(co_relationid)
        if initiatingsystem is not None:
            headers["InitiatingSystem"] = str(initiatingsystem)
        if servicemode is not None:
            headers["ServiceMode"] = str(servicemode)
        if uuidseqno is not None:
            headers["UUIDSeqNo"] = str(uuidseqno)
        if entity is not None:
            headers["entity"] = str(entity)
        if languagecode is not None:
            headers["languageCode"] = str(languagecode)
        if referenceid is not None:
            headers["referenceId"] = str(referenceid)
        if requesthash is not None:
            headers["requesthash"] = str(requesthash)
        if userid is not None:
            headers["userId"] = str(userid)
        
        
        return await make_api_request(
            "POST", 
            path, 
            data=data, 
            params=params if params else None, 
            headers=headers if headers else None
        )
    
    
    
    @mcp.tool()
    async def depet0140_prdct_slction_dtls_postusing_get(
        currency: str,
        customerreference: int,
        depositamount: float,
        periodfrequency: int,
        periodvalue: int,
        productid: int,
        periodfrequency1: Optional[int] = None,
        periodvalue1: Optional[int] = None,
        accesstoken: Optional[str] = None,
        channeltype: Optional[int] = None,
        co_relationid: Optional[int] = None,
        initiatingsystem: Optional[str] = None,
        servicemode: Optional[int] = None,
        uuidseqno: Optional[int] = None,
        entity: Optional[str] = None,
        languagecode: Optional[int] = None,
        referenceid: Optional[str] = None,
        userid: Optional[int] = None
    ) -> Dict[str, Any]:
        """
        Fetch deposit product details
        
        Generated from: GET /deposits/fetchDepositProduct
        Source: swagger_2_0
        Operation ID: DEPET0140PrdctSlctionDtls_POSTUsingGET
        
        
        Authentication: Not required
        
        Parameters:
        - currency: string (required)
          Currency USD, EUR etc.
        - customerReference: integer (required)
          Primary Barrower Id
        - depositAmount: number (required)
          Deposit Amount
        - periodFrequency: integer (required)
          Frequency of period(Domain Name: d_FreqUnit) e.g. 1-Day, 4-Month , 8-Year
        - periodFrequency1: integer
          Frequency of period(Domain Name: d_FreqUnit) e.g. 1-Day, 4-Month
        - periodValue: integer (required)
          Number of units ex:1,2,3 etc
        - periodvalue1: integer
          Period unit eg, 1,2,3 etc.
        - productId: integer (required)
          Product ID, 1654-Retail Term Deposit- STDR, 1656-Retail Term Deposit- Staff STDR, 2258-A_Term_Deposit_Product  etc. 
        
        
        
        Headers:
        - Accesstoken: string
          Authorization token for identification of the caller
        - ChannelType: integer
          Channel identifier from where the TXN has originated (Internet, Mobile, ATM, Branch Channel )
        - Co-Relationid: integer
          Unique ID for the service invoked, will be set by the TXN system
        - InitiatingSystem: string
          Indicating the initiated system
        - ServiceMode: integer
          Used for branch channel to indicate the type of customer
        - UUIDSeqNo: integer
          UUID Sequence Number
        - entity: string
          entity
        - languageCode: integer
          languageCode
        - referenceId: string
          Place holder for Token based authentication
        - userId: integer
          userId
        
        
        """
        
        
        # Prepare query parameters
        params = {}
        if currency is not None:
            params["currency"] = currency
            
        if customerreference is not None:
            params["customerReference"] = customerreference
            
        if depositamount is not None:
            params["depositAmount"] = depositamount
            
        if periodfrequency is not None:
            params["periodFrequency"] = periodfrequency
            
        if periodfrequency1 is not None:
            params["periodFrequency1"] = periodfrequency1
            
        if periodvalue is not None:
            params["periodValue"] = periodvalue
            
        if periodvalue1 is not None:
            params["periodvalue1"] = periodvalue1
            
        if productid is not None:
            params["productId"] = productid
            
        
        
        # Replace path parameters in URL
        path = "/deposits/fetchDepositProduct"
        
        
        # Prepare headers
        headers = {}
        if accesstoken is not None:
            headers["Accesstoken"] = str(accesstoken)
        if channeltype is not None:
            headers["ChannelType"] = str(channeltype)
        if co_relationid is not None:
            headers["Co-Relationid"] = str(co_relationid)
        if initiatingsystem is not None:
            headers["InitiatingSystem"] = str(initiatingsystem)
        if servicemode is not None:
            headers["ServiceMode"] = str(servicemode)
        if uuidseqno is not None:
            headers["UUIDSeqNo"] = str(uuidseqno)
        if entity is not None:
            headers["entity"] = str(entity)
        if languagecode is not None:
            headers["languageCode"] = str(languagecode)
        if referenceid is not None:
            headers["referenceId"] = str(referenceid)
        if userid is not None:
            headers["userId"] = str(userid)
        
        
        return await make_api_request(
            "GET", 
            path, 
            
            params=params if params else None, 
            headers=headers if headers else None
        )
    
    
    
    @mcp.tool()
    async def depet0316_get_nominee_rlts_getusing_get(
        accountreference: Optional[str] = None,
        channeltype: Optional[int] = None,
        co_relationid: Optional[int] = None,
        initiatingsystem: Optional[str] = None,
        servicemode: Optional[int] = None,
        uuidseqno: Optional[int] = None,
        entity: Optional[str] = None,
        languagecode: Optional[int] = None,
        userid: Optional[int] = None
    ) -> Dict[str, Any]:
        """
        This API is used to fetch Account relations of the Deposit
        
        Generated from: GET /deposits/fetchDepositRelations
        Source: swagger_2_0
        Operation ID: DEPET0316GetNomineeRlts_GETUsingGET
        
        
        Authentication: Not required
        
        Parameters:
        - AccountReference: string
          Deposit -Account Reference
        
        
        
        Headers:
        - ChannelType: integer
          Channel identifier from where the TXN has originated (Internet, Mobile, ATM, Branch Channel )
        - Co-Relationid: integer
          Unique ID for the service invoked, will be set by the TXN system
        - InitiatingSystem: string
          Indicating the initiated system
        - ServiceMode: integer
          Used for branch channel to indicate the type of customer
        - UUIDSeqNo: integer
          UUID Sequence Number
        - entity: string
          entity
        - languageCode: integer
          languageCode
        - userId: integer
          userId
        
        
        """
        
        
        # Prepare query parameters
        params = {}
        if accountreference is not None:
            params["AccountReference"] = accountreference
            
        
        
        # Replace path parameters in URL
        path = "/deposits/fetchDepositRelations"
        
        
        # Prepare headers
        headers = {}
        if channeltype is not None:
            headers["ChannelType"] = str(channeltype)
        if co_relationid is not None:
            headers["Co-Relationid"] = str(co_relationid)
        if initiatingsystem is not None:
            headers["InitiatingSystem"] = str(initiatingsystem)
        if servicemode is not None:
            headers["ServiceMode"] = str(servicemode)
        if uuidseqno is not None:
            headers["UUIDSeqNo"] = str(uuidseqno)
        if entity is not None:
            headers["entity"] = str(entity)
        if languagecode is not None:
            headers["languageCode"] = str(languagecode)
        if userid is not None:
            headers["userId"] = str(userid)
        
        
        return await make_api_request(
            "GET", 
            path, 
            
            params=params if params else None, 
            headers=headers if headers else None
        )
    
    
    
    @mcp.tool()
    async def depet0715_mtrd_dpst_amt_postusing_get(
        dealid: int,
        renewaltype: Optional[int] = None,
        accesstoken: Optional[str] = None,
        channeltype: Optional[int] = None,
        co_relationid: Optional[int] = None,
        initiatingsystem: Optional[str] = None,
        servicemode: Optional[int] = None,
        uuidseqno: Optional[int] = None,
        entity: Optional[str] = None,
        languagecode: Optional[int] = None,
        referenceid: Optional[str] = None,
        userid: Optional[int] = None
    ) -> Dict[str, Any]:
        """
        Fetch Matured Deposit Amount Details
        
        Generated from: GET /deposits/maturedDeposit/{dealId}
        Source: swagger_2_0
        Operation ID: DEPET0715MtrdDpstAmt_POSTUsingGET
        
        
        Authentication: Not required
        
        Parameters:
        - RenewalType: integer
          Renewal Type
        - dealId: integer (required)
          Deposit Number for which the Details required
        
        
        
        Headers:
        - Accesstoken: string
          Authorization token for identification of the caller
        - ChannelType: integer
          Channel identifier from where the TXN has originated (Internet, Mobile, ATM, Branch Channel )
        - Co-Relationid: integer
          Unique ID for the service invoked, will be set by the TXN system
        - InitiatingSystem: string
          Indicating the initiated system
        - ServiceMode: integer
          Used for branch channel to indicate the type of customer
        - UUIDSeqNo: integer
          UUID Sequence Number
        - entity: string
          entity
        - languageCode: integer
          languageCode
        - referenceId: string
          Place holder for Token based authentication
        - userId: integer
          userId
        
        
        """
        
        
        # Prepare query parameters
        params = {}
        if renewaltype is not None:
            params["RenewalType"] = renewaltype
            
        
        
        # Replace path parameters in URL
        path = "/deposits/maturedDeposit/{dealId}"
        if dealid is not None:
            path = path.replace("{dealId}", str(dealid))
        
        
        # Prepare headers
        headers = {}
        if accesstoken is not None:
            headers["Accesstoken"] = str(accesstoken)
        if channeltype is not None:
            headers["ChannelType"] = str(channeltype)
        if co_relationid is not None:
            headers["Co-Relationid"] = str(co_relationid)
        if initiatingsystem is not None:
            headers["InitiatingSystem"] = str(initiatingsystem)
        if servicemode is not None:
            headers["ServiceMode"] = str(servicemode)
        if uuidseqno is not None:
            headers["UUIDSeqNo"] = str(uuidseqno)
        if entity is not None:
            headers["entity"] = str(entity)
        if languagecode is not None:
            headers["languageCode"] = str(languagecode)
        if referenceid is not None:
            headers["referenceId"] = str(referenceid)
        if userid is not None:
            headers["userId"] = str(userid)
        
        
        return await make_api_request(
            "GET", 
            path, 
            
            params=params if params else None, 
            headers=headers if headers else None
        )
    
    
    
    @mcp.tool()
    async def depbt0710_crt_mtrd_dl_postusing_post(
        request_body:Dict[str, Any] ,  # DEP_DEAL_DEPBT0710CrtMtrdDl_Resource,
        co_relationid: Optional[int] = None,
        initiatingsystem: Optional[str] = None,
        servicemode: Optional[int] = None,
        uuidseqno: Optional[int] = None,
        entity: Optional[str] = None,
        languagecode: Optional[int] = None,
        referenceid: Optional[str] = None,
        requesthash: Optional[str] = None,
        userid: Optional[int] = None
    ) -> Dict[str, Any]:
        """
        Renew Matured Deposit
        
        Generated from: POST /deposits/maturedDepositAccount
        Source: swagger_2_0
        Operation ID: DEPBT0710CrtMtrdDl_POSTUsingPOST
        
        
        Authentication: Not required
        
        Parameters:
        - request_body: any (required)
          input
        
        
        
        Headers:
        - Co-Relationid: integer
          Unique ID for the service invoked, will be set by the TXN system
        - InitiatingSystem: string
          Indicating the initiated system
        - ServiceMode: integer
          Used for branch channel to indicate the type of customer
        - UUIDSeqNo: integer
          UUID Sequence Number
        - entity: string
          entity
        - languageCode: integer
          languageCode
        - referenceId: string
          Place holder for Token based authentication
        - requesthash: string
          Request payload for hash validation
        - userId: integer
          userId
        
        
        """
        
        
        # Prepare request data
        
        # Single body parameter - send directly
        data = request_body if request_body is not None else {}
        
        
        
        # Prepare query parameters
        params = {}
        
        
        # Replace path parameters in URL
        path = "/deposits/maturedDepositAccount"
        
        
        # Prepare headers
        headers = {}
        if co_relationid is not None:
            headers["Co-Relationid"] = str(co_relationid)
        if initiatingsystem is not None:
            headers["InitiatingSystem"] = str(initiatingsystem)
        if servicemode is not None:
            headers["ServiceMode"] = str(servicemode)
        if uuidseqno is not None:
            headers["UUIDSeqNo"] = str(uuidseqno)
        if entity is not None:
            headers["entity"] = str(entity)
        if languagecode is not None:
            headers["languageCode"] = str(languagecode)
        if referenceid is not None:
            headers["referenceId"] = str(referenceid)
        if requesthash is not None:
            headers["requesthash"] = str(requesthash)
        if userid is not None:
            headers["userId"] = str(userid)
        
        
        return await make_api_request(
            "POST", 
            path, 
            data=data, 
            params=params if params else None, 
            headers=headers if headers else None
        )
    
    
    
    @mcp.tool()
    async def depbt0714_mtrd_dl_auth_clsr_postusing_post(
        request_body:Dict[str, Any] ,  # DEPBT0714MtrdDlAuthClsrResource,
        accesstoken: Optional[str] = None,
        channeltype: Optional[int] = None,
        co_relationid: Optional[int] = None,
        initiatingsystem: Optional[str] = None,
        servicemode: Optional[int] = None,
        uuidseqno: Optional[int] = None,
        entity: Optional[str] = None,
        languagecode: Optional[int] = None,
        referenceid: Optional[str] = None,
        requesthash: Optional[str] = None,
        userid: Optional[int] = None
    ) -> Dict[str, Any]:
        """
        Matured Deposit Closure Authorization
        
        Generated from: POST /deposits/maturedDepositAuthClosure
        Source: swagger_2_0
        Operation ID: DEPBT0714MtrdDlAuthClsr_POSTUsingPOST
        
        
        Authentication: Not required
        
        Parameters:
        - request_body: any (required)
          input
        
        
        
        Headers:
        - Accesstoken: string
          Authorization token for identification of the caller
        - ChannelType: integer
          Channel identifier from where the TXN has originated (Internet, Mobile, ATM, Branch Channel )
        - Co-Relationid: integer
          Unique ID for the service invoked, will be set by the TXN system
        - InitiatingSystem: string
          Indicating the initiated system
        - ServiceMode: integer
          Used for branch channel to indicate the type of customer
        - UUIDSeqNo: integer
          UUID Sequence Number
        - entity: string
          entity
        - languageCode: integer
          languageCode
        - referenceId: string
          Place holder for Token based authentication
        - requesthash: string
          Request payload for hash validation
        - userId: integer
          userId
        
        
        """
        
        
        # Prepare request data
        
        # Single body parameter - send directly
        data = request_body if request_body is not None else {}
        
        
        
        # Prepare query parameters
        params = {}
        
        
        # Replace path parameters in URL
        path = "/deposits/maturedDepositAuthClosure"
        
        
        # Prepare headers
        headers = {}
        if accesstoken is not None:
            headers["Accesstoken"] = str(accesstoken)
        if channeltype is not None:
            headers["ChannelType"] = str(channeltype)
        if co_relationid is not None:
            headers["Co-Relationid"] = str(co_relationid)
        if initiatingsystem is not None:
            headers["InitiatingSystem"] = str(initiatingsystem)
        if servicemode is not None:
            headers["ServiceMode"] = str(servicemode)
        if uuidseqno is not None:
            headers["UUIDSeqNo"] = str(uuidseqno)
        if entity is not None:
            headers["entity"] = str(entity)
        if languagecode is not None:
            headers["languageCode"] = str(languagecode)
        if referenceid is not None:
            headers["referenceId"] = str(referenceid)
        if requesthash is not None:
            headers["requesthash"] = str(requesthash)
        if userid is not None:
            headers["userId"] = str(userid)
        
        
        return await make_api_request(
            "POST", 
            path, 
            data=data, 
            params=params if params else None, 
            headers=headers if headers else None
        )
    
    
    
    @mcp.tool()
    async def depbt0713_mtrd_dl_clsr_postusing_post(
        request_body:Dict[str, Any] ,  # MaturedDealClosureResource,
        accesstoken: Optional[str] = None,
        channeltype: Optional[int] = None,
        co_relationid: Optional[int] = None,
        initiatingsystem: Optional[str] = None,
        servicemode: Optional[int] = None,
        uuidseqno: Optional[int] = None,
        entity: Optional[str] = None,
        languagecode: Optional[int] = None,
        referenceid: Optional[str] = None,
        requesthash: Optional[str] = None,
        userid: Optional[int] = None
    ) -> Dict[str, Any]:
        """
        Matured Deposit Closure
        
        Generated from: POST /deposits/maturedDepositClosure
        Source: swagger_2_0
        Operation ID: DEPBT0713MtrdDlClsr_POSTUsingPOST
        
        
        Authentication: Not required
        
        Parameters:
        - request_body: any (required)
          input
        
        
        
        Headers:
        - Accesstoken: string
          Authorization token for identification of the caller
        - ChannelType: integer
          Channel identifier from where the TXN has originated (Internet, Mobile, ATM, Branch Channel )
        - Co-Relationid: integer
          Unique ID for the service invoked, will be set by the TXN system
        - InitiatingSystem: string
          Indicating the initiated system
        - ServiceMode: integer
          Used for branch channel to indicate the type of customer
        - UUIDSeqNo: integer
          UUID Sequence Number
        - entity: string
          entity
        - languageCode: integer
          languageCode
        - referenceId: string
          Place holder for Token based authentication
        - requesthash: string
          Request payload for hash validation
        - userId: integer
          userId
        
        
        """
        
        
        # Prepare request data
        
        # Single body parameter - send directly
        data = request_body if request_body is not None else {}
        
        
        
        # Prepare query parameters
        params = {}
        
        
        # Replace path parameters in URL
        path = "/deposits/maturedDepositClosure"
        
        
        # Prepare headers
        headers = {}
        if accesstoken is not None:
            headers["Accesstoken"] = str(accesstoken)
        if channeltype is not None:
            headers["ChannelType"] = str(channeltype)
        if co_relationid is not None:
            headers["Co-Relationid"] = str(co_relationid)
        if initiatingsystem is not None:
            headers["InitiatingSystem"] = str(initiatingsystem)
        if servicemode is not None:
            headers["ServiceMode"] = str(servicemode)
        if uuidseqno is not None:
            headers["UUIDSeqNo"] = str(uuidseqno)
        if entity is not None:
            headers["entity"] = str(entity)
        if languagecode is not None:
            headers["languageCode"] = str(languagecode)
        if referenceid is not None:
            headers["referenceId"] = str(referenceid)
        if requesthash is not None:
            headers["requesthash"] = str(requesthash)
        if userid is not None:
            headers["userId"] = str(userid)
        
        
        return await make_api_request(
            "POST", 
            path, 
            data=data, 
            params=params if params else None, 
            headers=headers if headers else None
        )
    
    
    
    @mcp.tool()
    async def depbt0501_ibcreate_part_wdwl_postusing_post(
        request_body:Dict[str, Any] ,  # CreatePartWithdrawal_Resource,
        accesstoken: Optional[str] = None,
        channeltype: Optional[int] = None,
        co_relationid: Optional[int] = None,
        initiatingsystem: Optional[str] = None,
        servicemode: Optional[int] = None,
        uuidseqno: Optional[int] = None,
        entity: Optional[str] = None,
        languagecode: Optional[int] = None,
        referenceid: Optional[str] = None,
        requesthash: Optional[str] = None,
        userid: Optional[int] = None
    ) -> Dict[str, Any]:
        """
        Create Part Withdrawal
        
        Generated from: POST /deposits/partWithdrawal
        Source: swagger_2_0
        Operation ID: DEPBT0501IBCreatePartWdwl_POSTUsingPOST
        
        
        Authentication: Not required
        
        Parameters:
        - request_body: any (required)
          input
        
        
        
        Headers:
        - Accesstoken: string
          Authorization token for identification of the caller
        - ChannelType: integer
          Channel identifier from where the TXN has originated (Internet, Mobile, ATM, Branch Channel )
        - Co-Relationid: integer
          Unique ID for the service invoked, will be set by the TXN system
        - InitiatingSystem: string
          Indicating the initiated system
        - ServiceMode: integer
          Used for branch channel to indicate the type of customer
        - UUIDSeqNo: integer
          UUID Sequence Number
        - entity: string
          entity
        - languageCode: integer
          languageCode
        - referenceId: string
          Place holder for Token based authentication
        - requesthash: string
          Request payload for hash validation
        - userId: integer
          userId
        
        
        """
        
        
        # Prepare request data
        
        # Single body parameter - send directly
        data = request_body if request_body is not None else {}
        
        
        
        # Prepare query parameters
        params = {}
        
        
        # Replace path parameters in URL
        path = "/deposits/partWithdrawal"
        
        
        # Prepare headers
        headers = {}
        if accesstoken is not None:
            headers["Accesstoken"] = str(accesstoken)
        if channeltype is not None:
            headers["ChannelType"] = str(channeltype)
        if co_relationid is not None:
            headers["Co-Relationid"] = str(co_relationid)
        if initiatingsystem is not None:
            headers["InitiatingSystem"] = str(initiatingsystem)
        if servicemode is not None:
            headers["ServiceMode"] = str(servicemode)
        if uuidseqno is not None:
            headers["UUIDSeqNo"] = str(uuidseqno)
        if entity is not None:
            headers["entity"] = str(entity)
        if languagecode is not None:
            headers["languageCode"] = str(languagecode)
        if referenceid is not None:
            headers["referenceId"] = str(referenceid)
        if requesthash is not None:
            headers["requesthash"] = str(requesthash)
        if userid is not None:
            headers["userId"] = str(userid)
        
        
        return await make_api_request(
            "POST", 
            path, 
            data=data, 
            params=params if params else None, 
            headers=headers if headers else None
        )
    
    
    
    @mcp.tool()
    async def depbt0502_auth_prt_wdwl_postusing_post(
        request_body:Dict[str, Any] ,  # DEP_DEAL_DEPBT0502AuthPrtWdwl_Request,
        accesstoken: Optional[str] = None,
        channeltype: Optional[int] = None,
        co_relationid: Optional[int] = None,
        initiatingsystem: Optional[str] = None,
        servicemode: Optional[int] = None,
        uuidseqno: Optional[int] = None,
        entity: Optional[str] = None,
        languagecode: Optional[int] = None,
        referenceid: Optional[str] = None,
        requesthash: Optional[str] = None,
        userid: Optional[int] = None
    ) -> Dict[str, Any]:
        """
        Authorize Part Withdrawal
        
        Generated from: POST /deposits/partWithdrawal/auth
        Source: swagger_2_0
        Operation ID: DEPBT0502AuthPrtWdwl_POSTUsingPOST
        
        
        Authentication: Not required
        
        Parameters:
        - request_body: any (required)
          input
        
        
        
        Headers:
        - Accesstoken: string
          Authorization token for identification of the caller
        - ChannelType: integer
          Channel identifier from where the TXN has originated (Internet, Mobile, ATM, Branch Channel )
        - Co-Relationid: integer
          Unique ID for the service invoked, will be set by the TXN system
        - InitiatingSystem: string
          Indicating the initiated system
        - ServiceMode: integer
          Used for branch channel to indicate the type of customer
        - UUIDSeqNo: integer
          UUID Sequence Number
        - entity: string
          entity
        - languageCode: integer
          languageCode
        - referenceId: string
          Place holder for Token based authentication
        - requesthash: string
          Request payload for hash validation
        - userId: integer
          userId
        
        
        """
        
        
        # Prepare request data
        
        # Single body parameter - send directly
        data = request_body if request_body is not None else {}
        
        
        
        # Prepare query parameters
        params = {}
        
        
        # Replace path parameters in URL
        path = "/deposits/partWithdrawal/auth"
        
        
        # Prepare headers
        headers = {}
        if accesstoken is not None:
            headers["Accesstoken"] = str(accesstoken)
        if channeltype is not None:
            headers["ChannelType"] = str(channeltype)
        if co_relationid is not None:
            headers["Co-Relationid"] = str(co_relationid)
        if initiatingsystem is not None:
            headers["InitiatingSystem"] = str(initiatingsystem)
        if servicemode is not None:
            headers["ServiceMode"] = str(servicemode)
        if uuidseqno is not None:
            headers["UUIDSeqNo"] = str(uuidseqno)
        if entity is not None:
            headers["entity"] = str(entity)
        if languagecode is not None:
            headers["languageCode"] = str(languagecode)
        if referenceid is not None:
            headers["referenceId"] = str(referenceid)
        if requesthash is not None:
            headers["requesthash"] = str(requesthash)
        if userid is not None:
            headers["userId"] = str(userid)
        
        
        return await make_api_request(
            "POST", 
            path, 
            data=data, 
            params=params if params else None, 
            headers=headers if headers else None
        )
    
    
    
    @mcp.tool()
    async def depet0303_calc_int_rate_erl_mtrty_postusing_get(
        accountid: int,
        accounttype: int,
        partialwithdrawalamount: float,
        primaryborrowerid: int,
        txndate: str,
        accesstoken: Optional[str] = None,
        channeltype: Optional[int] = None,
        co_relationid: Optional[int] = None,
        initiatingsystem: Optional[str] = None,
        servicemode: Optional[int] = None,
        uuidseqno: Optional[int] = None,
        entity: Optional[str] = None,
        languagecode: Optional[int] = None,
        referenceid: Optional[str] = None,
        userid: Optional[int] = None
    ) -> Dict[str, Any]:
        """
        Trial Part Withdrawal
        
        Generated from: GET /deposits/partWithdrawal/trialPartWithdrawal
        Source: swagger_2_0
        Operation ID: DEPET0303CalcIntRateErlMtrty_POSTUsingGET
        
        
        Authentication: Not required
        
        Parameters:
        - accountId: integer (required)
          This field describes the account ID
        - accountType: integer (required)
          This field describes the account Type(551-DepositTxn)
        - partialWithdrawalAmount: number (required)
          partial Withdrawal Amount
        - primaryBorrowerId: integer (required)
          Primary Barrower Id of customer
        - txnDate: string (required)
          Transaction Date (format: YYYYMMDD)
        
        
        
        Headers:
        - Accesstoken: string
          Authorization token for identification of the caller
        - ChannelType: integer
          Channel identifier from where the TXN has originated (Internet, Mobile, ATM, Branch Channel )
        - Co-Relationid: integer
          Unique ID for the service invoked, will be set by the TXN system
        - InitiatingSystem: string
          Indicating the initiated system
        - ServiceMode: integer
          Used for branch channel to indicate the type of customer
        - UUIDSeqNo: integer
          UUID Sequence Number
        - entity: string
          entity
        - languageCode: integer
          languageCode
        - referenceId: string
          Place holder for Token based authentication
        - userId: integer
          userId
        
        
        """
        
        
        # Prepare query parameters
        params = {}
        if accountid is not None:
            params["accountId"] = accountid
            
        if accounttype is not None:
            params["accountType"] = accounttype
            
        if partialwithdrawalamount is not None:
            params["partialWithdrawalAmount"] = partialwithdrawalamount
            
        if primaryborrowerid is not None:
            params["primaryBorrowerId"] = primaryborrowerid
            
        if txndate is not None:
            params["txnDate"] = txndate
            
        
        
        # Replace path parameters in URL
        path = "/deposits/partWithdrawal/trialPartWithdrawal"
        
        
        # Prepare headers
        headers = {}
        if accesstoken is not None:
            headers["Accesstoken"] = str(accesstoken)
        if channeltype is not None:
            headers["ChannelType"] = str(channeltype)
        if co_relationid is not None:
            headers["Co-Relationid"] = str(co_relationid)
        if initiatingsystem is not None:
            headers["InitiatingSystem"] = str(initiatingsystem)
        if servicemode is not None:
            headers["ServiceMode"] = str(servicemode)
        if uuidseqno is not None:
            headers["UUIDSeqNo"] = str(uuidseqno)
        if entity is not None:
            headers["entity"] = str(entity)
        if languagecode is not None:
            headers["languageCode"] = str(languagecode)
        if referenceid is not None:
            headers["referenceId"] = str(referenceid)
        if userid is not None:
            headers["userId"] = str(userid)
        
        
        return await make_api_request(
            "GET", 
            path, 
            
            params=params if params else None, 
            headers=headers if headers else None
        )
    
    
    
    @mcp.tool()
    async def depet404_view_pwemscdeal_evnt_lst_postusing_get(
        accountid: int,
        accounttype: int,
        dealid: int,
        dealtype: int,
        accesstoken: Optional[str] = None,
        channeltype: Optional[int] = None,
        co_relationid: Optional[int] = None,
        initiatingsystem: Optional[str] = None,
        servicemode: Optional[int] = None,
        uuidseqno: Optional[int] = None,
        entity: Optional[str] = None,
        languagecode: Optional[int] = None,
        referenceid: Optional[str] = None,
        requesthash: Optional[str] = None,
        userid: Optional[int] = None
    ) -> Dict[str, Any]:
        """
        Part withdrawal checker view
        
        Generated from: GET /deposits/partWithdrawal/txnView
        Source: swagger_2_0
        Operation ID: DEPET404ViewPWEMSCDealEvntLst_POSTUsingGET
        
        
        Authentication: Not required
        
        Parameters:
        - accountId: integer (required)
          This field describes the account ID
        - accountType: integer (required)
          This field describes the account Type(551-DepositTxn)
        - dealId: integer (required)
          Unique reference of the Deposit
        - dealType: integer (required)
          Deposit Account Type(551-DepositTxn)
        
        
        
        Headers:
        - Accesstoken: string
          Authorization token for identification of the caller
        - ChannelType: integer
          Channel identifier from where the TXN has originated (Internet, Mobile, ATM, Branch Channel )
        - Co-Relationid: integer
          Unique ID for the service invoked, will be set by the TXN system
        - InitiatingSystem: string
          Indicating the initiated system
        - ServiceMode: integer
          Used for branch channel to indicate the type of customer
        - UUIDSeqNo: integer
          UUID Sequence Number
        - entity: string
          entity
        - languageCode: integer
          languageCode
        - referenceId: string
          Place holder for Token based authentication
        - requesthash: string
          Request payload for hash validation
        - userId: integer
          userId
        
        
        """
        
        
        # Prepare query parameters
        params = {}
        if accountid is not None:
            params["accountId"] = accountid
            
        if accounttype is not None:
            params["accountType"] = accounttype
            
        if dealid is not None:
            params["dealId"] = dealid
            
        if dealtype is not None:
            params["dealType"] = dealtype
            
        
        
        # Replace path parameters in URL
        path = "/deposits/partWithdrawal/txnView"
        
        
        # Prepare headers
        headers = {}
        if accesstoken is not None:
            headers["Accesstoken"] = str(accesstoken)
        if channeltype is not None:
            headers["ChannelType"] = str(channeltype)
        if co_relationid is not None:
            headers["Co-Relationid"] = str(co_relationid)
        if initiatingsystem is not None:
            headers["InitiatingSystem"] = str(initiatingsystem)
        if servicemode is not None:
            headers["ServiceMode"] = str(servicemode)
        if uuidseqno is not None:
            headers["UUIDSeqNo"] = str(uuidseqno)
        if entity is not None:
            headers["entity"] = str(entity)
        if languagecode is not None:
            headers["languageCode"] = str(languagecode)
        if referenceid is not None:
            headers["referenceId"] = str(referenceid)
        if requesthash is not None:
            headers["requesthash"] = str(requesthash)
        if userid is not None:
            headers["userId"] = str(userid)
        
        
        return await make_api_request(
            "GET", 
            path, 
            
            params=params if params else None, 
            headers=headers if headers else None
        )
    
    
    
    @mcp.tool()
    async def depbt0210_auth_tdpre_clsr_rvrsl_using_post(
        request_body:Dict[str, Any] ,  # TDPreClsrReversalAuthorizeRequest,
        accesstoken: Optional[str] = None,
        channeltype: Optional[int] = None,
        co_relationid: Optional[int] = None,
        initiatingsystem: Optional[str] = None,
        servicemode: Optional[int] = None,
        uuidseqno: Optional[int] = None,
        entity: Optional[str] = None,
        languagecode: Optional[int] = None,
        referenceid: Optional[str] = None,
        requesthash: Optional[str] = None,
        userid: Optional[int] = None
    ) -> Dict[str, Any]:
        """
        This service is used to Authorize Pre Closure Reversal
        
        Generated from: POST /deposits/preClosure/reversal/auth
        Source: swagger_2_0
        Operation ID: DEPBT0210AuthTDPreClsrRvrslUsingPOST
        
        
        Authentication: Not required
        
        Parameters:
        - request_body: any (required)
          input
        
        
        
        Headers:
        - Accesstoken: string
          Authorization token for identification of the caller
        - ChannelType: integer
          Channel identifier from where the TXN has originated (Internet, Mobile, ATM, Branch Channel )
        - Co-Relationid: integer
          Unique ID for the service invoked, will be set by the TXN system
        - InitiatingSystem: string
          Indicating the initiated system
        - ServiceMode: integer
          Used for branch channel to indicate the type of customer
        - UUIDSeqNo: integer
          UUID Sequence Number
        - entity: string
          entity
        - languageCode: integer
          languageCode
        - referenceId: string
          Place holder for Token based authentication
        - requesthash: string
          Request payload for hash validation
        - userId: integer
          userId
        
        
        """
        
        
        # Prepare request data
        
        # Single body parameter - send directly
        data = request_body if request_body is not None else {}
        
        
        
        # Prepare query parameters
        params = {}
        
        
        # Replace path parameters in URL
        path = "/deposits/preClosure/reversal/auth"
        
        
        # Prepare headers
        headers = {}
        if accesstoken is not None:
            headers["Accesstoken"] = str(accesstoken)
        if channeltype is not None:
            headers["ChannelType"] = str(channeltype)
        if co_relationid is not None:
            headers["Co-Relationid"] = str(co_relationid)
        if initiatingsystem is not None:
            headers["InitiatingSystem"] = str(initiatingsystem)
        if servicemode is not None:
            headers["ServiceMode"] = str(servicemode)
        if uuidseqno is not None:
            headers["UUIDSeqNo"] = str(uuidseqno)
        if entity is not None:
            headers["entity"] = str(entity)
        if languagecode is not None:
            headers["languageCode"] = str(languagecode)
        if referenceid is not None:
            headers["referenceId"] = str(referenceid)
        if requesthash is not None:
            headers["requesthash"] = str(requesthash)
        if userid is not None:
            headers["userId"] = str(userid)
        
        
        return await make_api_request(
            "POST", 
            path, 
            data=data, 
            params=params if params else None, 
            headers=headers if headers else None
        )
    
    
    
    @mcp.tool()
    async def depet0303_calc_int_rate_erl_mtrty_postusing_get_1(
        currency: str,
        depositamount: float,
        interestpaymentfreq: int,
        interestpractice: int,
        interestrate: float,
        interesttype: int,
        maturitydate: str,
        periodfrequency: int,
        periodvalue: int,
        primarybarrowerid: int,
        productid: int,
        producttype: int,
        valuedate: str,
        periodfrequency1: Optional[int] = None,
        periodvalue1: Optional[int] = None,
        accesstoken: Optional[str] = None,
        channeltype: Optional[int] = None,
        co_relationid: Optional[int] = None,
        initiatingsystem: Optional[str] = None,
        servicemode: Optional[int] = None,
        uuidseqno: Optional[int] = None,
        entity: Optional[str] = None,
        languagecode: Optional[int] = None,
        referenceid: Optional[str] = None,
        userid: Optional[int] = None
    ) -> Dict[str, Any]:
        """
        Prefetch maturity amount
        
        Generated from: GET /deposits/preFetchMaturityAmount
        Source: swagger_2_0
        Operation ID: DEPET0303CalcIntRateErlMtrty_POSTUsingGET_1
        
        
        Authentication: Not required
        
        Parameters:
        - currency: string (required)
          Currency USD, EUR etc.
        - depositAmount: number (required)
          Deposit Amount
        - interestPaymentFreq: integer (required)
          Interest Payment Frequency 3-Monthly, 4-Monthly Anniversary,5-Quarterly, 6-Quarterly Anniversary, 9-Yearly, 11-Maturity (domain:d_IntrAppl)
        - interestPractice: integer (required)
          Interest Practice  1-30By360, 5-ActualBy365, 6-30By365 etc.(domain: d_IntrPractice)
        - interestRate: number (required)
          Interest Rate
        - interestType: integer (required)
          Interest type 1-Simple, 2-Compound(domain:d_IntrstType)
        - maturityDate: string (required)
          Maturity Date (format: YYYYMMDD)
        - periodFrequency: integer (required)
          Frequency of period(Domain Name: d_FreqUnit) e.g. 1-Day, 4-Month , 8-Year
        - periodFrequency1: integer
          Frequency of period
        - periodValue: integer (required)
          Number of units ex:1,2,3 etc
        - periodValue1: integer
          Period unit eg, 1,2,3 etc.
        - primaryBarrowerId: integer (required)
          Primary Barrower Id of customer
        - productId: integer (required)
          Product ID, 1654-Retail Term Deposit- STDR, 1656-Retail Term Deposit- Staff STDR, 2258-A_Term_Deposit_Product  etc.
        - productType: integer (required)
          Product Type, 221-Term Deposit (domain: d_InstrTyp)
        - valueDate: string (required)
          Date of deposit creation (Format:YYYYMMDD)
        
        
        
        Headers:
        - Accesstoken: string
          Authorization token for identification of the caller
        - ChannelType: integer
          Channel identifier from where the TXN has originated (Internet, Mobile, ATM, Branch Channel )
        - Co-Relationid: integer
          Unique ID for the service invoked, will be set by the TXN system
        - InitiatingSystem: string
          Indicating the initiated system
        - ServiceMode: integer
          Used for branch channel to indicate the type of customer
        - UUIDSeqNo: integer
          UUID Sequence Number
        - entity: string
          entity
        - languageCode: integer
          languageCode
        - referenceId: string
          Place holder for Token based authentication
        - userId: integer
          userId
        
        
        """
        
        
        # Prepare query parameters
        params = {}
        if currency is not None:
            params["currency"] = currency
            
        if depositamount is not None:
            params["depositAmount"] = depositamount
            
        if interestpaymentfreq is not None:
            params["interestPaymentFreq"] = interestpaymentfreq
            
        if interestpractice is not None:
            params["interestPractice"] = interestpractice
            
        if interestrate is not None:
            params["interestRate"] = interestrate
            
        if interesttype is not None:
            params["interestType"] = interesttype
            
        if maturitydate is not None:
            params["maturityDate"] = maturitydate
            
        if periodfrequency is not None:
            params["periodFrequency"] = periodfrequency
            
        if periodfrequency1 is not None:
            params["periodFrequency1"] = periodfrequency1
            
        if periodvalue is not None:
            params["periodValue"] = periodvalue
            
        if periodvalue1 is not None:
            params["periodValue1"] = periodvalue1
            
        if primarybarrowerid is not None:
            params["primaryBarrowerId"] = primarybarrowerid
            
        if productid is not None:
            params["productId"] = productid
            
        if producttype is not None:
            params["productType"] = producttype
            
        if valuedate is not None:
            params["valueDate"] = valuedate
            
        
        
        # Replace path parameters in URL
        path = "/deposits/preFetchMaturityAmount"
        
        
        # Prepare headers
        headers = {}
        if accesstoken is not None:
            headers["Accesstoken"] = str(accesstoken)
        if channeltype is not None:
            headers["ChannelType"] = str(channeltype)
        if co_relationid is not None:
            headers["Co-Relationid"] = str(co_relationid)
        if initiatingsystem is not None:
            headers["InitiatingSystem"] = str(initiatingsystem)
        if servicemode is not None:
            headers["ServiceMode"] = str(servicemode)
        if uuidseqno is not None:
            headers["UUIDSeqNo"] = str(uuidseqno)
        if entity is not None:
            headers["entity"] = str(entity)
        if languagecode is not None:
            headers["languageCode"] = str(languagecode)
        if referenceid is not None:
            headers["referenceId"] = str(referenceid)
        if userid is not None:
            headers["userId"] = str(userid)
        
        
        return await make_api_request(
            "GET", 
            path, 
            
            params=params if params else None, 
            headers=headers if headers else None
        )
    
    
    
    @mcp.tool()
    async def depbt0210_tdpre_clsr_rvrsl_postusing_post(
        request_body:Dict[str, Any] ,  # TDPreClsrReversalRequest,
        accesstoken: Optional[str] = None,
        channeltype: Optional[int] = None,
        co_relationid: Optional[int] = None,
        initiatingsystem: Optional[str] = None,
        servicemode: Optional[int] = None,
        uuidseqno: Optional[int] = None,
        entity: Optional[str] = None,
        languagecode: Optional[int] = None,
        referenceid: Optional[str] = None,
        requesthash: Optional[str] = None,
        userid: Optional[int] = None
    ) -> Dict[str, Any]:
        """
        This service is used to Pre Closure Reversal
        
        Generated from: POST /deposits/preclosure/reversal
        Source: swagger_2_0
        Operation ID: DEPBT0210TDPreClsrRvrsl_POSTUsingPOST
        
        
        Authentication: Not required
        
        Parameters:
        - request_body: any (required)
          input
        
        
        
        Headers:
        - Accesstoken: string
          Authorization token for identification of the caller
        - ChannelType: integer
          Channel identifier from where the TXN has originated (Internet, Mobile, ATM, Branch Channel )
        - Co-Relationid: integer
          Unique ID for the service invoked, will be set by the TXN system
        - InitiatingSystem: string
          Indicating the initiated system
        - ServiceMode: integer
          Used for branch channel to indicate the type of customer
        - UUIDSeqNo: integer
          UUID Sequence Number
        - entity: string
          entity
        - languageCode: integer
          languageCode
        - referenceId: string
          Place holder for Token based authentication
        - requesthash: string
          Request payload for hash validation
        - userId: integer
          userId
        
        
        """
        
        
        # Prepare request data
        
        # Single body parameter - send directly
        data = request_body if request_body is not None else {}
        
        
        
        # Prepare query parameters
        params = {}
        
        
        # Replace path parameters in URL
        path = "/deposits/preclosure/reversal"
        
        
        # Prepare headers
        headers = {}
        if accesstoken is not None:
            headers["Accesstoken"] = str(accesstoken)
        if channeltype is not None:
            headers["ChannelType"] = str(channeltype)
        if co_relationid is not None:
            headers["Co-Relationid"] = str(co_relationid)
        if initiatingsystem is not None:
            headers["InitiatingSystem"] = str(initiatingsystem)
        if servicemode is not None:
            headers["ServiceMode"] = str(servicemode)
        if uuidseqno is not None:
            headers["UUIDSeqNo"] = str(uuidseqno)
        if entity is not None:
            headers["entity"] = str(entity)
        if languagecode is not None:
            headers["languageCode"] = str(languagecode)
        if referenceid is not None:
            headers["referenceId"] = str(referenceid)
        if requesthash is not None:
            headers["requesthash"] = str(requesthash)
        if userid is not None:
            headers["userId"] = str(userid)
        
        
        return await make_api_request(
            "POST", 
            path, 
            data=data, 
            params=params if params else None, 
            headers=headers if headers else None
        )
    
    
    
    @mcp.tool()
    async def depetget_product_list_ib_postusing_get(
        accountcreationdate: Optional[str] = None,
        amount: Optional[float] = None,
        currency: Optional[str] = None,
        customerid: Optional[int] = None,
        identifiertype: Optional[int] = None,
        identifiervalue: Optional[str] = None,
        instrumentid: Optional[int] = None,
        periodfrequency: Optional[int] = None,
        periodfrequencydays: Optional[int] = None,
        periodvalue: Optional[int] = None,
        periodvaluedays: Optional[int] = None,
        pagenum: Optional[int] = None,
        pagesize: Optional[int] = None,
        accesstoken: Optional[str] = None,
        channeltype: Optional[int] = None,
        co_relationid: Optional[int] = None,
        initiatingsystem: Optional[str] = None,
        servicemode: Optional[int] = None,
        uuidseqno: Optional[int] = None,
        entity: Optional[str] = None,
        languagecode: Optional[int] = None,
        referenceid: Optional[str] = None,
        userid: Optional[int] = None
    ) -> Dict[str, Any]:
        """
        Fetch Product Maturity Details
        
        Generated from: GET /deposits/productMaturityDetails
        Source: swagger_2_0
        Operation ID: DEPETGetProductListIB_POSTUsingGET
        
        
        Authentication: Not required
        
        Parameters:
        - AccountCreationDate: string
          Enter the creation date of the account(format : YYYYMMDD)
        - Amount: number
          Enter the Deposit Amount
        - Currency: string
          Enter the Deposit Currency
        - CustomerID: integer
          Enter the Customer ID
        - IdentifierType: integer
          Identifier Type
        - IdentifierValue: string
          Identifier Value
        - InstrumentID: integer
          Enter the Instrument ID
        - PeriodFrequency: integer
          Enter the Period Frequency(1-Day,3-Hour,4-Month,5-Quarter,7-Week,8-Year)
        - PeriodFrequencyDays: integer
          Enter the Period Frequency(1-Day)
        - PeriodValue: integer
          Enter the Period Value
        - PeriodValueDays: integer
          Enter the Period Days
        - pageNum: integer
          pageNum
        - pageSize: integer
          pageSize
        
        
        
        Headers:
        - Accesstoken: string
          Authorization token for identification of the caller
        - ChannelType: integer
          Channel identifier from where the TXN has originated (Internet, Mobile, ATM, Branch Channel )
        - Co-Relationid: integer
          Unique ID for the service invoked, will be set by the TXN system
        - InitiatingSystem: string
          Indicating the initiated system
        - ServiceMode: integer
          Used for branch channel to indicate the type of customer
        - UUIDSeqNo: integer
          UUID Sequence Number
        - entity: string
          entity
        - languageCode: integer
          languageCode
        - referenceId: string
          Place holder for Token based authentication
        - userId: integer
          userId
        
        
        """
        
        
        # Prepare query parameters
        params = {}
        if accountcreationdate is not None:
            params["AccountCreationDate"] = accountcreationdate
            
        if amount is not None:
            params["Amount"] = amount
            
        if currency is not None:
            params["Currency"] = currency
            
        if customerid is not None:
            params["CustomerID"] = customerid
            
        if identifiertype is not None:
            params["IdentifierType"] = identifiertype
            
        if identifiervalue is not None:
            params["IdentifierValue"] = identifiervalue
            
        if instrumentid is not None:
            params["InstrumentID"] = instrumentid
            
        if periodfrequency is not None:
            params["PeriodFrequency"] = periodfrequency
            
        if periodfrequencydays is not None:
            params["PeriodFrequencyDays"] = periodfrequencydays
            
        if periodvalue is not None:
            params["PeriodValue"] = periodvalue
            
        if periodvaluedays is not None:
            params["PeriodValueDays"] = periodvaluedays
            
        if pagenum is not None:
            params["pageNum"] = pagenum
            
        if pagesize is not None:
            params["pageSize"] = pagesize
            
        
        
        # Replace path parameters in URL
        path = "/deposits/productMaturityDetails"
        
        
        # Prepare headers
        headers = {}
        if accesstoken is not None:
            headers["Accesstoken"] = str(accesstoken)
        if channeltype is not None:
            headers["ChannelType"] = str(channeltype)
        if co_relationid is not None:
            headers["Co-Relationid"] = str(co_relationid)
        if initiatingsystem is not None:
            headers["InitiatingSystem"] = str(initiatingsystem)
        if servicemode is not None:
            headers["ServiceMode"] = str(servicemode)
        if uuidseqno is not None:
            headers["UUIDSeqNo"] = str(uuidseqno)
        if entity is not None:
            headers["entity"] = str(entity)
        if languagecode is not None:
            headers["languageCode"] = str(languagecode)
        if referenceid is not None:
            headers["referenceId"] = str(referenceid)
        if userid is not None:
            headers["userId"] = str(userid)
        
        
        return await make_api_request(
            "GET", 
            path, 
            
            params=params if params else None, 
            headers=headers if headers else None
        )
    
    
    
    @mcp.tool()
    async def depbt0301_crt_rdinstlmt_rlsd_postusing_post(
        request_body:Dict[str, Any] ,  # rdPaymentRequest,
        accesstoken: Optional[str] = None,
        channeltype: Optional[int] = None,
        co_relationid: Optional[int] = None,
        initiatingsystem: Optional[str] = None,
        servicemode: Optional[int] = None,
        uuidseqno: Optional[int] = None,
        entity: Optional[str] = None,
        languagecode: Optional[int] = None,
        referenceid: Optional[str] = None,
        requesthash: Optional[str] = None,
        userid: Optional[int] = None
    ) -> Dict[str, Any]:
        """
        This API Is Used to Make RD Installments through Account transfer
        
        Generated from: POST /deposits/rdPayment
        Source: swagger_2_0
        Operation ID: DEPBT0301CrtRDInstlmtRlsd_POSTUsingPOST
        
        
        Authentication: Not required
        
        Parameters:
        - request_body: any (required)
          input
        
        
        
        Headers:
        - Accesstoken: string
          Authorization token for identification of the caller
        - ChannelType: integer
          Channel identifier from where the TXN has originated (Internet, Mobile, ATM, Branch Channel )
        - Co-Relationid: integer
          Unique ID for the service invoked, will be set by the TXN system
        - InitiatingSystem: string
          Indicating the initiated system
        - ServiceMode: integer
          Used for branch channel to indicate the type of customer
        - UUIDSeqNo: integer
          UUID Sequence Number
        - entity: string
          entity
        - languageCode: integer
          languageCode
        - referenceId: string
          Place holder for Token based authentication
        - requesthash: string
          Request payload for hash validation
        - userId: integer
          userId
        
        
        """
        
        
        # Prepare request data
        
        # Single body parameter - send directly
        data = request_body if request_body is not None else {}
        
        
        
        # Prepare query parameters
        params = {}
        
        
        # Replace path parameters in URL
        path = "/deposits/rdPayment"
        
        
        # Prepare headers
        headers = {}
        if accesstoken is not None:
            headers["Accesstoken"] = str(accesstoken)
        if channeltype is not None:
            headers["ChannelType"] = str(channeltype)
        if co_relationid is not None:
            headers["Co-Relationid"] = str(co_relationid)
        if initiatingsystem is not None:
            headers["InitiatingSystem"] = str(initiatingsystem)
        if servicemode is not None:
            headers["ServiceMode"] = str(servicemode)
        if uuidseqno is not None:
            headers["UUIDSeqNo"] = str(uuidseqno)
        if entity is not None:
            headers["entity"] = str(entity)
        if languagecode is not None:
            headers["languageCode"] = str(languagecode)
        if referenceid is not None:
            headers["referenceId"] = str(referenceid)
        if requesthash is not None:
            headers["requesthash"] = str(requesthash)
        if userid is not None:
            headers["userId"] = str(userid)
        
        
        return await make_api_request(
            "POST", 
            path, 
            data=data, 
            params=params if params else None, 
            headers=headers if headers else None
        )
    
    
    
    @mcp.tool()
    async def amet2603_ftch_whtbphist_postusing_get(
        customerreference: int,
        financialyear: str,
        pagenum: Optional[int] = None,
        pagesize: Optional[int] = None,
        accesstoken: Optional[str] = None,
        channeltype: Optional[int] = None,
        co_relationid: Optional[int] = None,
        initiatingsystem: Optional[str] = None,
        servicemode: Optional[int] = None,
        uuidseqno: Optional[int] = None,
        entity: Optional[str] = None,
        languagecode: Optional[int] = None,
        referenceid: Optional[str] = None,
        userid: Optional[int] = None
    ) -> Dict[str, Any]:
        """
        CustomertaxCollection
        
        Generated from: GET /deposits/taxCollection
        Source: swagger_2_0
        Operation ID: AMET2603FtchWHTBPHist_POSTUsingGET
        
        
        Authentication: Not required
        
        Parameters:
        - customerReference: integer (required)
          customer Reference
        - financialYear: string (required)
          FinancialYear
        - pageNum: integer
          pageNum
        - pageSize: integer
          pageSize
        
        
        
        Headers:
        - Accesstoken: string
          Authorization token for identification of the caller
        - ChannelType: integer
          Channel identifier from where the TXN has originated (Internet, Mobile, ATM, Branch Channel )
        - Co-Relationid: integer
          Unique ID for the service invoked, will be set by the TXN system
        - InitiatingSystem: string
          Indicating the initiated system
        - ServiceMode: integer
          Used for branch channel to indicate the type of customer
        - UUIDSeqNo: integer
          UUID Sequence Number
        - entity: string
          entity
        - languageCode: integer
          languageCode
        - referenceId: string
          Place holder for Token based authentication
        - userId: integer
          userId
        
        
        """
        
        
        # Prepare query parameters
        params = {}
        if customerreference is not None:
            params["customerReference"] = customerreference
            
        if financialyear is not None:
            params["financialYear"] = financialyear
            
        if pagenum is not None:
            params["pageNum"] = pagenum
            
        if pagesize is not None:
            params["pageSize"] = pagesize
            
        
        
        # Replace path parameters in URL
        path = "/deposits/taxCollection"
        
        
        # Prepare headers
        headers = {}
        if accesstoken is not None:
            headers["Accesstoken"] = str(accesstoken)
        if channeltype is not None:
            headers["ChannelType"] = str(channeltype)
        if co_relationid is not None:
            headers["Co-Relationid"] = str(co_relationid)
        if initiatingsystem is not None:
            headers["InitiatingSystem"] = str(initiatingsystem)
        if servicemode is not None:
            headers["ServiceMode"] = str(servicemode)
        if uuidseqno is not None:
            headers["UUIDSeqNo"] = str(uuidseqno)
        if entity is not None:
            headers["entity"] = str(entity)
        if languagecode is not None:
            headers["languageCode"] = str(languagecode)
        if referenceid is not None:
            headers["referenceId"] = str(referenceid)
        if userid is not None:
            headers["userId"] = str(userid)
        
        
        return await make_api_request(
            "GET", 
            path, 
            
            params=params if params else None, 
            headers=headers if headers else None
        )
    
    
    
    @mcp.tool()
    async def depbtopen_tdwrapper_ib_postusing_post(
        request_body:Dict[str, Any] ,  # CreateTermDepositAccount_Resource,
        accesstoken: Optional[str] = None,
        channeltype: Optional[int] = None,
        co_relationid: Optional[int] = None,
        initiatingsystem: Optional[str] = None,
        servicemode: Optional[int] = None,
        uuidseqno: Optional[int] = None,
        entity: Optional[str] = None,
        languagecode: Optional[int] = None,
        referenceid: Optional[str] = None,
        requesthash: Optional[str] = None,
        userid: Optional[int] = None
    ) -> Dict[str, Any]:
        """
        Create Term Deposit
        
        Generated from: POST /deposits/termDepositAccount
        Source: swagger_2_0
        Operation ID: DEPBTOpenTDWrapperIB_POSTUsingPOST
        
        
        Authentication: Not required
        
        Parameters:
        - request_body: any (required)
          input
        
        
        
        Headers:
        - Accesstoken: string
          Authorization token for identification of the caller
        - ChannelType: integer
          Channel identifier from where the TXN has originated (Internet, Mobile, ATM, Branch Channel )
        - Co-Relationid: integer
          Unique ID for the service invoked, will be set by the TXN system
        - InitiatingSystem: string
          Indicating the initiated system
        - ServiceMode: integer
          Used for branch channel to indicate the type of customer
        - UUIDSeqNo: integer
          UUID Sequence Number
        - entity: string
          entity
        - languageCode: integer
          languageCode
        - referenceId: string
          Place holder for Token based authentication
        - requesthash: string
          Request payload for hash validation
        - userId: integer
          userId
        
        
        """
        
        
        # Prepare request data
        
        # Single body parameter - send directly
        data = request_body if request_body is not None else {}
        
        
        
        # Prepare query parameters
        params = {}
        
        
        # Replace path parameters in URL
        path = "/deposits/termDepositAccount"
        
        
        # Prepare headers
        headers = {}
        if accesstoken is not None:
            headers["Accesstoken"] = str(accesstoken)
        if channeltype is not None:
            headers["ChannelType"] = str(channeltype)
        if co_relationid is not None:
            headers["Co-Relationid"] = str(co_relationid)
        if initiatingsystem is not None:
            headers["InitiatingSystem"] = str(initiatingsystem)
        if servicemode is not None:
            headers["ServiceMode"] = str(servicemode)
        if uuidseqno is not None:
            headers["UUIDSeqNo"] = str(uuidseqno)
        if entity is not None:
            headers["entity"] = str(entity)
        if languagecode is not None:
            headers["languageCode"] = str(languagecode)
        if referenceid is not None:
            headers["referenceId"] = str(referenceid)
        if requesthash is not None:
            headers["requesthash"] = str(requesthash)
        if userid is not None:
            headers["userId"] = str(userid)
        
        
        return await make_api_request(
            "POST", 
            path, 
            data=data, 
            params=params if params else None, 
            headers=headers if headers else None
        )
    
    
    
    @mcp.tool()
    async def depbt0208_rvrfd_deal_auth_postusing_post(
        request_body:Dict[str, Any] ,  # DEPBT0208RVrfdDealAuthRequest,
        accesstoken: Optional[str] = None,
        channeltype: Optional[int] = None,
        co_relationid: Optional[int] = None,
        initiatingsystem: Optional[str] = None,
        servicemode: Optional[int] = None,
        uuidseqno: Optional[int] = None,
        entity: Optional[str] = None,
        languagecode: Optional[int] = None,
        referenceid: Optional[str] = None,
        requesthash: Optional[str] = None,
        userid: Optional[int] = None
    ) -> Dict[str, Any]:
        """
        Authorize Term Deposit
        
        Generated from: POST /deposits/termDepositAccount/auth
        Source: swagger_2_0
        Operation ID: DEPBT0208RVrfdDealAuth_POSTUsingPOST
        
        
        Authentication: Not required
        
        Parameters:
        - request_body: any (required)
          input
        
        
        
        Headers:
        - Accesstoken: string
          Authorization token for identification of the caller
        - ChannelType: integer
          Channel identifier from where the TXN has originated (Internet, Mobile, ATM, Branch Channel )
        - Co-Relationid: integer
          Unique ID for the service invoked, will be set by the TXN system
        - InitiatingSystem: string
          Indicating the initiated system
        - ServiceMode: integer
          Used for branch channel to indicate the type of customer
        - UUIDSeqNo: integer
          UUID Sequence Number
        - entity: string
          entity
        - languageCode: integer
          languageCode
        - referenceId: string
          Place holder for Token based authentication
        - requesthash: string
          Request payload for hash validation
        - userId: integer
          userId
        
        
        """
        
        
        # Prepare request data
        
        # Single body parameter - send directly
        data = request_body if request_body is not None else {}
        
        
        
        # Prepare query parameters
        params = {}
        
        
        # Replace path parameters in URL
        path = "/deposits/termDepositAccount/auth"
        
        
        # Prepare headers
        headers = {}
        if accesstoken is not None:
            headers["Accesstoken"] = str(accesstoken)
        if channeltype is not None:
            headers["ChannelType"] = str(channeltype)
        if co_relationid is not None:
            headers["Co-Relationid"] = str(co_relationid)
        if initiatingsystem is not None:
            headers["InitiatingSystem"] = str(initiatingsystem)
        if servicemode is not None:
            headers["ServiceMode"] = str(servicemode)
        if uuidseqno is not None:
            headers["UUIDSeqNo"] = str(uuidseqno)
        if entity is not None:
            headers["entity"] = str(entity)
        if languagecode is not None:
            headers["languageCode"] = str(languagecode)
        if referenceid is not None:
            headers["referenceId"] = str(referenceid)
        if requesthash is not None:
            headers["requesthash"] = str(requesthash)
        if userid is not None:
            headers["userId"] = str(userid)
        
        
        return await make_api_request(
            "POST", 
            path, 
            data=data, 
            params=params if params else None, 
            headers=headers if headers else None
        )
    
    
    
    @mcp.tool()
    async def depbtrtl0441_auth_deal_renewal_postusing_post(
        request_body:Dict[str, Any] ,  # authDealRenewalRequest,
        accesstoken: Optional[str] = None,
        channeltype: Optional[int] = None,
        co_relationid: Optional[int] = None,
        initiatingsystem: Optional[str] = None,
        servicemode: Optional[int] = None,
        uuidseqno: Optional[int] = None,
        entity: Optional[str] = None,
        languagecode: Optional[int] = None,
        referenceid: Optional[str] = None,
        userid: Optional[int] = None
    ) -> Dict[str, Any]:
        """
        This API is to Autorize deposit settlement instruction
        
        Generated from: POST /deposits/termDepositAccount/settlementInstruction/auth
        Source: swagger_2_0
        Operation ID: DEPBTRtl0441AuthDealRenewal_POSTUsingPOST
        
        
        Authentication: Not required
        
        Parameters:
        - request_body: any (required)
          input
        
        
        
        Headers:
        - Accesstoken: string
          Authorization token for identification of the caller
        - ChannelType: integer
          Channel identifier from where the TXN has originated (Internet, Mobile, ATM, Branch Channel )
        - Co-Relationid: integer
          Unique ID for the service invoked, will be set by the TXN system
        - InitiatingSystem: string
          Indicating the initiated system
        - ServiceMode: integer
          Used for branch channel to indicate the type of customer
        - UUIDSeqNo: integer
          UUID Sequence Number
        - entity: string
          entity
        - languageCode: integer
          languageCode
        - referenceId: string
          Place holder for Token based authentication
        - userId: integer
          userId
        
        
        """
        
        
        # Prepare request data
        
        # Single body parameter - send directly
        data = request_body if request_body is not None else {}
        
        
        
        # Prepare query parameters
        params = {}
        
        
        # Replace path parameters in URL
        path = "/deposits/termDepositAccount/settlementInstruction/auth"
        
        
        # Prepare headers
        headers = {}
        if accesstoken is not None:
            headers["Accesstoken"] = str(accesstoken)
        if channeltype is not None:
            headers["ChannelType"] = str(channeltype)
        if co_relationid is not None:
            headers["Co-Relationid"] = str(co_relationid)
        if initiatingsystem is not None:
            headers["InitiatingSystem"] = str(initiatingsystem)
        if servicemode is not None:
            headers["ServiceMode"] = str(servicemode)
        if uuidseqno is not None:
            headers["UUIDSeqNo"] = str(uuidseqno)
        if entity is not None:
            headers["entity"] = str(entity)
        if languagecode is not None:
            headers["languageCode"] = str(languagecode)
        if referenceid is not None:
            headers["referenceId"] = str(referenceid)
        if userid is not None:
            headers["userId"] = str(userid)
        
        
        return await make_api_request(
            "POST", 
            path, 
            data=data, 
            params=params if params else None, 
            headers=headers if headers else None
        )
    
    
    
    @mcp.tool()
    async def depbtrtl0440_crt_deal_renewal_postusing_post(
        request_body:Dict[str, Any] ,  # depositSettlementInstructionRequest,
        accesstoken: Optional[str] = None,
        channeltype: Optional[int] = None,
        co_relationid: Optional[int] = None,
        initiatingsystem: Optional[str] = None,
        servicemode: Optional[int] = None,
        uuidseqno: Optional[int] = None,
        entity: Optional[str] = None,
        languagecode: Optional[int] = None,
        referenceid: Optional[str] = None,
        userid: Optional[int] = None
    ) -> Dict[str, Any]:
        """
        Modify Deposit Settlement Instruction
        
        Generated from: POST /deposits/termDepositAccount/settlementInstruction/modify
        Source: swagger_2_0
        Operation ID: DEPBTRtl0440CrtDealRenewal_POSTUsingPOST
        
        
        Authentication: Not required
        
        Parameters:
        - request_body: any (required)
          input
        
        
        
        Headers:
        - Accesstoken: string
          Authorization token for identification of the caller
        - ChannelType: integer
          Channel identifier from where the TXN has originated (Internet, Mobile, ATM, Branch Channel )
        - Co-Relationid: integer
          Unique ID for the service invoked, will be set by the TXN system
        - InitiatingSystem: string
          Indicating the initiated system
        - ServiceMode: integer
          Used for branch channel to indicate the type of customer
        - UUIDSeqNo: integer
          UUID Sequence Number
        - entity: string
          entity
        - languageCode: integer
          languageCode
        - referenceId: string
          Place holder for Token based authentication
        - userId: integer
          userId
        
        
        """
        
        
        # Prepare request data
        
        # Single body parameter - send directly
        data = request_body if request_body is not None else {}
        
        
        
        # Prepare query parameters
        params = {}
        
        
        # Replace path parameters in URL
        path = "/deposits/termDepositAccount/settlementInstruction/modify"
        
        
        # Prepare headers
        headers = {}
        if accesstoken is not None:
            headers["Accesstoken"] = str(accesstoken)
        if channeltype is not None:
            headers["ChannelType"] = str(channeltype)
        if co_relationid is not None:
            headers["Co-Relationid"] = str(co_relationid)
        if initiatingsystem is not None:
            headers["InitiatingSystem"] = str(initiatingsystem)
        if servicemode is not None:
            headers["ServiceMode"] = str(servicemode)
        if uuidseqno is not None:
            headers["UUIDSeqNo"] = str(uuidseqno)
        if entity is not None:
            headers["entity"] = str(entity)
        if languagecode is not None:
            headers["languageCode"] = str(languagecode)
        if referenceid is not None:
            headers["referenceId"] = str(referenceid)
        if userid is not None:
            headers["userId"] = str(userid)
        
        
        return await make_api_request(
            "POST", 
            path, 
            data=data, 
            params=params if params else None, 
            headers=headers if headers else None
        )
    
    
    
    @mcp.tool()
    async def depet0202_get_deal_dtls_using_get(
        accountreference: str,
        accesstoken: Optional[str] = None,
        channeltype: Optional[int] = None,
        co_relationid: Optional[int] = None,
        initiatingsystem: Optional[str] = None,
        servicemode: Optional[int] = None,
        uuidseqno: Optional[int] = None,
        entity: Optional[str] = None,
        languagecode: Optional[int] = None,
        referenceid: Optional[str] = None,
        userid: Optional[int] = None
    ) -> Dict[str, Any]:
        """
        Fetch Deposit settlement instruction  Details
        
        Generated from: GET /deposits/termDepositAccount/settlementInstruction/{accountReference}
        Source: swagger_2_0
        Operation ID: DEPET0202GetDealDtlsUsingGET
        
        
        Authentication: Not required
        
        Parameters:
        - accountReference: string (required)
          Deposit Number for which the Details required
        
        
        
        Headers:
        - Accesstoken: string
          Authorization token for identification of the caller
        - ChannelType: integer
          Channel identifier from where the TXN has originated (Internet, Mobile, ATM, Branch Channel )
        - Co-Relationid: integer
          Unique ID for the service invoked, will be set by the TXN system
        - InitiatingSystem: string
          Indicating the initiated system
        - ServiceMode: integer
          Used for branch channel to indicate the type of customer
        - UUIDSeqNo: integer
          UUID Sequence Number
        - entity: string
          entity
        - languageCode: integer
          languageCode
        - referenceId: string
          Place holder for Token based authentication
        - userId: integer
          userId
        
        
        """
        
        
        # Prepare query parameters
        params = {}
        
        
        # Replace path parameters in URL
        path = "/deposits/termDepositAccount/settlementInstruction/{accountReference}"
        if accountreference is not None:
            path = path.replace("{accountReference}", str(accountreference))
        
        
        # Prepare headers
        headers = {}
        if accesstoken is not None:
            headers["Accesstoken"] = str(accesstoken)
        if channeltype is not None:
            headers["ChannelType"] = str(channeltype)
        if co_relationid is not None:
            headers["Co-Relationid"] = str(co_relationid)
        if initiatingsystem is not None:
            headers["InitiatingSystem"] = str(initiatingsystem)
        if servicemode is not None:
            headers["ServiceMode"] = str(servicemode)
        if uuidseqno is not None:
            headers["UUIDSeqNo"] = str(uuidseqno)
        if entity is not None:
            headers["entity"] = str(entity)
        if languagecode is not None:
            headers["languageCode"] = str(languagecode)
        if referenceid is not None:
            headers["referenceId"] = str(referenceid)
        if userid is not None:
            headers["userId"] = str(userid)
        
        
        return await make_api_request(
            "GET", 
            path, 
            
            params=params if params else None, 
            headers=headers if headers else None
        )
    
    
    
    @mcp.tool()
    async def depbt0209_deal_rvrsl_postusing_post(
        request_body:Dict[str, Any] ,  # TDReversalRequest,
        accesstoken: Optional[str] = None,
        channeltype: Optional[int] = None,
        co_relationid: Optional[int] = None,
        initiatingsystem: Optional[str] = None,
        servicemode: Optional[int] = None,
        uuidseqno: Optional[int] = None,
        entity: Optional[str] = None,
        languagecode: Optional[int] = None,
        referenceid: Optional[str] = None,
        requesthash: Optional[str] = None,
        userid: Optional[int] = None
    ) -> Dict[str, Any]:
        """
        This service is used to reverse a Term deposit
        
        Generated from: POST /deposits/termDepositAccount/termDepositReversal
        Source: swagger_2_0
        Operation ID: DEPBT0209DealRvrsl_POSTUsingPOST
        
        
        Authentication: Not required
        
        Parameters:
        - request_body: any (required)
          input
        
        
        
        Headers:
        - Accesstoken: string
          Authorization token for identification of the caller
        - ChannelType: integer
          Channel identifier from where the TXN has originated (Internet, Mobile, ATM, Branch Channel )
        - Co-Relationid: integer
          Unique ID for the service invoked, will be set by the TXN system
        - InitiatingSystem: string
          Indicating the initiated system
        - ServiceMode: integer
          Used for branch channel to indicate the type of customer
        - UUIDSeqNo: integer
          UUID Sequence Number
        - entity: string
          entity
        - languageCode: integer
          languageCode
        - referenceId: string
          Place holder for Token based authentication
        - requesthash: string
          Request payload for hash validation
        - userId: integer
          userId
        
        
        """
        
        
        # Prepare request data
        
        # Single body parameter - send directly
        data = request_body if request_body is not None else {}
        
        
        
        # Prepare query parameters
        params = {}
        
        
        # Replace path parameters in URL
        path = "/deposits/termDepositAccount/termDepositReversal"
        
        
        # Prepare headers
        headers = {}
        if accesstoken is not None:
            headers["Accesstoken"] = str(accesstoken)
        if channeltype is not None:
            headers["ChannelType"] = str(channeltype)
        if co_relationid is not None:
            headers["Co-Relationid"] = str(co_relationid)
        if initiatingsystem is not None:
            headers["InitiatingSystem"] = str(initiatingsystem)
        if servicemode is not None:
            headers["ServiceMode"] = str(servicemode)
        if uuidseqno is not None:
            headers["UUIDSeqNo"] = str(uuidseqno)
        if entity is not None:
            headers["entity"] = str(entity)
        if languagecode is not None:
            headers["languageCode"] = str(languagecode)
        if referenceid is not None:
            headers["referenceId"] = str(referenceid)
        if requesthash is not None:
            headers["requesthash"] = str(requesthash)
        if userid is not None:
            headers["userId"] = str(userid)
        
        
        return await make_api_request(
            "POST", 
            path, 
            data=data, 
            params=params if params else None, 
            headers=headers if headers else None
        )
    
    
    
    @mcp.tool()
    async def depbt0209_auth_deal_rvrsl_postusing_post(
        request_body:Dict[str, Any] ,  # termDepositAuthoriseReversalRequest,
        accesstoken: Optional[str] = None,
        channeltype: Optional[int] = None,
        co_relationid: Optional[int] = None,
        initiatingsystem: Optional[str] = None,
        servicemode: Optional[int] = None,
        uuidseqno: Optional[int] = None,
        entity: Optional[str] = None,
        languagecode: Optional[int] = None,
        referenceid: Optional[str] = None,
        requesthash: Optional[str] = None,
        userid: Optional[int] = None
    ) -> Dict[str, Any]:
        """
        This service is used to Authorize Term Deposit Reversal
        
        Generated from: POST /deposits/termDepositAccount/termDepositReversal/auth
        Source: swagger_2_0
        Operation ID: DEPBT0209AuthDealRvrsl_POSTUsingPOST
        
        
        Authentication: Not required
        
        Parameters:
        - request_body: any (required)
          input
        
        
        
        Headers:
        - Accesstoken: string
          Authorization token for identification of the caller
        - ChannelType: integer
          Channel identifier from where the TXN has originated (Internet, Mobile, ATM, Branch Channel )
        - Co-Relationid: integer
          Unique ID for the service invoked, will be set by the TXN system
        - InitiatingSystem: string
          Indicating the initiated system
        - ServiceMode: integer
          Used for branch channel to indicate the type of customer
        - UUIDSeqNo: integer
          UUID Sequence Number
        - entity: string
          entity
        - languageCode: integer
          languageCode
        - referenceId: string
          Place holder for Token based authentication
        - requesthash: string
          Request payload for hash validation
        - userId: integer
          userId
        
        
        """
        
        
        # Prepare request data
        
        # Single body parameter - send directly
        data = request_body if request_body is not None else {}
        
        
        
        # Prepare query parameters
        params = {}
        
        
        # Replace path parameters in URL
        path = "/deposits/termDepositAccount/termDepositReversal/auth"
        
        
        # Prepare headers
        headers = {}
        if accesstoken is not None:
            headers["Accesstoken"] = str(accesstoken)
        if channeltype is not None:
            headers["ChannelType"] = str(channeltype)
        if co_relationid is not None:
            headers["Co-Relationid"] = str(co_relationid)
        if initiatingsystem is not None:
            headers["InitiatingSystem"] = str(initiatingsystem)
        if servicemode is not None:
            headers["ServiceMode"] = str(servicemode)
        if uuidseqno is not None:
            headers["UUIDSeqNo"] = str(uuidseqno)
        if entity is not None:
            headers["entity"] = str(entity)
        if languagecode is not None:
            headers["languageCode"] = str(languagecode)
        if referenceid is not None:
            headers["referenceId"] = str(referenceid)
        if requesthash is not None:
            headers["requesthash"] = str(requesthash)
        if userid is not None:
            headers["userId"] = str(userid)
        
        
        return await make_api_request(
            "POST", 
            path, 
            data=data, 
            params=params if params else None, 
            headers=headers if headers else None
        )
    
    
    
    @mcp.tool()
    async def depet0150_get_clsr_dtls_getusing_get(
        accountreference: str,
        trailclosuredate: str,
        accesstoken: Optional[str] = None,
        channeltype: Optional[int] = None,
        co_relationid: Optional[int] = None,
        initiatingsystem: Optional[str] = None,
        uuidseqno: Optional[int] = None,
        entity: Optional[str] = None,
        languagecode: Optional[int] = None,
        userid: Optional[int] = None
    ) -> Dict[str, Any]:
        """
        Fetch Deposit Term Account Trial Closure Details
        
        Generated from: GET /deposits/termDepositAccount/trailClosure/details
        Source: swagger_2_0
        Operation ID: DEPET0150GetClsrDtls_GETUsingGET
        
        
        Authentication: Not required
        
        Parameters:
        - accountReference: string (required)
          Unique Deposit Account Reference
        - trailClosureDate: string (required)
          Trail Closure Date of Deposit Account (Date Format : YYYYMMDD)
        
        
        
        Headers:
        - Accesstoken: string
          Authorization token for identification of the caller
        - ChannelType: integer
          Channel identifier from where the TXN has originated (Internet, Mobile, ATM, Branch Channel )
        - Co-Relationid: integer
          Unique ID for the service invoked, will be set by the TXN system
        - InitiatingSystem: string
          Indicating the initiated system
        - UUIDSeqNo: integer
          UUID Sequence Number
        - entity: string
          entity
        - languageCode: integer
          languageCode
        - userId: integer
          userId
        
        
        """
        
        
        # Prepare query parameters
        params = {}
        if accountreference is not None:
            params["accountReference"] = accountreference
            
        if trailclosuredate is not None:
            params["trailClosureDate"] = trailclosuredate
            
        
        
        # Replace path parameters in URL
        path = "/deposits/termDepositAccount/trailClosure/details"
        
        
        # Prepare headers
        headers = {}
        if accesstoken is not None:
            headers["Accesstoken"] = str(accesstoken)
        if channeltype is not None:
            headers["ChannelType"] = str(channeltype)
        if co_relationid is not None:
            headers["Co-Relationid"] = str(co_relationid)
        if initiatingsystem is not None:
            headers["InitiatingSystem"] = str(initiatingsystem)
        if uuidseqno is not None:
            headers["UUIDSeqNo"] = str(uuidseqno)
        if entity is not None:
            headers["entity"] = str(entity)
        if languagecode is not None:
            headers["languageCode"] = str(languagecode)
        if userid is not None:
            headers["userId"] = str(userid)
        
        
        return await make_api_request(
            "GET", 
            path, 
            
            params=params if params else None, 
            headers=headers if headers else None
        )
    
    
    
    @mcp.tool()
    async def depbt0210_rvrfd_deal_rjct_postusing_post(
        request_body:Dict[str, Any] ,  # depDealRVrfdDealRjctRequest,
        accesstoken: Optional[str] = None,
        channeltype: Optional[int] = None,
        co_relationid: Optional[int] = None,
        initiatingsystem: Optional[str] = None,
        servicemode: Optional[int] = None,
        uuidseqno: Optional[int] = None,
        entity: Optional[str] = None,
        languagecode: Optional[int] = None,
        referenceid: Optional[str] = None,
        requesthash: Optional[str] = None,
        userid: Optional[int] = None
    ) -> Dict[str, Any]:
        """
        Reject Term Deposit/Settlement Instruction/Early Maturity/Part withdrawal transactions
        
        Generated from: POST /deposits/transactions/reject
        Source: swagger_2_0
        Operation ID: DEPBT0210RVrfdDealRjct_POSTUsingPOST
        
        
        Authentication: Not required
        
        Parameters:
        - request_body: any (required)
          input
        
        
        
        Headers:
        - Accesstoken: string
          Authorization token for identification of the caller
        - ChannelType: integer
          Channel identifier from where the TXN has originated (Internet, Mobile, ATM, Branch Channel )
        - Co-Relationid: integer
          Unique ID for the service invoked, will be set by the TXN system
        - InitiatingSystem: string
          Indicating the initiated system
        - ServiceMode: integer
          Used for branch channel to indicate the type of customer
        - UUIDSeqNo: integer
          UUID Sequence Number
        - entity: string
          entity
        - languageCode: integer
          languageCode
        - referenceId: string
          Place holder for Token based authentication
        - requesthash: string
          Request payload for hash validation
        - userId: integer
          userId
        
        
        """
        
        
        # Prepare request data
        
        # Single body parameter - send directly
        data = request_body if request_body is not None else {}
        
        
        
        # Prepare query parameters
        params = {}
        
        
        # Replace path parameters in URL
        path = "/deposits/transactions/reject"
        
        
        # Prepare headers
        headers = {}
        if accesstoken is not None:
            headers["Accesstoken"] = str(accesstoken)
        if channeltype is not None:
            headers["ChannelType"] = str(channeltype)
        if co_relationid is not None:
            headers["Co-Relationid"] = str(co_relationid)
        if initiatingsystem is not None:
            headers["InitiatingSystem"] = str(initiatingsystem)
        if servicemode is not None:
            headers["ServiceMode"] = str(servicemode)
        if uuidseqno is not None:
            headers["UUIDSeqNo"] = str(uuidseqno)
        if entity is not None:
            headers["entity"] = str(entity)
        if languagecode is not None:
            headers["languageCode"] = str(languagecode)
        if referenceid is not None:
            headers["referenceId"] = str(referenceid)
        if requesthash is not None:
            headers["requesthash"] = str(requesthash)
        if userid is not None:
            headers["userId"] = str(userid)
        
        
        return await make_api_request(
            "POST", 
            path, 
            data=data, 
            params=params if params else None, 
            headers=headers if headers else None
        )
    
    
    
    @mcp.tool()
    async def depet0202_get_deal_dtls_using_get_1(
        dealid: int,
        accesstoken: Optional[str] = None,
        channeltype: Optional[int] = None,
        co_relationid: Optional[int] = None,
        initiatingsystem: Optional[str] = None,
        servicemode: Optional[int] = None,
        uuidseqno: Optional[int] = None,
        entity: Optional[str] = None,
        languagecode: Optional[int] = None,
        referenceid: Optional[str] = None,
        userid: Optional[int] = None
    ) -> Dict[str, Any]:
        """
        Fetch Deposit Details
        
        Generated from: GET /deposits/{dealId}
        Source: swagger_2_0
        Operation ID: DEPET0202GetDealDtlsUsingGET_1
        
        
        Authentication: Not required
        
        Parameters:
        - dealId: integer (required)
          Deposit Number for which the Details required
        
        
        
        Headers:
        - Accesstoken: string
          Authorization token for identification of the caller
        - ChannelType: integer
          Channel identifier from where the TXN has originated (Internet, Mobile, ATM, Branch Channel )
        - Co-Relationid: integer
          Unique ID for the service invoked, will be set by the TXN system
        - InitiatingSystem: string
          Indicating the initiated system
        - ServiceMode: integer
          Used for branch channel to indicate the type of customer
        - UUIDSeqNo: integer
          UUID Sequence Number
        - entity: string
          entity
        - languageCode: integer
          languageCode
        - referenceId: string
          Place holder for Token based authentication
        - userId: integer
          userId
        
        
        """
        
        
        # Prepare query parameters
        params = {}
        
        
        # Replace path parameters in URL
        path = "/deposits/{dealId}"
        if dealid is not None:
            path = path.replace("{dealId}", str(dealid))
        
        
        # Prepare headers
        headers = {}
        if accesstoken is not None:
            headers["Accesstoken"] = str(accesstoken)
        if channeltype is not None:
            headers["ChannelType"] = str(channeltype)
        if co_relationid is not None:
            headers["Co-Relationid"] = str(co_relationid)
        if initiatingsystem is not None:
            headers["InitiatingSystem"] = str(initiatingsystem)
        if servicemode is not None:
            headers["ServiceMode"] = str(servicemode)
        if uuidseqno is not None:
            headers["UUIDSeqNo"] = str(uuidseqno)
        if entity is not None:
            headers["entity"] = str(entity)
        if languagecode is not None:
            headers["languageCode"] = str(languagecode)
        if referenceid is not None:
            headers["referenceId"] = str(referenceid)
        if userid is not None:
            headers["userId"] = str(userid)
        
        
        return await make_api_request(
            "GET", 
            path, 
            
            params=params if params else None, 
            headers=headers if headers else None
        )
    
    
    
    @mcp.tool()
    async def depet0202_get_deal_dtls_wrapper_using_get(
        dealid: int,
        accesstoken: Optional[str] = None,
        channeltype: Optional[int] = None,
        co_relationid: Optional[int] = None,
        initiatingsystem: Optional[str] = None,
        servicemode: Optional[int] = None,
        uuidseqno: Optional[int] = None,
        entity: Optional[str] = None,
        languagecode: Optional[int] = None,
        referenceid: Optional[str] = None,
        userid: Optional[int] = None
    ) -> Dict[str, Any]:
        """
        Fetch Deposit Details
        
        Generated from: GET /deposits/{dealId}/details
        Source: swagger_2_0
        Operation ID: DEPET0202GetDealDtlsWrapperUsingGET
        
        
        Authentication: Not required
        
        Parameters:
        - dealId: integer (required)
          Deposit Number for which the Details required
        
        
        
        Headers:
        - Accesstoken: string
          Authorization token for identification of the caller
        - ChannelType: integer
          Channel identifier from where the TXN has originated (Internet, Mobile, ATM, Branch Channel )
        - Co-Relationid: integer
          Unique ID for the service invoked, will be set by the TXN system
        - InitiatingSystem: string
          Indicating the initiated system
        - ServiceMode: integer
          Used for branch channel to indicate the type of customer
        - UUIDSeqNo: integer
          UUID Sequence Number
        - entity: string
          entity
        - languageCode: integer
          languageCode
        - referenceId: string
          Place holder for Token based authentication
        - userId: integer
          userId
        
        
        """
        
        
        # Prepare query parameters
        params = {}
        
        
        # Replace path parameters in URL
        path = "/deposits/{dealId}/details"
        if dealid is not None:
            path = path.replace("{dealId}", str(dealid))
        
        
        # Prepare headers
        headers = {}
        if accesstoken is not None:
            headers["Accesstoken"] = str(accesstoken)
        if channeltype is not None:
            headers["ChannelType"] = str(channeltype)
        if co_relationid is not None:
            headers["Co-Relationid"] = str(co_relationid)
        if initiatingsystem is not None:
            headers["InitiatingSystem"] = str(initiatingsystem)
        if servicemode is not None:
            headers["ServiceMode"] = str(servicemode)
        if uuidseqno is not None:
            headers["UUIDSeqNo"] = str(uuidseqno)
        if entity is not None:
            headers["entity"] = str(entity)
        if languagecode is not None:
            headers["languageCode"] = str(languagecode)
        if referenceid is not None:
            headers["referenceId"] = str(referenceid)
        if userid is not None:
            headers["userId"] = str(userid)
        
        
        return await make_api_request(
            "GET", 
            path, 
            
            params=params if params else None, 
            headers=headers if headers else None
        )
    
    
    
    @mcp.tool()
    async def depet1051_get_dep_header_dtls_postusing_get(
        dealposnum: int,
        dealpostyp: int,
        accesstoken: Optional[str] = None,
        channeltype: Optional[int] = None,
        co_relationid: Optional[int] = None,
        initiatingsystem: Optional[str] = None,
        servicemode: Optional[int] = None,
        uuidseqno: Optional[int] = None,
        entity: Optional[str] = None,
        languagecode: Optional[int] = None,
        referenceid: Optional[str] = None,
        userid: Optional[int] = None
    ) -> Dict[str, Any]:
        """
        This API is to Get RD payment schedule details
        
        Generated from: GET /deposits/{dealPosNum}/{dealPosTyp}
        Source: swagger_2_0
        Operation ID: DEPET1051GetDepHeaderDtls_POSTUsingGET
        
        
        Authentication: Not required
        
        Parameters:
        - dealPosNum: integer (required)
          Deal pos num
        - dealPosTyp: integer (required)
          Deal pos type
        
        
        
        Headers:
        - Accesstoken: string
          Authorization token for identification of the caller
        - ChannelType: integer
          Channel identifier from where the TXN has originated (Internet, Mobile, ATM, Branch Channel )
        - Co-Relationid: integer
          Unique ID for the service invoked, will be set by the TXN system
        - InitiatingSystem: string
          Indicating the initiated system
        - ServiceMode: integer
          Used for branch channel to indicate the type of customer
        - UUIDSeqNo: integer
          UUID Sequence Number
        - entity: string
          entity
        - languageCode: integer
          languageCode
        - referenceId: string
          Place holder for Token based authentication
        - userId: integer
          userId
        
        
        """
        
        
        # Prepare query parameters
        params = {}
        
        
        # Replace path parameters in URL
        path = "/deposits/{dealPosNum}/{dealPosTyp}"
        if dealposnum is not None:
            path = path.replace("{dealPosNum}", str(dealposnum))
        if dealpostyp is not None:
            path = path.replace("{dealPosTyp}", str(dealpostyp))
        
        
        # Prepare headers
        headers = {}
        if accesstoken is not None:
            headers["Accesstoken"] = str(accesstoken)
        if channeltype is not None:
            headers["ChannelType"] = str(channeltype)
        if co_relationid is not None:
            headers["Co-Relationid"] = str(co_relationid)
        if initiatingsystem is not None:
            headers["InitiatingSystem"] = str(initiatingsystem)
        if servicemode is not None:
            headers["ServiceMode"] = str(servicemode)
        if uuidseqno is not None:
            headers["UUIDSeqNo"] = str(uuidseqno)
        if entity is not None:
            headers["entity"] = str(entity)
        if languagecode is not None:
            headers["languageCode"] = str(languagecode)
        if referenceid is not None:
            headers["referenceId"] = str(referenceid)
        if userid is not None:
            headers["userId"] = str(userid)
        
        
        return await make_api_request(
            "GET", 
            path, 
            
            params=params if params else None, 
            headers=headers if headers else None
        )
    
    
    
    @mcp.tool()
    async def fibt4704_crt_mdfy_dep_pnl_rate_postusing_post(
        instrumentid: str,
        request_body:Dict[str, Any] ,  # DEP_PENAL_RATE_FIBT4704CrtMdfyDepPnlRate_Resource,
        channeltype: Optional[int] = None,
        co_relationid: Optional[int] = None,
        initiatingsystem: Optional[str] = None,
        servicemode: Optional[int] = None,
        uuidseqno: Optional[int] = None,
        entity: Optional[str] = None,
        languagecode: Optional[int] = None,
        userid: Optional[int] = None
    ) -> Dict[str, Any]:
        """
        API to capture product level penalty rate detail for deposits
        
        Generated from: POST /deposits/{instrumentid}/captureProductLevelPenalty
        Source: swagger_2_0
        Operation ID: FIBT4704CrtMdfyDepPnlRate_POSTUsingPOST
        
        
        Authentication: Not required
        
        Parameters:
        - instrumentid: string (required)
          Path parameter instrumentid
        - request_body: any (required)
          input
        
        
        
        Headers:
        - ChannelType: integer
          Channel identifier from where the TXN has originated (Internet, Mobile, ATM, Branch Channel )
        - Co-Relationid: integer
          Unique ID for the service invoked, will be set by the TXN system
        - InitiatingSystem: string
          Indicating the initiated system
        - ServiceMode: integer
          Used for branch channel to indicate the type of customer
        - UUIDSeqNo: integer
          UUID Sequence Number
        - entity: string
          entity
        - languageCode: integer
          languageCode
        - userId: integer
          userId
        
        
        """
        
        
        # Prepare request data
        
        # Single body parameter - send directly
        data = request_body if request_body is not None else {}
        
        
        
        # Prepare query parameters
        params = {}
        
        
        # Replace path parameters in URL
        path = "/deposits/{instrumentid}/captureProductLevelPenalty"
        if instrumentid is not None:
            path = path.replace("{instrumentid}", str(instrumentid))
        
        
        # Prepare headers
        headers = {}
        if channeltype is not None:
            headers["ChannelType"] = str(channeltype)
        if co_relationid is not None:
            headers["Co-Relationid"] = str(co_relationid)
        if initiatingsystem is not None:
            headers["InitiatingSystem"] = str(initiatingsystem)
        if servicemode is not None:
            headers["ServiceMode"] = str(servicemode)
        if uuidseqno is not None:
            headers["UUIDSeqNo"] = str(uuidseqno)
        if entity is not None:
            headers["entity"] = str(entity)
        if languagecode is not None:
            headers["languageCode"] = str(languagecode)
        if userid is not None:
            headers["userId"] = str(userid)
        
        
        return await make_api_request(
            "POST", 
            path, 
            data=data, 
            params=params if params else None, 
            headers=headers if headers else None
        )
    
    
    
    @mcp.tool()
    async def fiet4705_fetch_dep_pnl_rate_postusing_get(
        instrumentid: str,
        # instrumentid: int,
        ratetype: Optional[int] = None,
        validfrom: Optional[str] = None,
        pagenum: Optional[int] = None,
        pagesize: Optional[int] = None,
        channeltype: Optional[int] = None,
        co_relationid: Optional[int] = None,
        initiatingsystem: Optional[str] = None,
        servicemode: Optional[int] = None,
        uuidseqno: Optional[int] = None,
        entity: Optional[str] = None,
        languagecode: Optional[int] = None,
        userid: Optional[int] = None
    ) -> Dict[str, Any]:
        """
        Return product level penalty rate details for deposits
        
        Generated from: GET /deposits/{instrumentid}/displayProductLevelPenalty
        Source: swagger_2_0
        Operation ID: FIET4705FetchDepPnlRate_POSTUsingGET
        
        
        Authentication: Not required
        
        Parameters:
        - InstrumentId: integer (required)
          Instrument ID of deposit
        - RateType: integer
          Penalty rate type will be 1 for Contracted Rate and 2 for Applicable Rate for Run Period
        - ValidFrom: string
          Valid From should be this format YYYMMDD
        - pageNum: integer
          pageNum
        - pageSize: integer
          pageSize
        - instrumentid: string (required)
          Path parameter instrumentid
        
        
        
        Headers:
        - ChannelType: integer
          Channel identifier from where the TXN has originated (Internet, Mobile, ATM, Branch Channel )
        - Co-Relationid: integer
          Unique ID for the service invoked, will be set by the TXN system
        - InitiatingSystem: string
          Indicating the initiated system
        - ServiceMode: integer
          Used for branch channel to indicate the type of customer
        - UUIDSeqNo: integer
          UUID Sequence Number
        - entity: string
          entity
        - languageCode: integer
          languageCode
        - userId: integer
          userId
        
        
        """
        
        
        # Prepare query parameters
        params = {}
        if instrumentid is not None:
            params["InstrumentId"] = instrumentid
            
        if ratetype is not None:
            params["RateType"] = ratetype
            
        if validfrom is not None:
            params["ValidFrom"] = validfrom
            
        if pagenum is not None:
            params["pageNum"] = pagenum
            
        if pagesize is not None:
            params["pageSize"] = pagesize
            
        
        
        # Replace path parameters in URL
        path = "/deposits/{instrumentid}/displayProductLevelPenalty"
        if instrumentid is not None:
            path = path.replace("{instrumentid}", str(instrumentid))
        
        
        # Prepare headers
        headers = {}
        if channeltype is not None:
            headers["ChannelType"] = str(channeltype)
        if co_relationid is not None:
            headers["Co-Relationid"] = str(co_relationid)
        if initiatingsystem is not None:
            headers["InitiatingSystem"] = str(initiatingsystem)
        if servicemode is not None:
            headers["ServiceMode"] = str(servicemode)
        if uuidseqno is not None:
            headers["UUIDSeqNo"] = str(uuidseqno)
        if entity is not None:
            headers["entity"] = str(entity)
        if languagecode is not None:
            headers["languageCode"] = str(languagecode)
        if userid is not None:
            headers["userId"] = str(userid)
        
        
        return await make_api_request(
            "GET", 
            path, 
            
            params=params if params else None, 
            headers=headers if headers else None
        )
    
    
    
    @mcp.tool()
    async def dsbt0005_pymnt_refund_booking_postusing_post(
        request_body:Dict[str, Any] ,  # onlineBankingTxnRefundRequest,
        channeltype: Optional[int] = None,
        co_relationid: Optional[int] = None,
        initiatingsystem: Optional[str] = None,
        servicemode: Optional[int] = None,
        uuidseqno: Optional[int] = None,
        entity: Optional[str] = None,
        languagecode: Optional[int] = None,
        userid: Optional[int] = None
    ) -> Dict[str, Any]:
        """
        Create Online Payment Refund Transaction
        
        Generated from: POST /digitalSecurity/onlinePaymentRefundTransaction/create
        Source: swagger_2_0
        Operation ID: DSBT0005PymntRefundBooking_POSTUsingPOST
        
        
        Authentication: Not required
        
        Parameters:
        - request_body: any (required)
          input
        
        
        
        Headers:
        - ChannelType: integer
          Channel identifier from where the TXN has originated (Internet, Mobile, ATM, Branch Channel )
        - Co-Relationid: integer
          Unique ID for the service invoked, will be set by the TXN system
        - InitiatingSystem: string
          Indicating the initiated system
        - ServiceMode: integer
          Used for branch channel to indicate the type of customer
        - UUIDSeqNo: integer
          UUID Sequence Number
        - entity: string
          entity
        - languageCode: integer
          languageCode
        - userId: integer
          userId
        
        
        """
        
        
        # Prepare request data
        
        # Single body parameter - send directly
        data = request_body if request_body is not None else {}
        
        
        
        # Prepare query parameters
        params = {}
        
        
        # Replace path parameters in URL
        path = "/digitalSecurity/onlinePaymentRefundTransaction/create"
        
        
        # Prepare headers
        headers = {}
        if channeltype is not None:
            headers["ChannelType"] = str(channeltype)
        if co_relationid is not None:
            headers["Co-Relationid"] = str(co_relationid)
        if initiatingsystem is not None:
            headers["InitiatingSystem"] = str(initiatingsystem)
        if servicemode is not None:
            headers["ServiceMode"] = str(servicemode)
        if uuidseqno is not None:
            headers["UUIDSeqNo"] = str(uuidseqno)
        if entity is not None:
            headers["entity"] = str(entity)
        if languagecode is not None:
            headers["languageCode"] = str(languagecode)
        if userid is not None:
            headers["userId"] = str(userid)
        
        
        return await make_api_request(
            "POST", 
            path, 
            data=data, 
            params=params if params else None, 
            headers=headers if headers else None
        )
    
    
    
    @mcp.tool()
    async def dsbt0002_auth_pymnt_txn_postusing_post(
        request_body:Dict[str, Any] ,  # onlineBankingTransactionRequest,
        channeltype: Optional[int] = None,
        co_relationid: Optional[int] = None,
        initiatingsystem: Optional[str] = None,
        servicemode: Optional[int] = None,
        uuidseqno: Optional[int] = None,
        entity: Optional[str] = None,
        languagecode: Optional[int] = None,
        userid: Optional[int] = None
    ) -> Dict[str, Any]:
        """
        Authorise Online Payment Transaction
        
        Generated from: POST /digitalSecurity/onlinePaymentTransaction/authorise
        Source: swagger_2_0
        Operation ID: DSBT0002AuthPymntTxn_POSTUsingPOST
        
        
        Authentication: Not required
        
        Parameters:
        - request_body: any (required)
          input
        
        
        
        Headers:
        - ChannelType: integer
          Channel identifier from where the TXN has originated (Internet, Mobile, ATM, Branch Channel )
        - Co-Relationid: integer
          Unique ID for the service invoked, will be set by the TXN system
        - InitiatingSystem: string
          Indicating the initiated system
        - ServiceMode: integer
          Used for branch channel to indicate the type of customer
        - UUIDSeqNo: integer
          UUID Sequence Number
        - entity: string
          entity
        - languageCode: integer
          languageCode
        - userId: integer
          userId
        
        
        """
        
        
        # Prepare request data
        
        # Single body parameter - send directly
        data = request_body if request_body is not None else {}
        
        
        
        # Prepare query parameters
        params = {}
        
        
        # Replace path parameters in URL
        path = "/digitalSecurity/onlinePaymentTransaction/authorise"
        
        
        # Prepare headers
        headers = {}
        if channeltype is not None:
            headers["ChannelType"] = str(channeltype)
        if co_relationid is not None:
            headers["Co-Relationid"] = str(co_relationid)
        if initiatingsystem is not None:
            headers["InitiatingSystem"] = str(initiatingsystem)
        if servicemode is not None:
            headers["ServiceMode"] = str(servicemode)
        if uuidseqno is not None:
            headers["UUIDSeqNo"] = str(uuidseqno)
        if entity is not None:
            headers["entity"] = str(entity)
        if languagecode is not None:
            headers["languageCode"] = str(languagecode)
        if userid is not None:
            headers["userId"] = str(userid)
        
        
        return await make_api_request(
            "POST", 
            path, 
            data=data, 
            params=params if params else None, 
            headers=headers if headers else None
        )
    
    
    
    @mcp.tool()
    async def dsbt0001_pymnt_initiation_txn_postusing_post(
        request_body:Dict[str, Any] ,  # onlineBankingTxnRequest,
        channeltype: Optional[int] = None,
        co_relationid: Optional[int] = None,
        initiatingsystem: Optional[str] = None,
        servicemode: Optional[int] = None,
        uuidseqno: Optional[int] = None,
        entity: Optional[str] = None,
        languagecode: Optional[int] = None,
        userid: Optional[int] = None
    ) -> Dict[str, Any]:
        """
        Create Online Payment Transaction
        
        Generated from: POST /digitalSecurity/onlinePaymentTransaction/create
        Source: swagger_2_0
        Operation ID: DSBT0001PymntInitiationTxn_POSTUsingPOST
        
        
        Authentication: Not required
        
        Parameters:
        - request_body: any (required)
          input
        
        
        
        Headers:
        - ChannelType: integer
          Channel identifier from where the TXN has originated (Internet, Mobile, ATM, Branch Channel )
        - Co-Relationid: integer
          Unique ID for the service invoked, will be set by the TXN system
        - InitiatingSystem: string
          Indicating the initiated system
        - ServiceMode: integer
          Used for branch channel to indicate the type of customer
        - UUIDSeqNo: integer
          UUID Sequence Number
        - entity: string
          entity
        - languageCode: integer
          languageCode
        - userId: integer
          userId
        
        
        """
        
        
        # Prepare request data
        
        # Single body parameter - send directly
        data = request_body if request_body is not None else {}
        
        
        
        # Prepare query parameters
        params = {}
        
        
        # Replace path parameters in URL
        path = "/digitalSecurity/onlinePaymentTransaction/create"
        
        
        # Prepare headers
        headers = {}
        if channeltype is not None:
            headers["ChannelType"] = str(channeltype)
        if co_relationid is not None:
            headers["Co-Relationid"] = str(co_relationid)
        if initiatingsystem is not None:
            headers["InitiatingSystem"] = str(initiatingsystem)
        if servicemode is not None:
            headers["ServiceMode"] = str(servicemode)
        if uuidseqno is not None:
            headers["UUIDSeqNo"] = str(uuidseqno)
        if entity is not None:
            headers["entity"] = str(entity)
        if languagecode is not None:
            headers["languageCode"] = str(languagecode)
        if userid is not None:
            headers["userId"] = str(userid)
        
        
        return await make_api_request(
            "POST", 
            path, 
            data=data, 
            params=params if params else None, 
            headers=headers if headers else None
        )
    
    
    
    @mcp.tool()
    async def dset0006_pymnt_verification_postusing_get(
        aggregatorreferencenumber: str,
        marketsegment: str,
        merchantinformation: str,
        payeeidentifier: str,
        transactionamount: float,
        transactioncurrency: str,
        transactiondate: str,
        bankacknowledgementnumber: Optional[int] = None,
        accesstoken: Optional[str] = None,
        channeltype: Optional[int] = None,
        co_relationid: Optional[int] = None,
        initiatingsystem: Optional[str] = None,
        servicemode: Optional[int] = None,
        uuidseqno: Optional[int] = None,
        entity: Optional[str] = None,
        languagecode: Optional[int] = None,
        referenceid: Optional[str] = None,
        userid: Optional[int] = None
    ) -> Dict[str, Any]:
        """
        Online Payment Transaction Verification
        
        Generated from: GET /digitalSecurity/onlinePaymentVerification/verify
        Source: swagger_2_0
        Operation ID: DSET0006PymntVerification_POSTUsingGET
        
        
        Authentication: Not required
        
        Parameters:
        - aggregatorReferenceNumber: string (required)
          This should be unique for each request. Maintained at aggregators end.
        - bankAcknowledgementNumber: integer
          Bank acknowledgement No of the transaction, uniquely generated id for successful transaction,B123456789 (if success) Or 0 (in case of failure)
        - marketSegment: string (required)
          market Segment
        - merchantInformation: string (required)
          merchant Information
        - payeeIdentifier: string (required)
          payee Identifier
        - transactionAmount: number (required)
          transaction Amount
        - transactionCurrency: string (required)
          transaction Currency
        - transactionDate: string (required)
          transaction Date
        
        
        
        Headers:
        - Accesstoken: string
          Authorization token for identification of the caller
        - ChannelType: integer
          Channel identifier from where the TXN has originated (Internet, Mobile, ATM, Branch Channel )
        - Co-Relationid: integer
          Unique ID for the service invoked, will be set by the TXN system
        - InitiatingSystem: string
          Indicating the initiated system
        - ServiceMode: integer
          Used for branch channel to indicate the type of customer
        - UUIDSeqNo: integer
          UUID Sequence Number
        - entity: string
          entity
        - languageCode: integer
          languageCode
        - referenceId: string
          Place holder for Token based authentication
        - userId: integer
          userId
        
        
        """
        
        
        # Prepare query parameters
        params = {}
        if aggregatorreferencenumber is not None:
            params["aggregatorReferenceNumber"] = aggregatorreferencenumber
            
        if bankacknowledgementnumber is not None:
            params["bankAcknowledgementNumber"] = bankacknowledgementnumber
            
        if marketsegment is not None:
            params["marketSegment"] = marketsegment
            
        if merchantinformation is not None:
            params["merchantInformation"] = merchantinformation
            
        if payeeidentifier is not None:
            params["payeeIdentifier"] = payeeidentifier
            
        if transactionamount is not None:
            params["transactionAmount"] = transactionamount
            
        if transactioncurrency is not None:
            params["transactionCurrency"] = transactioncurrency
            
        if transactiondate is not None:
            params["transactionDate"] = transactiondate
            
        
        
        # Replace path parameters in URL
        path = "/digitalSecurity/onlinePaymentVerification/verify"
        
        
        # Prepare headers
        headers = {}
        if accesstoken is not None:
            headers["Accesstoken"] = str(accesstoken)
        if channeltype is not None:
            headers["ChannelType"] = str(channeltype)
        if co_relationid is not None:
            headers["Co-Relationid"] = str(co_relationid)
        if initiatingsystem is not None:
            headers["InitiatingSystem"] = str(initiatingsystem)
        if servicemode is not None:
            headers["ServiceMode"] = str(servicemode)
        if uuidseqno is not None:
            headers["UUIDSeqNo"] = str(uuidseqno)
        if entity is not None:
            headers["entity"] = str(entity)
        if languagecode is not None:
            headers["languageCode"] = str(languagecode)
        if referenceid is not None:
            headers["referenceId"] = str(referenceid)
        if userid is not None:
            headers["userId"] = str(userid)
        
        
        return await make_api_request(
            "GET", 
            path, 
            
            params=params if params else None, 
            headers=headers if headers else None
        )
    
    
    
    @mcp.tool()
    async def intbt8000_cbtbkng_using_post(
        request_body:Dict[str, Any] ,  # createBookingResource,
        accesstoken: Optional[str] = None,
        channeltype: Optional[int] = None,
        co_relationid: Optional[int] = None,
        initiatingsystem: Optional[str] = None,
        servicemode: Optional[int] = None,
        uuidseqno: Optional[int] = None,
        entity: Optional[str] = None,
        languagecode: Optional[int] = None,
        referenceid: Optional[str] = None,
        requesthash: Optional[str] = None,
        userid: Optional[int] = None
    ) -> Dict[str, Any]:
        """
        This service is used to Create Booking
        
        Generated from: POST /financialAccounting/CreateBooking
        Source: swagger_2_0
        Operation ID: INTBT8000CBTBkngUsingPOST
        
        
        Authentication: Not required
        
        Parameters:
        - request_body: any (required)
          input
        
        
        
        Headers:
        - Accesstoken: string
          Authorization token for identification of the caller
        - ChannelType: integer
          Channel from where the transaction has originated (Internet, Mobile, ATM, Branch Channel )
        - Co-Relationid: integer
          Unique ID for the service invoked, will be set by the TXN system
        - InitiatingSystem: string
          Indicating the initiated system
        - ServiceMode: integer
          Used for branch channel to indicate the type of customer
        - UUIDSeqNo: integer
          UUID Sequence Number
        - entity: string
          entity
        - languageCode: integer
          languageCode
        - referenceId: string
          Place holder for Token based authentication
        - requesthash: string
          Request payload for hash validation
        - userId: integer
          userId
        
        
        """
        
        
        # Prepare request data
        
        # Single body parameter - send directly
        data = request_body if request_body is not None else {}
        
        
        
        # Prepare query parameters
        params = {}
        
        
        # Replace path parameters in URL
        path = "/financialAccounting/CreateBooking"
        
        
        # Prepare headers
        headers = {}
        if accesstoken is not None:
            headers["Accesstoken"] = str(accesstoken)
        if channeltype is not None:
            headers["ChannelType"] = str(channeltype)
        if co_relationid is not None:
            headers["Co-Relationid"] = str(co_relationid)
        if initiatingsystem is not None:
            headers["InitiatingSystem"] = str(initiatingsystem)
        if servicemode is not None:
            headers["ServiceMode"] = str(servicemode)
        if uuidseqno is not None:
            headers["UUIDSeqNo"] = str(uuidseqno)
        if entity is not None:
            headers["entity"] = str(entity)
        if languagecode is not None:
            headers["languageCode"] = str(languagecode)
        if referenceid is not None:
            headers["referenceId"] = str(referenceid)
        if requesthash is not None:
            headers["requesthash"] = str(requesthash)
        if userid is not None:
            headers["userId"] = str(userid)
        
        
        return await make_api_request(
            "POST", 
            path, 
            data=data, 
            params=params if params else None, 
            headers=headers if headers else None
        )
    
    
    
    @mcp.tool()
    async def cbpetgettransactions_by_date_using_get(
        accountreference: str,
        fromdate: Optional[str] = None,
        todate: Optional[str] = None,
        pagenum: Optional[int] = None,
        pagesize: Optional[int] = None,
        transactionid: Optional[str] = None,
        accesstoken: Optional[str] = None,
        channeltype: Optional[int] = None,
        co_relationid: Optional[int] = None,
        initiatingsystem: Optional[str] = None,
        servicemode: Optional[int] = None,
        uuidseqno: Optional[int] = None,
        entity: Optional[str] = None,
        languagecode: Optional[int] = None,
        referenceid: Optional[str] = None,
        userid: Optional[int] = None
    ) -> Dict[str, Any]:
        """
        Fetch Transactions By Date
        
        Generated from: GET /financialAccounting/account/transactions/{accountReference}
        Source: swagger_2_0
        Operation ID: CBPETGettransactionsByDateUsingGET
        
        
        Authentication: Not required
        
        Parameters:
        - FromDate: string
          Enter the transaction start date(format : YYYYMMDD)
        - ToDate: string
          Enter the transaction end date(format : YYYYMMDD)
        - accountReference: string (required)
          Enter the Account Reference
        - pageNum: integer
          pageNum
        - pageSize: integer
          pageSize
        - transactionId: string
          Enter the transaction ID
        
        
        
        Headers:
        - Accesstoken: string
          Authorization token for identification of the caller
        - ChannelType: integer
          Channel identifier from where the TXN has originated (Internet, Mobile, ATM, Branch Channel )
        - Co-Relationid: integer
          Unique ID for the service invoked, will be set by the TXN system
        - InitiatingSystem: string
          Indicating the initiated system
        - ServiceMode: integer
          Used for branch channel to indicate the type of customer
        - UUIDSeqNo: integer
          UUID Sequence Number
        - entity: string
          entity
        - languageCode: integer
          languageCode
        - referenceId: string
          Place holder for Token based authentication
        - userId: integer
          userId
        
        
        """
        
        
        # Prepare query parameters
        params = {}
        if fromdate is not None:
            params["FromDate"] = fromdate
            
        if todate is not None:
            params["ToDate"] = todate
            
        if pagenum is not None:
            params["pageNum"] = pagenum
            
        if pagesize is not None:
            params["pageSize"] = pagesize
            
        if transactionid is not None:
            params["transactionId"] = transactionid
            
        
        
        # Replace path parameters in URL
        path = "/financialAccounting/account/transactions/{accountReference}"
        if accountreference is not None:
            path = path.replace("{accountReference}", str(accountreference))
        
        
        # Prepare headers
        headers = {}
        if accesstoken is not None:
            headers["Accesstoken"] = str(accesstoken)
        if channeltype is not None:
            headers["ChannelType"] = str(channeltype)
        if co_relationid is not None:
            headers["Co-Relationid"] = str(co_relationid)
        if initiatingsystem is not None:
            headers["InitiatingSystem"] = str(initiatingsystem)
        if servicemode is not None:
            headers["ServiceMode"] = str(servicemode)
        if uuidseqno is not None:
            headers["UUIDSeqNo"] = str(uuidseqno)
        if entity is not None:
            headers["entity"] = str(entity)
        if languagecode is not None:
            headers["languageCode"] = str(languagecode)
        if referenceid is not None:
            headers["referenceId"] = str(referenceid)
        if userid is not None:
            headers["userId"] = str(userid)
        
        
        return await make_api_request(
            "GET", 
            path, 
            
            params=params if params else None, 
            headers=headers if headers else None
        )
    
    
    
    @mcp.tool()
    async def cbcbt5548_bsns_crspndc_cash_dpst_postusing_post(
        request_body:Dict[str, Any] ,  # accountBookingFromBsnsCrspndsAcntToCustomerAccountRequest,
        accesstoken: Optional[str] = None,
        channeltype: Optional[int] = None,
        co_relationid: Optional[int] = None,
        entity: Optional[str] = None,
        initiatingsystem: Optional[str] = None,
        languagecode: Optional[int] = None,
        referenceid: Optional[str] = None,
        servicemode: Optional[int] = None,
        userid: Optional[int] = None,
        uuidseqno: Optional[int] = None
    ) -> Dict[str, Any]:
        """
        Api to desposit the cash into the customer account from business correspondence account
        
        Generated from: POST /financialAccounting/accountBookingToCustomerAccount
        Source: swagger_2_0
        Operation ID: CBCBT5548BsnsCrspndcCashDpst_POSTUsingPOST
        
        
        Authentication: Not required
        
        Parameters:
        - request_body: any (required)
          input
        
        
        
        Headers:
        - Accesstoken: string
          Authorization Token to validation the caller
        - channelType: integer
          Channel identifier from where the TXN has originated (Internet, Mobile, ATM, Branch Channel )
        - co-Relationid: integer
          Unique ID for the service invoked, will be set by the TXN system
        - entity: string
          entity
        - initiatingSystem: string
          Indicating the initiated system
        - languageCode: integer
          languageCode
        - referenceId: string
          Place holder for Token based authentication
        - serviceMode: integer
          Used for branch channel to indicate the type of customer
        - userId: integer
          userId
        - uuidSeqNo: integer
          UUID Sequence Number
        
        
        """
        
        
        # Prepare request data
        
        # Single body parameter - send directly
        data = request_body if request_body is not None else {}
        
        
        
        # Prepare query parameters
        params = {}
        
        
        # Replace path parameters in URL
        path = "/financialAccounting/accountBookingToCustomerAccount"
        
        
        # Prepare headers
        headers = {}
        if accesstoken is not None:
            headers["Accesstoken"] = str(accesstoken)
        if channeltype is not None:
            headers["channelType"] = str(channeltype)
        if co_relationid is not None:
            headers["co-Relationid"] = str(co_relationid)
        if entity is not None:
            headers["entity"] = str(entity)
        if initiatingsystem is not None:
            headers["initiatingSystem"] = str(initiatingsystem)
        if languagecode is not None:
            headers["languageCode"] = str(languagecode)
        if referenceid is not None:
            headers["referenceId"] = str(referenceid)
        if servicemode is not None:
            headers["serviceMode"] = str(servicemode)
        if userid is not None:
            headers["userId"] = str(userid)
        if uuidseqno is not None:
            headers["uuidSeqNo"] = str(uuidseqno)
        
        
        return await make_api_request(
            "POST", 
            path, 
            data=data, 
            params=params if params else None, 
            headers=headers if headers else None
        )
    
    
    
    @mcp.tool()
    async def faet2021_fetch_acnt_bal_api_postusing_get(
        accountreference: str,
        accountcurrency: Optional[str] = None,
        balancetype: Optional[int] = None,
        accesstoken: Optional[str] = None,
        channeltype: Optional[int] = None,
        co_relationid: Optional[int] = None,
        initiatingsystem: Optional[str] = None,
        servicemode: Optional[int] = None,
        uuidseqno: Optional[int] = None,
        entity: Optional[str] = None,
        referenceid: Optional[str] = None,
        userid: Optional[int] = None
    ) -> Dict[str, Any]:
        """
        Fetch account balance
        
        Generated from: GET /financialAccounting/accountbalance
        Source: swagger_2_0
        Operation ID: FAET2021FetchAcntBalAPI_POSTUsingGET
        
        
        Authentication: Not required
        
        Parameters:
        - AccountCurrency: string
          Account Currency of the Account.
        - AccountReference: string (required)
          Account Number of the Account. It can be IBAN or BBAN for Cash Account and Reference Account Number for Internal Account
        - BalanceType: integer
          Balance Type like 1 - Book Dated Balance ( Sum of Movements Amount ), 13 - Current Balance ( Sum of Movements Amount - Active Cash Blocks or Fund Hold ), 4 - Available Balance ( Sum of Movements Amount and Overdraft Limit Amount - Active Cash Blocks or Fund Hold) . Default will be Available Balance when No value for Balance Type is received in the Input(Domain Name: d_BalType)
        
        
        
        Headers:
        - Accesstoken: string
          Authorization token for identification of the caller
        - ChannelType: integer
          Channel from where the transaction has originated (Internet, Mobile, ATM, Branch Channel )
        - Co-Relationid: integer
          Unique ID for the service invoked, will be set by the TXN system
        - InitiatingSystem: string
          Indicating the initiated system
        - ServiceMode: integer
          Used for branch channel to indicate the type of customer
        - UUIDSeqNo: integer
          UUID Sequence Number
        - entity: string
          entity
        - referenceId: string
          Place holder for Token based authentication
        - userId: integer
          userId
        
        
        """
        
        
        # Prepare query parameters
        params = {}
        if accountcurrency is not None:
            params["AccountCurrency"] = accountcurrency
            
        if accountreference is not None:
            params["AccountReference"] = accountreference
            
        if balancetype is not None:
            params["BalanceType"] = balancetype
            
        
        
        # Replace path parameters in URL
        path = "/financialAccounting/accountbalance"
        
        
        # Prepare headers
        headers = {}
        if accesstoken is not None:
            headers["Accesstoken"] = str(accesstoken)
        if channeltype is not None:
            headers["ChannelType"] = str(channeltype)
        if co_relationid is not None:
            headers["Co-Relationid"] = str(co_relationid)
        if initiatingsystem is not None:
            headers["InitiatingSystem"] = str(initiatingsystem)
        if servicemode is not None:
            headers["ServiceMode"] = str(servicemode)
        if uuidseqno is not None:
            headers["UUIDSeqNo"] = str(uuidseqno)
        if entity is not None:
            headers["entity"] = str(entity)
        if referenceid is not None:
            headers["referenceId"] = str(referenceid)
        if userid is not None:
            headers["userId"] = str(userid)
        
        
        return await make_api_request(
            "GET", 
            path, 
            
            params=params if params else None, 
            headers=headers if headers else None
        )
    
    
    
    @mcp.tool()
    async def faet6008_get_accounting_book_qbe_postusing_get(
        accountingbookref: Optional[str] = None,
        branch: Optional[str] = None,
        pagenum: Optional[int] = None,
        pagesize: Optional[int] = None,
        accesstoken: Optional[str] = None,
        servicemode_: Optional[int] = None,
        entity: Optional[str] = None,
        languagecode: Optional[int] = None,
        userid: Optional[int] = None
    ) -> Dict[str, Any]:
        """
        Fetch Accounting book list
        
        Generated from: GET /financialAccounting/accountingBookList
        Source: swagger_2_0
        Operation ID: FAET6008GetAccountingBookQBE_POSTUsingGET
        
        
        Authentication: Not required
        
        Parameters:
        - accountingBookRef: string
          Accounting Book ref
        - branch: string
          branch
        - pageNum: integer
          pageNum
        - pageSize: integer
          pageSize
        
        
        
        Headers:
        - Accesstoken: string
          Authorization token for identification of the caller
        - ServiceMode : integer
          Used for branch channel to indicate the type of customer
        - entity: string
          entity
        - languageCode: integer
          languageCode
        - userId: integer
          userId
        
        
        """
        
        
        # Prepare query parameters
        params = {}
        if accountingbookref is not None:
            params["accountingBookRef"] = accountingbookref
            
        if branch is not None:
            params["branch"] = branch
            
        if pagenum is not None:
            params["pageNum"] = pagenum
            
        if pagesize is not None:
            params["pageSize"] = pagesize
            
        
        
        # Replace path parameters in URL
        path = "/financialAccounting/accountingBookList"
        
        
        # Prepare headers
        headers = {}
        if accesstoken is not None:
            headers["Accesstoken"] = str(accesstoken)
        if servicemode_ is not None:
            headers["ServiceMode "] = str(servicemode_)
        if entity is not None:
            headers["entity"] = str(entity)
        if languagecode is not None:
            headers["languageCode"] = str(languagecode)
        if userid is not None:
            headers["userId"] = str(userid)
        
        
        return await make_api_request(
            "GET", 
            path, 
            
            params=params if params else None, 
            headers=headers if headers else None
        )
    
    
    
    @mcp.tool()
    async def faet0301_get_bspllst_postusing_get(
        bpcategory: Optional[int] = None,
        bsplcode: Optional[str] = None,
        businesspartnercode: Optional[int] = None,
        counterentity: Optional[str] = None,
        faclassification: Optional[int] = None,
        instrumentid: Optional[int] = None,
        instrumenttype: Optional[int] = None,
        portfoliousage: Optional[int] = None,
        pagenum: Optional[int] = None,
        pagesize: Optional[int] = None,
        accesstoken: Optional[str] = None,
        channeltype: Optional[int] = None,
        co_relationid: Optional[int] = None,
        initiatingsystem: Optional[str] = None,
        servicemode: Optional[int] = None,
        uuidseqno: Optional[int] = None,
        entity: Optional[str] = None,
        languagecode: Optional[int] = None,
        referenceid: Optional[str] = None,
        requesthash: Optional[str] = None,
        userid: Optional[int] = None
    ) -> Dict[str, Any]:
        """
        Fetch BSPL List
        
        Generated from: GET /financialAccounting/bsplList
        Source: swagger_2_0
        Operation ID: FAET0301GetBSPLLst_POSTUsingGET
        
        
        Authentication: Not required
        
        Parameters:
        - BPCategory: integer
          BP Category
        - BSPLCode: string
          BSPL Code
        - BusinessPartnerCode: integer
          Business Partner Code
        - CounterEntity: string
          Counter Entity
        - FAClassification: integer
          FA Classification
        - InstrumentId: integer
          Instrument Id
        - InstrumentType: integer
          Instrument Type
        - PortfolioUsage: integer
          Portfolio Usage
        - pageNum: integer
          pageNum
        - pageSize: integer
          pageSize
        
        
        
        Headers:
        - Accesstoken: string
          Authorization Token to validation the caller
        - ChannelType: integer
          Channel identifier from where the TXN has originated (Internet, Mobile, ATM, Branch Channel )
        - Co-Relationid: integer
          Unique ID for the service invoked, will be set by the TXN system
        - InitiatingSystem: string
          Indicating the initiated system
        - ServiceMode: integer
          Used for branch channel to indicate the type of customer
        - UUIDSeqNo: integer
          UUID Sequence Number
        - entity: string
          entity
        - languageCode: integer
          languageCode
        - referenceId: string
          Place holder forToken based authetication
        - requesthash: string
          Request payload for hash validation
        - userId: integer
          userId
        
        
        """
        
        
        # Prepare query parameters
        params = {}
        if bpcategory is not None:
            params["BPCategory"] = bpcategory
            
        if bsplcode is not None:
            params["BSPLCode"] = bsplcode
            
        if businesspartnercode is not None:
            params["BusinessPartnerCode"] = businesspartnercode
            
        if counterentity is not None:
            params["CounterEntity"] = counterentity
            
        if faclassification is not None:
            params["FAClassification"] = faclassification
            
        if instrumentid is not None:
            params["InstrumentId"] = instrumentid
            
        if instrumenttype is not None:
            params["InstrumentType"] = instrumenttype
            
        if portfoliousage is not None:
            params["PortfolioUsage"] = portfoliousage
            
        if pagenum is not None:
            params["pageNum"] = pagenum
            
        if pagesize is not None:
            params["pageSize"] = pagesize
            
        
        
        # Replace path parameters in URL
        path = "/financialAccounting/bsplList"
        
        
        # Prepare headers
        headers = {}
        if accesstoken is not None:
            headers["Accesstoken"] = str(accesstoken)
        if channeltype is not None:
            headers["ChannelType"] = str(channeltype)
        if co_relationid is not None:
            headers["Co-Relationid"] = str(co_relationid)
        if initiatingsystem is not None:
            headers["InitiatingSystem"] = str(initiatingsystem)
        if servicemode is not None:
            headers["ServiceMode"] = str(servicemode)
        if uuidseqno is not None:
            headers["UUIDSeqNo"] = str(uuidseqno)
        if entity is not None:
            headers["entity"] = str(entity)
        if languagecode is not None:
            headers["languageCode"] = str(languagecode)
        if referenceid is not None:
            headers["referenceId"] = str(referenceid)
        if requesthash is not None:
            headers["requesthash"] = str(requesthash)
        if userid is not None:
            headers["userId"] = str(userid)
        
        
        return await make_api_request(
            "GET", 
            path, 
            
            params=params if params else None, 
            headers=headers if headers else None
        )
    
    
    
    @mcp.tool()
    async def intbt8001_sngl_leg_bkng_postusing_post(
        request_body:Dict[str, Any] ,  # singleLegBookingResource,
        accesstoken: Optional[str] = None,
        channeltype: Optional[int] = None,
        co_relationid: Optional[int] = None,
        initiatingsystem: Optional[str] = None,
        servicemode: Optional[int] = None,
        uuidseqno: Optional[int] = None,
        entity: Optional[str] = None,
        languagecode: Optional[int] = None,
        referenceid: Optional[str] = None,
        requesthash: Optional[str] = None,
        userid: Optional[int] = None
    ) -> Dict[str, Any]:
        """
        This service is used to Create Single leg Booking
        
        Generated from: POST /financialAccounting/singleLeg/createBooking
        Source: swagger_2_0
        Operation ID: INTBT8001SnglLegBkng_POSTUsingPOST
        
        
        Authentication: Not required
        
        Parameters:
        - request_body: any (required)
          input
        
        
        
        Headers:
        - Accesstoken: string
          Authorization token for identification of the caller
        - ChannelType: integer
          Channel from where the transaction has originated (Internet, Mobile, ATM, Branch Channel )
        - Co-Relationid: integer
          Unique ID for the service invoked, will be set by the TXN system
        - InitiatingSystem: string
          Indicating the initiated system
        - ServiceMode: integer
          Used for branch channel to indicate the type of customer
        - UUIDSeqNo: integer
          UUID Sequence Number
        - entity: string
          entity
        - languageCode: integer
          languageCode
        - referenceId: string
          Place holder for Token based authentication
        - requesthash: string
          Request payload for hash validation
        - userId: integer
          userId
        
        
        """
        
        
        # Prepare request data
        
        # Single body parameter - send directly
        data = request_body if request_body is not None else {}
        
        
        
        # Prepare query parameters
        params = {}
        
        
        # Replace path parameters in URL
        path = "/financialAccounting/singleLeg/createBooking"
        
        
        # Prepare headers
        headers = {}
        if accesstoken is not None:
            headers["Accesstoken"] = str(accesstoken)
        if channeltype is not None:
            headers["ChannelType"] = str(channeltype)
        if co_relationid is not None:
            headers["Co-Relationid"] = str(co_relationid)
        if initiatingsystem is not None:
            headers["InitiatingSystem"] = str(initiatingsystem)
        if servicemode is not None:
            headers["ServiceMode"] = str(servicemode)
        if uuidseqno is not None:
            headers["UUIDSeqNo"] = str(uuidseqno)
        if entity is not None:
            headers["entity"] = str(entity)
        if languagecode is not None:
            headers["languageCode"] = str(languagecode)
        if referenceid is not None:
            headers["referenceId"] = str(referenceid)
        if requesthash is not None:
            headers["requesthash"] = str(requesthash)
        if userid is not None:
            headers["userId"] = str(userid)
        
        
        return await make_api_request(
            "POST", 
            path, 
            data=data, 
            params=params if params else None, 
            headers=headers if headers else None
        )
    
    
    
    @mcp.tool()
    async def intbt0118_crt_csh_blck_intf_postusing_post(
        request_body:Dict[str, Any] ,  # RiskCheckRequest,
        accesstoken: Optional[str] = None,
        channeltype: Optional[int] = None,
        co_relationid: Optional[int] = None,
        initiatingsystem: Optional[str] = None,
        servicemode: Optional[int] = None,
        uuidseqno: Optional[int] = None,
        entity: Optional[str] = None,
        languagecode: Optional[int] = None,
        referenceid: Optional[str] = None,
        userid: Optional[int] = None
    ) -> Dict[str, Any]:
        """
        Create CashBlock
        
        Generated from: POST /interfaceServices/cashBlock/create
        Source: swagger_2_0
        Operation ID: INTBT0118CrtCshBlckIntf_POSTUsingPOST
        
        
        Authentication: Not required
        
        Parameters:
        - request_body: any (required)
          input
        
        
        
        Headers:
        - Accesstoken: string
          Authorization token for identification of the caller
        - ChannelType: integer
          Channel identifier from where the TXN has originated (Internet, Mobile, ATM, Branch Channel )
        - Co-Relationid: integer
          Unique ID for the service invoked, will be set by the TXN system
        - InitiatingSystem: string
          Indicating the initiated system
        - ServiceMode: integer
          Used for branch channel to indicate the type of customer
        - UUIDSeqNo: integer
          UUID Sequence Number
        - entity: string
          entity
        - languageCode: integer
          languageCode
        - referenceId: string
          Place holder for Token based authentication
        - userId: integer
          userId
        
        
        """
        
        
        # Prepare request data
        
        # Single body parameter - send directly
        data = request_body if request_body is not None else {}
        
        
        
        # Prepare query parameters
        params = {}
        
        
        # Replace path parameters in URL
        path = "/interfaceServices/cashBlock/create"
        
        
        # Prepare headers
        headers = {}
        if accesstoken is not None:
            headers["Accesstoken"] = str(accesstoken)
        if channeltype is not None:
            headers["ChannelType"] = str(channeltype)
        if co_relationid is not None:
            headers["Co-Relationid"] = str(co_relationid)
        if initiatingsystem is not None:
            headers["InitiatingSystem"] = str(initiatingsystem)
        if servicemode is not None:
            headers["ServiceMode"] = str(servicemode)
        if uuidseqno is not None:
            headers["UUIDSeqNo"] = str(uuidseqno)
        if entity is not None:
            headers["entity"] = str(entity)
        if languagecode is not None:
            headers["languageCode"] = str(languagecode)
        if referenceid is not None:
            headers["referenceId"] = str(referenceid)
        if userid is not None:
            headers["userId"] = str(userid)
        
        
        return await make_api_request(
            "POST", 
            path, 
            data=data, 
            params=params if params else None, 
            headers=headers if headers else None
        )
    
    
    
    @mcp.tool()
    async def inttc0121_exp_blck_using_post(
        request_body:Dict[str, Any] ,  # expireBlockResource,
        accesstoken: Optional[str] = None,
        channeltype: Optional[int] = None,
        co_relationid: Optional[int] = None,
        initiatingsystem: Optional[str] = None,
        servicemode: Optional[int] = None,
        uuidseqno: Optional[int] = None,
        entity: Optional[str] = None,
        languagecode: Optional[int] = None,
        referenceid: Optional[str] = None,
        requesthash: Optional[str] = None,
        userid: Optional[int] = None
    ) -> Dict[str, Any]:
        """
        INTTC0121ExpBlck
        
        Generated from: POST /interfaceServices/expireBlock
        Source: swagger_2_0
        Operation ID: INTTC0121ExpBlckUsingPOST
        
        
        Authentication: Not required
        
        Parameters:
        - request_body: any (required)
          input
        
        
        
        Headers:
        - Accesstoken: string
          Authorization token for identification of the caller
        - ChannelType: integer
          Channel identifier from where the TXN has originated (Internet, Mobile, ATM, Branch Channel )
        - Co-Relationid: integer
          Unique ID for the service invoked, will be set by the TXN system
        - InitiatingSystem: string
          Indicating the initiated system
        - ServiceMode: integer
          Used for branch channel to indicate the type of customer
        - UUIDSeqNo: integer
          UUID Sequence Number
        - entity: string
          entity
        - languageCode: integer
          languageCode
        - referenceId: string
          Place holder for Token based authentication
        - requesthash: string
          Request payload for hash validation
        - userId: integer
          userId
        
        
        """
        
        
        # Prepare request data
        
        # Single body parameter - send directly
        data = request_body if request_body is not None else {}
        
        
        
        # Prepare query parameters
        params = {}
        
        
        # Replace path parameters in URL
        path = "/interfaceServices/expireBlock"
        
        
        # Prepare headers
        headers = {}
        if accesstoken is not None:
            headers["Accesstoken"] = str(accesstoken)
        if channeltype is not None:
            headers["ChannelType"] = str(channeltype)
        if co_relationid is not None:
            headers["Co-Relationid"] = str(co_relationid)
        if initiatingsystem is not None:
            headers["InitiatingSystem"] = str(initiatingsystem)
        if servicemode is not None:
            headers["ServiceMode"] = str(servicemode)
        if uuidseqno is not None:
            headers["UUIDSeqNo"] = str(uuidseqno)
        if entity is not None:
            headers["entity"] = str(entity)
        if languagecode is not None:
            headers["languageCode"] = str(languagecode)
        if referenceid is not None:
            headers["referenceId"] = str(referenceid)
        if requesthash is not None:
            headers["requesthash"] = str(requesthash)
        if userid is not None:
            headers["userId"] = str(userid)
        
        
        return await make_api_request(
            "POST", 
            path, 
            data=data, 
            params=params if params else None, 
            headers=headers if headers else None
        )
    
    
    
    @mcp.tool()
    async def inttc0700_validate_peacnt_postusing_post(
        request_body:Dict[str, Any] ,  # CORE_INTF_INTTC0700ValidatePEAcnt_Resource,
        accesstoken: Optional[str] = None,
        channeltype: Optional[int] = None,
        co_relationid: Optional[int] = None,
        initiatingsystem: Optional[str] = None,
        servicemode: Optional[int] = None,
        uuidseqno: Optional[int] = None,
        entity: Optional[str] = None,
        languagecode: Optional[int] = None,
        referenceid: Optional[str] = None,
        requesthash: Optional[str] = None,
        userid: Optional[int] = None
    ) -> Dict[str, Any]:
        """
        INTTC0700ValidatePEAcnt
        
        Generated from: POST /interfaceServices/inttc0700validatepeacnt
        Source: swagger_2_0
        Operation ID: INTTC0700ValidatePEAcnt_POSTUsingPOST
        
        
        Authentication: Not required
        
        Parameters:
        - request_body: any (required)
          input
        
        
        
        Headers:
        - Accesstoken: string
          Authorization Token to validation the caller
        - ChannelType: integer
          Channel identifier from where the TXN has originated (Internet, Mobile, ATM, Branch Channel )
        - Co-Relationid: integer
          Unique ID for the service invoked, will be set by the TXN system
        - InitiatingSystem: string
          Indicating the initiated system
        - ServiceMode: integer
          Used for branch channel to indicate the type of customer
        - UUIDSeqNo: integer
          UUID Sequence Number
        - entity: string
          entity
        - languageCode: integer
          languageCode
        - referenceId: string
          Place holder for Token based authentication
        - requesthash: string
          Request payload for hash validation
        - userId: integer
          userId
        
        
        """
        
        
        # Prepare request data
        
        # Single body parameter - send directly
        data = request_body if request_body is not None else {}
        
        
        
        # Prepare query parameters
        params = {}
        
        
        # Replace path parameters in URL
        path = "/interfaceServices/inttc0700validatepeacnt"
        
        
        # Prepare headers
        headers = {}
        if accesstoken is not None:
            headers["Accesstoken"] = str(accesstoken)
        if channeltype is not None:
            headers["ChannelType"] = str(channeltype)
        if co_relationid is not None:
            headers["Co-Relationid"] = str(co_relationid)
        if initiatingsystem is not None:
            headers["InitiatingSystem"] = str(initiatingsystem)
        if servicemode is not None:
            headers["ServiceMode"] = str(servicemode)
        if uuidseqno is not None:
            headers["UUIDSeqNo"] = str(uuidseqno)
        if entity is not None:
            headers["entity"] = str(entity)
        if languagecode is not None:
            headers["languageCode"] = str(languagecode)
        if referenceid is not None:
            headers["referenceId"] = str(referenceid)
        if requesthash is not None:
            headers["requesthash"] = str(requesthash)
        if userid is not None:
            headers["userId"] = str(userid)
        
        
        return await make_api_request(
            "POST", 
            path, 
            data=data, 
            params=params if params else None, 
            headers=headers if headers else None
        )
    
    
    
    @mcp.tool()
    async def amet0329_get_blnc_dtls_using_get(
        accountreference: str,
        pagenum: Optional[int] = None,
        pagesize: Optional[int] = None,
        accesstoken: Optional[str] = None,
        channeltype: Optional[int] = None,
        co_relationid: Optional[int] = None,
        initiatingsystem: Optional[str] = None,
        servicemode: Optional[int] = None,
        uuidseqno: Optional[int] = None,
        entity: Optional[str] = None,
        languagecode: Optional[int] = None,
        referenceid: Optional[str] = None,
        userid: Optional[int] = None
    ) -> Dict[str, Any]:
        """
        Provides Account Balance and Pool Interest
        
        Generated from: GET /liquidityManagement/account/interest/{accountReference}
        Source: swagger_2_0
        Operation ID: AMET0329GetBlncDtlsUsingGET
        
        
        Authentication: Not required
        
        Parameters:
        - accountReference: string (required)
          Account Reference
        - pageNum: integer
          pageNum
        - pageSize: integer
          pageSize
        
        
        
        Headers:
        - Accesstoken: string
          Authorization token for identification of the caller
        - ChannelType: integer
          Channel identifier from where the transaction has originated (Internet, Mobile, ATM, Branch Channel )
        - Co-Relationid: integer
          Unique ID for the service invoked, will be set by the transaction system
        - InitiatingSystem: string
          Indicating the initiated system
        - ServiceMode: integer
          Used for branch channel to indicate the type of customer
        - UUIDSeqNo: integer
          UUID Sequence Number
        - entity: string
          entity
        - languageCode: integer
          languageCode
        - referenceId: string
          Place holder for Token based authentication
        - userId: integer
          userId
        
        
        """
        
        
        # Prepare query parameters
        params = {}
        if pagenum is not None:
            params["pageNum"] = pagenum
            
        if pagesize is not None:
            params["pageSize"] = pagesize
            
        
        
        # Replace path parameters in URL
        path = "/liquidityManagement/account/interest/{accountReference}"
        if accountreference is not None:
            path = path.replace("{accountReference}", str(accountreference))
        
        
        # Prepare headers
        headers = {}
        if accesstoken is not None:
            headers["Accesstoken"] = str(accesstoken)
        if channeltype is not None:
            headers["ChannelType"] = str(channeltype)
        if co_relationid is not None:
            headers["Co-Relationid"] = str(co_relationid)
        if initiatingsystem is not None:
            headers["InitiatingSystem"] = str(initiatingsystem)
        if servicemode is not None:
            headers["ServiceMode"] = str(servicemode)
        if uuidseqno is not None:
            headers["UUIDSeqNo"] = str(uuidseqno)
        if entity is not None:
            headers["entity"] = str(entity)
        if languagecode is not None:
            headers["languageCode"] = str(languagecode)
        if referenceid is not None:
            headers["referenceId"] = str(referenceid)
        if userid is not None:
            headers["userId"] = str(userid)
        
        
        return await make_api_request(
            "GET", 
            path, 
            
            params=params if params else None, 
            headers=headers if headers else None
        )
    
    
    
    @mcp.tool()
    async def lmet0101_fetch_conc_structure_postusing_get(
        masteraccount: str,
        concentrationid: str,
        concentrationreference: int,
        # masteraccount: str,
        pagenum: Optional[int] = None,
        pagesize: Optional[int] = None,
        accesstoken: Optional[str] = None,
        channeltype: Optional[int] = None,
        co_relationid: Optional[int] = None,
        initiatingsystem: Optional[str] = None,
        servicemode: Optional[int] = None,
        uuidseqno: Optional[int] = None,
        entity: Optional[str] = None,
        languagecode: Optional[int] = None,
        referenceid: Optional[str] = None,
        userid: Optional[int] = None
    ) -> Dict[str, Any]:
        """
        Fetch Cash Concentration Details
        
        Generated from: GET /liquidityManagement/cashConcentration/{concentrationId}/account/{masterAccount}
        Source: swagger_2_0
        Operation ID: LMET0101FetchConcStructure_POSTUsingGET
        
        
        Authentication: Not required
        
        Parameters:
        - concentrationReference: integer (required)
          Enter the Cash Concentration Reference
        - masterAccount: string (required)
          Enter the Master Account Reference
        - pageNum: integer
          pageNum
        - pageSize: integer
          pageSize
        - masterAccount: string (required)
          Path parameter masterAccount
        - concentrationId: string (required)
          Path parameter concentrationId
        
        
        
        Headers:
        - Accesstoken: string
          Authorization token for identification of the caller
        - ChannelType: integer
          Channel identifier from where the transaction has originated (Internet, Mobile, ATM, Branch Channel )
        - Co-Relationid: integer
          Unique ID for the service invoked, will be set by the transaction system
        - InitiatingSystem: string
          Indicating the initiated system
        - ServiceMode: integer
          Used for branch channel to indicate the type of customer
        - UUIDSeqNo: integer
          UUID Sequence Number
        - entity: string
          entity
        - languageCode: integer
          languageCode
        - referenceId: string
          Place holder for Token based authentication
        - userId: integer
          userId
        
        
        """
        
        
        # Prepare query parameters
        params = {}
        if concentrationreference is not None:
            params["concentrationReference"] = concentrationreference
            
        if masteraccount is not None:
            params["masterAccount"] = masteraccount
            
        if pagenum is not None:
            params["pageNum"] = pagenum
            
        if pagesize is not None:
            params["pageSize"] = pagesize
            
        
        
        # Replace path parameters in URL
        path = "/liquidityManagement/cashConcentration/{concentrationId}/account/{masterAccount}"
        if masteraccount is not None:
            path = path.replace("{masterAccount}", str(masteraccount))
        if concentrationid is not None:
            path = path.replace("{concentrationId}", str(concentrationid))
        
        
        # Prepare headers
        headers = {}
        if accesstoken is not None:
            headers["Accesstoken"] = str(accesstoken)
        if channeltype is not None:
            headers["ChannelType"] = str(channeltype)
        if co_relationid is not None:
            headers["Co-Relationid"] = str(co_relationid)
        if initiatingsystem is not None:
            headers["InitiatingSystem"] = str(initiatingsystem)
        if servicemode is not None:
            headers["ServiceMode"] = str(servicemode)
        if uuidseqno is not None:
            headers["UUIDSeqNo"] = str(uuidseqno)
        if entity is not None:
            headers["entity"] = str(entity)
        if languagecode is not None:
            headers["languageCode"] = str(languagecode)
        if referenceid is not None:
            headers["referenceId"] = str(referenceid)
        if userid is not None:
            headers["userId"] = str(userid)
        
        
        return await make_api_request(
            "GET", 
            path, 
            
            params=params if params else None, 
            headers=headers if headers else None
        )
    
    
    
    @mcp.tool()
    async def lmet4303_fetch_cash_concntrtn_postusing_get(
        customerreference: str,
        pagenum: Optional[int] = None,
        pagesize: Optional[int] = None,
        accesstoken: Optional[str] = None,
        channeltype: Optional[int] = None,
        co_relationid: Optional[int] = None,
        initiatingsystem: Optional[str] = None,
        servicemode: Optional[int] = None,
        uuidseqno: Optional[int] = None,
        entity: Optional[str] = None,
        languagecode: Optional[int] = None,
        referenceid: Optional[str] = None,
        userid: Optional[int] = None
    ) -> Dict[str, Any]:
        """
        Fetch Cash Concentrations List
        
        Generated from: GET /liquidityManagement/cashConcentrationsList
        Source: swagger_2_0
        Operation ID: LMET4303FetchCashConcntrtn_POSTUsingGET
        
        
        Authentication: Not required
        
        Parameters:
        - CustomerReference: string (required)
          Enter the Customer Reference
        - pageNum: integer
          pageNum
        - pageSize: integer
          pageSize
        
        
        
        Headers:
        - Accesstoken: string
          Authorization token for identification of the caller
        - ChannelType: integer
          Channel identifier from where the transaction has originated (Internet, Mobile, ATM, Branch Channel )
        - Co-Relationid: integer
          Unique ID for the service invoked, will be set by the transaction system
        - InitiatingSystem: string
          Indicating the initiated system
        - ServiceMode: integer
          Used for branch channel to indicate the type of customer
        - UUIDSeqNo: integer
          UUID Sequence Number
        - entity: string
          entity
        - languageCode: integer
          languageCode
        - referenceId: string
          Place holder for Token based authentication
        - userId: integer
          userId
        
        
        """
        
        
        # Prepare query parameters
        params = {}
        if customerreference is not None:
            params["CustomerReference"] = customerreference
            
        if pagenum is not None:
            params["pageNum"] = pagenum
            
        if pagesize is not None:
            params["pageSize"] = pagesize
            
        
        
        # Replace path parameters in URL
        path = "/liquidityManagement/cashConcentrationsList"
        
        
        # Prepare headers
        headers = {}
        if accesstoken is not None:
            headers["Accesstoken"] = str(accesstoken)
        if channeltype is not None:
            headers["ChannelType"] = str(channeltype)
        if co_relationid is not None:
            headers["Co-Relationid"] = str(co_relationid)
        if initiatingsystem is not None:
            headers["InitiatingSystem"] = str(initiatingsystem)
        if servicemode is not None:
            headers["ServiceMode"] = str(servicemode)
        if uuidseqno is not None:
            headers["UUIDSeqNo"] = str(uuidseqno)
        if entity is not None:
            headers["entity"] = str(entity)
        if languagecode is not None:
            headers["languageCode"] = str(languagecode)
        if referenceid is not None:
            headers["referenceId"] = str(referenceid)
        if userid is not None:
            headers["userId"] = str(userid)
        
        
        return await make_api_request(
            "GET", 
            path, 
            
            params=params if params else None, 
            headers=headers if headers else None
        )
    
    
    
    @mcp.tool()
    async def lmet4305_fetch_concntrtn_txn_hist_postusing_get(
        concentrationid: str,
        nodeid: str,
        pagenum: Optional[int] = None,
        pagesize: Optional[int] = None,
        accesstoken: Optional[str] = None,
        channeltype: Optional[int] = None,
        co_relationid: Optional[int] = None,
        initiatingsystem: Optional[str] = None,
        servicemode: Optional[int] = None,
        uuidseqno: Optional[int] = None,
        entity: Optional[str] = None,
        languagecode: Optional[int] = None,
        referenceid: Optional[str] = None,
        userid: Optional[int] = None
    ) -> Dict[str, Any]:
        """
        Fetch Cash Concentrations transaction history
        
        Generated from: GET /liquidityManagement/movementDetails/{concentrationId}/{nodeId}
        Source: swagger_2_0
        Operation ID: LMET4305FetchConcntrtnTxnHist_POSTUsingGET
        
        
        Authentication: Not required
        
        Parameters:
        - concentrationId: string (required)
          Enter the Concentration ID
        - nodeId: string (required)
          Enter the Node ID
        - pageNum: integer
          pageNum
        - pageSize: integer
          pageSize
        
        
        
        Headers:
        - Accesstoken: string
          Authorization token for identification of the caller
        - ChannelType: integer
          Channel identifier from where the transaction has originated (Internet, Mobile, ATM, Branch Channel )
        - Co-Relationid: integer
          Unique ID for the service invoked, will be set by the transaction system
        - InitiatingSystem: string
          Indicating the initiated system
        - ServiceMode: integer
          Used for branch channel to indicate the type of customer
        - UUIDSeqNo: integer
          UUID Sequence Number
        - entity: string
          entity
        - languageCode: integer
          languageCode
        - referenceId: string
          Place holder for Token based authentication
        - userId: integer
          userId
        
        
        """
        
        
        # Prepare query parameters
        params = {}
        if pagenum is not None:
            params["pageNum"] = pagenum
            
        if pagesize is not None:
            params["pageSize"] = pagesize
            
        
        
        # Replace path parameters in URL
        path = "/liquidityManagement/movementDetails/{concentrationId}/{nodeId}"
        if concentrationid is not None:
            path = path.replace("{concentrationId}", str(concentrationid))
        if nodeid is not None:
            path = path.replace("{nodeId}", str(nodeid))
        
        
        # Prepare headers
        headers = {}
        if accesstoken is not None:
            headers["Accesstoken"] = str(accesstoken)
        if channeltype is not None:
            headers["ChannelType"] = str(channeltype)
        if co_relationid is not None:
            headers["Co-Relationid"] = str(co_relationid)
        if initiatingsystem is not None:
            headers["InitiatingSystem"] = str(initiatingsystem)
        if servicemode is not None:
            headers["ServiceMode"] = str(servicemode)
        if uuidseqno is not None:
            headers["UUIDSeqNo"] = str(uuidseqno)
        if entity is not None:
            headers["entity"] = str(entity)
        if languagecode is not None:
            headers["languageCode"] = str(languagecode)
        if referenceid is not None:
            headers["referenceId"] = str(referenceid)
        if userid is not None:
            headers["userId"] = str(userid)
        
        
        return await make_api_request(
            "GET", 
            path, 
            
            params=params if params else None, 
            headers=headers if headers else None
        )
    
    
    
    @mcp.tool()
    async def lmet0205_fetch_notnl_pool_postusing_get(
        poolid: str,
        poolreference: int,
        pagenum: Optional[int] = None,
        pagesize: Optional[int] = None,
        accesstoken: Optional[str] = None,
        channeltype: Optional[int] = None,
        co_relationid: Optional[int] = None,
        initiatingsystem: Optional[str] = None,
        servicemode: Optional[int] = None,
        uuidseqno: Optional[int] = None,
        entity: Optional[str] = None,
        languagecode: Optional[int] = None,
        referenceid: Optional[str] = None,
        userid: Optional[int] = None
    ) -> Dict[str, Any]:
        """
        Fetch Notional Pool Details
        
        Generated from: GET /liquidityManagement/notionalPool/{poolId}
        Source: swagger_2_0
        Operation ID: LMET0205FetchNotnlPool_POSTUsingGET
        
        
        Authentication: Not required
        
        Parameters:
        - PoolReference: integer (required)
          Enter the Pool Reference
        - pageNum: integer
          pageNum
        - pageSize: integer
          pageSize
        - poolId: string (required)
          Path parameter poolId
        
        
        
        Headers:
        - Accesstoken: string
          Authorization token for identification of the caller
        - ChannelType: integer
          Channel identifier from where the transaction has originated (Internet, Mobile, ATM, Branch Channel )
        - Co-Relationid: integer
          Unique ID for the service invoked, will be set by the transaction system
        - InitiatingSystem: string
          Indicating the initiated system
        - ServiceMode: integer
          Used for branch channel to indicate the type of customer
        - UUIDSeqNo: integer
          UUID Sequence Number
        - entity: string
          entity
        - languageCode: integer
          languageCode
        - referenceId: string
          Place holder for Token based authentication
        - userId: integer
          userId
        
        
        """
        
        
        # Prepare query parameters
        params = {}
        if poolreference is not None:
            params["PoolReference"] = poolreference
            
        if pagenum is not None:
            params["pageNum"] = pagenum
            
        if pagesize is not None:
            params["pageSize"] = pagesize
            
        
        
        # Replace path parameters in URL
        path = "/liquidityManagement/notionalPool/{poolId}"
        if poolid is not None:
            path = path.replace("{poolId}", str(poolid))
        
        
        # Prepare headers
        headers = {}
        if accesstoken is not None:
            headers["Accesstoken"] = str(accesstoken)
        if channeltype is not None:
            headers["ChannelType"] = str(channeltype)
        if co_relationid is not None:
            headers["Co-Relationid"] = str(co_relationid)
        if initiatingsystem is not None:
            headers["InitiatingSystem"] = str(initiatingsystem)
        if servicemode is not None:
            headers["ServiceMode"] = str(servicemode)
        if uuidseqno is not None:
            headers["UUIDSeqNo"] = str(uuidseqno)
        if entity is not None:
            headers["entity"] = str(entity)
        if languagecode is not None:
            headers["languageCode"] = str(languagecode)
        if referenceid is not None:
            headers["referenceId"] = str(referenceid)
        if userid is not None:
            headers["userId"] = str(userid)
        
        
        return await make_api_request(
            "GET", 
            path, 
            
            params=params if params else None, 
            headers=headers if headers else None
        )
    
    
    
    @mcp.tool()
    async def lmet9003_fetch_notional_pool_acnts_postusing_get(
        customerreference: str,
        pagenum: Optional[int] = None,
        pagesize: Optional[int] = None,
        accesstoken: Optional[str] = None,
        channeltype: Optional[int] = None,
        co_relationid: Optional[int] = None,
        initiatingsystem: Optional[str] = None,
        servicemode: Optional[int] = None,
        uuidseqno: Optional[int] = None,
        entity: Optional[str] = None,
        languagecode: Optional[int] = None,
        referenceid: Optional[str] = None,
        userid: Optional[int] = None
    ) -> Dict[str, Any]:
        """
        Fetch Notional Pool List
        
        Generated from: GET /liquidityManagement/notionalPoolList
        Source: swagger_2_0
        Operation ID: LMET9003FetchNotionalPoolAcnts_POSTUsingGET
        
        
        Authentication: Not required
        
        Parameters:
        - CustomerReference: string (required)
          Enter the Customer Reference
        - pageNum: integer
          pageNum
        - pageSize: integer
          pageSize
        
        
        
        Headers:
        - Accesstoken: string
          Authorization token for identification of the caller
        - ChannelType: integer
          Channel identifier from where the transaction has originated (Internet, Mobile, ATM, Branch Channel )
        - Co-Relationid: integer
          Unique ID for the service invoked, will be set by the transaction system
        - InitiatingSystem: string
          Indicating the initiated system
        - ServiceMode: integer
          Used for branch channel to indicate the type of customer
        - UUIDSeqNo: integer
          UUID Sequence Number
        - entity: string
          entity
        - languageCode: integer
          languageCode
        - referenceId: string
          Place holder for Token based authentication
        - userId: integer
          userId
        
        
        """
        
        
        # Prepare query parameters
        params = {}
        if customerreference is not None:
            params["CustomerReference"] = customerreference
            
        if pagenum is not None:
            params["pageNum"] = pagenum
            
        if pagesize is not None:
            params["pageSize"] = pagesize
            
        
        
        # Replace path parameters in URL
        path = "/liquidityManagement/notionalPoolList"
        
        
        # Prepare headers
        headers = {}
        if accesstoken is not None:
            headers["Accesstoken"] = str(accesstoken)
        if channeltype is not None:
            headers["ChannelType"] = str(channeltype)
        if co_relationid is not None:
            headers["Co-Relationid"] = str(co_relationid)
        if initiatingsystem is not None:
            headers["InitiatingSystem"] = str(initiatingsystem)
        if servicemode is not None:
            headers["ServiceMode"] = str(servicemode)
        if uuidseqno is not None:
            headers["UUIDSeqNo"] = str(uuidseqno)
        if entity is not None:
            headers["entity"] = str(entity)
        if languagecode is not None:
            headers["languageCode"] = str(languagecode)
        if referenceid is not None:
            headers["referenceId"] = str(referenceid)
        if userid is not None:
            headers["userId"] = str(userid)
        
        
        return await make_api_request(
            "GET", 
            path, 
            
            params=params if params else None, 
            headers=headers if headers else None
        )
    
    
    
    @mcp.tool()
    async def rmet2001_get_group_lmt_bal_postusing_get(
        poolid: str,
        pagenum: Optional[int] = None,
        pagesize: Optional[int] = None,
        accesstoken: Optional[str] = None,
        channeltype: Optional[int] = None,
        co_relationid: Optional[int] = None,
        initiatingsystem: Optional[str] = None,
        servicemode: Optional[int] = None,
        uuidseqno: Optional[int] = None,
        entity: Optional[str] = None,
        languagecode: Optional[int] = None,
        referenceid: Optional[str] = None,
        userid: Optional[int] = None
    ) -> Dict[str, Any]:
        """
        Fetch Pool Balance
        
        Generated from: GET /liquidityManagement/poolBalance/{poolId}
        Source: swagger_2_0
        Operation ID: RMET2001GetGroupLmtBal_POSTUsingGET
        
        
        Authentication: Not required
        
        Parameters:
        - pageNum: integer
          pageNum
        - pageSize: integer
          pageSize
        - poolId: string (required)
          Enter the Pool ID
        
        
        
        Headers:
        - Accesstoken: string
          Authorization token for identification of the caller
        - ChannelType: integer
          Channel identifier from where the transaction has originated (Internet, Mobile, ATM, Branch Channel )
        - Co-Relationid: integer
          Unique ID for the service invoked, will be set by the transaction system
        - InitiatingSystem: string
          Indicating the initiated system
        - ServiceMode: integer
          Used for branch channel to indicate the type of customer
        - UUIDSeqNo: integer
          UUID Sequence Number
        - entity: string
          entity
        - languageCode: integer
          languageCode
        - referenceId: string
          Place holder for Token based authentication
        - userId: integer
          userId
        
        
        """
        
        
        # Prepare query parameters
        params = {}
        if pagenum is not None:
            params["pageNum"] = pagenum
            
        if pagesize is not None:
            params["pageSize"] = pagesize
            
        
        
        # Replace path parameters in URL
        path = "/liquidityManagement/poolBalance/{poolId}"
        if poolid is not None:
            path = path.replace("{poolId}", str(poolid))
        
        
        # Prepare headers
        headers = {}
        if accesstoken is not None:
            headers["Accesstoken"] = str(accesstoken)
        if channeltype is not None:
            headers["ChannelType"] = str(channeltype)
        if co_relationid is not None:
            headers["Co-Relationid"] = str(co_relationid)
        if initiatingsystem is not None:
            headers["InitiatingSystem"] = str(initiatingsystem)
        if servicemode is not None:
            headers["ServiceMode"] = str(servicemode)
        if uuidseqno is not None:
            headers["UUIDSeqNo"] = str(uuidseqno)
        if entity is not None:
            headers["entity"] = str(entity)
        if languagecode is not None:
            headers["languageCode"] = str(languagecode)
        if referenceid is not None:
            headers["referenceId"] = str(referenceid)
        if userid is not None:
            headers["userId"] = str(userid)
        
        
        return await make_api_request(
            "GET", 
            path, 
            
            params=params if params else None, 
            headers=headers if headers else None
        )
    
    
    
    @mcp.tool()
    async def cret5789_get_synd_loan_list_rest_apiusing_get(
        slposnum: int,
        slpostype: int,
        applicationid: Optional[str] = None,
        entity: Optional[str] = None,
        languagecode: Optional[int] = None,
        userid: Optional[int] = None
    ) -> Dict[str, Any]:
        """
        Fetch Loan List via Syndication Contract
        
        Generated from: GET /loans/GetSyndLoanList
        Source: swagger_2_0
        Operation ID: CRET5789GetSyndLoanListRestAPIUsingGET
        
        
        Authentication: Not required
        
        Parameters:
        - slPosNum: integer (required)
          Pos Num of Syndication Contract
        - slPosType: integer (required)
          Pos Type of Syndication Contract
        
        
        
        Headers:
        - applicationId: string
          applicationId
        - entity: string
          entity
        - languageCode: integer
          languageCode
        - userId: integer
          userId
        
        
        """
        
        
        # Prepare query parameters
        params = {}
        if slposnum is not None:
            params["slPosNum"] = slposnum
            
        if slpostype is not None:
            params["slPosType"] = slpostype
            
        
        
        # Replace path parameters in URL
        path = "/loans/GetSyndLoanList"
        
        
        # Prepare headers
        headers = {}
        if applicationid is not None:
            headers["applicationId"] = str(applicationid)
        if entity is not None:
            headers["entity"] = str(entity)
        if languagecode is not None:
            headers["languageCode"] = str(languagecode)
        if userid is not None:
            headers["userId"] = str(userid)
        
        
        return await make_api_request(
            "GET", 
            path, 
            
            params=params if params else None, 
            headers=headers if headers else None
        )
    
    
    
    @mcp.tool()
    async def crbt2022_auth_pdcdetail_using_post(
        request_body:Dict[str, Any] ,  # AuthPDCDetailRequest,
        accesstoken: Optional[str] = None,
        channeltype: Optional[int] = None,
        co_relationid: Optional[int] = None,
        initiatingsystem: Optional[str] = None,
        servicemode: Optional[int] = None,
        uuidseqno: Optional[int] = None,
        entity: Optional[str] = None,
        languagecode: Optional[int] = None,
        referenceid: Optional[str] = None,
        requesthash: Optional[str] = None,
        userid: Optional[int] = None
    ) -> Dict[str, Any]:
        """
        Authorize PDC
        
        Generated from: POST /loans/PDC/Auth
        Source: swagger_2_0
        Operation ID: CRBT2022AuthPDCDetailUsingPOST
        
        
        Authentication: Not required
        
        Parameters:
        - request_body: any (required)
          input
        
        
        
        Headers:
        - Accesstoken: string
          Authorization token for identification of the caller
        - ChannelType: integer
          Channel identifier from where the TXN has originated (Internet, Mobile, ATM, Branch Channel )
        - Co-Relationid: integer
          Unique ID for the service invoked, will be set by the TXN system
        - InitiatingSystem: string
          Indicating the initiated system
        - ServiceMode: integer
          Used for branch channel to indicate the type of customer
        - UUIDSeqNo: integer
          UUID Sequence Number
        - entity: string
          entity
        - languageCode: integer
          languageCode
        - referenceId: string
          Place holder for Token based authentication
        - requesthash: string
          Request payload for hash validation
        - userId: integer
          userId
        
        
        """
        
        
        # Prepare request data
        
        # Single body parameter - send directly
        data = request_body if request_body is not None else {}
        
        
        
        # Prepare query parameters
        params = {}
        
        
        # Replace path parameters in URL
        path = "/loans/PDC/Auth"
        
        
        # Prepare headers
        headers = {}
        if accesstoken is not None:
            headers["Accesstoken"] = str(accesstoken)
        if channeltype is not None:
            headers["ChannelType"] = str(channeltype)
        if co_relationid is not None:
            headers["Co-Relationid"] = str(co_relationid)
        if initiatingsystem is not None:
            headers["InitiatingSystem"] = str(initiatingsystem)
        if servicemode is not None:
            headers["ServiceMode"] = str(servicemode)
        if uuidseqno is not None:
            headers["UUIDSeqNo"] = str(uuidseqno)
        if entity is not None:
            headers["entity"] = str(entity)
        if languagecode is not None:
            headers["languageCode"] = str(languagecode)
        if referenceid is not None:
            headers["referenceId"] = str(referenceid)
        if requesthash is not None:
            headers["requesthash"] = str(requesthash)
        if userid is not None:
            headers["userId"] = str(userid)
        
        
        return await make_api_request(
            "POST", 
            path, 
            data=data, 
            params=params if params else None, 
            headers=headers if headers else None
        )
    
    
    
    @mcp.tool()
    async def crbt2022_create_pdcdetail_using_post(
        request_body:Dict[str, Any] ,  # CreatePDCDetailRequest,
        accesstoken: Optional[str] = None,
        channeltype: Optional[int] = None,
        co_relationid: Optional[int] = None,
        initiatingsystem: Optional[str] = None,
        servicemode: Optional[int] = None,
        uuidseqno: Optional[int] = None,
        entity: Optional[str] = None,
        languagecode: Optional[int] = None,
        referenceid: Optional[str] = None,
        requesthash: Optional[str] = None,
        userid: Optional[int] = None
    ) -> Dict[str, Any]:
        """
        This Api is used to Create PDC
        
        Generated from: POST /loans/PDC/Create
        Source: swagger_2_0
        Operation ID: CRBT2022CreatePDCDetailUsingPOST
        
        
        Authentication: Not required
        
        Parameters:
        - request_body: any (required)
          input
        
        
        
        Headers:
        - Accesstoken: string
          Authorization token for identification of the caller
        - ChannelType: integer
          Channel identifier from where the TXN has originated (Internet, Mobile, ATM, Branch Channel )
        - Co-Relationid: integer
          Unique ID for the service invoked, will be set by the TXN system
        - InitiatingSystem: string
          Indicating the initiated system
        - ServiceMode: integer
          Used for branch channel to indicate the type of customer
        - UUIDSeqNo: integer
          UUID Sequence Number
        - entity: string
          entity
        - languageCode: integer
          languageCode
        - referenceId: string
          Place holder for Token based authentication
        - requesthash: string
          Request payload for hash validation
        - userId: integer
          userId
        
        
        """
        
        
        # Prepare request data
        
        # Single body parameter - send directly
        data = request_body if request_body is not None else {}
        
        
        
        # Prepare query parameters
        params = {}
        
        
        # Replace path parameters in URL
        path = "/loans/PDC/Create"
        
        
        # Prepare headers
        headers = {}
        if accesstoken is not None:
            headers["Accesstoken"] = str(accesstoken)
        if channeltype is not None:
            headers["ChannelType"] = str(channeltype)
        if co_relationid is not None:
            headers["Co-Relationid"] = str(co_relationid)
        if initiatingsystem is not None:
            headers["InitiatingSystem"] = str(initiatingsystem)
        if servicemode is not None:
            headers["ServiceMode"] = str(servicemode)
        if uuidseqno is not None:
            headers["UUIDSeqNo"] = str(uuidseqno)
        if entity is not None:
            headers["entity"] = str(entity)
        if languagecode is not None:
            headers["languageCode"] = str(languagecode)
        if referenceid is not None:
            headers["referenceId"] = str(referenceid)
        if requesthash is not None:
            headers["requesthash"] = str(requesthash)
        if userid is not None:
            headers["userId"] = str(userid)
        
        
        return await make_api_request(
            "POST", 
            path, 
            data=data, 
            params=params if params else None, 
            headers=headers if headers else None
        )
    
    
    
    @mcp.tool()
    async def crbt2022_pdcmod_on_hold_using_post(
        request_body:Dict[str, Any] ,  # PDCModOnHoldRequest,
        accesstoken: Optional[str] = None,
        channeltype: Optional[int] = None,
        co_relationid: Optional[int] = None,
        initiatingsystem: Optional[str] = None,
        servicemode: Optional[int] = None,
        uuidseqno: Optional[int] = None,
        entity: Optional[str] = None,
        languagecode: Optional[int] = None,
        referenceid: Optional[str] = None,
        requesthash: Optional[str] = None,
        userid: Optional[int] = None
    ) -> Dict[str, Any]:
        """
        Create PDC In ModOnHold
        
        Generated from: POST /loans/PDC/Create/ModOnHold
        Source: swagger_2_0
        Operation ID: CRBT2022PDCModOnHoldUsingPOST
        
        
        Authentication: Not required
        
        Parameters:
        - request_body: any (required)
          input
        
        
        
        Headers:
        - Accesstoken: string
          Authorization token for identification of the caller
        - ChannelType: integer
          Channel identifier from where the TXN has originated (Internet, Mobile, ATM, Branch Channel )
        - Co-Relationid: integer
          Unique ID for the service invoked, will be set by the TXN system
        - InitiatingSystem: string
          Indicating the initiated system
        - ServiceMode: integer
          Used for branch channel to indicate the type of customer
        - UUIDSeqNo: integer
          UUID Sequence Number
        - entity: string
          entity
        - languageCode: integer
          languageCode
        - referenceId: string
          Place holder for Token based authentication
        - requesthash: string
          Request payload for hash validation
        - userId: integer
          userId
        
        
        """
        
        
        # Prepare request data
        
        # Single body parameter - send directly
        data = request_body if request_body is not None else {}
        
        
        
        # Prepare query parameters
        params = {}
        
        
        # Replace path parameters in URL
        path = "/loans/PDC/Create/ModOnHold"
        
        
        # Prepare headers
        headers = {}
        if accesstoken is not None:
            headers["Accesstoken"] = str(accesstoken)
        if channeltype is not None:
            headers["ChannelType"] = str(channeltype)
        if co_relationid is not None:
            headers["Co-Relationid"] = str(co_relationid)
        if initiatingsystem is not None:
            headers["InitiatingSystem"] = str(initiatingsystem)
        if servicemode is not None:
            headers["ServiceMode"] = str(servicemode)
        if uuidseqno is not None:
            headers["UUIDSeqNo"] = str(uuidseqno)
        if entity is not None:
            headers["entity"] = str(entity)
        if languagecode is not None:
            headers["languageCode"] = str(languagecode)
        if referenceid is not None:
            headers["referenceId"] = str(referenceid)
        if requesthash is not None:
            headers["requesthash"] = str(requesthash)
        if userid is not None:
            headers["userId"] = str(userid)
        
        
        return await make_api_request(
            "POST", 
            path, 
            data=data, 
            params=params if params else None, 
            headers=headers if headers else None
        )
    
    
    
    @mcp.tool()
    async def crbt2022_pdcmod_pendng_auth_using_post(
        request_body:Dict[str, Any] ,  # PDCModPendngAuthRequest,
        accesstoken: Optional[str] = None,
        channeltype: Optional[int] = None,
        co_relationid: Optional[int] = None,
        initiatingsystem: Optional[str] = None,
        servicemode: Optional[int] = None,
        uuidseqno: Optional[int] = None,
        entity: Optional[str] = None,
        languagecode: Optional[int] = None,
        referenceid: Optional[str] = None,
        requesthash: Optional[str] = None,
        userid: Optional[int] = None
    ) -> Dict[str, Any]:
        """
        PDC Pending Authorization
        
        Generated from: POST /loans/PDC/Create/ModifyPendingAuth
        Source: swagger_2_0
        Operation ID: CRBT2022PDCModPendngAuthUsingPOST
        
        
        Authentication: Not required
        
        Parameters:
        - request_body: any (required)
          input
        
        
        
        Headers:
        - Accesstoken: string
          Authorization token for identification of the caller
        - ChannelType: integer
          Channel identifier from where the TXN has originated (Internet, Mobile, ATM, Branch Channel )
        - Co-Relationid: integer
          Unique ID for the service invoked, will be set by the TXN system
        - InitiatingSystem: string
          Indicating the initiated system
        - ServiceMode: integer
          Used for branch channel to indicate the type of customer
        - UUIDSeqNo: integer
          UUID Sequence Number
        - entity: string
          entity
        - languageCode: integer
          languageCode
        - referenceId: string
          Place holder for Token based authentication
        - requesthash: string
          Request payload for hash validation
        - userId: integer
          userId
        
        
        """
        
        
        # Prepare request data
        
        # Single body parameter - send directly
        data = request_body if request_body is not None else {}
        
        
        
        # Prepare query parameters
        params = {}
        
        
        # Replace path parameters in URL
        path = "/loans/PDC/Create/ModifyPendingAuth"
        
        
        # Prepare headers
        headers = {}
        if accesstoken is not None:
            headers["Accesstoken"] = str(accesstoken)
        if channeltype is not None:
            headers["ChannelType"] = str(channeltype)
        if co_relationid is not None:
            headers["Co-Relationid"] = str(co_relationid)
        if initiatingsystem is not None:
            headers["InitiatingSystem"] = str(initiatingsystem)
        if servicemode is not None:
            headers["ServiceMode"] = str(servicemode)
        if uuidseqno is not None:
            headers["UUIDSeqNo"] = str(uuidseqno)
        if entity is not None:
            headers["entity"] = str(entity)
        if languagecode is not None:
            headers["languageCode"] = str(languagecode)
        if referenceid is not None:
            headers["referenceId"] = str(referenceid)
        if requesthash is not None:
            headers["requesthash"] = str(requesthash)
        if userid is not None:
            headers["userId"] = str(userid)
        
        
        return await make_api_request(
            "POST", 
            path, 
            data=data, 
            params=params if params else None, 
            headers=headers if headers else None
        )
    
    
    
    @mcp.tool()
    async def crbt2022_pdcon_hold_using_post(
        request_body:Dict[str, Any] ,  # PDCOnHoldRequest,
        accesstoken: Optional[str] = None,
        channeltype: Optional[int] = None,
        co_relationid: Optional[int] = None,
        initiatingsystem: Optional[str] = None,
        servicemode: Optional[int] = None,
        uuidseqno: Optional[int] = None,
        entity: Optional[str] = None,
        languagecode: Optional[int] = None,
        referenceid: Optional[str] = None,
        requesthash: Optional[str] = None,
        userid: Optional[int] = None
    ) -> Dict[str, Any]:
        """
        PDC On Hold
        
        Generated from: POST /loans/PDC/Create/OnHold
        Source: swagger_2_0
        Operation ID: CRBT2022PDCOnHoldUsingPOST
        
        
        Authentication: Not required
        
        Parameters:
        - request_body: any (required)
          input
        
        
        
        Headers:
        - Accesstoken: string
          Authorization token for identification of the caller
        - ChannelType: integer
          Channel identifier from where the TXN has originated (Internet, Mobile, ATM, Branch Channel )
        - Co-Relationid: integer
          Unique ID for the service invoked, will be set by the TXN system
        - InitiatingSystem: string
          Indicating the initiated system
        - ServiceMode: integer
          Used for branch channel to indicate the type of customer
        - UUIDSeqNo: integer
          UUID Sequence Number
        - entity: string
          entity
        - languageCode: integer
          languageCode
        - referenceId: string
          Place holder for Token based authentication
        - requesthash: string
          Request payload for hash validation
        - userId: integer
          userId
        
        
        """
        
        
        # Prepare request data
        
        # Single body parameter - send directly
        data = request_body if request_body is not None else {}
        
        
        
        # Prepare query parameters
        params = {}
        
        
        # Replace path parameters in URL
        path = "/loans/PDC/Create/OnHold"
        
        
        # Prepare headers
        headers = {}
        if accesstoken is not None:
            headers["Accesstoken"] = str(accesstoken)
        if channeltype is not None:
            headers["ChannelType"] = str(channeltype)
        if co_relationid is not None:
            headers["Co-Relationid"] = str(co_relationid)
        if initiatingsystem is not None:
            headers["InitiatingSystem"] = str(initiatingsystem)
        if servicemode is not None:
            headers["ServiceMode"] = str(servicemode)
        if uuidseqno is not None:
            headers["UUIDSeqNo"] = str(uuidseqno)
        if entity is not None:
            headers["entity"] = str(entity)
        if languagecode is not None:
            headers["languageCode"] = str(languagecode)
        if referenceid is not None:
            headers["referenceId"] = str(referenceid)
        if requesthash is not None:
            headers["requesthash"] = str(requesthash)
        if userid is not None:
            headers["userId"] = str(userid)
        
        
        return await make_api_request(
            "POST", 
            path, 
            data=data, 
            params=params if params else None, 
            headers=headers if headers else None
        )
    
    
    
    @mcp.tool()
    async def cret2022_update_pdcdetail_using_get(
        loanaccountposid: Optional[int] = None,
        loanaccountpostype: Optional[int] = None,
        accesstoken: Optional[str] = None,
        channeltype: Optional[int] = None,
        co_relationid: Optional[int] = None,
        initiatingsystem: Optional[str] = None,
        servicemode: Optional[int] = None,
        uuidseqno: Optional[int] = None,
        entity: Optional[str] = None,
        languagecode: Optional[int] = None,
        referenceid: Optional[str] = None,
        requesthash: Optional[str] = None,
        userid: Optional[int] = None
    ) -> Dict[str, Any]:
        """
        GetUpdatedPDCDetails
        
        Generated from: GET /loans/PDC/Get/UpdatedPDCDetails
        Source: swagger_2_0
        Operation ID: CRET2022UpdatePDCDetailUsingGET
        
        
        Authentication: Not required
        
        Parameters:
        - loanAccountPosId: integer
          loanAccountPosId
        - loanAccountPosType: integer
          loanAccountPosType
        
        
        
        Headers:
        - Accesstoken: string
          Authorization token for identification of the caller
        - ChannelType: integer
          Channel identifier from where the TXN has originated (Internet, Mobile, ATM, Branch Channel )
        - Co-Relationid: integer
          Unique ID for the service invoked, will be set by the TXN system
        - InitiatingSystem: string
          Indicating the initiated system
        - ServiceMode: integer
          Used for branch channel to indicate the type of customer
        - UUIDSeqNo: integer
          UUID Sequence Number
        - entity: string
          entity
        - languageCode: integer
          languageCode
        - referenceId: string
          Place holder for Token based authentication
        - requesthash: string
          Request payload for hash validation
        - userId: integer
          userId
        
        
        """
        
        
        # Prepare query parameters
        params = {}
        if loanaccountposid is not None:
            params["loanAccountPosId"] = loanaccountposid
            
        if loanaccountpostype is not None:
            params["loanAccountPosType"] = loanaccountpostype
            
        
        
        # Replace path parameters in URL
        path = "/loans/PDC/Get/UpdatedPDCDetails"
        
        
        # Prepare headers
        headers = {}
        if accesstoken is not None:
            headers["Accesstoken"] = str(accesstoken)
        if channeltype is not None:
            headers["ChannelType"] = str(channeltype)
        if co_relationid is not None:
            headers["Co-Relationid"] = str(co_relationid)
        if initiatingsystem is not None:
            headers["InitiatingSystem"] = str(initiatingsystem)
        if servicemode is not None:
            headers["ServiceMode"] = str(servicemode)
        if uuidseqno is not None:
            headers["UUIDSeqNo"] = str(uuidseqno)
        if entity is not None:
            headers["entity"] = str(entity)
        if languagecode is not None:
            headers["languageCode"] = str(languagecode)
        if referenceid is not None:
            headers["referenceId"] = str(referenceid)
        if requesthash is not None:
            headers["requesthash"] = str(requesthash)
        if userid is not None:
            headers["userId"] = str(userid)
        
        
        return await make_api_request(
            "GET", 
            path, 
            
            params=params if params else None, 
            headers=headers if headers else None
        )
    
    
    
    @mcp.tool()
    async def cret2022_repayment_detail_list_using_get(
        chequenumber: Optional[str] = None,
        draweebankname: Optional[str] = None,
        installmentdatefrom: Optional[str] = None,
        installmentdateto: Optional[str] = None,
        loanaccountposid: Optional[int] = None,
        loanaccountpostype: Optional[int] = None,
        pagenum: Optional[int] = None,
        pagesize: Optional[int] = None,
        accesstoken: Optional[str] = None,
        channeltype: Optional[int] = None,
        co_relationid: Optional[int] = None,
        initiatingsystem: Optional[str] = None,
        servicemode: Optional[int] = None,
        uuidseqno: Optional[int] = None,
        entity: Optional[str] = None,
        languagecode: Optional[int] = None,
        referenceid: Optional[str] = None,
        requesthash: Optional[str] = None,
        userid: Optional[int] = None
    ) -> Dict[str, Any]:
        """
        Repayment Detail List
        
        Generated from: GET /loans/PDC/GetRepaymentDetailList
        Source: swagger_2_0
        Operation ID: CRET2022RepaymentDetailListUsingGET
        
        
        Authentication: Not required
        
        Parameters:
        - chequeNumber: string
          chequeNumber
        - draweeBankName: string
          draweeBankName
        - installmentDateFrom: string
          installmentDateFrom
        - installmentDateTo: string
          installmentDateTo
        - loanAccountPosID: integer
          loanAccountPosID
        - loanAccountPosType: integer
          loanAccountPosType
        - pageNum: integer
          pageNum
        - pageSize: integer
          pageSize
        
        
        
        Headers:
        - Accesstoken: string
          Authorization token for identification of the caller
        - ChannelType: integer
          Channel identifier from where the TXN has originated (Internet, Mobile, ATM, Branch Channel )
        - Co-Relationid: integer
          Unique ID for the service invoked, will be set by the TXN system
        - InitiatingSystem: string
          Indicating the initiated system
        - ServiceMode: integer
          Used for branch channel to indicate the type of customer
        - UUIDSeqNo: integer
          UUID Sequence Number
        - entity: string
          entity
        - languageCode: integer
          languageCode
        - referenceId: string
          Place holder for Token based authentication
        - requesthash: string
          Request payload for hash validation
        - userId: integer
          userId
        
        
        """
        
        
        # Prepare query parameters
        params = {}
        if chequenumber is not None:
            params["chequeNumber"] = chequenumber
            
        if draweebankname is not None:
            params["draweeBankName"] = draweebankname
            
        if installmentdatefrom is not None:
            params["installmentDateFrom"] = installmentdatefrom
            
        if installmentdateto is not None:
            params["installmentDateTo"] = installmentdateto
            
        if loanaccountposid is not None:
            params["loanAccountPosID"] = loanaccountposid
            
        if loanaccountpostype is not None:
            params["loanAccountPosType"] = loanaccountpostype
            
        if pagenum is not None:
            params["pageNum"] = pagenum
            
        if pagesize is not None:
            params["pageSize"] = pagesize
            
        
        
        # Replace path parameters in URL
        path = "/loans/PDC/GetRepaymentDetailList"
        
        
        # Prepare headers
        headers = {}
        if accesstoken is not None:
            headers["Accesstoken"] = str(accesstoken)
        if channeltype is not None:
            headers["ChannelType"] = str(channeltype)
        if co_relationid is not None:
            headers["Co-Relationid"] = str(co_relationid)
        if initiatingsystem is not None:
            headers["InitiatingSystem"] = str(initiatingsystem)
        if servicemode is not None:
            headers["ServiceMode"] = str(servicemode)
        if uuidseqno is not None:
            headers["UUIDSeqNo"] = str(uuidseqno)
        if entity is not None:
            headers["entity"] = str(entity)
        if languagecode is not None:
            headers["languageCode"] = str(languagecode)
        if referenceid is not None:
            headers["referenceId"] = str(referenceid)
        if requesthash is not None:
            headers["requesthash"] = str(requesthash)
        if userid is not None:
            headers["userId"] = str(userid)
        
        
        return await make_api_request(
            "GET", 
            path, 
            
            params=params if params else None, 
            headers=headers if headers else None
        )
    
    
    
    @mcp.tool()
    async def cret2022_view_pdcdetail_using_get(
        chequeamount: Optional[float] = None,
        chequedateddrangeflag: Optional[int] = None,
        chequedateddrangeope: Optional[str] = None,
        chequedateddtoval: Optional[str] = None,
        chequedateddfromval: Optional[str] = None,
        chequenumberfrom: Optional[str] = None,
        chequenumberto: Optional[str] = None,
        chequepresentdateddfromval: Optional[str] = None,
        chequepresentdateddrangeopr: Optional[str] = None,
        chequepresentdateddtoval: Optional[str] = None,
        chequepresentdateddstatus: Optional[int] = None,
        draweebankaccount: Optional[str] = None,
        draweebankname: Optional[str] = None,
        loanreference: Optional[str] = None,
        product: Optional[int] = None,
        repaymenttransactionid: Optional[int] = None,
        status: Optional[int] = None,
        accesstoken: Optional[str] = None,
        channeltype: Optional[int] = None,
        co_relationid: Optional[int] = None,
        initiatingsystem: Optional[str] = None,
        servicemode: Optional[int] = None,
        uuidseqno: Optional[int] = None,
        entity: Optional[str] = None,
        languagecode: Optional[int] = None,
        referenceid: Optional[str] = None,
        requesthash: Optional[str] = None,
        userid: Optional[int] = None
    ) -> Dict[str, Any]:
        """
        PDC Details View
        
        Generated from: GET /loans/PDC/ViewPDCDetails
        Source: swagger_2_0
        Operation ID: CRET2022ViewPDCDetailUsingGET
        
        
        Authentication: Not required
        
        Parameters:
        - chequeAmount: number
          chequeAmount
        - chequeDateDDRangeFlag: integer
          d_d_RangeFlag
        - chequeDateDDRangeOpe: string
          d_d_RangeOpr
        - chequeDateDDToVal: string
          d_d_ToValue
        - chequeDateDDfromVal: string
          d_d_FromValue
        - chequeNumberFrom: string
          chequeNumberFrom
        - chequeNumberTo: string
          chequeNumberTo
        - chequePresentDateDDFromVal: string
          d_d_FromValue
        - chequePresentDateDDRangeOpr: string
          d_d_RangeOpr
        - chequePresentDateDDToVal: string
          d_d_ToValue
        - chequePresentDateDDstatus: integer
          d_d_RangeFlag
        - draweeBankAccount: string
          draweeBankAccount
        - draweeBankName: string
          draweeBankName
        - loanReference: string
          loanReference
        - product: integer
          product
        - repaymentTransactionId: integer
          EXTRA_NUM_1
        - status: integer
          status
        
        
        
        Headers:
        - Accesstoken: string
          Authorization token for identification of the caller
        - ChannelType: integer
          Channel identifier from where the TXN has originated (Internet, Mobile, ATM, Branch Channel )
        - Co-Relationid: integer
          Unique ID for the service invoked, will be set by the TXN system
        - InitiatingSystem: string
          Indicating the initiated system
        - ServiceMode: integer
          Used for branch channel to indicate the type of customer
        - UUIDSeqNo: integer
          UUID Sequence Number
        - entity: string
          entity
        - languageCode: integer
          languageCode
        - referenceId: string
          Place holder for Token based authentication
        - requesthash: string
          Request payload for hash validation
        - userId: integer
          userId
        
        
        """
        
        
        # Prepare query parameters
        params = {}
        if chequeamount is not None:
            params["chequeAmount"] = chequeamount
            
        if chequedateddrangeflag is not None:
            params["chequeDateDDRangeFlag"] = chequedateddrangeflag
            
        if chequedateddrangeope is not None:
            params["chequeDateDDRangeOpe"] = chequedateddrangeope
            
        if chequedateddtoval is not None:
            params["chequeDateDDToVal"] = chequedateddtoval
            
        if chequedateddfromval is not None:
            params["chequeDateDDfromVal"] = chequedateddfromval
            
        if chequenumberfrom is not None:
            params["chequeNumberFrom"] = chequenumberfrom
            
        if chequenumberto is not None:
            params["chequeNumberTo"] = chequenumberto
            
        if chequepresentdateddfromval is not None:
            params["chequePresentDateDDFromVal"] = chequepresentdateddfromval
            
        if chequepresentdateddrangeopr is not None:
            params["chequePresentDateDDRangeOpr"] = chequepresentdateddrangeopr
            
        if chequepresentdateddtoval is not None:
            params["chequePresentDateDDToVal"] = chequepresentdateddtoval
            
        if chequepresentdateddstatus is not None:
            params["chequePresentDateDDstatus"] = chequepresentdateddstatus
            
        if draweebankaccount is not None:
            params["draweeBankAccount"] = draweebankaccount
            
        if draweebankname is not None:
            params["draweeBankName"] = draweebankname
            
        if loanreference is not None:
            params["loanReference"] = loanreference
            
        if product is not None:
            params["product"] = product
            
        if repaymenttransactionid is not None:
            params["repaymentTransactionId"] = repaymenttransactionid
            
        if status is not None:
            params["status"] = status
            
        
        
        # Replace path parameters in URL
        path = "/loans/PDC/ViewPDCDetails"
        
        
        # Prepare headers
        headers = {}
        if accesstoken is not None:
            headers["Accesstoken"] = str(accesstoken)
        if channeltype is not None:
            headers["ChannelType"] = str(channeltype)
        if co_relationid is not None:
            headers["Co-Relationid"] = str(co_relationid)
        if initiatingsystem is not None:
            headers["InitiatingSystem"] = str(initiatingsystem)
        if servicemode is not None:
            headers["ServiceMode"] = str(servicemode)
        if uuidseqno is not None:
            headers["UUIDSeqNo"] = str(uuidseqno)
        if entity is not None:
            headers["entity"] = str(entity)
        if languagecode is not None:
            headers["languageCode"] = str(languagecode)
        if referenceid is not None:
            headers["referenceId"] = str(referenceid)
        if requesthash is not None:
            headers["requesthash"] = str(requesthash)
        if userid is not None:
            headers["userId"] = str(userid)
        
        
        return await make_api_request(
            "GET", 
            path, 
            
            params=params if params else None, 
            headers=headers if headers else None
        )
    
    
    
    @mcp.tool()
    async def cbcet0101_fetch_conduct_details_using_get(
        customerreference: int,
        accesstoken: Optional[str] = None,
        channeltype: Optional[int] = None,
        co_relationid: Optional[int] = None,
        initiatingsystem: Optional[str] = None,
        servicemode: Optional[int] = None,
        uuidseqno: Optional[int] = None,
        entity: Optional[str] = None,
        languagecode: Optional[int] = None,
        referenceid: Optional[str] = None,
        userid: Optional[int] = None
    ) -> Dict[str, Any]:
        """
        Fetch Loan Account Conduct Details
        
        Generated from: GET /loans/accountConductDetails/{customerReference}
        Source: swagger_2_0
        Operation ID: CBCET0101FetchConductDetailsUsingGET
        
        
        Authentication: Not required
        
        Parameters:
        - customerReference: integer (required)
          Reference Number of Customer
        
        
        
        Headers:
        - Accesstoken: string
          Authorization token for identification of the caller
        - ChannelType: integer
          Channel identifier from where the TXN has originated (Internet, Mobile, ATM, Branch Channel )
        - Co-Relationid: integer
          Unique ID for the service invoked, will be set by the TXN system
        - InitiatingSystem: string
          Indicating the initiated system
        - ServiceMode: integer
          Used for branch channel to indicate the type of customer
        - UUIDSeqNo: integer
          UUID Sequence Number
        - entity: string
          entity
        - languageCode: integer
          languageCode
        - referenceId: string
          Place holder for Token based authentication
        - userId: integer
          userId
        
        
        """
        
        
        # Prepare query parameters
        params = {}
        
        
        # Replace path parameters in URL
        path = "/loans/accountConductDetails/{customerReference}"
        if customerreference is not None:
            path = path.replace("{customerReference}", str(customerreference))
        
        
        # Prepare headers
        headers = {}
        if accesstoken is not None:
            headers["Accesstoken"] = str(accesstoken)
        if channeltype is not None:
            headers["ChannelType"] = str(channeltype)
        if co_relationid is not None:
            headers["Co-Relationid"] = str(co_relationid)
        if initiatingsystem is not None:
            headers["InitiatingSystem"] = str(initiatingsystem)
        if servicemode is not None:
            headers["ServiceMode"] = str(servicemode)
        if uuidseqno is not None:
            headers["UUIDSeqNo"] = str(uuidseqno)
        if entity is not None:
            headers["entity"] = str(entity)
        if languagecode is not None:
            headers["languageCode"] = str(languagecode)
        if referenceid is not None:
            headers["referenceId"] = str(referenceid)
        if userid is not None:
            headers["userId"] = str(userid)
        
        
        return await make_api_request(
            "GET", 
            path, 
            
            params=params if params else None, 
            headers=headers if headers else None
        )
    
    
    
    @mcp.tool()
    async def crbt1995_create_bank_dep_cltrl_using_post_1(
        request_body:Dict[str, Any] ,  # bankDepositCollateralResource,
        accesstoken: Optional[str] = None,
        channeltype: Optional[int] = None,
        co_relationid: Optional[int] = None,
        initiatingsystem: Optional[str] = None,
        servicemode: Optional[int] = None,
        uuidseqno: Optional[int] = None,
        entity: Optional[str] = None,
        languagecode: Optional[int] = None,
        referenceid: Optional[str] = None,
        requesthash: Optional[str] = None,
        userid: Optional[int] = None
    ) -> Dict[str, Any]:
        """
        Creation of Bank deposit collateral
        
        Generated from: POST /loans/bankDeposit
        Source: swagger_2_0
        Operation ID: CRBT1995CreateBankDepCltrlUsingPOST_1
        
        
        Authentication: Not required
        
        Parameters:
        - request_body: any (required)
          input
        
        
        
        Headers:
        - Accesstoken: string
          Authorization token for identification of the caller
        - ChannelType: integer
          Channel identifier from where the TXN has originated (Internet, Mobile, ATM, Branch Channel)
        - Co-Relationid: integer
          Unique ID for the service invoked, will be set by the TXN system
        - InitiatingSystem: string
          Indicating the initiated system
        - ServiceMode: integer
          Used for branch channel to indicate the type of customer
        - UUIDSeqNo: integer
          UUID Sequence Number
        - entity: string
          entity
        - languageCode: integer
          languageCode
        - referenceId: string
          Place holder for Token based authentication
        - requesthash: string
          Request payload for hash validation
        - userId: integer
          userId
        
        
        """
        
        
        # Prepare request data
        
        # Single body parameter - send directly
        data = request_body if request_body is not None else {}
        
        
        
        # Prepare query parameters
        params = {}
        
        
        # Replace path parameters in URL
        path = "/loans/bankDeposit"
        
        
        # Prepare headers
        headers = {}
        if accesstoken is not None:
            headers["Accesstoken"] = str(accesstoken)
        if channeltype is not None:
            headers["ChannelType"] = str(channeltype)
        if co_relationid is not None:
            headers["Co-Relationid"] = str(co_relationid)
        if initiatingsystem is not None:
            headers["InitiatingSystem"] = str(initiatingsystem)
        if servicemode is not None:
            headers["ServiceMode"] = str(servicemode)
        if uuidseqno is not None:
            headers["UUIDSeqNo"] = str(uuidseqno)
        if entity is not None:
            headers["entity"] = str(entity)
        if languagecode is not None:
            headers["languageCode"] = str(languagecode)
        if referenceid is not None:
            headers["referenceId"] = str(referenceid)
        if requesthash is not None:
            headers["requesthash"] = str(requesthash)
        if userid is not None:
            headers["userId"] = str(userid)
        
        
        return await make_api_request(
            "POST", 
            path, 
            data=data, 
            params=params if params else None, 
            headers=headers if headers else None
        )
    
    
    
    @mcp.tool()
    async def crbt3852_cancel_loan_postusing_post(
        posnum: int,
        postype: int,
        accesstoken: Optional[str] = None,
        channeltype: Optional[int] = None,
        co_relationid: Optional[int] = None,
        initiatingsystem: Optional[str] = None,
        servicemode: Optional[int] = None,
        uuidseqno: Optional[int] = None,
        entity: Optional[str] = None,
        languagecode: Optional[int] = None,
        referenceid: Optional[str] = None,
        userid: Optional[int] = None
    ) -> Dict[str, Any]:
        """
        Cancel Loan
        
        Generated from: POST /loans/cancel
        Source: swagger_2_0
        Operation ID: CRBT3852CancelLoan_POSTUsingPOST
        
        
        Authentication: Not required
        
        Parameters:
        - PosNum: integer (required)
          This field is used to display Pos type
        - PosType: integer (required)
          This field is used to display Pos type
        
        
        
        Headers:
        - Accesstoken: string
          Authorization token for identification of the caller
        - ChannelType: integer
          Channel identifier from where the transaction has originated (Internet, Mobile, ATM, Branch Channel )
        - Co-Relationid: integer
          Unique ID for the service invoked, will be set by the transaction system
        - InitiatingSystem: string
          Indicating the initiated system
        - ServiceMode: integer
          Used for branch channel to indicate the type of customer
        - UUIDSeqNo: integer
          UUID Sequence Number
        - entity: string
          entity
        - languageCode: integer
          languageCode
        - referenceId: string
          Place holder for Token based authentication
        - userId: integer
          userId
        
        
        """
        
        
        # Prepare query parameters
        params = {}
        if posnum is not None:
            params["PosNum"] = posnum
            
        if postype is not None:
            params["PosType"] = postype
            
        
        
        # Replace path parameters in URL
        path = "/loans/cancel"
        
        
        # Prepare headers
        headers = {}
        if accesstoken is not None:
            headers["Accesstoken"] = str(accesstoken)
        if channeltype is not None:
            headers["ChannelType"] = str(channeltype)
        if co_relationid is not None:
            headers["Co-Relationid"] = str(co_relationid)
        if initiatingsystem is not None:
            headers["InitiatingSystem"] = str(initiatingsystem)
        if servicemode is not None:
            headers["ServiceMode"] = str(servicemode)
        if uuidseqno is not None:
            headers["UUIDSeqNo"] = str(uuidseqno)
        if entity is not None:
            headers["entity"] = str(entity)
        if languagecode is not None:
            headers["languageCode"] = str(languagecode)
        if referenceid is not None:
            headers["referenceId"] = str(referenceid)
        if userid is not None:
            headers["userId"] = str(userid)
        
        
        return await make_api_request(
            "POST", 
            path, 
            
            params=params if params else None, 
            headers=headers if headers else None
        )
    
    
    
    @mcp.tool()
    async def crbt3852_auth_cancel_loan_postusing_post(
        request_body:Dict[str, Any] ,  # CR_LN_CANCEL_DTLS_CRBT3852AuthCancelLoan_Resource,
        accesstoken: Optional[str] = None,
        channeltype: Optional[int] = None,
        co_relationid: Optional[int] = None,
        initiatingsystem: Optional[str] = None,
        servicemode: Optional[int] = None,
        uuidseqno: Optional[int] = None,
        entity: Optional[str] = None,
        languagecode: Optional[int] = None,
        referenceid: Optional[str] = None,
        userid: Optional[int] = None
    ) -> Dict[str, Any]:
        """
        Authorize Loan cancellation
        
        Generated from: POST /loans/cancel/authorize
        Source: swagger_2_0
        Operation ID: CRBT3852AuthCancelLoan_POSTUsingPOST
        
        
        Authentication: Not required
        
        Parameters:
        - request_body: any (required)
          input
        
        
        
        Headers:
        - Accesstoken: string
          Authorization token for identification of the caller
        - ChannelType: integer
          Channel identifier from where the transaction has originated (Internet, Mobile, ATM, Branch Channel )
        - Co-Relationid: integer
          Unique ID for the service invoked, will be set by the transaction system
        - InitiatingSystem: string
          Indicating the initiated system
        - ServiceMode: integer
          Used for branch channel to indicate the type of customer
        - UUIDSeqNo: integer
          UUID Sequence Number
        - entity: string
          entity
        - languageCode: integer
          languageCode
        - referenceId: string
          Place holder for Token based authentication
        - userId: integer
          userId
        
        
        """
        
        
        # Prepare request data
        
        # Single body parameter - send directly
        data = request_body if request_body is not None else {}
        
        
        
        # Prepare query parameters
        params = {}
        
        
        # Replace path parameters in URL
        path = "/loans/cancel/authorize"
        
        
        # Prepare headers
        headers = {}
        if accesstoken is not None:
            headers["Accesstoken"] = str(accesstoken)
        if channeltype is not None:
            headers["ChannelType"] = str(channeltype)
        if co_relationid is not None:
            headers["Co-Relationid"] = str(co_relationid)
        if initiatingsystem is not None:
            headers["InitiatingSystem"] = str(initiatingsystem)
        if servicemode is not None:
            headers["ServiceMode"] = str(servicemode)
        if uuidseqno is not None:
            headers["UUIDSeqNo"] = str(uuidseqno)
        if entity is not None:
            headers["entity"] = str(entity)
        if languagecode is not None:
            headers["languageCode"] = str(languagecode)
        if referenceid is not None:
            headers["referenceId"] = str(referenceid)
        if userid is not None:
            headers["userId"] = str(userid)
        
        
        return await make_api_request(
            "POST", 
            path, 
            data=data, 
            params=params if params else None, 
            headers=headers if headers else None
        )
    
    
    
    @mcp.tool()
    async def crbt6068_ins_claim_proceed_modification_wrapper_postusing_post(
        request_body:Dict[str, Any] ,  # CLTRL_MASTER_CRBT6068InsClaimProceedModificationWrapper_Resource,
        channeltype: Optional[int] = None,
        co_relationid: Optional[int] = None,
        initiatingsystem: Optional[str] = None,
        servicemode: Optional[int] = None,
        uuidseqno: Optional[int] = None,
        entity: Optional[str] = None,
        languagecode: Optional[int] = None,
        userid: Optional[int] = None
    ) -> Dict[str, Any]:
        """
        Insurance Claim Proceed Modification Wrapper
        
        Generated from: POST /loans/collateral/InsClaimProceed/update
        Source: swagger_2_0
        Operation ID: CRBT6068InsClaimProceedModificationWrapper_POSTUsingPOST
        
        
        Authentication: Not required
        
        Parameters:
        - request_body: any (required)
          input
        
        
        
        Headers:
        - ChannelType: integer
          Channel identifier from where the TXN has originated (Internet, Mobile, ATM, Branch Channel )
        - Co-Relationid: integer
          Unique ID for the service invoked, will be set by the TXN system
        - InitiatingSystem: string
          Indicating the initiated system
        - ServiceMode: integer
          Used for branch channel to indicate the type of customer
        - UUIDSeqNo: integer
          UUID Sequence Number
        - entity: string
          entity
        - languageCode: integer
          languageCode
        - userId: integer
          userId
        
        
        """
        
        
        # Prepare request data
        
        # Single body parameter - send directly
        data = request_body if request_body is not None else {}
        
        
        
        # Prepare query parameters
        params = {}
        
        
        # Replace path parameters in URL
        path = "/loans/collateral/InsClaimProceed/update"
        
        
        # Prepare headers
        headers = {}
        if channeltype is not None:
            headers["ChannelType"] = str(channeltype)
        if co_relationid is not None:
            headers["Co-Relationid"] = str(co_relationid)
        if initiatingsystem is not None:
            headers["InitiatingSystem"] = str(initiatingsystem)
        if servicemode is not None:
            headers["ServiceMode"] = str(servicemode)
        if uuidseqno is not None:
            headers["UUIDSeqNo"] = str(uuidseqno)
        if entity is not None:
            headers["entity"] = str(entity)
        if languagecode is not None:
            headers["languageCode"] = str(languagecode)
        if userid is not None:
            headers["userId"] = str(userid)
        
        
        return await make_api_request(
            "POST", 
            path, 
            data=data, 
            params=params if params else None, 
            headers=headers if headers else None
        )
    
    
    
    @mcp.tool()
    async def crbt1830_create_shr_bnd_dtls_postusing_post(
        request_body:Dict[str, Any] ,  # modifyShrBndDtlsRequest,
        accesstoken: Optional[str] = None,
        channeltype: Optional[int] = None,
        co_relationid: Optional[int] = None,
        initiatingsystem: Optional[str] = None,
        servicemode: Optional[int] = None,
        uuidseqno: Optional[int] = None,
        entity: Optional[str] = None,
        languagecode: Optional[int] = None,
        referenceid: Optional[str] = None,
        requesthash: Optional[str] = None,
        userid: Optional[int] = None
    ) -> Dict[str, Any]:
        """
        modify share and bond collateral
        
        Generated from: POST /loans/collateral/ShareAndBondCltrl/modify
        Source: swagger_2_0
        Operation ID: CRBT1830CreateShrBndDtls_POSTUsingPOST
        
        
        Authentication: Not required
        
        Parameters:
        - request_body: any (required)
          input
        
        
        
        Headers:
        - Accesstoken: string
          Authorization token for identification of the caller
        - ChannelType: integer
          Channel identifier from where the TXN has originated (Internet, Mobile, ATM, Branch Channel )
        - Co-Relationid: integer
          Unique ID for the service invoked, will be set by the TXN system
        - InitiatingSystem: string
          Indicating the initiated system
        - ServiceMode: integer
          Used for branch channel to indicate the type of customer
        - UUIDSeqNo: integer
          UUID Sequence Number
        - entity: string
          entity
        - languageCode: integer
          languageCode
        - referenceId: string
          Place holder for Token based authentication
        - requesthash: string
          Request payload for hash validation
        - userId: integer
          userId
        
        
        """
        
        
        # Prepare request data
        
        # Single body parameter - send directly
        data = request_body if request_body is not None else {}
        
        
        
        # Prepare query parameters
        params = {}
        
        
        # Replace path parameters in URL
        path = "/loans/collateral/ShareAndBondCltrl/modify"
        
        
        # Prepare headers
        headers = {}
        if accesstoken is not None:
            headers["Accesstoken"] = str(accesstoken)
        if channeltype is not None:
            headers["ChannelType"] = str(channeltype)
        if co_relationid is not None:
            headers["Co-Relationid"] = str(co_relationid)
        if initiatingsystem is not None:
            headers["InitiatingSystem"] = str(initiatingsystem)
        if servicemode is not None:
            headers["ServiceMode"] = str(servicemode)
        if uuidseqno is not None:
            headers["UUIDSeqNo"] = str(uuidseqno)
        if entity is not None:
            headers["entity"] = str(entity)
        if languagecode is not None:
            headers["languageCode"] = str(languagecode)
        if referenceid is not None:
            headers["referenceId"] = str(referenceid)
        if requesthash is not None:
            headers["requesthash"] = str(requesthash)
        if userid is not None:
            headers["userId"] = str(userid)
        
        
        return await make_api_request(
            "POST", 
            path, 
            data=data, 
            params=params if params else None, 
            headers=headers if headers else None
        )
    
    
    
    @mcp.tool()
    async def crbt1808_createt_invoice_cltrl_postusing_post(
        request_body:Dict[str, Any] ,  # CLTRL_MASTER_CRBT1808CreatetInvoiceCltrl_Resource,
        accesstoken: Optional[str] = None,
        channeltype: Optional[int] = None,
        co_relationid: Optional[int] = None,
        initiatingsystem: Optional[str] = None,
        servicemode: Optional[int] = None,
        uuidseqno: Optional[int] = None,
        entity: Optional[str] = None,
        languagecode: Optional[int] = None,
        referenceid: Optional[str] = None,
        requesthash: Optional[str] = None,
        userid: Optional[int] = None
    ) -> Dict[str, Any]:
        """
        Creation of Agreement Of Proceed Type of Collateral
        
        Generated from: POST /loans/collateral/agreementofproceed/create
        Source: swagger_2_0
        Operation ID: CRBT1808CreatetInvoiceCltrl_POSTUsingPOST
        
        
        Authentication: Not required
        
        Parameters:
        - request_body: any (required)
          input
        
        
        
        Headers:
        - Accesstoken: string
          Authorization token for identification of the caller
        - ChannelType: integer
          Channel identifier from where the TXN has originated (Internet, Mobile, ATM, Branch Channel )
        - Co-Relationid: integer
          Unique ID for the service invoked, will be set by the TXN system
        - InitiatingSystem: string
          Indicating the initiated system
        - ServiceMode: integer
          Used for branch channel to indicate the type of customer
        - UUIDSeqNo: integer
          UUID Sequence Number
        - entity: string
          entity
        - languageCode: integer
          languageCode
        - referenceId: string
          Place holder for Token based authentication
        - requesthash: string
          Request payload for hash validation
        - userId: integer
          userId
        
        
        """
        
        
        # Prepare request data
        
        # Single body parameter - send directly
        data = request_body if request_body is not None else {}
        
        
        
        # Prepare query parameters
        params = {}
        
        
        # Replace path parameters in URL
        path = "/loans/collateral/agreementofproceed/create"
        
        
        # Prepare headers
        headers = {}
        if accesstoken is not None:
            headers["Accesstoken"] = str(accesstoken)
        if channeltype is not None:
            headers["ChannelType"] = str(channeltype)
        if co_relationid is not None:
            headers["Co-Relationid"] = str(co_relationid)
        if initiatingsystem is not None:
            headers["InitiatingSystem"] = str(initiatingsystem)
        if servicemode is not None:
            headers["ServiceMode"] = str(servicemode)
        if uuidseqno is not None:
            headers["UUIDSeqNo"] = str(uuidseqno)
        if entity is not None:
            headers["entity"] = str(entity)
        if languagecode is not None:
            headers["languageCode"] = str(languagecode)
        if referenceid is not None:
            headers["referenceId"] = str(referenceid)
        if requesthash is not None:
            headers["requesthash"] = str(requesthash)
        if userid is not None:
            headers["userId"] = str(userid)
        
        
        return await make_api_request(
            "POST", 
            path, 
            data=data, 
            params=params if params else None, 
            headers=headers if headers else None
        )
    
    
    
    @mcp.tool()
    async def crbt0101_asgnmnt_of_proceed_modification_wrapper_postusing_post(
        request_body:Dict[str, Any] ,  # CLTRL_INVC_RCVBL_MASTER_CRBT0101AsgnmntOfProceedModificationWrapper_Resource,
        accesstoken: Optional[str] = None,
        channeltype: Optional[int] = None,
        co_relationid: Optional[int] = None,
        initiatingsystem: Optional[str] = None,
        servicemode: Optional[int] = None,
        uuidseqno: Optional[int] = None,
        entity: Optional[str] = None,
        languagecode: Optional[int] = None,
        referenceid: Optional[str] = None,
        requesthash: Optional[str] = None,
        userid: Optional[int] = None
    ) -> Dict[str, Any]:
        """
        Assignment of Proceed  Collateral creation
        
        Generated from: POST /loans/collateral/agreementofproceed/update
        Source: swagger_2_0
        Operation ID: CRBT0101AsgnmntOfProceedModificationWrapper_POSTUsingPOST
        
        
        Authentication: Not required
        
        Parameters:
        - request_body: any (required)
          input
        
        
        
        Headers:
        - Accesstoken: string
          Authorization token for identification of the caller
        - ChannelType: integer
          Channel identifier from where the TXN has originated (Internet, Mobile, ATM, Branch Channel )
        - Co-Relationid: integer
          Unique ID for the service invoked, will be set by the TXN system
        - InitiatingSystem: string
          Indicating the initiated system
        - ServiceMode: integer
          Used for branch channel to indicate the type of customer
        - UUIDSeqNo: integer
          UUID Sequence Number
        - entity: string
          entity
        - languageCode: integer
          languageCode
        - referenceId: string
          Place holder for Token based authentication
        - requesthash: string
          Request payload for hash validation
        - userId: integer
          userId
        
        
        """
        
        
        # Prepare request data
        
        # Single body parameter - send directly
        data = request_body if request_body is not None else {}
        
        
        
        # Prepare query parameters
        params = {}
        
        
        # Replace path parameters in URL
        path = "/loans/collateral/agreementofproceed/update"
        
        
        # Prepare headers
        headers = {}
        if accesstoken is not None:
            headers["Accesstoken"] = str(accesstoken)
        if channeltype is not None:
            headers["ChannelType"] = str(channeltype)
        if co_relationid is not None:
            headers["Co-Relationid"] = str(co_relationid)
        if initiatingsystem is not None:
            headers["InitiatingSystem"] = str(initiatingsystem)
        if servicemode is not None:
            headers["ServiceMode"] = str(servicemode)
        if uuidseqno is not None:
            headers["UUIDSeqNo"] = str(uuidseqno)
        if entity is not None:
            headers["entity"] = str(entity)
        if languagecode is not None:
            headers["languageCode"] = str(languagecode)
        if referenceid is not None:
            headers["referenceId"] = str(referenceid)
        if requesthash is not None:
            headers["requesthash"] = str(requesthash)
        if userid is not None:
            headers["userId"] = str(userid)
        
        
        return await make_api_request(
            "POST", 
            path, 
            data=data, 
            params=params if params else None, 
            headers=headers if headers else None
        )
    
    
    
    @mcp.tool()
    async def cret1808_fetch_invoice_cltrl_using_get_1(
        collateralreference: int,
        accesstoken: Optional[str] = None,
        channeltype: Optional[int] = None,
        co_relationid: Optional[int] = None,
        initiatingsystem: Optional[str] = None,
        servicemode: Optional[int] = None,
        uuidseqno: Optional[int] = None,
        entity: Optional[str] = None,
        languagecode: Optional[int] = None,
        referenceid: Optional[str] = None,
        requesthash: Optional[str] = None,
        userid: Optional[int] = None
    ) -> Dict[str, Any]:
        """
        Fetch Details of Agreement of Proceed Collateral
        
        Generated from: GET /loans/collateral/agreementofproceed/view/{collateralReference}
        Source: swagger_2_0
        Operation ID: CRET1808FetchInvoiceCltrlUsingGET_1
        
        
        Authentication: Not required
        
        Parameters:
        - collateralReference: integer (required)
          System generated unique reference of collateral
        
        
        
        Headers:
        - Accesstoken: string
          Authorization token for identification of the caller
        - ChannelType: integer
          Channel identifier from where the TXN has originated (Internet, Mobile, ATM, Branch Channel )
        - Co-Relationid: integer
          Unique ID for the service invoked, will be set by the TXN system
        - InitiatingSystem: string
          Indicating the initiated system
        - ServiceMode: integer
          Used for branch channel to indicate the type of customer
        - UUIDSeqNo: integer
          UUID Sequence Number
        - entity: string
          entity
        - languageCode: integer
          languageCode
        - referenceId: string
          Place holder for Token based authentication
        - requesthash: string
          Request payload for hash validation
        - userId: integer
          userId
        
        
        """
        
        
        # Prepare query parameters
        params = {}
        
        
        # Replace path parameters in URL
        path = "/loans/collateral/agreementofproceed/view/{collateralReference}"
        if collateralreference is not None:
            path = path.replace("{collateralReference}", str(collateralreference))
        
        
        # Prepare headers
        headers = {}
        if accesstoken is not None:
            headers["Accesstoken"] = str(accesstoken)
        if channeltype is not None:
            headers["ChannelType"] = str(channeltype)
        if co_relationid is not None:
            headers["Co-Relationid"] = str(co_relationid)
        if initiatingsystem is not None:
            headers["InitiatingSystem"] = str(initiatingsystem)
        if servicemode is not None:
            headers["ServiceMode"] = str(servicemode)
        if uuidseqno is not None:
            headers["UUIDSeqNo"] = str(uuidseqno)
        if entity is not None:
            headers["entity"] = str(entity)
        if languagecode is not None:
            headers["languageCode"] = str(languagecode)
        if referenceid is not None:
            headers["referenceId"] = str(referenceid)
        if requesthash is not None:
            headers["requesthash"] = str(requesthash)
        if userid is not None:
            headers["userId"] = str(userid)
        
        
        return await make_api_request(
            "GET", 
            path, 
            
            params=params if params else None, 
            headers=headers if headers else None
        )
    
    
    
    @mcp.tool()
    async def crbt1995_create_bank_dep_cltrl_postusing_post(
        request_body:Dict[str, Any] ,  # BankDepositCollateralRequest,
        accesstoken: Optional[str] = None,
        channeltype: Optional[int] = None,
        co_relationid: Optional[int] = None,
        initiatingsystem: Optional[str] = None,
        servicemode: Optional[int] = None,
        uuidseqno: Optional[int] = None,
        entity: Optional[str] = None,
        languagecode: Optional[int] = None,
        referenceid: Optional[str] = None,
        requesthash: Optional[str] = None,
        userid: Optional[int] = None
    ) -> Dict[str, Any]:
        """
        Creation of Bank deposit collateral
        
        Generated from: POST /loans/collateral/bankDeposit/create
        Source: swagger_2_0
        Operation ID: CRBT1995CreateBankDepCltrl_POSTUsingPOST
        
        
        Authentication: Not required
        
        Parameters:
        - request_body: any (required)
          input
        
        
        
        Headers:
        - Accesstoken: string
          Authorization token for identification of the caller
        - ChannelType: integer
          Channel identifier from where  the TXN has originated (Internet, Mobile, ATM, Branch Channel )
        - Co-Relationid: integer
          Unique ID for the service invoked, will be set by the TXN system
        - InitiatingSystem: string
          Indicating the initiated system
        - ServiceMode: integer
          Used for branch channel to indicate the type of customer
        - UUIDSeqNo: integer
          UUID Sequence Number
        - entity: string
          entity
        - languageCode: integer
          languageCode
        - referenceId: string
          Place holder for Token based authentication
        - requesthash: string
          Request payload for hash validation
        - userId: integer
          userId
        
        
        """
        
        
        # Prepare request data
        
        # Single body parameter - send directly
        data = request_body if request_body is not None else {}
        
        
        
        # Prepare query parameters
        params = {}
        
        
        # Replace path parameters in URL
        path = "/loans/collateral/bankDeposit/create"
        
        
        # Prepare headers
        headers = {}
        if accesstoken is not None:
            headers["Accesstoken"] = str(accesstoken)
        if channeltype is not None:
            headers["ChannelType"] = str(channeltype)
        if co_relationid is not None:
            headers["Co-Relationid"] = str(co_relationid)
        if initiatingsystem is not None:
            headers["InitiatingSystem"] = str(initiatingsystem)
        if servicemode is not None:
            headers["ServiceMode"] = str(servicemode)
        if uuidseqno is not None:
            headers["UUIDSeqNo"] = str(uuidseqno)
        if entity is not None:
            headers["entity"] = str(entity)
        if languagecode is not None:
            headers["languageCode"] = str(languagecode)
        if referenceid is not None:
            headers["referenceId"] = str(referenceid)
        if requesthash is not None:
            headers["requesthash"] = str(requesthash)
        if userid is not None:
            headers["userId"] = str(userid)
        
        
        return await make_api_request(
            "POST", 
            path, 
            data=data, 
            params=params if params else None, 
            headers=headers if headers else None
        )
    
    
    
    @mcp.tool()
    async def crbt0101_cltrl_bank_dep_modification_wrapper_postusing_post(
        request_body:Dict[str, Any] ,  # CollateralBankDepositModifyRequest,
        accesstoken: Optional[str] = None,
        channeltype: Optional[int] = None,
        co_relationid: Optional[int] = None,
        initiatingsystem: Optional[str] = None,
        servicemode: Optional[int] = None,
        uuidseqno: Optional[int] = None,
        entity: Optional[str] = None,
        languagecode: Optional[int] = None,
        referenceid: Optional[str] = None,
        requesthash: Optional[str] = None,
        userid: Optional[int] = None
    ) -> Dict[str, Any]:
        """
        BankDepositCollateralModification
        
        Generated from: POST /loans/collateral/bankDeposit/update
        Source: swagger_2_0
        Operation ID: CRBT0101CltrlBankDepModificationWrapper_POSTUsingPOST
        
        
        Authentication: Not required
        
        Parameters:
        - request_body: any (required)
          input
        
        
        
        Headers:
        - Accesstoken: string
          Authorization token for identification of the caller
        - ChannelType: integer
          Channel identifier from where the TXN has originated (Internet, Mobile, ATM, Branch Channel )
        - Co-Relationid: integer
          Unique ID for the service invoked, will be set by the TXN system
        - InitiatingSystem: string
          Indicating the initiated system
        - ServiceMode: integer
          Used for branch channel to indicate the type of customer
        - UUIDSeqNo: integer
          UUID Sequence Number
        - entity: string
          entity
        - languageCode: integer
          languageCode
        - referenceId: string
          Place holder for Token based authentication
        - requesthash: string
          Request payload for hash validation
        - userId: integer
          userId
        
        
        """
        
        
        # Prepare request data
        
        # Single body parameter - send directly
        data = request_body if request_body is not None else {}
        
        
        
        # Prepare query parameters
        params = {}
        
        
        # Replace path parameters in URL
        path = "/loans/collateral/bankDeposit/update"
        
        
        # Prepare headers
        headers = {}
        if accesstoken is not None:
            headers["Accesstoken"] = str(accesstoken)
        if channeltype is not None:
            headers["ChannelType"] = str(channeltype)
        if co_relationid is not None:
            headers["Co-Relationid"] = str(co_relationid)
        if initiatingsystem is not None:
            headers["InitiatingSystem"] = str(initiatingsystem)
        if servicemode is not None:
            headers["ServiceMode"] = str(servicemode)
        if uuidseqno is not None:
            headers["UUIDSeqNo"] = str(uuidseqno)
        if entity is not None:
            headers["entity"] = str(entity)
        if languagecode is not None:
            headers["languageCode"] = str(languagecode)
        if referenceid is not None:
            headers["referenceId"] = str(referenceid)
        if requesthash is not None:
            headers["requesthash"] = str(requesthash)
        if userid is not None:
            headers["userId"] = str(userid)
        
        
        return await make_api_request(
            "POST", 
            path, 
            data=data, 
            params=params if params else None, 
            headers=headers if headers else None
        )
    
    
    
    @mcp.tool()
    async def crbt1870_release_cltrl_on_hold_using_post_1(
        request_body:Dict[str, Any] ,  # CollateralDischargeRequest,
        accesstoken: Optional[str] = None,
        channeltype: Optional[int] = None,
        co_relationid: Optional[int] = None,
        initiatingsystem: Optional[str] = None,
        servicemode: Optional[int] = None,
        uuidseqno: Optional[int] = None,
        entity: Optional[str] = None,
        languagecode: Optional[int] = None,
        referenceid: Optional[str] = None,
        requesthash: Optional[str] = None,
        userid: Optional[int] = None
    ) -> Dict[str, Any]:
        """
        Discharge of collaterals
        
        Generated from: POST /loans/collateral/cltrlDischarge
        Source: swagger_2_0
        Operation ID: CRBT1870ReleaseCltrlOnHoldUsingPOST_1
        
        
        Authentication: Not required
        
        Parameters:
        - request_body: any (required)
          input
        
        
        
        Headers:
        - Accesstoken: string
          Authorization token for identification of the caller
        - ChannelType: integer
          Channel identifier from where the TXN has originated (Internet, Mobile, ATM, Branch Channel )
        - Co-Relationid: integer
          Unique ID for the service invoked, will be set by the TXN system
        - InitiatingSystem: string
          Indicating the initiated system
        - ServiceMode: integer
          Used for branch channel to indicate the type of customer
        - UUIDSeqNo: integer
          UUID Sequence Number
        - entity: string
          entity
        - languageCode: integer
          languageCode
        - referenceId: string
          Place holder for Token based authentication
        - requesthash: string
          Request payload for hash validation
        - userId: integer
          userId
        
        
        """
        
        
        # Prepare request data
        
        # Single body parameter - send directly
        data = request_body if request_body is not None else {}
        
        
        
        # Prepare query parameters
        params = {}
        
        
        # Replace path parameters in URL
        path = "/loans/collateral/cltrlDischarge"
        
        
        # Prepare headers
        headers = {}
        if accesstoken is not None:
            headers["Accesstoken"] = str(accesstoken)
        if channeltype is not None:
            headers["ChannelType"] = str(channeltype)
        if co_relationid is not None:
            headers["Co-Relationid"] = str(co_relationid)
        if initiatingsystem is not None:
            headers["InitiatingSystem"] = str(initiatingsystem)
        if servicemode is not None:
            headers["ServiceMode"] = str(servicemode)
        if uuidseqno is not None:
            headers["UUIDSeqNo"] = str(uuidseqno)
        if entity is not None:
            headers["entity"] = str(entity)
        if languagecode is not None:
            headers["languageCode"] = str(languagecode)
        if referenceid is not None:
            headers["referenceId"] = str(referenceid)
        if requesthash is not None:
            headers["requesthash"] = str(requesthash)
        if userid is not None:
            headers["userId"] = str(userid)
        
        
        return await make_api_request(
            "POST", 
            path, 
            data=data, 
            params=params if params else None, 
            headers=headers if headers else None
        )
    
    
    
    @mcp.tool()
    async def crbt1864_create_coll_link_using_post_1(
        request_body:Dict[str, Any] ,  # CLTRL_LINK_CRBT1864CreateCollLink_Resource,
        accesstoken: Optional[str] = None,
        channeltype: Optional[int] = None,
        co_relationid: Optional[int] = None,
        initiatingsystem: Optional[str] = None,
        servicemode: Optional[int] = None,
        uuidseqno: Optional[int] = None,
        entity: Optional[str] = None,
        languagecode: Optional[int] = None,
        referenceid: Optional[str] = None,
        requesthash: Optional[str] = None,
        userid: Optional[int] = None
    ) -> Dict[str, Any]:
        """
        Creation of a collateral Link
        
        Generated from: POST /loans/collateral/collaterallink/create
        Source: swagger_2_0
        Operation ID: CRBT1864CreateCollLinkUsingPOST_1
        
        
        Authentication: Not required
        
        Parameters:
        - request_body: any (required)
          input
        
        
        
        Headers:
        - Accesstoken: string
          Authorization token for identification of the caller
        - ChannelType: integer
          Channel identifier from where the TXN has originated (Internet, Mobile, ATM, Branch Channel )
        - Co-Relationid: integer
          Unique ID for the service invoked, will be set by the TXN system
        - InitiatingSystem: string
          Indicating the initiated system
        - ServiceMode: integer
          Used for branch channel to indicate the type of customer
        - UUIDSeqNo: integer
          UUID Sequence Number
        - entity: string
          entity
        - languageCode: integer
          languageCode
        - referenceId: string
          Place holder for Token based authentication
        - requesthash: string
          Request payload for hash validation
        - userId: integer
          userId
        
        
        """
        
        
        # Prepare request data
        
        # Single body parameter - send directly
        data = request_body if request_body is not None else {}
        
        
        
        # Prepare query parameters
        params = {}
        
        
        # Replace path parameters in URL
        path = "/loans/collateral/collaterallink/create"
        
        
        # Prepare headers
        headers = {}
        if accesstoken is not None:
            headers["Accesstoken"] = str(accesstoken)
        if channeltype is not None:
            headers["ChannelType"] = str(channeltype)
        if co_relationid is not None:
            headers["Co-Relationid"] = str(co_relationid)
        if initiatingsystem is not None:
            headers["InitiatingSystem"] = str(initiatingsystem)
        if servicemode is not None:
            headers["ServiceMode"] = str(servicemode)
        if uuidseqno is not None:
            headers["UUIDSeqNo"] = str(uuidseqno)
        if entity is not None:
            headers["entity"] = str(entity)
        if languagecode is not None:
            headers["languageCode"] = str(languagecode)
        if referenceid is not None:
            headers["referenceId"] = str(referenceid)
        if requesthash is not None:
            headers["requesthash"] = str(requesthash)
        if userid is not None:
            headers["userId"] = str(userid)
        
        
        return await make_api_request(
            "POST", 
            path, 
            data=data, 
            params=params if params else None, 
            headers=headers if headers else None
        )
    
    
    
    @mcp.tool()
    async def crbt6064_crt_contract_proceed_cltrl_postusing_post(
        request_body:Dict[str, Any] ,  # CLTRL_MASTER_CRBT6064CrtContractProceedCltrl_Resource,
        accesstoken: Optional[str] = None,
        channeltype: Optional[int] = None,
        co_relationid: Optional[int] = None,
        initiatingsystem: Optional[str] = None,
        servicemode: Optional[int] = None,
        uuidseqno: Optional[int] = None,
        entity: Optional[str] = None,
        languagecode: Optional[int] = None,
        referenceid: Optional[str] = None,
        requesthash: Optional[str] = None,
        userid: Optional[int] = None
    ) -> Dict[str, Any]:
        """
        Create Contract Proceed Collateral
        
        Generated from: POST /loans/collateral/createContractProceedCollateral
        Source: swagger_2_0
        Operation ID: CRBT6064CrtContractProceedCltrl_POSTUsingPOST
        
        
        Authentication: Not required
        
        Parameters:
        - request_body: any (required)
          input
        
        
        
        Headers:
        - Accesstoken: string
          Authorization token for identification of the caller
        - ChannelType: integer
          Channel identifier from where the TXN has originated (Internet, Mobile, ATM, Branch Channel )
        - Co-Relationid: integer
          Unique ID for the service invoked, will be set by the TXN system
        - InitiatingSystem: string
          Indicating the initiated system
        - ServiceMode: integer
          Used for branch channel to indicate the type of customer
        - UUIDSeqNo: integer
          UUID Sequence Number
        - entity: string
          entity
        - languageCode: integer
          languageCode
        - referenceId: string
          Place holder for Token based authentication
        - requesthash: string
          Request payload for hash validation
        - userId: integer
          userId
        
        
        """
        
        
        # Prepare request data
        
        # Single body parameter - send directly
        data = request_body if request_body is not None else {}
        
        
        
        # Prepare query parameters
        params = {}
        
        
        # Replace path parameters in URL
        path = "/loans/collateral/createContractProceedCollateral"
        
        
        # Prepare headers
        headers = {}
        if accesstoken is not None:
            headers["Accesstoken"] = str(accesstoken)
        if channeltype is not None:
            headers["ChannelType"] = str(channeltype)
        if co_relationid is not None:
            headers["Co-Relationid"] = str(co_relationid)
        if initiatingsystem is not None:
            headers["InitiatingSystem"] = str(initiatingsystem)
        if servicemode is not None:
            headers["ServiceMode"] = str(servicemode)
        if uuidseqno is not None:
            headers["UUIDSeqNo"] = str(uuidseqno)
        if entity is not None:
            headers["entity"] = str(entity)
        if languagecode is not None:
            headers["languageCode"] = str(languagecode)
        if referenceid is not None:
            headers["referenceId"] = str(referenceid)
        if requesthash is not None:
            headers["requesthash"] = str(requesthash)
        if userid is not None:
            headers["userId"] = str(userid)
        
        
        return await make_api_request(
            "POST", 
            path, 
            data=data, 
            params=params if params else None, 
            headers=headers if headers else None
        )
    
    
    
    @mcp.tool()
    async def crbt6068_crt_dividendcash_cltrl_postusing_post(
        request_body:Dict[str, Any] ,  # crtDividendcashCltrlResource,
        accesstoken: Optional[str] = None,
        channeltype: Optional[int] = None,
        co_relationid: Optional[int] = None,
        initiatingsystem: Optional[str] = None,
        servicemode: Optional[int] = None,
        uuidseqno: Optional[int] = None,
        entity: Optional[str] = None,
        languagecode: Optional[int] = None,
        referenceid: Optional[str] = None,
        requesthash: Optional[str] = None,
        userid: Optional[int] = None
    ) -> Dict[str, Any]:
        """
        Create Dividend and Cash Distribution Proceed Collateral
        
        Generated from: POST /loans/collateral/createDividendcashProceedCltrl
        Source: swagger_2_0
        Operation ID: CRBT6068CrtDividendcashCltrl_POSTUsingPOST
        
        
        Authentication: Not required
        
        Parameters:
        - request_body: any (required)
          input
        
        
        
        Headers:
        - Accesstoken: string
          Authorization token for identification of the caller
        - ChannelType: integer
          Channel identifier from where the TXN has originated (Internet, Mobile, ATM, Branch Channel )
        - Co-Relationid: integer
          Unique ID for the service invoked, will be set by the TXN system
        - InitiatingSystem: string
          Indicating the initiated system
        - ServiceMode: integer
          Used for branch channel to indicate the type of customer
        - UUIDSeqNo: integer
          UUID Sequence Number
        - entity: string
          entity
        - languageCode: integer
          languageCode
        - referenceId: string
          Place holder for Token based authentication
        - requesthash: string
          Request payload for hash validation
        - userId: integer
          userId
        
        
        """
        
        
        # Prepare request data
        
        # Single body parameter - send directly
        data = request_body if request_body is not None else {}
        
        
        
        # Prepare query parameters
        params = {}
        
        
        # Replace path parameters in URL
        path = "/loans/collateral/createDividendcashProceedCltrl"
        
        
        # Prepare headers
        headers = {}
        if accesstoken is not None:
            headers["Accesstoken"] = str(accesstoken)
        if channeltype is not None:
            headers["ChannelType"] = str(channeltype)
        if co_relationid is not None:
            headers["Co-Relationid"] = str(co_relationid)
        if initiatingsystem is not None:
            headers["InitiatingSystem"] = str(initiatingsystem)
        if servicemode is not None:
            headers["ServiceMode"] = str(servicemode)
        if uuidseqno is not None:
            headers["UUIDSeqNo"] = str(uuidseqno)
        if entity is not None:
            headers["entity"] = str(entity)
        if languagecode is not None:
            headers["languageCode"] = str(languagecode)
        if referenceid is not None:
            headers["referenceId"] = str(referenceid)
        if requesthash is not None:
            headers["requesthash"] = str(requesthash)
        if userid is not None:
            headers["userId"] = str(userid)
        
        
        return await make_api_request(
            "POST", 
            path, 
            data=data, 
            params=params if params else None, 
            headers=headers if headers else None
        )
    
    
    
    @mcp.tool()
    async def crbt6068_crt_insurance_claim_cltrl_postusing_post(
        request_body:Dict[str, Any] ,  # crtInsuranceClaimCltrlResource,
        accesstoken: Optional[str] = None,
        channeltype: Optional[int] = None,
        co_relationid: Optional[int] = None,
        initiatingsystem: Optional[str] = None,
        servicemode: Optional[int] = None,
        uuidseqno: Optional[int] = None,
        entity: Optional[str] = None,
        languagecode: Optional[int] = None,
        referenceid: Optional[str] = None,
        requesthash: Optional[str] = None,
        userid: Optional[int] = None
    ) -> Dict[str, Any]:
        """
        Create Insurance Proceed Collateral
        
        Generated from: POST /loans/collateral/createInsuranceProceedCltrl
        Source: swagger_2_0
        Operation ID: CRBT6068CrtInsuranceClaimCltrl_POSTUsingPOST
        
        
        Authentication: Not required
        
        Parameters:
        - request_body: any (required)
          input
        
        
        
        Headers:
        - Accesstoken: string
          Authorization token for identification of the caller
        - ChannelType: integer
          Channel identifier from where the TXN has originated (Internet, Mobile, ATM, Branch Channel )
        - Co-Relationid: integer
          Unique ID for the service invoked, will be set by the TXN system
        - InitiatingSystem: string
          Indicating the initiated system
        - ServiceMode: integer
          Used for branch channel to indicate the type of customer
        - UUIDSeqNo: integer
          UUID Sequence Number
        - entity: string
          entity
        - languageCode: integer
          languageCode
        - referenceId: string
          Place holder for Token based authentication
        - requesthash: string
          Request payload for hash validation
        - userId: integer
          userId
        
        
        """
        
        
        # Prepare request data
        
        # Single body parameter - send directly
        data = request_body if request_body is not None else {}
        
        
        
        # Prepare query parameters
        params = {}
        
        
        # Replace path parameters in URL
        path = "/loans/collateral/createInsuranceProceedCltrl"
        
        
        # Prepare headers
        headers = {}
        if accesstoken is not None:
            headers["Accesstoken"] = str(accesstoken)
        if channeltype is not None:
            headers["ChannelType"] = str(channeltype)
        if co_relationid is not None:
            headers["Co-Relationid"] = str(co_relationid)
        if initiatingsystem is not None:
            headers["InitiatingSystem"] = str(initiatingsystem)
        if servicemode is not None:
            headers["ServiceMode"] = str(servicemode)
        if uuidseqno is not None:
            headers["UUIDSeqNo"] = str(uuidseqno)
        if entity is not None:
            headers["entity"] = str(entity)
        if languagecode is not None:
            headers["languageCode"] = str(languagecode)
        if referenceid is not None:
            headers["referenceId"] = str(referenceid)
        if requesthash is not None:
            headers["requesthash"] = str(requesthash)
        if userid is not None:
            headers["userId"] = str(userid)
        
        
        return await make_api_request(
            "POST", 
            path, 
            data=data, 
            params=params if params else None, 
            headers=headers if headers else None
        )
    
    
    
    @mcp.tool()
    async def crbt6068_crt_medicalclaim_proceed_cltrl_postusing_post(
        request_body:Dict[str, Any] ,  # CrtMedicalclaimProceedCltrlrequest,
        accesstoken: Optional[str] = None,
        channeltype: Optional[int] = None,
        co_relationid: Optional[int] = None,
        initiatingsystem: Optional[str] = None,
        servicemode: Optional[int] = None,
        uuidseqno: Optional[int] = None,
        entity: Optional[str] = None,
        languagecode: Optional[int] = None,
        referenceid: Optional[str] = None,
        requesthash: Optional[str] = None,
        userid: Optional[int] = None
    ) -> Dict[str, Any]:
        """
        Create Medical Claim Proceed Collateral
        
        Generated from: POST /loans/collateral/createMedicalClaimProceedCltrl
        Source: swagger_2_0
        Operation ID: CRBT6068CrtMedicalclaimProceedCltrl_POSTUsingPOST
        
        
        Authentication: Not required
        
        Parameters:
        - request_body: any (required)
          input
        
        
        
        Headers:
        - Accesstoken: string
          Authorization token for identification of the caller
        - ChannelType: integer
          Channel identifier from where the TXN has originated (Internet, Mobile, ATM, Branch Channel )
        - Co-Relationid: integer
          Unique ID for the service invoked, will be set by the TXN system
        - InitiatingSystem: string
          Indicating the initiated system
        - ServiceMode: integer
          Used for branch channel to indicate the type of customer
        - UUIDSeqNo: integer
          UUID Sequence Number
        - entity: string
          entity
        - languageCode: integer
          languageCode
        - referenceId: string
          Place holder for Token based authentication
        - requesthash: string
          Request payload for hash validation
        - userId: integer
          userId
        
        
        """
        
        
        # Prepare request data
        
        # Single body parameter - send directly
        data = request_body if request_body is not None else {}
        
        
        
        # Prepare query parameters
        params = {}
        
        
        # Replace path parameters in URL
        path = "/loans/collateral/createMedicalClaimProceedCltrl"
        
        
        # Prepare headers
        headers = {}
        if accesstoken is not None:
            headers["Accesstoken"] = str(accesstoken)
        if channeltype is not None:
            headers["ChannelType"] = str(channeltype)
        if co_relationid is not None:
            headers["Co-Relationid"] = str(co_relationid)
        if initiatingsystem is not None:
            headers["InitiatingSystem"] = str(initiatingsystem)
        if servicemode is not None:
            headers["ServiceMode"] = str(servicemode)
        if uuidseqno is not None:
            headers["UUIDSeqNo"] = str(uuidseqno)
        if entity is not None:
            headers["entity"] = str(entity)
        if languagecode is not None:
            headers["languageCode"] = str(languagecode)
        if referenceid is not None:
            headers["referenceId"] = str(referenceid)
        if requesthash is not None:
            headers["requesthash"] = str(requesthash)
        if userid is not None:
            headers["userId"] = str(userid)
        
        
        return await make_api_request(
            "POST", 
            path, 
            data=data, 
            params=params if params else None, 
            headers=headers if headers else None
        )
    
    
    
    @mcp.tool()
    async def crbt6068_crt_multi_bonding_cltrl_postusing_post(
        request_body:Dict[str, Any] ,  # CLTRL_MASTER_CRBT6068CrtMultiBondingCltrl_Resource,
        accesstoken: Optional[str] = None,
        channeltype: Optional[int] = None,
        co_relationid: Optional[int] = None,
        initiatingsystem: Optional[str] = None,
        servicemode: Optional[int] = None,
        uuidseqno: Optional[int] = None,
        entity: Optional[str] = None,
        languagecode: Optional[int] = None,
        referenceid: Optional[str] = None,
        requesthash: Optional[str] = None,
        userid: Optional[int] = None
    ) -> Dict[str, Any]:
        """
        Create MultiBonding Proceed Collateral
        
        Generated from: POST /loans/collateral/createMultiBondingProceedCollateral
        Source: swagger_2_0
        Operation ID: CRBT6068CrtMultiBondingCltrl_POSTUsingPOST
        
        
        Authentication: Not required
        
        Parameters:
        - request_body: any (required)
          input
        
        
        
        Headers:
        - Accesstoken: string
          Authorization token for identification of the caller
        - ChannelType: integer
          Channel identifier from where the TXN has originated (Internet, Mobile, ATM, Branch Channel )
        - Co-Relationid: integer
          Unique ID for the service invoked, will be set by the TXN system
        - InitiatingSystem: string
          Indicating the initiated system
        - ServiceMode: integer
          Used for branch channel to indicate the type of customer
        - UUIDSeqNo: integer
          UUID Sequence Number
        - entity: string
          entity
        - languageCode: integer
          languageCode
        - referenceId: string
          Place holder for Token based authentication
        - requesthash: string
          Request payload for hash validation
        - userId: integer
          userId
        
        
        """
        
        
        # Prepare request data
        
        # Single body parameter - send directly
        data = request_body if request_body is not None else {}
        
        
        
        # Prepare query parameters
        params = {}
        
        
        # Replace path parameters in URL
        path = "/loans/collateral/createMultiBondingProceedCollateral"
        
        
        # Prepare headers
        headers = {}
        if accesstoken is not None:
            headers["Accesstoken"] = str(accesstoken)
        if channeltype is not None:
            headers["ChannelType"] = str(channeltype)
        if co_relationid is not None:
            headers["Co-Relationid"] = str(co_relationid)
        if initiatingsystem is not None:
            headers["InitiatingSystem"] = str(initiatingsystem)
        if servicemode is not None:
            headers["ServiceMode"] = str(servicemode)
        if uuidseqno is not None:
            headers["UUIDSeqNo"] = str(uuidseqno)
        if entity is not None:
            headers["entity"] = str(entity)
        if languagecode is not None:
            headers["languageCode"] = str(languagecode)
        if referenceid is not None:
            headers["referenceId"] = str(referenceid)
        if requesthash is not None:
            headers["requesthash"] = str(requesthash)
        if userid is not None:
            headers["userId"] = str(userid)
        
        
        return await make_api_request(
            "POST", 
            path, 
            data=data, 
            params=params if params else None, 
            headers=headers if headers else None
        )
    
    
    
    @mcp.tool()
    async def crbt1996_create_physical_asset_cltrl_postusing_post(
        request_body:Dict[str, Any] ,  # createPhysicalAssetCltrlRequest,
        accesstoken: Optional[str] = None,
        channeltype: Optional[int] = None,
        co_relationid: Optional[int] = None,
        initiatingsystem: Optional[str] = None,
        servicemode: Optional[int] = None,
        uuidseqno: Optional[int] = None,
        entity: Optional[str] = None,
        languagecode: Optional[int] = None,
        referenceid: Optional[str] = None,
        requesthash: Optional[str] = None,
        userid: Optional[int] = None
    ) -> Dict[str, Any]:
        """
        Create Physical Asset Collateral
        
        Generated from: POST /loans/collateral/createPhysicalAssetCltrl
        Source: swagger_2_0
        Operation ID: CRBT1996CreatePhysicalAssetCltrl_POSTUsingPOST
        
        
        Authentication: Not required
        
        Parameters:
        - request_body: any (required)
          input
        
        
        
        Headers:
        - Accesstoken: string
          Authorization token for identification of the caller
        - ChannelType: integer
          Channel identifier from where the TXN has originated (Internet, Mobile, ATM, Branch Channel )
        - Co-Relationid: integer
          Unique ID for the service invoked, will be set by the TXN system
        - InitiatingSystem: string
          Indicating the initiated system
        - ServiceMode: integer
          Used for branch channel to indicate the type of customer
        - UUIDSeqNo: integer
          UUID Sequence Number
        - entity: string
          entity
        - languageCode: integer
          languageCode
        - referenceId: string
          Place holder for Token based authentication
        - requesthash: string
          Request payload for hash validation
        - userId: integer
          userId
        
        
        """
        
        
        # Prepare request data
        
        # Single body parameter - send directly
        data = request_body if request_body is not None else {}
        
        
        
        # Prepare query parameters
        params = {}
        
        
        # Replace path parameters in URL
        path = "/loans/collateral/createPhysicalAssetCltrl"
        
        
        # Prepare headers
        headers = {}
        if accesstoken is not None:
            headers["Accesstoken"] = str(accesstoken)
        if channeltype is not None:
            headers["ChannelType"] = str(channeltype)
        if co_relationid is not None:
            headers["Co-Relationid"] = str(co_relationid)
        if initiatingsystem is not None:
            headers["InitiatingSystem"] = str(initiatingsystem)
        if servicemode is not None:
            headers["ServiceMode"] = str(servicemode)
        if uuidseqno is not None:
            headers["UUIDSeqNo"] = str(uuidseqno)
        if entity is not None:
            headers["entity"] = str(entity)
        if languagecode is not None:
            headers["languageCode"] = str(languagecode)
        if referenceid is not None:
            headers["referenceId"] = str(referenceid)
        if requesthash is not None:
            headers["requesthash"] = str(requesthash)
        if userid is not None:
            headers["userId"] = str(userid)
        
        
        return await make_api_request(
            "POST", 
            path, 
            data=data, 
            params=params if params else None, 
            headers=headers if headers else None
        )
    
    
    
    @mcp.tool()
    async def crbt6073_crt_pldge_of_llccltrl_postusing_post(
        request_body:Dict[str, Any] ,  # createPledgeOfLLCSharesCollateralResource,
        accesstoken: Optional[str] = None,
        channeltype: Optional[int] = None,
        co_relationid: Optional[int] = None,
        initiatingsystem: Optional[str] = None,
        servicemode: Optional[int] = None,
        uuidseqno: Optional[int] = None,
        entity: Optional[str] = None,
        languagecode: Optional[int] = None,
        referenceid: Optional[str] = None,
        requesthash: Optional[str] = None,
        userid: Optional[int] = None
    ) -> Dict[str, Any]:
        """
        Create Pledge of LLC Shares Collateral
        
        Generated from: POST /loans/collateral/createPledgeOfLLCSharesCollateral
        Source: swagger_2_0
        Operation ID: CRBT6073CrtPldgeOfLLCCltrl_POSTUsingPOST
        
        
        Authentication: Not required
        
        Parameters:
        - request_body: any (required)
          input
        
        
        
        Headers:
        - Accesstoken: string
          Authorization token for identification of the caller
        - ChannelType: integer
          Channel identifier from where the TXN has originated (Internet, Mobile, ATM, Branch Channel )
        - Co-Relationid: integer
          Unique ID for the service invoked, will be set by the TXN system
        - InitiatingSystem: string
          Indicating the initiated system
        - ServiceMode: integer
          Used for branch channel to indicate the type of customer
        - UUIDSeqNo: integer
          UUID Sequence Number
        - entity: string
          entity
        - languageCode: integer
          languageCode
        - referenceId: string
          Place holder for Token based authentication
        - requesthash: string
          Request payload for hash validation
        - userId: integer
          userId
        
        
        """
        
        
        # Prepare request data
        
        # Single body parameter - send directly
        data = request_body if request_body is not None else {}
        
        
        
        # Prepare query parameters
        params = {}
        
        
        # Replace path parameters in URL
        path = "/loans/collateral/createPledgeOfLLCSharesCollateral"
        
        
        # Prepare headers
        headers = {}
        if accesstoken is not None:
            headers["Accesstoken"] = str(accesstoken)
        if channeltype is not None:
            headers["ChannelType"] = str(channeltype)
        if co_relationid is not None:
            headers["Co-Relationid"] = str(co_relationid)
        if initiatingsystem is not None:
            headers["InitiatingSystem"] = str(initiatingsystem)
        if servicemode is not None:
            headers["ServiceMode"] = str(servicemode)
        if uuidseqno is not None:
            headers["UUIDSeqNo"] = str(uuidseqno)
        if entity is not None:
            headers["entity"] = str(entity)
        if languagecode is not None:
            headers["languageCode"] = str(languagecode)
        if referenceid is not None:
            headers["referenceId"] = str(referenceid)
        if requesthash is not None:
            headers["requesthash"] = str(requesthash)
        if userid is not None:
            headers["userId"] = str(userid)
        
        
        return await make_api_request(
            "POST", 
            path, 
            data=data, 
            params=params if params else None, 
            headers=headers if headers else None
        )
    
    
    
    @mcp.tool()
    async def crbt6074_crt_prchs_ordr_cltrl_using_post(
        request_body:Dict[str, Any] ,  # crtPrchsOrdrCltrlResource,
        accesstoken: Optional[str] = None,
        channeltype: Optional[int] = None,
        co_relationid: Optional[int] = None,
        initiatingsystem: Optional[str] = None,
        servicemode: Optional[int] = None,
        uuidseqno: Optional[int] = None,
        entity: Optional[str] = None,
        languagecode: Optional[int] = None,
        referenceid: Optional[str] = None,
        requesthash: Optional[str] = None,
        userid: Optional[int] = None
    ) -> Dict[str, Any]:
        """
        Create Purchase Order Proceed Collateral
        
        Generated from: POST /loans/collateral/createPurchaseOrderProceedCollateral
        Source: swagger_2_0
        Operation ID: CRBT6074CrtPrchsOrdrCltrlUsingPOST
        
        
        Authentication: Not required
        
        Parameters:
        - request_body: any (required)
          input
        
        
        
        Headers:
        - Accesstoken: string
          Authorization token for identification of the caller
        - ChannelType: integer
          Channel identifier from where the TXN has originated (Internet, Mobile, ATM, Branch Channel )
        - Co-Relationid: integer
          Unique ID for the service invoked, will be set by the TXN system
        - InitiatingSystem: string
          Indicating the initiated system
        - ServiceMode: integer
          Used for branch channel to indicate the type of customer
        - UUIDSeqNo: integer
          UUID Sequence Number
        - entity: string
          entity
        - languageCode: integer
          languageCode
        - referenceId: string
          Place holder for Token based authentication
        - requesthash: string
          Request payload for hash validation
        - userId: integer
          userId
        
        
        """
        
        
        # Prepare request data
        
        # Single body parameter - send directly
        data = request_body if request_body is not None else {}
        
        
        
        # Prepare query parameters
        params = {}
        
        
        # Replace path parameters in URL
        path = "/loans/collateral/createPurchaseOrderProceedCollateral"
        
        
        # Prepare headers
        headers = {}
        if accesstoken is not None:
            headers["Accesstoken"] = str(accesstoken)
        if channeltype is not None:
            headers["ChannelType"] = str(channeltype)
        if co_relationid is not None:
            headers["Co-Relationid"] = str(co_relationid)
        if initiatingsystem is not None:
            headers["InitiatingSystem"] = str(initiatingsystem)
        if servicemode is not None:
            headers["ServiceMode"] = str(servicemode)
        if uuidseqno is not None:
            headers["UUIDSeqNo"] = str(uuidseqno)
        if entity is not None:
            headers["entity"] = str(entity)
        if languagecode is not None:
            headers["languageCode"] = str(languagecode)
        if referenceid is not None:
            headers["referenceId"] = str(referenceid)
        if requesthash is not None:
            headers["requesthash"] = str(requesthash)
        if userid is not None:
            headers["userId"] = str(userid)
        
        
        return await make_api_request(
            "POST", 
            path, 
            data=data, 
            params=params if params else None, 
            headers=headers if headers else None
        )
    
    
    
    @mcp.tool()
    async def crbt6066_crt_rcvbl_proceed_cltrl_postusing_post(
        request_body:Dict[str, Any] ,  # crtRcvblProceedCltrlResource,
        accesstoken: Optional[str] = None,
        channeltype: Optional[int] = None,
        co_relationid: Optional[int] = None,
        initiatingsystem: Optional[str] = None,
        servicemode: Optional[int] = None,
        uuidseqno: Optional[int] = None,
        entity: Optional[str] = None,
        languagecode: Optional[int] = None,
        referenceid: Optional[str] = None,
        requesthash: Optional[str] = None,
        userid: Optional[int] = None
    ) -> Dict[str, Any]:
        """
        Create Receivable Proceed Collateral
        
        Generated from: POST /loans/collateral/createReceivableProceedCollateral
        Source: swagger_2_0
        Operation ID: CRBT6066CrtRcvblProceedCltrl_POSTUsingPOST
        
        
        Authentication: Not required
        
        Parameters:
        - request_body: any (required)
          input
        
        
        
        Headers:
        - Accesstoken: string
          Authorization token for identification of the caller
        - ChannelType: integer
          Channel identifier from where the TXN has originated (Internet, Mobile, ATM, Branch Channel )
        - Co-Relationid: integer
          Unique ID for the service invoked, will be set by the TXN system
        - InitiatingSystem: string
          Indicating the initiated system
        - ServiceMode: integer
          Used for branch channel to indicate the type of customer
        - UUIDSeqNo: integer
          UUID Sequence Number
        - entity: string
          entity
        - languageCode: integer
          languageCode
        - referenceId: string
          Place holder for Token based authentication
        - requesthash: string
          Request payload for hash validation
        - userId: integer
          userId
        
        
        """
        
        
        # Prepare request data
        
        # Single body parameter - send directly
        data = request_body if request_body is not None else {}
        
        
        
        # Prepare query parameters
        params = {}
        
        
        # Replace path parameters in URL
        path = "/loans/collateral/createReceivableProceedCollateral"
        
        
        # Prepare headers
        headers = {}
        if accesstoken is not None:
            headers["Accesstoken"] = str(accesstoken)
        if channeltype is not None:
            headers["ChannelType"] = str(channeltype)
        if co_relationid is not None:
            headers["Co-Relationid"] = str(co_relationid)
        if initiatingsystem is not None:
            headers["InitiatingSystem"] = str(initiatingsystem)
        if servicemode is not None:
            headers["ServiceMode"] = str(servicemode)
        if uuidseqno is not None:
            headers["UUIDSeqNo"] = str(uuidseqno)
        if entity is not None:
            headers["entity"] = str(entity)
        if languagecode is not None:
            headers["languageCode"] = str(languagecode)
        if referenceid is not None:
            headers["referenceId"] = str(referenceid)
        if requesthash is not None:
            headers["requesthash"] = str(requesthash)
        if userid is not None:
            headers["userId"] = str(userid)
        
        
        return await make_api_request(
            "POST", 
            path, 
            data=data, 
            params=params if params else None, 
            headers=headers if headers else None
        )
    
    
    
    @mcp.tool()
    async def crbt6068_crt_rental_proceed_cltrl_postusing_post(
        request_body:Dict[str, Any] ,  # crtRentalProceedCltrlrequest,
        accesstoken: Optional[str] = None,
        channeltype: Optional[int] = None,
        co_relationid: Optional[int] = None,
        initiatingsystem: Optional[str] = None,
        servicemode: Optional[int] = None,
        uuidseqno: Optional[int] = None,
        entity: Optional[str] = None,
        languagecode: Optional[int] = None,
        referenceid: Optional[str] = None,
        requesthash: Optional[str] = None,
        userid: Optional[int] = None
    ) -> Dict[str, Any]:
        """
        Create Rental Proceed Collateral
        
        Generated from: POST /loans/collateral/createRentalProceedCltrl
        Source: swagger_2_0
        Operation ID: CRBT6068CrtRentalProceedCltrl_POSTUsingPOST
        
        
        Authentication: Not required
        
        Parameters:
        - request_body: any (required)
          input
        
        
        
        Headers:
        - Accesstoken: string
          Authorization token for identification of the caller
        - ChannelType: integer
          Channel identifier from where the TXN has originated (Internet, Mobile, ATM, Branch Channel )
        - Co-Relationid: integer
          Unique ID for the service invoked, will be set by the TXN system
        - InitiatingSystem: string
          Indicating the initiated system
        - ServiceMode: integer
          Used for branch channel to indicate the type of customer
        - UUIDSeqNo: integer
          UUID Sequence Number
        - entity: string
          entity
        - languageCode: integer
          languageCode
        - referenceId: string
          Place holder for Token based authentication
        - requesthash: string
          Request payload for hash validation
        - userId: integer
          userId
        
        
        """
        
        
        # Prepare request data
        
        # Single body parameter - send directly
        data = request_body if request_body is not None else {}
        
        
        
        # Prepare query parameters
        params = {}
        
        
        # Replace path parameters in URL
        path = "/loans/collateral/createRentalProceedCltrl"
        
        
        # Prepare headers
        headers = {}
        if accesstoken is not None:
            headers["Accesstoken"] = str(accesstoken)
        if channeltype is not None:
            headers["ChannelType"] = str(channeltype)
        if co_relationid is not None:
            headers["Co-Relationid"] = str(co_relationid)
        if initiatingsystem is not None:
            headers["InitiatingSystem"] = str(initiatingsystem)
        if servicemode is not None:
            headers["ServiceMode"] = str(servicemode)
        if uuidseqno is not None:
            headers["UUIDSeqNo"] = str(uuidseqno)
        if entity is not None:
            headers["entity"] = str(entity)
        if languagecode is not None:
            headers["languageCode"] = str(languagecode)
        if referenceid is not None:
            headers["referenceId"] = str(referenceid)
        if requesthash is not None:
            headers["requesthash"] = str(requesthash)
        if userid is not None:
            headers["userId"] = str(userid)
        
        
        return await make_api_request(
            "POST", 
            path, 
            data=data, 
            params=params if params else None, 
            headers=headers if headers else None
        )
    
    
    
    @mcp.tool()
    async def crbt6068_crt_salary_proceed_cltrl_postusing_post(
        request_body:Dict[str, Any] ,  # CrtSalaryProceedCltrlrequest,
        accesstoken: Optional[str] = None,
        channeltype: Optional[int] = None,
        co_relationid: Optional[int] = None,
        initiatingsystem: Optional[str] = None,
        servicemode: Optional[int] = None,
        uuidseqno: Optional[int] = None,
        entity: Optional[str] = None,
        languagecode: Optional[int] = None,
        referenceid: Optional[str] = None,
        requesthash: Optional[str] = None,
        userid: Optional[int] = None
    ) -> Dict[str, Any]:
        """
        Create Salary Proceed Collateral
        
        Generated from: POST /loans/collateral/createSalaryProceedCollateral
        Source: swagger_2_0
        Operation ID: CRBT6068CrtSalaryProceedCltrl_POSTUsingPOST
        
        
        Authentication: Not required
        
        Parameters:
        - request_body: any (required)
          input
        
        
        
        Headers:
        - Accesstoken: string
          Authorization token for identification of the caller
        - ChannelType: integer
          Channel identifier from where the TXN has originated (Internet, Mobile, ATM, Branch Channel )
        - Co-Relationid: integer
          Unique ID for the service invoked, will be set by the TXN system
        - InitiatingSystem: string
          Indicating the initiated system
        - ServiceMode: integer
          Used for branch channel to indicate the type of customer
        - UUIDSeqNo: integer
          UUID Sequence Number
        - entity: string
          entity
        - languageCode: integer
          languageCode
        - referenceId: string
          Place holder for Token based authentication
        - requesthash: string
          Request payload for hash validation
        - userId: integer
          userId
        
        
        """
        
        
        # Prepare request data
        
        # Single body parameter - send directly
        data = request_body if request_body is not None else {}
        
        
        
        # Prepare query parameters
        params = {}
        
        
        # Replace path parameters in URL
        path = "/loans/collateral/createSalaryProceedCollateral"
        
        
        # Prepare headers
        headers = {}
        if accesstoken is not None:
            headers["Accesstoken"] = str(accesstoken)
        if channeltype is not None:
            headers["ChannelType"] = str(channeltype)
        if co_relationid is not None:
            headers["Co-Relationid"] = str(co_relationid)
        if initiatingsystem is not None:
            headers["InitiatingSystem"] = str(initiatingsystem)
        if servicemode is not None:
            headers["ServiceMode"] = str(servicemode)
        if uuidseqno is not None:
            headers["UUIDSeqNo"] = str(uuidseqno)
        if entity is not None:
            headers["entity"] = str(entity)
        if languagecode is not None:
            headers["languageCode"] = str(languagecode)
        if referenceid is not None:
            headers["referenceId"] = str(referenceid)
        if requesthash is not None:
            headers["requesthash"] = str(requesthash)
        if userid is not None:
            headers["userId"] = str(userid)
        
        
        return await make_api_request(
            "POST", 
            path, 
            data=data, 
            params=params if params else None, 
            headers=headers if headers else None
        )
    
    
    
    @mcp.tool()
    async def crbt1830_create_shr_bnd_dtls_postusing_post_1(
        request_body:Dict[str, Any] ,  # createShrBndDtlsRequest,
        accesstoken: Optional[str] = None,
        channeltype: Optional[int] = None,
        co_relationid: Optional[int] = None,
        initiatingsystem: Optional[str] = None,
        servicemode: Optional[int] = None,
        uuidseqno: Optional[int] = None,
        entity: Optional[str] = None,
        languagecode: Optional[int] = None,
        referenceid: Optional[str] = None,
        requesthash: Optional[str] = None,
        userid: Optional[int] = None
    ) -> Dict[str, Any]:
        """
        Create share and bond collateral
        
        Generated from: POST /loans/collateral/createShareAndBondCltrl
        Source: swagger_2_0
        Operation ID: CRBT1830CreateShrBndDtls_POSTUsingPOST_1
        
        
        Authentication: Not required
        
        Parameters:
        - request_body: any (required)
          input
        
        
        
        Headers:
        - Accesstoken: string
          Authorization token for identification of the caller
        - ChannelType: integer
          Channel identifier from where the TXN has originated (Internet, Mobile, ATM, Branch Channel )
        - Co-Relationid: integer
          Unique ID for the service invoked, will be set by the TXN system
        - InitiatingSystem: string
          Indicating the initiated system
        - ServiceMode: integer
          Used for branch channel to indicate the type of customer
        - UUIDSeqNo: integer
          UUID Sequence Number
        - entity: string
          entity
        - languageCode: integer
          languageCode
        - referenceId: string
          Place holder for Token based authentication
        - requesthash: string
          Request payload for hash validation
        - userId: integer
          userId
        
        
        """
        
        
        # Prepare request data
        
        # Single body parameter - send directly
        data = request_body if request_body is not None else {}
        
        
        
        # Prepare query parameters
        params = {}
        
        
        # Replace path parameters in URL
        path = "/loans/collateral/createShareAndBondCltrl"
        
        
        # Prepare headers
        headers = {}
        if accesstoken is not None:
            headers["Accesstoken"] = str(accesstoken)
        if channeltype is not None:
            headers["ChannelType"] = str(channeltype)
        if co_relationid is not None:
            headers["Co-Relationid"] = str(co_relationid)
        if initiatingsystem is not None:
            headers["InitiatingSystem"] = str(initiatingsystem)
        if servicemode is not None:
            headers["ServiceMode"] = str(servicemode)
        if uuidseqno is not None:
            headers["UUIDSeqNo"] = str(uuidseqno)
        if entity is not None:
            headers["entity"] = str(entity)
        if languagecode is not None:
            headers["languageCode"] = str(languagecode)
        if referenceid is not None:
            headers["referenceId"] = str(referenceid)
        if requesthash is not None:
            headers["requesthash"] = str(requesthash)
        if userid is not None:
            headers["userId"] = str(userid)
        
        
        return await make_api_request(
            "POST", 
            path, 
            data=data, 
            params=params if params else None, 
            headers=headers if headers else None
        )
    
    
    
    @mcp.tool()
    async def crbt1815_create_grnte_cltrl_using_post_1(
        request_body:Dict[str, Any] ,  # CLTRL_MASTER_CRBT1815CreateGrnteCltrl_Resource,
        accesstoken: Optional[str] = None,
        channeltype: Optional[int] = None,
        co_relationid: Optional[int] = None,
        initiatingsystem: Optional[str] = None,
        servicemode: Optional[int] = None,
        uuidseqno: Optional[int] = None,
        entity: Optional[str] = None,
        languagecode: Optional[int] = None,
        referenceid: Optional[str] = None,
        requesthash: Optional[str] = None,
        userid: Optional[int] = None
    ) -> Dict[str, Any]:
        """
        Create Guarantee Collatarel
        
        Generated from: POST /loans/collateral/guarantee/create
        Source: swagger_2_0
        Operation ID: CRBT1815CreateGrnteCltrlUsingPOST_1
        
        
        Authentication: Not required
        
        Parameters:
        - request_body: any (required)
          input
        
        
        
        Headers:
        - Accesstoken: string
          Authorization token for identification of the caller
        - ChannelType: integer
          Channel identifier from where the TXN has originated (Internet, Mobile, ATM, Branch Channel )
        - Co-Relationid: integer
          Unique ID for the service invoked, will be set by the TXN system
        - InitiatingSystem: string
          Indicating the initiated system
        - ServiceMode: integer
          Used for branch channel to indicate the type of customer
        - UUIDSeqNo: integer
          UUID Sequence Number
        - entity: string
          entity
        - languageCode: integer
          languageCode
        - referenceId: string
          Place holder for Token based authentication
        - requesthash: string
          Request payload for hash validation
        - userId: integer
          userId
        
        
        """
        
        
        # Prepare request data
        
        # Single body parameter - send directly
        data = request_body if request_body is not None else {}
        
        
        
        # Prepare query parameters
        params = {}
        
        
        # Replace path parameters in URL
        path = "/loans/collateral/guarantee/create"
        
        
        # Prepare headers
        headers = {}
        if accesstoken is not None:
            headers["Accesstoken"] = str(accesstoken)
        if channeltype is not None:
            headers["ChannelType"] = str(channeltype)
        if co_relationid is not None:
            headers["Co-Relationid"] = str(co_relationid)
        if initiatingsystem is not None:
            headers["InitiatingSystem"] = str(initiatingsystem)
        if servicemode is not None:
            headers["ServiceMode"] = str(servicemode)
        if uuidseqno is not None:
            headers["UUIDSeqNo"] = str(uuidseqno)
        if entity is not None:
            headers["entity"] = str(entity)
        if languagecode is not None:
            headers["languageCode"] = str(languagecode)
        if referenceid is not None:
            headers["referenceId"] = str(referenceid)
        if requesthash is not None:
            headers["requesthash"] = str(requesthash)
        if userid is not None:
            headers["userId"] = str(userid)
        
        
        return await make_api_request(
            "POST", 
            path, 
            data=data, 
            params=params if params else None, 
            headers=headers if headers else None
        )
    
    
    
    @mcp.tool()
    async def crbt0101_guarantee_modification_wrapper_postusing_post(
        request_body:Dict[str, Any] ,  # CollateralGuaranteeModificationRequest,
        accesstoken: Optional[str] = None,
        channeltype: Optional[int] = None,
        co_relationid: Optional[int] = None,
        initiatingsystem: Optional[str] = None,
        servicemode: Optional[int] = None,
        uuidseqno: Optional[int] = None,
        entity: Optional[str] = None,
        languagecode: Optional[int] = None,
        referenceid: Optional[str] = None,
        requesthash: Optional[str] = None,
        userid: Optional[int] = None
    ) -> Dict[str, Any]:
        """
        GuaranteeCollateralModification
        
        Generated from: POST /loans/collateral/guarantee/update
        Source: swagger_2_0
        Operation ID: CRBT0101GuaranteeModificationWrapper_POSTUsingPOST
        
        
        Authentication: Not required
        
        Parameters:
        - request_body: any (required)
          input
        
        
        
        Headers:
        - Accesstoken: string
          Authorization token for identification of the caller
        - ChannelType: integer
          Channel identifier from where the TXN has originated (Internet, Mobile, ATM, Branch Channel )
        - Co-Relationid: integer
          Unique ID for the service invoked, will be set by the TXN system
        - InitiatingSystem: string
          Indicating the initiated system
        - ServiceMode: integer
          Used for branch channel to indicate the type of customer
        - UUIDSeqNo: integer
          UUID Sequence Number
        - entity: string
          entity
        - languageCode: integer
          languageCode
        - referenceId: string
          Place holder for Token based authentication
        - requesthash: string
          Request payload for hash validation
        - userId: integer
          userId
        
        
        """
        
        
        # Prepare request data
        
        # Single body parameter - send directly
        data = request_body if request_body is not None else {}
        
        
        
        # Prepare query parameters
        params = {}
        
        
        # Replace path parameters in URL
        path = "/loans/collateral/guarantee/update"
        
        
        # Prepare headers
        headers = {}
        if accesstoken is not None:
            headers["Accesstoken"] = str(accesstoken)
        if channeltype is not None:
            headers["ChannelType"] = str(channeltype)
        if co_relationid is not None:
            headers["Co-Relationid"] = str(co_relationid)
        if initiatingsystem is not None:
            headers["InitiatingSystem"] = str(initiatingsystem)
        if servicemode is not None:
            headers["ServiceMode"] = str(servicemode)
        if uuidseqno is not None:
            headers["UUIDSeqNo"] = str(uuidseqno)
        if entity is not None:
            headers["entity"] = str(entity)
        if languagecode is not None:
            headers["languageCode"] = str(languagecode)
        if referenceid is not None:
            headers["referenceId"] = str(referenceid)
        if requesthash is not None:
            headers["requesthash"] = str(requesthash)
        if userid is not None:
            headers["userId"] = str(userid)
        
        
        return await make_api_request(
            "POST", 
            path, 
            data=data, 
            params=params if params else None, 
            headers=headers if headers else None
        )
    
    
    
    @mcp.tool()
    async def cret1815_view_grnte_cltrl_getusing_get(
        collateralreference: int,
        accesstoken: Optional[str] = None,
        channeltype: Optional[int] = None,
        co_relationid: Optional[int] = None,
        initiatingsystem: Optional[str] = None,
        servicemode: Optional[int] = None,
        uuidseqno: Optional[int] = None,
        entity: Optional[str] = None,
        languagecode: Optional[int] = None,
        referenceid: Optional[str] = None,
        requesthash: Optional[str] = None,
        userid: Optional[int] = None
    ) -> Dict[str, Any]:
        """
        View Guarantee Collateral Details
        
        Generated from: GET /loans/collateral/guarantee/view{collateralReference}
        Source: swagger_2_0
        Operation ID: CRET1815ViewGrnteCltrl_GETUsingGET
        
        
        Authentication: Not required
        
        Parameters:
        - collateralReference: integer (required)
          System generated unique reference of collateral
        
        
        
        Headers:
        - Accesstoken: string
          Authorization token for identification of the caller
        - ChannelType: integer
          Channel identifier from where the TXN has originated (Internet, Mobile, ATM, Branch Channel )
        - Co-Relationid: integer
          Unique ID for the service invoked, will be set by the TXN system
        - InitiatingSystem: string
          Indicating the initiated system
        - ServiceMode: integer
          Used for branch channel to indicate the type of customer
        - UUIDSeqNo: integer
          UUID Sequence Number
        - entity: string
          entity
        - languageCode: integer
          languageCode
        - referenceId: string
          Place holder for Token based authentication
        - requesthash: string
          Request payload for hash validation
        - userId: integer
          userId
        
        
        """
        
        
        # Prepare query parameters
        params = {}
        
        
        # Replace path parameters in URL
        path = "/loans/collateral/guarantee/view{collateralReference}"
        if collateralreference is not None:
            path = path.replace("{collateralReference}", str(collateralreference))
        
        
        # Prepare headers
        headers = {}
        if accesstoken is not None:
            headers["Accesstoken"] = str(accesstoken)
        if channeltype is not None:
            headers["ChannelType"] = str(channeltype)
        if co_relationid is not None:
            headers["Co-Relationid"] = str(co_relationid)
        if initiatingsystem is not None:
            headers["InitiatingSystem"] = str(initiatingsystem)
        if servicemode is not None:
            headers["ServiceMode"] = str(servicemode)
        if uuidseqno is not None:
            headers["UUIDSeqNo"] = str(uuidseqno)
        if entity is not None:
            headers["entity"] = str(entity)
        if languagecode is not None:
            headers["languageCode"] = str(languagecode)
        if referenceid is not None:
            headers["referenceId"] = str(referenceid)
        if requesthash is not None:
            headers["requesthash"] = str(requesthash)
        if userid is not None:
            headers["userId"] = str(userid)
        
        
        return await make_api_request(
            "GET", 
            path, 
            
            params=params if params else None, 
            headers=headers if headers else None
        )
    
    
    
    @mcp.tool()
    async def crbt2019_create_insrnc_cltrl_postusing_post(
        request_body:Dict[str, Any] ,  # CollateralInsuranceAndValueDocCreateRequest,
        entity: Optional[str] = None,
        languagecode: Optional[int] = None
    ) -> Dict[str, Any]:
        """
        Create Insurance Collatarel
        
        Generated from: POST /loans/collateral/insuranceandvaluedoc/create
        Source: swagger_2_0
        Operation ID: CRBT2019CreateInsrncCltrl_POSTUsingPOST
        
        
        Authentication: Not required
        
        Parameters:
        - request_body: any (required)
          input
        
        
        
        Headers:
        - entity: string
          entity
        - languageCode: integer
          languageCode
        
        
        """
        
        
        # Prepare request data
        
        # Single body parameter - send directly
        data = request_body if request_body is not None else {}
        
        
        
        # Prepare query parameters
        params = {}
        
        
        # Replace path parameters in URL
        path = "/loans/collateral/insuranceandvaluedoc/create"
        
        
        # Prepare headers
        headers = {}
        if entity is not None:
            headers["entity"] = str(entity)
        if languagecode is not None:
            headers["languageCode"] = str(languagecode)
        
        
        return await make_api_request(
            "POST", 
            path, 
            data=data, 
            params=params if params else None, 
            headers=headers if headers else None
        )
    
    
    
    @mcp.tool()
    async def crbt0101_insrnc_value_doc_modification_wrapper_postusing_post(
        request_body:Dict[str, Any] ,  # CollateralInsuranceAndValueDocModifyRequest,
        entity: Optional[str] = None,
        languagecode: Optional[int] = None,
        runmode: Optional[int] = None,
        userid: Optional[int] = None
    ) -> Dict[str, Any]:
        """
        InsuranceAndValueDocCollateralModification
        
        Generated from: POST /loans/collateral/insuranceandvaluedoc/update
        Source: swagger_2_0
        Operation ID: CRBT0101InsrncValueDocModificationWrapper_POSTUsingPOST
        
        
        Authentication: Not required
        
        Parameters:
        - request_body: any (required)
          input
        
        
        
        Headers:
        - entity: string
          entity
        - languageCode: integer
          languageCode
        - runMode: integer
          runMode
        - userId: integer
          userId
        
        
        """
        
        
        # Prepare request data
        
        # Single body parameter - send directly
        data = request_body if request_body is not None else {}
        
        
        
        # Prepare query parameters
        params = {}
        
        
        # Replace path parameters in URL
        path = "/loans/collateral/insuranceandvaluedoc/update"
        
        
        # Prepare headers
        headers = {}
        if entity is not None:
            headers["entity"] = str(entity)
        if languagecode is not None:
            headers["languageCode"] = str(languagecode)
        if runmode is not None:
            headers["runMode"] = str(runmode)
        if userid is not None:
            headers["userId"] = str(userid)
        
        
        return await make_api_request(
            "POST", 
            path, 
            data=data, 
            params=params if params else None, 
            headers=headers if headers else None
        )
    
    
    
    @mcp.tool()
    async def cret2019_fetch_insrnc_cltrl_using_get_1(
        collateralreference: int,
        accesstoken: Optional[str] = None,
        channeltype: Optional[int] = None,
        co_relationid: Optional[int] = None,
        initiatingsystem: Optional[str] = None,
        servicemode: Optional[int] = None,
        uuidseqno: Optional[int] = None,
        entity: Optional[str] = None,
        languagecode: Optional[int] = None,
        referenceid: Optional[str] = None,
        requesthash: Optional[str] = None,
        userid: Optional[int] = None
    ) -> Dict[str, Any]:
        """
        CollateralInsuranceView
        
        Generated from: GET /loans/collateral/insuranceandvaluedoc/{collateralReference}
        Source: swagger_2_0
        Operation ID: CRET2019FetchInsrncCltrlUsingGET_1
        
        
        Authentication: Not required
        
        Parameters:
        - collateralReference: integer (required)
          System generated unique reference of collateral
        
        
        
        Headers:
        - Accesstoken: string
          Authorization token for identification of the caller
        - ChannelType: integer
          Channel identifier from where the TXN has originated (Internet, Mobile, ATM, Branch Channel )
        - Co-Relationid: integer
          Unique ID for the service invoked, will be set by the TXN system
        - InitiatingSystem: string
          Indicating the initiated system
        - ServiceMode: integer
          Used for branch channel to indicate the type of customer
        - UUIDSeqNo: integer
          UUID Sequence Number
        - entity: string
          entity
        - languageCode: integer
          languageCode
        - referenceId: string
          Place holder for Token based authentication
        - requesthash: string
          Request payload for hash validation
        - userId: integer
          userId
        
        
        """
        
        
        # Prepare query parameters
        params = {}
        
        
        # Replace path parameters in URL
        path = "/loans/collateral/insuranceandvaluedoc/{collateralReference}"
        if collateralreference is not None:
            path = path.replace("{collateralReference}", str(collateralreference))
        
        
        # Prepare headers
        headers = {}
        if accesstoken is not None:
            headers["Accesstoken"] = str(accesstoken)
        if channeltype is not None:
            headers["ChannelType"] = str(channeltype)
        if co_relationid is not None:
            headers["Co-Relationid"] = str(co_relationid)
        if initiatingsystem is not None:
            headers["InitiatingSystem"] = str(initiatingsystem)
        if servicemode is not None:
            headers["ServiceMode"] = str(servicemode)
        if uuidseqno is not None:
            headers["UUIDSeqNo"] = str(uuidseqno)
        if entity is not None:
            headers["entity"] = str(entity)
        if languagecode is not None:
            headers["languageCode"] = str(languagecode)
        if referenceid is not None:
            headers["referenceId"] = str(referenceid)
        if requesthash is not None:
            headers["requesthash"] = str(requesthash)
        if userid is not None:
            headers["userId"] = str(userid)
        
        
        return await make_api_request(
            "GET", 
            path, 
            
            params=params if params else None, 
            headers=headers if headers else None
        )
    
    
    
    @mcp.tool()
    async def crbt6064_contract_proceed_modification_wrapper_postusing_post(
        request_body:Dict[str, Any] ,  # CLTRL_MASTER_CRBT6064ContractProceedModificationWrapper_Resource,
        accesstoken: Optional[str] = None,
        channeltype: Optional[int] = None,
        co_relationid: Optional[int] = None,
        initiatingsystem: Optional[str] = None,
        servicemode: Optional[int] = None,
        uuidseqno: Optional[int] = None,
        entity: Optional[str] = None,
        languagecode: Optional[int] = None,
        referenceid: Optional[str] = None,
        requesthash: Optional[str] = None,
        userid: Optional[int] = None
    ) -> Dict[str, Any]:
        """
        modify Contract Proceed Collateral
        
        Generated from: POST /loans/collateral/modifyContractProceedCollateral
        Source: swagger_2_0
        Operation ID: CRBT6064ContractProceedModificationWrapper_POSTUsingPOST
        
        
        Authentication: Not required
        
        Parameters:
        - request_body: any (required)
          input
        
        
        
        Headers:
        - Accesstoken: string
          Authorization token for identification of the caller
        - ChannelType: integer
          Channel identifier from where the TXN has originated (Internet, Mobile, ATM, Branch Channel )
        - Co-Relationid: integer
          Unique ID for the service invoked, will be set by the TXN system
        - InitiatingSystem: string
          Indicating the initiated system
        - ServiceMode: integer
          Used for branch channel to indicate the type of customer
        - UUIDSeqNo: integer
          UUID Sequence Number
        - entity: string
          entity
        - languageCode: integer
          languageCode
        - referenceId: string
          Place holder for Token based authentication
        - requesthash: string
          Request payload for hash validation
        - userId: integer
          userId
        
        
        """
        
        
        # Prepare request data
        
        # Single body parameter - send directly
        data = request_body if request_body is not None else {}
        
        
        
        # Prepare query parameters
        params = {}
        
        
        # Replace path parameters in URL
        path = "/loans/collateral/modifyContractProceedCollateral"
        
        
        # Prepare headers
        headers = {}
        if accesstoken is not None:
            headers["Accesstoken"] = str(accesstoken)
        if channeltype is not None:
            headers["ChannelType"] = str(channeltype)
        if co_relationid is not None:
            headers["Co-Relationid"] = str(co_relationid)
        if initiatingsystem is not None:
            headers["InitiatingSystem"] = str(initiatingsystem)
        if servicemode is not None:
            headers["ServiceMode"] = str(servicemode)
        if uuidseqno is not None:
            headers["UUIDSeqNo"] = str(uuidseqno)
        if entity is not None:
            headers["entity"] = str(entity)
        if languagecode is not None:
            headers["languageCode"] = str(languagecode)
        if referenceid is not None:
            headers["referenceId"] = str(referenceid)
        if requesthash is not None:
            headers["requesthash"] = str(requesthash)
        if userid is not None:
            headers["userId"] = str(userid)
        
        
        return await make_api_request(
            "POST", 
            path, 
            data=data, 
            params=params if params else None, 
            headers=headers if headers else None
        )
    
    
    
    @mcp.tool()
    async def crbt6068_dividend_proceed_modification_wrapper_postusing_post(
        request_body:Dict[str, Any] ,  # dividendProceedModificationWrapperResource,
        accesstoken: Optional[str] = None,
        channeltype: Optional[int] = None,
        co_relationid: Optional[int] = None,
        initiatingsystem: Optional[str] = None,
        servicemode: Optional[int] = None,
        uuidseqno: Optional[int] = None,
        entity: Optional[str] = None,
        languagecode: Optional[int] = None,
        referenceid: Optional[str] = None,
        requesthash: Optional[str] = None,
        userid: Optional[int] = None
    ) -> Dict[str, Any]:
        """
        Modify Dividend and cash Distribution Proceed Collateral
        
        Generated from: POST /loans/collateral/modifyDividendcashProceedCltrl
        Source: swagger_2_0
        Operation ID: CRBT6068DividendProceedModificationWrapper_POSTUsingPOST
        
        
        Authentication: Not required
        
        Parameters:
        - request_body: any (required)
          input
        
        
        
        Headers:
        - Accesstoken: string
          Authorization token for identification of the caller
        - ChannelType: integer
          Channel identifier from where the TXN has originated (Internet, Mobile, ATM, Branch Channel )
        - Co-Relationid: integer
          Unique ID for the service invoked, will be set by the TXN system
        - InitiatingSystem: string
          Indicating the initiated system
        - ServiceMode: integer
          Used for branch channel to indicate the type of customer
        - UUIDSeqNo: integer
          UUID Sequence Number
        - entity: string
          entity
        - languageCode: integer
          languageCode
        - referenceId: string
          Place holder for Token based authentication
        - requesthash: string
          Request payload for hash validation
        - userId: integer
          userId
        
        
        """
        
        
        # Prepare request data
        
        # Single body parameter - send directly
        data = request_body if request_body is not None else {}
        
        
        
        # Prepare query parameters
        params = {}
        
        
        # Replace path parameters in URL
        path = "/loans/collateral/modifyDividendcashProceedCltrl"
        
        
        # Prepare headers
        headers = {}
        if accesstoken is not None:
            headers["Accesstoken"] = str(accesstoken)
        if channeltype is not None:
            headers["ChannelType"] = str(channeltype)
        if co_relationid is not None:
            headers["Co-Relationid"] = str(co_relationid)
        if initiatingsystem is not None:
            headers["InitiatingSystem"] = str(initiatingsystem)
        if servicemode is not None:
            headers["ServiceMode"] = str(servicemode)
        if uuidseqno is not None:
            headers["UUIDSeqNo"] = str(uuidseqno)
        if entity is not None:
            headers["entity"] = str(entity)
        if languagecode is not None:
            headers["languageCode"] = str(languagecode)
        if referenceid is not None:
            headers["referenceId"] = str(referenceid)
        if requesthash is not None:
            headers["requesthash"] = str(requesthash)
        if userid is not None:
            headers["userId"] = str(userid)
        
        
        return await make_api_request(
            "POST", 
            path, 
            data=data, 
            params=params if params else None, 
            headers=headers if headers else None
        )
    
    
    
    @mcp.tool()
    async def crbt6073_div_frm_llcmodification_wrapper_postusing_post(
        request_body:Dict[str, Any] ,  # CLTRL_MASTER_CRBT6073DivFrmLLCModificationWrapper_Resource,
        accesstoken: Optional[str] = None,
        channeltype: Optional[int] = None,
        co_relationid: Optional[int] = None,
        initiatingsystem: Optional[str] = None,
        servicemode: Optional[int] = None,
        uuidseqno: Optional[int] = None,
        entity: Optional[str] = None,
        languagecode: Optional[int] = None,
        referenceid: Optional[str] = None,
        requesthash: Optional[str] = None,
        runmode: Optional[int] = None,
        userid: Optional[int] = None
    ) -> Dict[str, Any]:
        """
        modify Dividend from LLC Proceed Collateral
        
        Generated from: POST /loans/collateral/modifyDividendfromLLCProceedCollateral
        Source: swagger_2_0
        Operation ID: CRBT6073DivFrmLLCModificationWrapper_POSTUsingPOST
        
        
        Authentication: Not required
        
        Parameters:
        - request_body: any (required)
          input
        
        
        
        Headers:
        - Accesstoken: string
          Authorization token for identification of the caller
        - ChannelType: integer
          Channel identifier from where the TXN has originated (Internet, Mobile, ATM, Branch Channel )
        - Co-Relationid: integer
          Unique ID for the service invoked, will be set by the TXN system
        - InitiatingSystem: string
          Indicating the initiated system
        - ServiceMode: integer
          Used for branch channel to indicate the type of customer
        - UUIDSeqNo: integer
          UUID Sequence Number
        - entity: string
          entity
        - languageCode: integer
          languageCode
        - referenceId: string
          Place holder for Token based authentication
        - requesthash: string
          Request payload for hash validation
        - runMode: integer
          runMode
        - userId: integer
          userId
        
        
        """
        
        
        # Prepare request data
        
        # Single body parameter - send directly
        data = request_body if request_body is not None else {}
        
        
        
        # Prepare query parameters
        params = {}
        
        
        # Replace path parameters in URL
        path = "/loans/collateral/modifyDividendfromLLCProceedCollateral"
        
        
        # Prepare headers
        headers = {}
        if accesstoken is not None:
            headers["Accesstoken"] = str(accesstoken)
        if channeltype is not None:
            headers["ChannelType"] = str(channeltype)
        if co_relationid is not None:
            headers["Co-Relationid"] = str(co_relationid)
        if initiatingsystem is not None:
            headers["InitiatingSystem"] = str(initiatingsystem)
        if servicemode is not None:
            headers["ServiceMode"] = str(servicemode)
        if uuidseqno is not None:
            headers["UUIDSeqNo"] = str(uuidseqno)
        if entity is not None:
            headers["entity"] = str(entity)
        if languagecode is not None:
            headers["languageCode"] = str(languagecode)
        if referenceid is not None:
            headers["referenceId"] = str(referenceid)
        if requesthash is not None:
            headers["requesthash"] = str(requesthash)
        if runmode is not None:
            headers["runMode"] = str(runmode)
        if userid is not None:
            headers["userId"] = str(userid)
        
        
        return await make_api_request(
            "POST", 
            path, 
            data=data, 
            params=params if params else None, 
            headers=headers if headers else None
        )
    
    
    
    @mcp.tool()
    async def crbt6068_medical_proceed_modification_wrapper_postusing_post(
        request_body:Dict[str, Any] ,  # medicalProceedModificationWrapperResource,
        accesstoken: Optional[str] = None,
        channeltype: Optional[int] = None,
        co_relationid: Optional[int] = None,
        initiatingsystem: Optional[str] = None,
        servicemode: Optional[int] = None,
        uuidseqno: Optional[int] = None,
        entity: Optional[str] = None,
        languagecode: Optional[int] = None,
        referenceid: Optional[str] = None,
        requesthash: Optional[str] = None,
        userid: Optional[int] = None
    ) -> Dict[str, Any]:
        """
        Modify Medical Claim Proceed Collateral
        
        Generated from: POST /loans/collateral/modifyMedicalClaimProceedCltrl
        Source: swagger_2_0
        Operation ID: CRBT6068MedicalProceedModificationWrapper_POSTUsingPOST
        
        
        Authentication: Not required
        
        Parameters:
        - request_body: any (required)
          input
        
        
        
        Headers:
        - Accesstoken: string
          Authorization token for identification of the caller
        - ChannelType: integer
          Channel identifier from where the TXN has originated (Internet, Mobile, ATM, Branch Channel )
        - Co-Relationid: integer
          Unique ID for the service invoked, will be set by the TXN system
        - InitiatingSystem: string
          Indicating the initiated system
        - ServiceMode: integer
          Used for branch channel to indicate the type of customer
        - UUIDSeqNo: integer
          UUID Sequence Number
        - entity: string
          entity
        - languageCode: integer
          languageCode
        - referenceId: string
          Place holder for Token based authentication
        - requesthash: string
          Request payload for hash validation
        - userId: integer
          userId
        
        
        """
        
        
        # Prepare request data
        
        # Single body parameter - send directly
        data = request_body if request_body is not None else {}
        
        
        
        # Prepare query parameters
        params = {}
        
        
        # Replace path parameters in URL
        path = "/loans/collateral/modifyMedicalClaimProceedCltrl"
        
        
        # Prepare headers
        headers = {}
        if accesstoken is not None:
            headers["Accesstoken"] = str(accesstoken)
        if channeltype is not None:
            headers["ChannelType"] = str(channeltype)
        if co_relationid is not None:
            headers["Co-Relationid"] = str(co_relationid)
        if initiatingsystem is not None:
            headers["InitiatingSystem"] = str(initiatingsystem)
        if servicemode is not None:
            headers["ServiceMode"] = str(servicemode)
        if uuidseqno is not None:
            headers["UUIDSeqNo"] = str(uuidseqno)
        if entity is not None:
            headers["entity"] = str(entity)
        if languagecode is not None:
            headers["languageCode"] = str(languagecode)
        if referenceid is not None:
            headers["referenceId"] = str(referenceid)
        if requesthash is not None:
            headers["requesthash"] = str(requesthash)
        if userid is not None:
            headers["userId"] = str(userid)
        
        
        return await make_api_request(
            "POST", 
            path, 
            data=data, 
            params=params if params else None, 
            headers=headers if headers else None
        )
    
    
    
    @mcp.tool()
    async def crbt6065_multi_bonding_modification_wrapper_postusing_post(
        request_body:Dict[str, Any] ,  # CLTRL_MASTER_CRBT6065MultiBondingModificationWrapper_Resource,
        accesstoken: Optional[str] = None,
        channeltype: Optional[int] = None,
        co_relationid: Optional[int] = None,
        initiatingsystem: Optional[str] = None,
        servicemode: Optional[int] = None,
        uuidseqno: Optional[int] = None,
        entity: Optional[str] = None,
        languagecode: Optional[int] = None,
        referenceid: Optional[str] = None,
        requesthash: Optional[str] = None,
        userid: Optional[int] = None
    ) -> Dict[str, Any]:
        """
        modify MultiBonding Proceed Collateral
        
        Generated from: POST /loans/collateral/modifyMultiBondingProceedCollateral
        Source: swagger_2_0
        Operation ID: CRBT6065MultiBondingModificationWrapper_POSTUsingPOST
        
        
        Authentication: Not required
        
        Parameters:
        - request_body: any (required)
          input
        
        
        
        Headers:
        - Accesstoken: string
          Authorization token for identification of the caller
        - ChannelType: integer
          Channel identifier from where the TXN has originated (Internet, Mobile, ATM, Branch Channel )
        - Co-Relationid: integer
          Unique ID for the service invoked, will be set by the TXN system
        - InitiatingSystem: string
          Indicating the initiated system
        - ServiceMode: integer
          Used for branch channel to indicate the type of customer
        - UUIDSeqNo: integer
          UUID Sequence Number
        - entity: string
          entity
        - languageCode: integer
          languageCode
        - referenceId: string
          Place holder for Token based authentication
        - requesthash: string
          Request payload for hash validation
        - userId: integer
          userId
        
        
        """
        
        
        # Prepare request data
        
        # Single body parameter - send directly
        data = request_body if request_body is not None else {}
        
        
        
        # Prepare query parameters
        params = {}
        
        
        # Replace path parameters in URL
        path = "/loans/collateral/modifyMultiBondingProceedCollateral"
        
        
        # Prepare headers
        headers = {}
        if accesstoken is not None:
            headers["Accesstoken"] = str(accesstoken)
        if channeltype is not None:
            headers["ChannelType"] = str(channeltype)
        if co_relationid is not None:
            headers["Co-Relationid"] = str(co_relationid)
        if initiatingsystem is not None:
            headers["InitiatingSystem"] = str(initiatingsystem)
        if servicemode is not None:
            headers["ServiceMode"] = str(servicemode)
        if uuidseqno is not None:
            headers["UUIDSeqNo"] = str(uuidseqno)
        if entity is not None:
            headers["entity"] = str(entity)
        if languagecode is not None:
            headers["languageCode"] = str(languagecode)
        if referenceid is not None:
            headers["referenceId"] = str(referenceid)
        if requesthash is not None:
            headers["requesthash"] = str(requesthash)
        if userid is not None:
            headers["userId"] = str(userid)
        
        
        return await make_api_request(
            "POST", 
            path, 
            data=data, 
            params=params if params else None, 
            headers=headers if headers else None
        )
    
    
    
    @mcp.tool()
    async def crbt0101_phy_asset_cltrl_mdfy_wrapper_postusing_post(
        request_body:Dict[str, Any] ,  # phyAssetCltrlMdfyWrapperRequest,
        accesstoken: Optional[str] = None,
        channeltype: Optional[int] = None,
        co_relationid: Optional[int] = None,
        initiatingsystem: Optional[str] = None,
        servicemode: Optional[int] = None,
        uuidseqno: Optional[int] = None,
        entity: Optional[str] = None,
        languagecode: Optional[int] = None,
        referenceid: Optional[str] = None,
        requesthash: Optional[str] = None,
        userid: Optional[int] = None
    ) -> Dict[str, Any]:
        """
        Modify Physical Asset Collateral
        
        Generated from: POST /loans/collateral/modifyPhysicalAssetCltrl
        Source: swagger_2_0
        Operation ID: CRBT0101PhyAssetCltrlMdfyWrapper_POSTUsingPOST
        
        
        Authentication: Not required
        
        Parameters:
        - request_body: any (required)
          input
        
        
        
        Headers:
        - Accesstoken: string
          Authorization token for identification of the caller
        - ChannelType: integer
          Channel identifier from where the TXN has originated (Internet, Mobile, ATM, Branch Channel )
        - Co-Relationid: integer
          Unique ID for the service invoked, will be set by the TXN system
        - InitiatingSystem: string
          Indicating the initiated system
        - ServiceMode: integer
          Used for branch channel to indicate the type of customer
        - UUIDSeqNo: integer
          UUID Sequence Number
        - entity: string
          entity
        - languageCode: integer
          languageCode
        - referenceId: string
          Place holder for Token based authentication
        - requesthash: string
          Request payload for hash validation
        - userId: integer
          userId
        
        
        """
        
        
        # Prepare request data
        
        # Single body parameter - send directly
        data = request_body if request_body is not None else {}
        
        
        
        # Prepare query parameters
        params = {}
        
        
        # Replace path parameters in URL
        path = "/loans/collateral/modifyPhysicalAssetCltrl"
        
        
        # Prepare headers
        headers = {}
        if accesstoken is not None:
            headers["Accesstoken"] = str(accesstoken)
        if channeltype is not None:
            headers["ChannelType"] = str(channeltype)
        if co_relationid is not None:
            headers["Co-Relationid"] = str(co_relationid)
        if initiatingsystem is not None:
            headers["InitiatingSystem"] = str(initiatingsystem)
        if servicemode is not None:
            headers["ServiceMode"] = str(servicemode)
        if uuidseqno is not None:
            headers["UUIDSeqNo"] = str(uuidseqno)
        if entity is not None:
            headers["entity"] = str(entity)
        if languagecode is not None:
            headers["languageCode"] = str(languagecode)
        if referenceid is not None:
            headers["referenceId"] = str(referenceid)
        if requesthash is not None:
            headers["requesthash"] = str(requesthash)
        if userid is not None:
            headers["userId"] = str(userid)
        
        
        return await make_api_request(
            "POST", 
            path, 
            data=data, 
            params=params if params else None, 
            headers=headers if headers else None
        )
    
    
    
    @mcp.tool()
    async def crbt6073_pldge_of_llcmodification_wrapper_postusing_post(
        request_body:Dict[str, Any] ,  # CLTRL_MASTER_CRBT6073modifyPledgeOfLLCSharesCollateralWrapper_Resource,
        accesstoken: Optional[str] = None,
        channeltype: Optional[int] = None,
        co_relationid: Optional[int] = None,
        initiatingsystem: Optional[str] = None,
        servicemode: Optional[int] = None,
        uuidseqno: Optional[int] = None,
        entity: Optional[str] = None,
        languagecode: Optional[int] = None,
        referenceid: Optional[str] = None,
        requesthash: Optional[str] = None,
        userid: Optional[int] = None
    ) -> Dict[str, Any]:
        """
        modify Pledge Of LLC Shares Collateral
        
        Generated from: POST /loans/collateral/modifyPledgeOfLLCSharesCollateral
        Source: swagger_2_0
        Operation ID: CRBT6073PldgeOfLLCModificationWrapper_POSTUsingPOST
        
        
        Authentication: Not required
        
        Parameters:
        - request_body: any (required)
          input
        
        
        
        Headers:
        - Accesstoken: string
          Authorization token for identification of the caller
        - ChannelType: integer
          Channel identifier from where the TXN has originated (Internet, Mobile, ATM, Branch Channel )
        - Co-Relationid: integer
          Unique ID for the service invoked, will be set by the TXN system
        - InitiatingSystem: string
          Indicating the initiated system
        - ServiceMode: integer
          Used for branch channel to indicate the type of customer
        - UUIDSeqNo: integer
          UUID Sequence Number
        - entity: string
          entity
        - languageCode: integer
          languageCode
        - referenceId: string
          Place holder for Token based authentication
        - requesthash: string
          Request payload for hash validation
        - userId: integer
          userId
        
        
        """
        
        
        # Prepare request data
        
        # Single body parameter - send directly
        data = request_body if request_body is not None else {}
        
        
        
        # Prepare query parameters
        params = {}
        
        
        # Replace path parameters in URL
        path = "/loans/collateral/modifyPledgeOfLLCSharesCollateral"
        
        
        # Prepare headers
        headers = {}
        if accesstoken is not None:
            headers["Accesstoken"] = str(accesstoken)
        if channeltype is not None:
            headers["ChannelType"] = str(channeltype)
        if co_relationid is not None:
            headers["Co-Relationid"] = str(co_relationid)
        if initiatingsystem is not None:
            headers["InitiatingSystem"] = str(initiatingsystem)
        if servicemode is not None:
            headers["ServiceMode"] = str(servicemode)
        if uuidseqno is not None:
            headers["UUIDSeqNo"] = str(uuidseqno)
        if entity is not None:
            headers["entity"] = str(entity)
        if languagecode is not None:
            headers["languageCode"] = str(languagecode)
        if referenceid is not None:
            headers["referenceId"] = str(referenceid)
        if requesthash is not None:
            headers["requesthash"] = str(requesthash)
        if userid is not None:
            headers["userId"] = str(userid)
        
        
        return await make_api_request(
            "POST", 
            path, 
            data=data, 
            params=params if params else None, 
            headers=headers if headers else None
        )
    
    
    
    @mcp.tool()
    async def crbt6068_salary_proceed_modification_wrapper_postusing_post(
        request_body:Dict[str, Any] ,  # salaryProceedModificationWrapperResource,
        accesstoken: Optional[str] = None,
        channeltype: Optional[int] = None,
        co_relationid: Optional[int] = None,
        initiatingsystem: Optional[str] = None,
        servicemode: Optional[int] = None,
        uuidseqno: Optional[int] = None,
        entity: Optional[str] = None,
        languagecode: Optional[int] = None,
        userid: Optional[int] = None
    ) -> Dict[str, Any]:
        """
        Modify Salary Proceed Collateral
        
        Generated from: POST /loans/collateral/modifySalaryProceedCltrl
        Source: swagger_2_0
        Operation ID: CRBT6068SalaryProceedModificationWrapper_POSTUsingPOST
        
        
        Authentication: Not required
        
        Parameters:
        - request_body: any (required)
          input
        
        
        
        Headers:
        - Accesstoken: string
          Authorization token for identification of the caller
        - ChannelType: integer
          Channel identifier from where the TXN has originated (Internet, Mobile, ATM, Branch Channel )
        - Co-Relationid: integer
          Unique ID for the service invoked, will be set by the TXN system
        - InitiatingSystem: string
          Indicating the initiated system
        - ServiceMode: integer
          Used for branch channel to indicate the type of customer
        - UUIDSeqNo: integer
          UUID Sequence Number
        - entity: string
          entity
        - languageCode: integer
          languageCode
        - userId: integer
          userId
        
        
        """
        
        
        # Prepare request data
        
        # Single body parameter - send directly
        data = request_body if request_body is not None else {}
        
        
        
        # Prepare query parameters
        params = {}
        
        
        # Replace path parameters in URL
        path = "/loans/collateral/modifySalaryProceedCltrl"
        
        
        # Prepare headers
        headers = {}
        if accesstoken is not None:
            headers["Accesstoken"] = str(accesstoken)
        if channeltype is not None:
            headers["ChannelType"] = str(channeltype)
        if co_relationid is not None:
            headers["Co-Relationid"] = str(co_relationid)
        if initiatingsystem is not None:
            headers["InitiatingSystem"] = str(initiatingsystem)
        if servicemode is not None:
            headers["ServiceMode"] = str(servicemode)
        if uuidseqno is not None:
            headers["UUIDSeqNo"] = str(uuidseqno)
        if entity is not None:
            headers["entity"] = str(entity)
        if languagecode is not None:
            headers["languageCode"] = str(languagecode)
        if userid is not None:
            headers["userId"] = str(userid)
        
        
        return await make_api_request(
            "POST", 
            path, 
            data=data, 
            params=params if params else None, 
            headers=headers if headers else None
        )
    
    
    
    @mcp.tool()
    async def cret2022_fetch_other_cltrl_dtls_postusing_get(
        collateralreference: int,
        accesstoken: Optional[str] = None,
        channeltype: Optional[int] = None,
        co_relationid: Optional[int] = None,
        initiatingsystem: Optional[str] = None,
        servicemode: Optional[int] = None,
        uuidseqno: Optional[int] = None,
        entity: Optional[str] = None,
        languagecode: Optional[int] = None,
        referenceid: Optional[str] = None,
        requesthash: Optional[str] = None,
        userid: Optional[int] = None
    ) -> Dict[str, Any]:
        """
        Others Collateral View
        
        Generated from: GET /loans/collateral/others/{collateralReference}
        Source: swagger_2_0
        Operation ID: CRET2022FetchOtherCltrlDtls_POSTUsingGET
        
        
        Authentication: Not required
        
        Parameters:
        - collateralReference: integer (required)
          System generated unique reference of collateral
        
        
        
        Headers:
        - Accesstoken: string
          Authorization token for identification of the caller
        - ChannelType: integer
          Channel identifier from where the TXN has originated (Internet, Mobile, ATM, Branch Channel )
        - Co-Relationid: integer
          Unique ID for the service invoked, will be set by the TXN system
        - InitiatingSystem: string
          Indicating the initiated system
        - ServiceMode: integer
          Used for branch channel to indicate the type of customer
        - UUIDSeqNo: integer
          UUID Sequence Number
        - entity: string
          entity
        - languageCode: integer
          languageCode
        - referenceId: string
          Place holder for Token based authentication
        - requesthash: string
          Request payload for hash validation
        - userId: integer
          userId
        
        
        """
        
        
        # Prepare query parameters
        params = {}
        
        
        # Replace path parameters in URL
        path = "/loans/collateral/others/{collateralReference}"
        if collateralreference is not None:
            path = path.replace("{collateralReference}", str(collateralreference))
        
        
        # Prepare headers
        headers = {}
        if accesstoken is not None:
            headers["Accesstoken"] = str(accesstoken)
        if channeltype is not None:
            headers["ChannelType"] = str(channeltype)
        if co_relationid is not None:
            headers["Co-Relationid"] = str(co_relationid)
        if initiatingsystem is not None:
            headers["InitiatingSystem"] = str(initiatingsystem)
        if servicemode is not None:
            headers["ServiceMode"] = str(servicemode)
        if uuidseqno is not None:
            headers["UUIDSeqNo"] = str(uuidseqno)
        if entity is not None:
            headers["entity"] = str(entity)
        if languagecode is not None:
            headers["languageCode"] = str(languagecode)
        if referenceid is not None:
            headers["referenceId"] = str(referenceid)
        if requesthash is not None:
            headers["requesthash"] = str(requesthash)
        if userid is not None:
            headers["userId"] = str(userid)
        
        
        return await make_api_request(
            "GET", 
            path, 
            
            params=params if params else None, 
            headers=headers if headers else None
        )
    
    
    
    @mcp.tool()
    async def crbt6074_prchs_ordr_modification_wrapper_postusing_post(
        request_body:Dict[str, Any] ,  # prchsOrdrModificationWrapperResource,
        accesstoken: Optional[str] = None,
        channeltype: Optional[int] = None,
        co_relationid: Optional[int] = None,
        initiatingsystem: Optional[str] = None,
        servicemode: Optional[int] = None,
        uuidseqno: Optional[int] = None,
        entity: Optional[str] = None,
        languagecode: Optional[int] = None,
        referenceid: Optional[str] = None,
        requesthash: Optional[str] = None,
        userid: Optional[int] = None
    ) -> Dict[str, Any]:
        """
        Modify Purchase Order Proceed Collateral
        
        Generated from: POST /loans/collateral/purchaseOrderProceedCollateral/update
        Source: swagger_2_0
        Operation ID: CRBT6074PrchsOrdrModificationWrapper_POSTUsingPOST
        
        
        Authentication: Not required
        
        Parameters:
        - request_body: any (required)
          input
        
        
        
        Headers:
        - Accesstoken: string
          Authorization token for identification of the caller
        - ChannelType: integer
          Channel identifier from where the TXN has originated (Internet, Mobile, ATM, Branch Channel )
        - Co-Relationid: integer
          Unique ID for the service invoked, will be set by the TXN system
        - InitiatingSystem: string
          Indicating the initiated system
        - ServiceMode: integer
          Used for branch channel to indicate the type of customer
        - UUIDSeqNo: integer
          UUID Sequence Number
        - entity: string
          entity
        - languageCode: integer
          languageCode
        - referenceId: string
          Place holder for Token based authentication
        - requesthash: string
          Request payload for hash validation
        - userId: integer
          userId
        
        
        """
        
        
        # Prepare request data
        
        # Single body parameter - send directly
        data = request_body if request_body is not None else {}
        
        
        
        # Prepare query parameters
        params = {}
        
        
        # Replace path parameters in URL
        path = "/loans/collateral/purchaseOrderProceedCollateral/update"
        
        
        # Prepare headers
        headers = {}
        if accesstoken is not None:
            headers["Accesstoken"] = str(accesstoken)
        if channeltype is not None:
            headers["ChannelType"] = str(channeltype)
        if co_relationid is not None:
            headers["Co-Relationid"] = str(co_relationid)
        if initiatingsystem is not None:
            headers["InitiatingSystem"] = str(initiatingsystem)
        if servicemode is not None:
            headers["ServiceMode"] = str(servicemode)
        if uuidseqno is not None:
            headers["UUIDSeqNo"] = str(uuidseqno)
        if entity is not None:
            headers["entity"] = str(entity)
        if languagecode is not None:
            headers["languageCode"] = str(languagecode)
        if referenceid is not None:
            headers["referenceId"] = str(referenceid)
        if requesthash is not None:
            headers["requesthash"] = str(requesthash)
        if userid is not None:
            headers["userId"] = str(userid)
        
        
        return await make_api_request(
            "POST", 
            path, 
            data=data, 
            params=params if params else None, 
            headers=headers if headers else None
        )
    
    
    
    @mcp.tool()
    async def crbt1801_crt_tenant_owned_cltrl_wrapper_using_post(
        request_body:Dict[str, Any] ,  # tenantOwnedRealEstateCollateralResource,
        accesstoken: Optional[str] = None,
        channeltype: Optional[int] = None,
        co_relationid: Optional[int] = None,
        initiatingsystem: Optional[str] = None,
        servicemode: Optional[int] = None,
        uuidseqno: Optional[int] = None,
        entity: Optional[str] = None,
        languagecode: Optional[int] = None,
        referenceid: Optional[str] = None,
        requesthash: Optional[str] = None,
        userid: Optional[int] = None
    ) -> Dict[str, Any]:
        """
        Creation of Tenant owned collateral
        
        Generated from: POST /loans/collateral/realestate/create
        Source: swagger_2_0
        Operation ID: CRBT1801CrtTenantOwnedCltrlWrapperUsingPOST
        
        
        Authentication: Not required
        
        Parameters:
        - request_body: any (required)
          input
        
        
        
        Headers:
        - Accesstoken: string
          Authorization token for identification of the caller
        - ChannelType: integer
          Channel identifier from where the TXN has originated (Internet, Mobile, ATM, Branch Channel )
        - Co-Relationid: integer
          Unique ID for the service invoked, will be set by the TXN system
        - InitiatingSystem: string
          Indicating the initiated system
        - ServiceMode: integer
          Used for branch channel to indicate the type of customer
        - UUIDSeqNo: integer
          UUID Sequence Number
        - entity: string
          entity
        - languageCode: integer
          languageCode
        - referenceId: string
          Place holder for Token based authentication
        - requesthash: string
          Request payload for hash validation
        - userId: integer
          userId
        
        
        """
        
        
        # Prepare request data
        
        # Single body parameter - send directly
        data = request_body if request_body is not None else {}
        
        
        
        # Prepare query parameters
        params = {}
        
        
        # Replace path parameters in URL
        path = "/loans/collateral/realestate/create"
        
        
        # Prepare headers
        headers = {}
        if accesstoken is not None:
            headers["Accesstoken"] = str(accesstoken)
        if channeltype is not None:
            headers["ChannelType"] = str(channeltype)
        if co_relationid is not None:
            headers["Co-Relationid"] = str(co_relationid)
        if initiatingsystem is not None:
            headers["InitiatingSystem"] = str(initiatingsystem)
        if servicemode is not None:
            headers["ServiceMode"] = str(servicemode)
        if uuidseqno is not None:
            headers["UUIDSeqNo"] = str(uuidseqno)
        if entity is not None:
            headers["entity"] = str(entity)
        if languagecode is not None:
            headers["languageCode"] = str(languagecode)
        if referenceid is not None:
            headers["referenceId"] = str(referenceid)
        if requesthash is not None:
            headers["requesthash"] = str(requesthash)
        if userid is not None:
            headers["userId"] = str(userid)
        
        
        return await make_api_request(
            "POST", 
            path, 
            data=data, 
            params=params if params else None, 
            headers=headers if headers else None
        )
    
    
    
    @mcp.tool()
    async def crbt0101_immovable_property_modification_wrapper_postusing_post(
        request_body:Dict[str, Any] ,  # CollateralLandAndPropertyModifyRequest,
        accesstoken: Optional[str] = None,
        channeltype: Optional[int] = None,
        co_relationid: Optional[int] = None,
        initiatingsystem: Optional[str] = None,
        servicemode: Optional[int] = None,
        uuidseqno: Optional[int] = None,
        entity: Optional[str] = None,
        languagecode: Optional[int] = None,
        referenceid: Optional[str] = None,
        requesthash: Optional[str] = None,
        userid: Optional[int] = None
    ) -> Dict[str, Any]:
        """
        LandAndImmovablePropertyCollateralModification
        
        Generated from: POST /loans/collateral/realestate/update
        Source: swagger_2_0
        Operation ID: CRBT0101ImmovablePropertyModificationWrapper_POSTUsingPOST
        
        
        Authentication: Not required
        
        Parameters:
        - request_body: any (required)
          input
        
        
        
        Headers:
        - Accesstoken: string
          Authorization token for identification of the caller
        - ChannelType: integer
          Channel identifier from where the TXN has originated (Internet, Mobile, ATM, Branch Channel )
        - Co-Relationid: integer
          Unique ID for the service invoked, will be set by the TXN system
        - InitiatingSystem: string
          Indicating the initiated system
        - ServiceMode: integer
          Used for branch channel to indicate the type of customer
        - UUIDSeqNo: integer
          UUID Sequence Number
        - entity: string
          entity
        - languageCode: integer
          languageCode
        - referenceId: string
          Place holder for Token based authentication
        - requesthash: string
          Request payload for hash validation
        - userId: integer
          userId
        
        
        """
        
        
        # Prepare request data
        
        # Single body parameter - send directly
        data = request_body if request_body is not None else {}
        
        
        
        # Prepare query parameters
        params = {}
        
        
        # Replace path parameters in URL
        path = "/loans/collateral/realestate/update"
        
        
        # Prepare headers
        headers = {}
        if accesstoken is not None:
            headers["Accesstoken"] = str(accesstoken)
        if channeltype is not None:
            headers["ChannelType"] = str(channeltype)
        if co_relationid is not None:
            headers["Co-Relationid"] = str(co_relationid)
        if initiatingsystem is not None:
            headers["InitiatingSystem"] = str(initiatingsystem)
        if servicemode is not None:
            headers["ServiceMode"] = str(servicemode)
        if uuidseqno is not None:
            headers["UUIDSeqNo"] = str(uuidseqno)
        if entity is not None:
            headers["entity"] = str(entity)
        if languagecode is not None:
            headers["languageCode"] = str(languagecode)
        if referenceid is not None:
            headers["referenceId"] = str(referenceid)
        if requesthash is not None:
            headers["requesthash"] = str(requesthash)
        if userid is not None:
            headers["userId"] = str(userid)
        
        
        return await make_api_request(
            "POST", 
            path, 
            data=data, 
            params=params if params else None, 
            headers=headers if headers else None
        )
    
    
    
    @mcp.tool()
    async def cret1802_fetch_prprty_mortgage_deeds_cltrl_wrapper_using_get_1(
        collateralreference: int,
        accesstoken: Optional[str] = None,
        channeltype: Optional[int] = None,
        co_relationid: Optional[int] = None,
        initiatingsystem: Optional[str] = None,
        servicemode: Optional[int] = None,
        uuidseqno: Optional[int] = None,
        entity: Optional[str] = None,
        languagecode: Optional[int] = None,
        referenceid: Optional[str] = None,
        requesthash: Optional[str] = None,
        userid: Optional[int] = None
    ) -> Dict[str, Any]:
        """
        Fetch Details of Land And immovable property Collateral
        
        Generated from: GET /loans/collateral/realestate/{collateralReference}
        Source: swagger_2_0
        Operation ID: CRET1802FetchPrprtyMortgageDeedsCltrlWrapperUsingGET_1
        
        
        Authentication: Not required
        
        Parameters:
        - collateralReference: integer (required)
          Collateral Id Generated
        
        
        
        Headers:
        - Accesstoken: string
          Authorization token for identification of the caller
        - ChannelType: integer
          Channel identifier from where the TXN has originated (Internet, Mobile, ATM, Branch Channel )
        - Co-Relationid: integer
          Unique ID for the service invoked, will be set by the TXN system
        - InitiatingSystem: string
          Indicating the initiated system
        - ServiceMode: integer
          Used for branch channel to indicate the type of customer
        - UUIDSeqNo: integer
          UUID Sequence Number
        - entity: string
          entity
        - languageCode: integer
          languageCode
        - referenceId: string
          Place holder for Token based authentication
        - requesthash: string
          Request payload for hash validation
        - userId: integer
          userId
        
        
        """
        
        
        # Prepare query parameters
        params = {}
        
        
        # Replace path parameters in URL
        path = "/loans/collateral/realestate/{collateralReference}"
        if collateralreference is not None:
            path = path.replace("{collateralReference}", str(collateralreference))
        
        
        # Prepare headers
        headers = {}
        if accesstoken is not None:
            headers["Accesstoken"] = str(accesstoken)
        if channeltype is not None:
            headers["ChannelType"] = str(channeltype)
        if co_relationid is not None:
            headers["Co-Relationid"] = str(co_relationid)
        if initiatingsystem is not None:
            headers["InitiatingSystem"] = str(initiatingsystem)
        if servicemode is not None:
            headers["ServiceMode"] = str(servicemode)
        if uuidseqno is not None:
            headers["UUIDSeqNo"] = str(uuidseqno)
        if entity is not None:
            headers["entity"] = str(entity)
        if languagecode is not None:
            headers["languageCode"] = str(languagecode)
        if referenceid is not None:
            headers["referenceId"] = str(referenceid)
        if requesthash is not None:
            headers["requesthash"] = str(requesthash)
        if userid is not None:
            headers["userId"] = str(userid)
        
        
        return await make_api_request(
            "GET", 
            path, 
            
            params=params if params else None, 
            headers=headers if headers else None
        )
    
    
    
    @mcp.tool()
    async def crbt6066_rcvbl_proceed_modification_wrapper_postusing_post(
        request_body:Dict[str, Any] ,  # rcvblProceedModificationWrapperResource,
        accesstoken: Optional[str] = None,
        channeltype: Optional[int] = None,
        co_relationid: Optional[int] = None,
        initiatingsystem: Optional[str] = None,
        servicemode: Optional[int] = None,
        uuidseqno: Optional[int] = None,
        entity: Optional[str] = None,
        languagecode: Optional[int] = None,
        referenceid: Optional[str] = None,
        requesthash: Optional[str] = None,
        userid: Optional[int] = None
    ) -> Dict[str, Any]:
        """
        Modify Receivable Proceed Collateral
        
        Generated from: POST /loans/collateral/receivableProceedCollateral/update
        Source: swagger_2_0
        Operation ID: CRBT6066RcvblProceedModificationWrapper_POSTUsingPOST
        
        
        Authentication: Not required
        
        Parameters:
        - request_body: any (required)
          input
        
        
        
        Headers:
        - Accesstoken: string
          Authorization token for identification of the caller
        - ChannelType: integer
          Channel identifier from where the TXN has originated (Internet, Mobile, ATM, Branch Channel )
        - Co-Relationid: integer
          Unique ID for the service invoked, will be set by the TXN system
        - InitiatingSystem: string
          Indicating the initiated system
        - ServiceMode: integer
          Used for branch channel to indicate the type of customer
        - UUIDSeqNo: integer
          UUID Sequence Number
        - entity: string
          entity
        - languageCode: integer
          languageCode
        - referenceId: string
          Place holder for Token based authentication
        - requesthash: string
          Request payload for hash validation
        - userId: integer
          userId
        
        
        """
        
        
        # Prepare request data
        
        # Single body parameter - send directly
        data = request_body if request_body is not None else {}
        
        
        
        # Prepare query parameters
        params = {}
        
        
        # Replace path parameters in URL
        path = "/loans/collateral/receivableProceedCollateral/update"
        
        
        # Prepare headers
        headers = {}
        if accesstoken is not None:
            headers["Accesstoken"] = str(accesstoken)
        if channeltype is not None:
            headers["ChannelType"] = str(channeltype)
        if co_relationid is not None:
            headers["Co-Relationid"] = str(co_relationid)
        if initiatingsystem is not None:
            headers["InitiatingSystem"] = str(initiatingsystem)
        if servicemode is not None:
            headers["ServiceMode"] = str(servicemode)
        if uuidseqno is not None:
            headers["UUIDSeqNo"] = str(uuidseqno)
        if entity is not None:
            headers["entity"] = str(entity)
        if languagecode is not None:
            headers["languageCode"] = str(languagecode)
        if referenceid is not None:
            headers["referenceId"] = str(referenceid)
        if requesthash is not None:
            headers["requesthash"] = str(requesthash)
        if userid is not None:
            headers["userId"] = str(userid)
        
        
        return await make_api_request(
            "POST", 
            path, 
            data=data, 
            params=params if params else None, 
            headers=headers if headers else None
        )
    
    
    
    @mcp.tool()
    async def cret1830_get_shr_bnd_dtls_postusing_get(
        collateralreference: int,
        pagenum: Optional[int] = None,
        pagesize: Optional[int] = None,
        accesstoken: Optional[str] = None,
        channeltype: Optional[int] = None,
        co_relationid: Optional[int] = None,
        initiatingsystem: Optional[str] = None,
        servicemode: Optional[int] = None,
        uuidseqno: Optional[int] = None,
        entity: Optional[str] = None,
        languagecode: Optional[int] = None,
        referenceid: Optional[str] = None,
        requesthash: Optional[str] = None,
        userid: Optional[int] = None
    ) -> Dict[str, Any]:
        """
        View Shares and bonds Collateral Details
        
        Generated from: GET /loans/collateral/shareBond/view{collateralReference}
        Source: swagger_2_0
        Operation ID: CRET1830GetShrBndDtls_POSTUsingGET
        
        
        Authentication: Not required
        
        Parameters:
        - collateralReference: integer (required)
          System generated unique reference of collateral
        - pageNum: integer
          pageNum
        - pageSize: integer
          pageSize
        
        
        
        Headers:
        - Accesstoken: string
          Authorization token for identification of the caller
        - ChannelType: integer
          Channel identifier from where the TXN has originated (Internet, Mobile, ATM, Branch Channel )
        - Co-Relationid: integer
          Unique ID for the service invoked, will be set by the TXN system
        - InitiatingSystem: string
          Indicating the initiated system
        - ServiceMode: integer
          Used for branch channel to indicate the type of customer
        - UUIDSeqNo: integer
          UUID Sequence Number
        - entity: string
          entity
        - languageCode: integer
          languageCode
        - referenceId: string
          Place holder for Token based authentication
        - requesthash: string
          Request payload for hash validation
        - userId: integer
          userId
        
        
        """
        
        
        # Prepare query parameters
        params = {}
        if pagenum is not None:
            params["pageNum"] = pagenum
            
        if pagesize is not None:
            params["pageSize"] = pagesize
            
        
        
        # Replace path parameters in URL
        path = "/loans/collateral/shareBond/view{collateralReference}"
        if collateralreference is not None:
            path = path.replace("{collateralReference}", str(collateralreference))
        
        
        # Prepare headers
        headers = {}
        if accesstoken is not None:
            headers["Accesstoken"] = str(accesstoken)
        if channeltype is not None:
            headers["ChannelType"] = str(channeltype)
        if co_relationid is not None:
            headers["Co-Relationid"] = str(co_relationid)
        if initiatingsystem is not None:
            headers["InitiatingSystem"] = str(initiatingsystem)
        if servicemode is not None:
            headers["ServiceMode"] = str(servicemode)
        if uuidseqno is not None:
            headers["UUIDSeqNo"] = str(uuidseqno)
        if entity is not None:
            headers["entity"] = str(entity)
        if languagecode is not None:
            headers["languageCode"] = str(languagecode)
        if referenceid is not None:
            headers["referenceId"] = str(referenceid)
        if requesthash is not None:
            headers["requesthash"] = str(requesthash)
        if userid is not None:
            headers["userId"] = str(userid)
        
        
        return await make_api_request(
            "GET", 
            path, 
            
            params=params if params else None, 
            headers=headers if headers else None
        )
    
    
    
    @mcp.tool()
    async def crbt1809_create_vhcl_cltrl_postusing_post(
        request_body:Dict[str, Any] ,  # CLTRL_MASTER_CRBT1809CreateVhclCltrl_Resource,
        accesstoken: Optional[str] = None,
        channeltype: Optional[int] = None,
        co_relationid: Optional[int] = None,
        initiatingsystem: Optional[str] = None,
        servicemode: Optional[int] = None,
        uuidseqno: Optional[int] = None,
        entity: Optional[str] = None,
        languagecode: Optional[int] = None,
        referenceid: Optional[str] = None,
        requesthash: Optional[str] = None,
        userid: Optional[int] = None
    ) -> Dict[str, Any]:
        """
        Creation of Vehicle and Heavy Machinery Collateral
        
        Generated from: POST /loans/collateral/vehicleandheavymachinery/create
        Source: swagger_2_0
        Operation ID: CRBT1809CreateVhclCltrl_POSTUsingPOST
        
        
        Authentication: Not required
        
        Parameters:
        - request_body: any (required)
          input
        
        
        
        Headers:
        - Accesstoken: string
          Authorization token for identification of the caller
        - ChannelType: integer
          Channel identifier from where the TXN has originated (Internet, Mobile, ATM, Branch Channel )
        - Co-Relationid: integer
          Unique ID for the service invoked, will be set by the TXN system
        - InitiatingSystem: string
          Indicating the initiated system
        - ServiceMode: integer
          Used for branch channel to indicate the type of customer
        - UUIDSeqNo: integer
          UUID Sequence Number
        - entity: string
          entity
        - languageCode: integer
          languageCode
        - referenceId: string
          Place holder for Token based authentication
        - requesthash: string
          Request payload for hash validation
        - userId: integer
          userId
        
        
        """
        
        
        # Prepare request data
        
        # Single body parameter - send directly
        data = request_body if request_body is not None else {}
        
        
        
        # Prepare query parameters
        params = {}
        
        
        # Replace path parameters in URL
        path = "/loans/collateral/vehicleandheavymachinery/create"
        
        
        # Prepare headers
        headers = {}
        if accesstoken is not None:
            headers["Accesstoken"] = str(accesstoken)
        if channeltype is not None:
            headers["ChannelType"] = str(channeltype)
        if co_relationid is not None:
            headers["Co-Relationid"] = str(co_relationid)
        if initiatingsystem is not None:
            headers["InitiatingSystem"] = str(initiatingsystem)
        if servicemode is not None:
            headers["ServiceMode"] = str(servicemode)
        if uuidseqno is not None:
            headers["UUIDSeqNo"] = str(uuidseqno)
        if entity is not None:
            headers["entity"] = str(entity)
        if languagecode is not None:
            headers["languageCode"] = str(languagecode)
        if referenceid is not None:
            headers["referenceId"] = str(referenceid)
        if requesthash is not None:
            headers["requesthash"] = str(requesthash)
        if userid is not None:
            headers["userId"] = str(userid)
        
        
        return await make_api_request(
            "POST", 
            path, 
            data=data, 
            params=params if params else None, 
            headers=headers if headers else None
        )
    
    
    
    @mcp.tool()
    async def crbt0101_veh_and_heavy_machinery_modification_wrapper_postusing_post(
        request_body:Dict[str, Any] ,  # CLTRL_VHCL_MCHNRY_CRBT0101VehAndHeavyMachineryModificationWrapper_Resource,
        accesstoken: Optional[str] = None,
        channeltype: Optional[int] = None,
        co_relationid: Optional[int] = None,
        initiatingsystem: Optional[str] = None,
        servicemode: Optional[int] = None,
        uuidseqno: Optional[int] = None,
        entity: Optional[str] = None,
        languagecode: Optional[int] = None,
        referenceid: Optional[str] = None,
        requesthash: Optional[str] = None,
        userid: Optional[int] = None
    ) -> Dict[str, Any]:
        """
        Modification of Vehicle And Heavy Machinery collateral
        
        Generated from: POST /loans/collateral/vehicleandheavymachinery/update
        Source: swagger_2_0
        Operation ID: CRBT0101VehAndHeavyMachineryModificationWrapper_POSTUsingPOST
        
        
        Authentication: Not required
        
        Parameters:
        - request_body: any (required)
          input
        
        
        
        Headers:
        - Accesstoken: string
          Authorization token for identification of the caller
        - ChannelType: integer
          Channel identifier from where the TXN has originated (Internet, Mobile, ATM, Branch Channel )
        - Co-Relationid: integer
          Unique ID for the service invoked, will be set by the TXN system
        - InitiatingSystem: string
          Indicating the initiated system
        - ServiceMode: integer
          Used for branch channel to indicate the type of customer
        - UUIDSeqNo: integer
          UUID Sequence Number
        - entity: string
          entity
        - languageCode: integer
          languageCode
        - referenceId: string
          Place holder for Token based authentication
        - requesthash: string
          Request payload for hash validation
        - userId: integer
          userId
        
        
        """
        
        
        # Prepare request data
        
        # Single body parameter - send directly
        data = request_body if request_body is not None else {}
        
        
        
        # Prepare query parameters
        params = {}
        
        
        # Replace path parameters in URL
        path = "/loans/collateral/vehicleandheavymachinery/update"
        
        
        # Prepare headers
        headers = {}
        if accesstoken is not None:
            headers["Accesstoken"] = str(accesstoken)
        if channeltype is not None:
            headers["ChannelType"] = str(channeltype)
        if co_relationid is not None:
            headers["Co-Relationid"] = str(co_relationid)
        if initiatingsystem is not None:
            headers["InitiatingSystem"] = str(initiatingsystem)
        if servicemode is not None:
            headers["ServiceMode"] = str(servicemode)
        if uuidseqno is not None:
            headers["UUIDSeqNo"] = str(uuidseqno)
        if entity is not None:
            headers["entity"] = str(entity)
        if languagecode is not None:
            headers["languageCode"] = str(languagecode)
        if referenceid is not None:
            headers["referenceId"] = str(referenceid)
        if requesthash is not None:
            headers["requesthash"] = str(requesthash)
        if userid is not None:
            headers["userId"] = str(userid)
        
        
        return await make_api_request(
            "POST", 
            path, 
            data=data, 
            params=params if params else None, 
            headers=headers if headers else None
        )
    
    
    
    @mcp.tool()
    async def cret1809_fetch_vehicle_cltrl_dtls_getusing_get(
        collateralreference: int,
        accesstoken: Optional[str] = None,
        channeltype: Optional[int] = None,
        co_relationid: Optional[int] = None,
        initiatingsystem: Optional[str] = None,
        servicemode: Optional[int] = None,
        uuidseqno: Optional[int] = None,
        entity: Optional[str] = None,
        languagecode: Optional[int] = None,
        referenceid: Optional[str] = None,
        requesthash: Optional[str] = None,
        userid: Optional[int] = None
    ) -> Dict[str, Any]:
        """
        Fetch Details of  Vehicle and Heavy  Machinary Collateral
        
        Generated from: GET /loans/collateral/vehicleandheavymachinery/view/{collateralReference}
        Source: swagger_2_0
        Operation ID: CRET1809FetchVehicleCltrlDtls_GETUsingGET
        
        
        Authentication: Not required
        
        Parameters:
        - collateralReference: integer (required)
          System generated unique reference of collateral
        
        
        
        Headers:
        - Accesstoken: string
          Authorization token for identification of the caller
        - ChannelType: integer
          Channel identifier from where the TXN has originated (Internet, Mobile, ATM, Branch Channel )
        - Co-Relationid: integer
          Unique ID for the service invoked, will be set by the TXN system
        - InitiatingSystem: string
          Indicating the initiated system
        - ServiceMode: integer
          Used for branch channel to indicate the type of customer
        - UUIDSeqNo: integer
          UUID Sequence Number
        - entity: string
          entity
        - languageCode: integer
          languageCode
        - referenceId: string
          Place holder for Token based authentication
        - requesthash: string
          Request payload for hash validation
        - userId: integer
          userId
        
        
        """
        
        
        # Prepare query parameters
        params = {}
        
        
        # Replace path parameters in URL
        path = "/loans/collateral/vehicleandheavymachinery/view/{collateralReference}"
        if collateralreference is not None:
            path = path.replace("{collateralReference}", str(collateralreference))
        
        
        # Prepare headers
        headers = {}
        if accesstoken is not None:
            headers["Accesstoken"] = str(accesstoken)
        if channeltype is not None:
            headers["ChannelType"] = str(channeltype)
        if co_relationid is not None:
            headers["Co-Relationid"] = str(co_relationid)
        if initiatingsystem is not None:
            headers["InitiatingSystem"] = str(initiatingsystem)
        if servicemode is not None:
            headers["ServiceMode"] = str(servicemode)
        if uuidseqno is not None:
            headers["UUIDSeqNo"] = str(uuidseqno)
        if entity is not None:
            headers["entity"] = str(entity)
        if languagecode is not None:
            headers["languageCode"] = str(languagecode)
        if referenceid is not None:
            headers["referenceId"] = str(referenceid)
        if requesthash is not None:
            headers["requesthash"] = str(requesthash)
        if userid is not None:
            headers["userId"] = str(userid)
        
        
        return await make_api_request(
            "GET", 
            path, 
            
            params=params if params else None, 
            headers=headers if headers else None
        )
    
    
    
    @mcp.tool()
    async def crbt1801_auth_tenant_owned_cltrl_using_put(
        collateralid: str,
        request_body:Dict[str, Any] ,  # AuthorizeCollateral_Resource,
        accesstoken: Optional[str] = None,
        channeltype: Optional[int] = None,
        co_relationid: Optional[int] = None,
        initiatingsystem: Optional[str] = None,
        servicemode: Optional[int] = None,
        uuidseqno: Optional[int] = None,
        entity: Optional[str] = None,
        languagecode: Optional[int] = None,
        referenceid: Optional[str] = None,
        requesthash: Optional[str] = None,
        userid: Optional[int] = None
    ) -> Dict[str, Any]:
        """
        Authorize Collateral
        
        Generated from: PUT /loans/collateral/{collateralId}
        Source: swagger_2_0
        Operation ID: CRBT1801AuthTenantOwnedCltrlUsingPUT
        
        
        Authentication: Not required
        
        Parameters:
        - collateralId: string (required)
          Path parameter collateralId
        - request_body: any (required)
          input
        
        
        
        Headers:
        - Accesstoken: string
          Authorization token for identification of the caller
        - ChannelType: integer
          Channel identifier from where the TXN has originated (Internet, Mobile, ATM, Branch Channel )
        - Co-Relationid: integer
          Unique ID for the service invoked, will be set by the TXN system
        - InitiatingSystem: string
          Indicating the initiated system
        - ServiceMode: integer
          Used for branch channel to indicate the type of customer
        - UUIDSeqNo: integer
          UUID Sequence Number
        - entity: string
          entity
        - languageCode: integer
          languageCode
        - referenceId: string
          Place holder for Token based authentication
        - requesthash: string
          Request payload for hash validation
        - userId: integer
          userId
        
        
        """
        
        
        # Prepare request data
        
        # Single body parameter - send directly
        data = request_body if request_body is not None else {}
        
        
        
        # Prepare query parameters
        params = {}
        
        
        # Replace path parameters in URL
        path = "/loans/collateral/{collateralId}"
        if collateralid is not None:
            path = path.replace("{collateralId}", str(collateralid))
        
        
        # Prepare headers
        headers = {}
        if accesstoken is not None:
            headers["Accesstoken"] = str(accesstoken)
        if channeltype is not None:
            headers["ChannelType"] = str(channeltype)
        if co_relationid is not None:
            headers["Co-Relationid"] = str(co_relationid)
        if initiatingsystem is not None:
            headers["InitiatingSystem"] = str(initiatingsystem)
        if servicemode is not None:
            headers["ServiceMode"] = str(servicemode)
        if uuidseqno is not None:
            headers["UUIDSeqNo"] = str(uuidseqno)
        if entity is not None:
            headers["entity"] = str(entity)
        if languagecode is not None:
            headers["languageCode"] = str(languagecode)
        if referenceid is not None:
            headers["referenceId"] = str(referenceid)
        if requesthash is not None:
            headers["requesthash"] = str(requesthash)
        if userid is not None:
            headers["userId"] = str(userid)
        
        
        return await make_api_request(
            "PUT", 
            path, 
            data=data, 
            params=params if params else None, 
            headers=headers if headers else None
        )
    
    
    
    @mcp.tool()
    async def crbt2022_create_other_cltrl_postusing_post_1(
        request_body:Dict[str, Any] ,  # CLTRL_MASTER_CRBT2022CreateOtherCltrl_Resource,
        accesstoken: Optional[str] = None,
        channeltype: Optional[int] = None,
        co_relationid: Optional[int] = None,
        initiatingsystem: Optional[str] = None,
        servicemode: Optional[int] = None,
        uuidseqno: Optional[int] = None,
        entity: Optional[str] = None,
        languagecode: Optional[int] = None,
        referenceid: Optional[str] = None,
        requesthash: Optional[str] = None,
        userid: Optional[int] = None
    ) -> Dict[str, Any]:
        """
        Create Other Colateral
        
        Generated from: POST /loans/crbt2022createothercltrl
        Source: swagger_2_0
        Operation ID: CRBT2022CreateOtherCltrl_POSTUsingPOST_1
        
        
        Authentication: Not required
        
        Parameters:
        - request_body: any (required)
          input
        
        
        
        Headers:
        - Accesstoken: string
          Authorization token for identification of the caller
        - ChannelType: integer
          Channel identifier from where the TXN has originated (Internet, Mobile, ATM, Branch Channel )
        - Co-Relationid: integer
          Unique ID for the service invoked, will be set by the TXN system
        - InitiatingSystem: string
          Indicating the initiated system
        - ServiceMode: integer
          Used for branch channel to indicate the type of customer
        - UUIDSeqNo: integer
          UUID Sequence Number
        - entity: string
          entity
        - languageCode: integer
          languageCode
        - referenceId: string
          Place holder for Token based authentication
        - requesthash: string
          Request payload for hash validation
        - userId: integer
          userId
        
        
        """
        
        
        # Prepare request data
        
        # Single body parameter - send directly
        data = request_body if request_body is not None else {}
        
        
        
        # Prepare query parameters
        params = {}
        
        
        # Replace path parameters in URL
        path = "/loans/crbt2022createothercltrl"
        
        
        # Prepare headers
        headers = {}
        if accesstoken is not None:
            headers["Accesstoken"] = str(accesstoken)
        if channeltype is not None:
            headers["ChannelType"] = str(channeltype)
        if co_relationid is not None:
            headers["Co-Relationid"] = str(co_relationid)
        if initiatingsystem is not None:
            headers["InitiatingSystem"] = str(initiatingsystem)
        if servicemode is not None:
            headers["ServiceMode"] = str(servicemode)
        if uuidseqno is not None:
            headers["UUIDSeqNo"] = str(uuidseqno)
        if entity is not None:
            headers["entity"] = str(entity)
        if languagecode is not None:
            headers["languageCode"] = str(languagecode)
        if referenceid is not None:
            headers["referenceId"] = str(referenceid)
        if requesthash is not None:
            headers["requesthash"] = str(requesthash)
        if userid is not None:
            headers["userId"] = str(userid)
        
        
        return await make_api_request(
            "POST", 
            path, 
            data=data, 
            params=params if params else None, 
            headers=headers if headers else None
        )
    
    
    
    @mcp.tool()
    async def cret2912_simulate_tier_based_repayment_evnts_islamic_postusing_post(
        request_body:Dict[str, Any] ,  # SimulateRepaymentEventsIslamicWithMultitierResource,
        accesstoken: Optional[str] = None,
        channeltype: Optional[int] = None,
        co_relationid: Optional[int] = None,
        initiatingsystem: Optional[str] = None,
        servicemode: Optional[int] = None,
        uuidseqno: Optional[int] = None,
        entity: Optional[str] = None,
        languagecode: Optional[int] = None,
        referenceid: Optional[str] = None,
        requesthash: Optional[str] = None,
        userid: Optional[int] = None
    ) -> Dict[str, Any]:
        """
        Calculate Upfront Profit with Multitier Interest Rates
        
        Generated from: POST /loans/cret2912simulatetierbasedrepaymentevntsislamic
        Source: swagger_2_0
        Operation ID: CRET2912SimulateTierBasedRepaymentEvntsIslamic_POSTUsingPOST
        
        
        Authentication: Not required
        
        Parameters:
        - request_body: any (required)
          input
        
        
        
        Headers:
        - Accesstoken: string
          Authorization token for identification of the caller
        - ChannelType: integer
          Channel identifier from where the TXN has originated (Internet, Mobile, ATM, Branch Channel )
        - Co-Relationid: integer
          Unique ID for the service invoked, will be set by the TXN system
        - InitiatingSystem: string
          Indicating the initiated system
        - ServiceMode: integer
          Used for branch channel to indicate the type of customer
        - UUIDSeqNo: integer
          UUID Sequence Number
        - entity: string
          entity
        - languageCode: integer
          languageCode
        - referenceId: string
          Place holder for Token based authentication
        - requesthash: string
          Request payload for hash validation
        - userId: integer
          userId
        
        
        """
        
        
        # Prepare request data
        
        # Single body parameter - send directly
        data = request_body if request_body is not None else {}
        
        
        
        # Prepare query parameters
        params = {}
        
        
        # Replace path parameters in URL
        path = "/loans/cret2912simulatetierbasedrepaymentevntsislamic"
        
        
        # Prepare headers
        headers = {}
        if accesstoken is not None:
            headers["Accesstoken"] = str(accesstoken)
        if channeltype is not None:
            headers["ChannelType"] = str(channeltype)
        if co_relationid is not None:
            headers["Co-Relationid"] = str(co_relationid)
        if initiatingsystem is not None:
            headers["InitiatingSystem"] = str(initiatingsystem)
        if servicemode is not None:
            headers["ServiceMode"] = str(servicemode)
        if uuidseqno is not None:
            headers["UUIDSeqNo"] = str(uuidseqno)
        if entity is not None:
            headers["entity"] = str(entity)
        if languagecode is not None:
            headers["languageCode"] = str(languagecode)
        if referenceid is not None:
            headers["referenceId"] = str(referenceid)
        if requesthash is not None:
            headers["requesthash"] = str(requesthash)
        if userid is not None:
            headers["userId"] = str(userid)
        
        
        return await make_api_request(
            "POST", 
            path, 
            data=data, 
            params=params if params else None, 
            headers=headers if headers else None
        )
    
    
    
    @mcp.tool()
    async def cret0101_fetch_loan_details_using_get(
        loanreference: str,
        accesstoken: Optional[str] = None,
        channeltype: Optional[int] = None,
        co_relationid: Optional[int] = None,
        initiatingsystem: Optional[str] = None,
        servicemode: Optional[int] = None,
        uuidseqno: Optional[int] = None,
        entity: Optional[str] = None,
        languagecode: Optional[int] = None,
        referenceid: Optional[str] = None,
        userid: Optional[int] = None
    ) -> Dict[str, Any]:
        """
        Fetch Loan Account Details
        
        Generated from: GET /loans/details/{loanReference}
        Source: swagger_2_0
        Operation ID: CRET0101FetchLoanDetailsUsingGET
        
        
        Authentication: Not required
        
        Parameters:
        - loanReference: string (required)
          Loan Account Reference
        
        
        
        Headers:
        - Accesstoken: string
          Authorization token for identification of the caller
        - ChannelType: integer
          Channel identifier from where the TXN has originated (Internet, Mobile, ATM, Branch Channel )
        - Co-Relationid: integer
          Unique ID for the service invoked, will be set by the TXN system
        - InitiatingSystem: string
          Indicating the initiated system
        - ServiceMode: integer
          Used for branch channel to indicate the type of customer
        - UUIDSeqNo: integer
          UUID Sequence Number
        - entity: string
          entity
        - languageCode: integer
          languageCode
        - referenceId: string
          Place holder for Token based authentication
        - userId: integer
          userId
        
        
        """
        
        
        # Prepare query parameters
        params = {}
        
        
        # Replace path parameters in URL
        path = "/loans/details/{loanReference}"
        if loanreference is not None:
            path = path.replace("{loanReference}", str(loanreference))
        
        
        # Prepare headers
        headers = {}
        if accesstoken is not None:
            headers["Accesstoken"] = str(accesstoken)
        if channeltype is not None:
            headers["ChannelType"] = str(channeltype)
        if co_relationid is not None:
            headers["Co-Relationid"] = str(co_relationid)
        if initiatingsystem is not None:
            headers["InitiatingSystem"] = str(initiatingsystem)
        if servicemode is not None:
            headers["ServiceMode"] = str(servicemode)
        if uuidseqno is not None:
            headers["UUIDSeqNo"] = str(uuidseqno)
        if entity is not None:
            headers["entity"] = str(entity)
        if languagecode is not None:
            headers["languageCode"] = str(languagecode)
        if referenceid is not None:
            headers["referenceId"] = str(referenceid)
        if userid is not None:
            headers["userId"] = str(userid)
        
        
        return await make_api_request(
            "GET", 
            path, 
            
            params=params if params else None, 
            headers=headers if headers else None
        )
    
    
    
    @mcp.tool()
    async def crbt4211_down_disb_losmaster_wrapper_postusing_post(
        request_body:Dict[str, Any] ,  # CR_LOAN_EXT_CRBT4211DownDisbLOSMasterWrapper_Resource,
        accesstoken: Optional[str] = None,
        channeltype: Optional[int] = None,
        co_relationid: Optional[int] = None,
        initiatingsystem: Optional[str] = None,
        servicemode: Optional[int] = None,
        uuidseqno: Optional[int] = None,
        entity: Optional[str] = None,
        languagecode: Optional[int] = None,
        referenceid: Optional[str] = None,
        requesthash: Optional[str] = None,
        userid: Optional[int] = None
    ) -> Dict[str, Any]:
        """
        This API is used for disburse of loans
        
        Generated from: POST /loans/disburse
        Source: swagger_2_0
        Operation ID: CRBT4211DownDisbLOSMasterWrapper_POSTUsingPOST
        
        
        Authentication: Not required
        
        Parameters:
        - request_body: any (required)
          input
        
        
        
        Headers:
        - Accesstoken: string
          Authorization Token to validation the caller
        - ChannelType: integer
          Channel identifier from where the TXN has originated (Internet, Mobile, ATM, Branch Channel )
        - Co-Relationid: integer
          Unique ID for the service invoked, will be set by the TXN system
        - InitiatingSystem: string
          Indicating the initiated system
        - ServiceMode: integer
          Used for branch channel to indicate the type of customer
        - UUIDSeqNo: integer
          UUID Sequence Number
        - entity: string
          entity
        - languageCode: integer
          languageCode
        - referenceId: string
          Place holder for Token based authentication
        - requesthash: string
          Request payload for hash validation
        - userId: integer
          userId
        
        
        """
        
        
        # Prepare request data
        
        # Single body parameter - send directly
        data = request_body if request_body is not None else {}
        
        
        
        # Prepare query parameters
        params = {}
        
        
        # Replace path parameters in URL
        path = "/loans/disburse"
        
        
        # Prepare headers
        headers = {}
        if accesstoken is not None:
            headers["Accesstoken"] = str(accesstoken)
        if channeltype is not None:
            headers["ChannelType"] = str(channeltype)
        if co_relationid is not None:
            headers["Co-Relationid"] = str(co_relationid)
        if initiatingsystem is not None:
            headers["InitiatingSystem"] = str(initiatingsystem)
        if servicemode is not None:
            headers["ServiceMode"] = str(servicemode)
        if uuidseqno is not None:
            headers["UUIDSeqNo"] = str(uuidseqno)
        if entity is not None:
            headers["entity"] = str(entity)
        if languagecode is not None:
            headers["languageCode"] = str(languagecode)
        if referenceid is not None:
            headers["referenceId"] = str(referenceid)
        if requesthash is not None:
            headers["requesthash"] = str(requesthash)
        if userid is not None:
            headers["userId"] = str(userid)
        
        
        return await make_api_request(
            "POST", 
            path, 
            data=data, 
            params=params if params else None, 
            headers=headers if headers else None
        )
    
    
    
    @mcp.tool()
    async def crbt1752_auth_disbur_req_using_put(
        request_body:Dict[str, Any] ,  # loanDisbursementAuthResource,
        accesstoken: Optional[str] = None,
        channeltype: Optional[int] = None,
        co_relationid: Optional[int] = None,
        initiatingsystem: Optional[str] = None,
        servicemode: Optional[int] = None,
        uuidseqno: Optional[int] = None,
        entity: Optional[str] = None,
        languagecode: Optional[int] = None,
        referenceid: Optional[str] = None,
        requesthash: Optional[str] = None,
        userid: Optional[int] = None
    ) -> Dict[str, Any]:
        """
        This service is to authorize the Loan disbursement request which is in pending authorization status
        
        Generated from: PUT /loans/disbursement/authorize
        Source: swagger_2_0
        Operation ID: CRBT1752AuthDisburReqUsingPUT
        
        
        Authentication: Not required
        
        Parameters:
        - request_body: any (required)
          input
        
        
        
        Headers:
        - Accesstoken: string
          Authorization Token to validation the caller
        - ChannelType: integer
          Channel identifier from where the TXN has originated (Internet, Mobile, ATM, Branch Channel )
        - Co-Relationid: integer
          Unique ID for the service invoked, will be set by the TXN system
        - InitiatingSystem: string
          Indicating the initiated system
        - ServiceMode: integer
          Used for branch channel to indicate the type of customer
        - UUIDSeqNo: integer
          UUID Sequence Number
        - entity: string
          entity
        - languageCode: integer
          languageCode
        - referenceId: string
          Place holder for Token based authentication
        - requesthash: string
          Request payload for hash validation
        - userId: integer
          userId
        
        
        """
        
        
        # Prepare request data
        
        # Single body parameter - send directly
        data = request_body if request_body is not None else {}
        
        
        
        # Prepare query parameters
        params = {}
        
        
        # Replace path parameters in URL
        path = "/loans/disbursement/authorize"
        
        
        # Prepare headers
        headers = {}
        if accesstoken is not None:
            headers["Accesstoken"] = str(accesstoken)
        if channeltype is not None:
            headers["ChannelType"] = str(channeltype)
        if co_relationid is not None:
            headers["Co-Relationid"] = str(co_relationid)
        if initiatingsystem is not None:
            headers["InitiatingSystem"] = str(initiatingsystem)
        if servicemode is not None:
            headers["ServiceMode"] = str(servicemode)
        if uuidseqno is not None:
            headers["UUIDSeqNo"] = str(uuidseqno)
        if entity is not None:
            headers["entity"] = str(entity)
        if languagecode is not None:
            headers["languageCode"] = str(languagecode)
        if referenceid is not None:
            headers["referenceId"] = str(referenceid)
        if requesthash is not None:
            headers["requesthash"] = str(requesthash)
        if userid is not None:
            headers["userId"] = str(userid)
        
        
        return await make_api_request(
            "PUT", 
            path, 
            data=data, 
            params=params if params else None, 
            headers=headers if headers else None
        )
    
    
    
    @mcp.tool()
    async def crbt1751_create_disbur_req_using_post(
        request_body:Dict[str, Any] ,  # loanDisbursementResource,
        accesstoken: Optional[str] = None,
        channeltype: Optional[int] = None,
        co_relationid: Optional[int] = None,
        initiatingsystem: Optional[str] = None,
        servicemode: Optional[int] = None,
        uuidseqno: Optional[int] = None,
        entity: Optional[str] = None,
        languagecode: Optional[int] = None,
        referenceid: Optional[str] = None,
        requesthash: Optional[str] = None,
        userid: Optional[int] = None
    ) -> Dict[str, Any]:
        """
        This service is to create the Loan disbursement request in pending authorization status
        
        Generated from: POST /loans/disbursement/onHold
        Source: swagger_2_0
        Operation ID: CRBT1751CreateDisburReqUsingPOST
        
        
        Authentication: Not required
        
        Parameters:
        - request_body: any (required)
          input
        
        
        
        Headers:
        - Accesstoken: string
          Authorization Token to validation the caller
        - ChannelType: integer
          Channel identifier from where the TXN has originated (Internet, Mobile, ATM, Branch Channel )
        - Co-Relationid: integer
          Unique ID for the service invoked, will be set by the TXN system
        - InitiatingSystem: string
          Indicating the initiated system
        - ServiceMode: integer
          Used for branch channel to indicate the type of customer
        - UUIDSeqNo: integer
          UUID Sequence Number
        - entity: string
          entity
        - languageCode: integer
          languageCode
        - referenceId: string
          Place holder for Token based authentication
        - requesthash: string
          Request payload for hash validation
        - userId: integer
          userId
        
        
        """
        
        
        # Prepare request data
        
        # Single body parameter - send directly
        data = request_body if request_body is not None else {}
        
        
        
        # Prepare query parameters
        params = {}
        
        
        # Replace path parameters in URL
        path = "/loans/disbursement/onHold"
        
        
        # Prepare headers
        headers = {}
        if accesstoken is not None:
            headers["Accesstoken"] = str(accesstoken)
        if channeltype is not None:
            headers["ChannelType"] = str(channeltype)
        if co_relationid is not None:
            headers["Co-Relationid"] = str(co_relationid)
        if initiatingsystem is not None:
            headers["InitiatingSystem"] = str(initiatingsystem)
        if servicemode is not None:
            headers["ServiceMode"] = str(servicemode)
        if uuidseqno is not None:
            headers["UUIDSeqNo"] = str(uuidseqno)
        if entity is not None:
            headers["entity"] = str(entity)
        if languagecode is not None:
            headers["languageCode"] = str(languagecode)
        if referenceid is not None:
            headers["referenceId"] = str(referenceid)
        if requesthash is not None:
            headers["requesthash"] = str(requesthash)
        if userid is not None:
            headers["userId"] = str(userid)
        
        
        return await make_api_request(
            "POST", 
            path, 
            data=data, 
            params=params if params else None, 
            headers=headers if headers else None
        )
    
    
    
    @mcp.tool()
    async def cret0601_gt_dsbrsmnt_schdl_lst_getusing_get(
        loanaccountnumber: str,
        accesstoken: Optional[str] = None,
        channeltype: Optional[int] = None,
        co_relationid: Optional[int] = None,
        initiatingsystem: Optional[str] = None,
        servicemode: Optional[int] = None,
        uuidseqno: Optional[int] = None,
        entity: Optional[str] = None,
        languagecode: Optional[int] = None,
        referenceid: Optional[str] = None,
        userid: Optional[int] = None
    ) -> Dict[str, Any]:
        """
        This service displays disbursement schedule created for loans
        
        Generated from: GET /loans/disbursement/view/{loanAccountNumber}
        Source: swagger_2_0
        Operation ID: CRET0601GtDsbrsmntSchdlLst_GETUsingGET
        
        
        Authentication: Not required
        
        Parameters:
        - loanAccountNumber: string (required)
          Customer loan reference number
        
        
        
        Headers:
        - Accesstoken: string
          Authorization token for identification of the caller
        - ChannelType: integer
          Channel identifier from where the TXN has originated (Internet, Mobile, ATM, Branch Channel )
        - Co-Relationid: integer
          Unique ID for the service invoked, will be set by the TXN system
        - InitiatingSystem: string
          Indicating the initiated system
        - ServiceMode: integer
          Used for branch channel to indicate the type of customer
        - UUIDSeqNo: integer
          UUID Sequence Number
        - entity: string
          entity
        - languageCode: integer
          languageCode
        - referenceId: string
          Place holder for Token based authentication
        - userId: integer
          userId
        
        
        """
        
        
        # Prepare query parameters
        params = {}
        
        
        # Replace path parameters in URL
        path = "/loans/disbursement/view/{loanAccountNumber}"
        if loanaccountnumber is not None:
            path = path.replace("{loanAccountNumber}", str(loanaccountnumber))
        
        
        # Prepare headers
        headers = {}
        if accesstoken is not None:
            headers["Accesstoken"] = str(accesstoken)
        if channeltype is not None:
            headers["ChannelType"] = str(channeltype)
        if co_relationid is not None:
            headers["Co-Relationid"] = str(co_relationid)
        if initiatingsystem is not None:
            headers["InitiatingSystem"] = str(initiatingsystem)
        if servicemode is not None:
            headers["ServiceMode"] = str(servicemode)
        if uuidseqno is not None:
            headers["UUIDSeqNo"] = str(uuidseqno)
        if entity is not None:
            headers["entity"] = str(entity)
        if languagecode is not None:
            headers["languageCode"] = str(languagecode)
        if referenceid is not None:
            headers["referenceId"] = str(referenceid)
        if userid is not None:
            headers["userId"] = str(userid)
        
        
        return await make_api_request(
            "GET", 
            path, 
            
            params=params if params else None, 
            headers=headers if headers else None
        )
    
    
    
    @mcp.tool()
    async def crbt2018_crt_disb_sch_on_hold_using_post(
        request_body:Dict[str, Any] ,  # disbursementScheduleOnHoldResource,
        accesstoken: Optional[str] = None,
        channeltype: Optional[int] = None,
        co_relationid: Optional[int] = None,
        entity: Optional[str] = None,
        initiatingsystem: Optional[str] = None,
        languagecode: Optional[int] = None,
        referenceid: Optional[str] = None,
        requesthash: Optional[str] = None,
        servicemode: Optional[int] = None,
        userid: Optional[int] = None,
        uuidseqno: Optional[int] = None
    ) -> Dict[str, Any]:
        """
        Disbursement Schedule on hold
        
        Generated from: POST /loans/disbursementSchedule
        Source: swagger_2_0
        Operation ID: CRBT2018CrtDisbSchOnHoldUsingPOST
        
        
        Authentication: Not required
        
        Parameters:
        - request_body: any (required)
          input
        
        
        
        Headers:
        - accessToken: string
          Authorization Token to validation the caller
        - channelType: integer
          Channel identifier from where the TXN has originated (Internet, Mobile, ATM, Branch Channel )
        - co-Relationid: integer
          Unique ID for the service invoked, will be set by the TXN system
        - entity: string
          entity
        - initiatingSystem: string
          Indicating the initiated system
        - languageCode: integer
          languageCode
        - referenceId: string
          Place holder for Token based authentication
        - requestHash: string
          Request payload for hash validation
        - serviceMode: integer
          Used for branch channel to indicate the type of customer
        - userId: integer
          userId
        - uuidSeqNo: integer
          UUID Sequence Number
        
        
        """
        
        
        # Prepare request data
        
        # Single body parameter - send directly
        data = request_body if request_body is not None else {}
        
        
        
        # Prepare query parameters
        params = {}
        
        
        # Replace path parameters in URL
        path = "/loans/disbursementSchedule"
        
        
        # Prepare headers
        headers = {}
        if accesstoken is not None:
            headers["accessToken"] = str(accesstoken)
        if channeltype is not None:
            headers["channelType"] = str(channeltype)
        if co_relationid is not None:
            headers["co-Relationid"] = str(co_relationid)
        if entity is not None:
            headers["entity"] = str(entity)
        if initiatingsystem is not None:
            headers["initiatingSystem"] = str(initiatingsystem)
        if languagecode is not None:
            headers["languageCode"] = str(languagecode)
        if referenceid is not None:
            headers["referenceId"] = str(referenceid)
        if requesthash is not None:
            headers["requestHash"] = str(requesthash)
        if servicemode is not None:
            headers["serviceMode"] = str(servicemode)
        if userid is not None:
            headers["userId"] = str(userid)
        if uuidseqno is not None:
            headers["uuidSeqNo"] = str(uuidseqno)
        
        
        return await make_api_request(
            "POST", 
            path, 
            data=data, 
            params=params if params else None, 
            headers=headers if headers else None
        )
    
    
    
    @mcp.tool()
    async def cret6827_fetch_loan_writeoff_dtls_using_get(
        balancetype: int,
        businessdate: str,
        loanreference: str,
        accesstoken: Optional[str] = None,
        channeltype: Optional[int] = None,
        co_relationid: Optional[int] = None,
        initiatingsystem: Optional[str] = None,
        servicemode: Optional[int] = None,
        uuidseqno: Optional[int] = None,
        entity: Optional[str] = None,
        languagecode: Optional[int] = None,
        referenceid: Optional[str] = None,
        userid: Optional[int] = None
    ) -> Dict[str, Any]:
        """
        Fetch Loan Balance
        
        Generated from: GET /loans/enquiry/loanDischargeEnquiry
        Source: swagger_2_0
        Operation ID: CRET6827FetchLoanWriteoffDtlsUsingGET
        
        
        Authentication: Not required
        
        Parameters:
        - balanceType: integer (required)
          Indicates the balance component:1 - Interest,2 - Fees,4 - Penal,5 - Principal,6 - ODPrincipal,7 - ODInterest,8 - ODPenalInterest,9 - ODFees,31 - InsuranceBal.More balance type refer d_CmpntTyp
        - businessDate: string (required)
          Date on which Balance of the loan account is derived(Date format : YYYYMMDD).
        - loanReference: string (required)
          Reference Number generated for account based on configured scheme
        
        
        
        Headers:
        - Accesstoken: string
          Authorization token for identification of the caller
        - ChannelType: integer
          Channel identifier from where the TXN has originated (Internet, Mobile, ATM, Branch Channel )
        - Co-Relationid: integer
          Unique ID for the service invoked, will be set by the TXN system
        - InitiatingSystem: string
          Indicating the initiated system
        - ServiceMode: integer
          Used for branch channel to indicate the type of customer
        - UUIDSeqNo: integer
          UUID Sequence Number
        - entity: string
          entity
        - languageCode: integer
          languageCode
        - referenceId: string
          Place holder for Token based authentication
        - userId: integer
          userId
        
        
        """
        
        
        # Prepare query parameters
        params = {}
        if balancetype is not None:
            params["balanceType"] = balancetype
            
        if businessdate is not None:
            params["businessDate"] = businessdate
            
        if loanreference is not None:
            params["loanReference"] = loanreference
            
        
        
        # Replace path parameters in URL
        path = "/loans/enquiry/loanDischargeEnquiry"
        
        
        # Prepare headers
        headers = {}
        if accesstoken is not None:
            headers["Accesstoken"] = str(accesstoken)
        if channeltype is not None:
            headers["ChannelType"] = str(channeltype)
        if co_relationid is not None:
            headers["Co-Relationid"] = str(co_relationid)
        if initiatingsystem is not None:
            headers["InitiatingSystem"] = str(initiatingsystem)
        if servicemode is not None:
            headers["ServiceMode"] = str(servicemode)
        if uuidseqno is not None:
            headers["UUIDSeqNo"] = str(uuidseqno)
        if entity is not None:
            headers["entity"] = str(entity)
        if languagecode is not None:
            headers["languageCode"] = str(languagecode)
        if referenceid is not None:
            headers["referenceId"] = str(referenceid)
        if userid is not None:
            headers["userId"] = str(userid)
        
        
        return await make_api_request(
            "GET", 
            path, 
            
            params=params if params else None, 
            headers=headers if headers else None
        )
    
    
    
    @mcp.tool()
    async def cret1401_get_crloan_lst_postusing_get(
        primaryborrowerid: int,
        islamicflag: Optional[int] = None,
        limit: Optional[str] = None,
        loanstatus: Optional[int] = None,
        pagenum: Optional[int] = None,
        pagesize: Optional[int] = None,
        portfolioid: Optional[int] = None,
        accesstoken: Optional[str] = None,
        channeltype: Optional[int] = None,
        co_relationid: Optional[int] = None,
        initiatingsystem: Optional[str] = None,
        servicemode: Optional[int] = None,
        uuidseqno: Optional[int] = None,
        entity: Optional[str] = None,
        languagecode: Optional[int] = None,
        referenceid: Optional[str] = None,
        userid: Optional[int] = None
    ) -> Dict[str, Any]:
        """
        This service displays all the retail loans that are created
        
        Generated from: GET /loans/enquiry/loanList/{primaryBorrowerId}
        Source: swagger_2_0
        Operation ID: CRET1401GetCRLoanLst_POSTUsingGET
        
        
        Authentication: Not required
        
        Parameters:
        - islamicFlag: integer
          Islamic Flag 1 - Islamic Loans 2 - Conventional Loans
        - limit: string
          Enter the Limit Value
        - loanStatus: integer
          Loan Status 24-Active,20-InProgress,21-Grant,37-PendingWithdrwl,38-PendingAuth,36-Frozen,29-DebitFrozen,27-Closed (Domain Name:d_LoanStatus)
        - pageNum: integer
          pageNum
        - pageSize: integer
          pageSize
        - portfolioID: integer
          PortFolio ID
        - primaryBorrowerId: integer (required)
          Customer reference of Primary borrower
        
        
        
        Headers:
        - Accesstoken: string
          Authorization token for identification of the caller
        - ChannelType: integer
          Channel identifier from where the TXN has originated (Internet, Mobile, ATM, Branch Channel )
        - Co-Relationid: integer
          Unique ID for the service invoked, will be set by the TXN system
        - InitiatingSystem: string
          Indicating the initiated system
        - ServiceMode: integer
          Used for branch channel to indicate the type of customer
        - UUIDSeqNo: integer
          UUID Sequence Number
        - entity: string
          entity
        - languageCode: integer
          languageCode
        - referenceId: string
          Place holder for Token based authentication
        - userId: integer
          userId
        
        
        """
        
        
        # Prepare query parameters
        params = {}
        if islamicflag is not None:
            params["islamicFlag"] = islamicflag
            
        if limit is not None:
            params["limit"] = limit
            
        if loanstatus is not None:
            params["loanStatus"] = loanstatus
            
        if pagenum is not None:
            params["pageNum"] = pagenum
            
        if pagesize is not None:
            params["pageSize"] = pagesize
            
        if portfolioid is not None:
            params["portfolioID"] = portfolioid
            
        
        
        # Replace path parameters in URL
        path = "/loans/enquiry/loanList/{primaryBorrowerId}"
        if primaryborrowerid is not None:
            path = path.replace("{primaryBorrowerId}", str(primaryborrowerid))
        
        
        # Prepare headers
        headers = {}
        if accesstoken is not None:
            headers["Accesstoken"] = str(accesstoken)
        if channeltype is not None:
            headers["ChannelType"] = str(channeltype)
        if co_relationid is not None:
            headers["Co-Relationid"] = str(co_relationid)
        if initiatingsystem is not None:
            headers["InitiatingSystem"] = str(initiatingsystem)
        if servicemode is not None:
            headers["ServiceMode"] = str(servicemode)
        if uuidseqno is not None:
            headers["UUIDSeqNo"] = str(uuidseqno)
        if entity is not None:
            headers["entity"] = str(entity)
        if languagecode is not None:
            headers["languageCode"] = str(languagecode)
        if referenceid is not None:
            headers["referenceId"] = str(referenceid)
        if userid is not None:
            headers["userId"] = str(userid)
        
        
        return await make_api_request(
            "GET", 
            path, 
            
            params=params if params else None, 
            headers=headers if headers else None
        )
    
    
    
    @mcp.tool()
    async def cbcetget_mini_stmnt_ib_postusing_get(
        loanreference: str,
        balancetype: int,
        # loanreference: str,
        fromdate: Optional[str] = None,
        todate: Optional[str] = None,
        pagenum: Optional[int] = None,
        pagesize: Optional[int] = None,
        accesstoken: Optional[str] = None,
        channeltype: Optional[int] = None,
        co_relationid: Optional[int] = None,
        initiatingsystem: Optional[str] = None,
        servicemode: Optional[int] = None,
        uuidseqno: Optional[int] = None,
        entity: Optional[str] = None,
        languagecode: Optional[int] = None,
        referenceid: Optional[str] = None,
        userid: Optional[int] = None
    ) -> Dict[str, Any]:
        """
        View Loan transactions along with running balance
        
        Generated from: GET /loans/enquiry/loanMiniStatement/{loanReference}
        Source: swagger_2_0
        Operation ID: CBCETGetMiniStmntIB_POSTUsingGET
        
        
        Authentication: Not required
        
        Parameters:
        - FromDate: string
          Transactions from date(format:YYYYMMDD)
        - ToDate: string
          Transactions to date(format:YYYYMMDD)
        - balanceType: integer (required)
          Balance type
        - loanReference: string (required)
          Reference Number generated for account based on configured scheme
        - pageNum: integer
          pageNum
        - pageSize: integer
          pageSize
        - loanReference: string (required)
          Path parameter loanReference
        
        
        
        Headers:
        - Accesstoken: string
          Authorization token for identification of the caller
        - ChannelType: integer
          Channel identifier from where the TXN has originated (Internet, Mobile, ATM, Branch Channel )
        - Co-Relationid: integer
          Unique ID for the service invoked, will be set by the TXN system
        - InitiatingSystem: string
          Indicating the initiated system
        - ServiceMode: integer
          Used for branch channel to indicate the type of customer
        - UUIDSeqNo: integer
          UUID Sequence Number
        - entity: string
          entity
        - languageCode: integer
          languageCode
        - referenceId: string
          Place holder for Token based authentication
        - userId: integer
          userId
        
        
        """
        
        
        # Prepare query parameters
        params = {}
        if fromdate is not None:
            params["FromDate"] = fromdate
            
        if todate is not None:
            params["ToDate"] = todate
            
        if balancetype is not None:
            params["balanceType"] = balancetype
            
        if loanreference is not None:
            params["loanReference"] = loanreference
            
        if pagenum is not None:
            params["pageNum"] = pagenum
            
        if pagesize is not None:
            params["pageSize"] = pagesize
            
        
        
        # Replace path parameters in URL
        path = "/loans/enquiry/loanMiniStatement/{loanReference}"
        if loanreference is not None:
            path = path.replace("{loanReference}", str(loanreference))
        
        
        # Prepare headers
        headers = {}
        if accesstoken is not None:
            headers["Accesstoken"] = str(accesstoken)
        if channeltype is not None:
            headers["ChannelType"] = str(channeltype)
        if co_relationid is not None:
            headers["Co-Relationid"] = str(co_relationid)
        if initiatingsystem is not None:
            headers["InitiatingSystem"] = str(initiatingsystem)
        if servicemode is not None:
            headers["ServiceMode"] = str(servicemode)
        if uuidseqno is not None:
            headers["UUIDSeqNo"] = str(uuidseqno)
        if entity is not None:
            headers["entity"] = str(entity)
        if languagecode is not None:
            headers["languageCode"] = str(languagecode)
        if referenceid is not None:
            headers["referenceId"] = str(referenceid)
        if userid is not None:
            headers["userId"] = str(userid)
        
        
        return await make_api_request(
            "GET", 
            path, 
            
            params=params if params else None, 
            headers=headers if headers else None
        )
    
    
    
    @mcp.tool()
    async def cret4087_listof_prenotice_postusing_get(
        loanreference: str,
        pagenum: Optional[int] = None,
        pagesize: Optional[int] = None,
        accesstoken: Optional[str] = None,
        channeltype: Optional[int] = None,
        co_relationid: Optional[int] = None,
        initiatingsystem: Optional[str] = None,
        servicemode: Optional[int] = None,
        uuidseqno: Optional[int] = None,
        entity: Optional[str] = None,
        languagecode: Optional[int] = None,
        referenceid: Optional[str] = None,
        userid: Optional[int] = None
    ) -> Dict[str, Any]:
        """
        List of Prenotice of Loan
        
        Generated from: GET /loans/enquiry/loanPreNoticeList/{loanReference}
        Source: swagger_2_0
        Operation ID: CRET4087ListofPrenotice_POSTUsingGET
        
        
        Authentication: Not required
        
        Parameters:
        - loanReference: string (required)
          Reference Number generated for account based on configured scheme
        - pageNum: integer
          pageNum
        - pageSize: integer
          pageSize
        
        
        
        Headers:
        - Accesstoken: string
          Authorization token for identification of the caller
        - ChannelType: integer
          Channel identifier from where the TXN has originated (Internet, Mobile, ATM, Branch Channel )
        - Co-Relationid: integer
          Unique ID for the service invoked, will be set by the TXN system
        - InitiatingSystem: string
          Indicating the initiated system
        - ServiceMode: integer
          Used for branch channel to indicate the type of customer
        - UUIDSeqNo: integer
          UUID Sequence Number
        - entity: string
          entity
        - languageCode: integer
          languageCode
        - referenceId: string
          Place holder for Token based authentication
        - userId: integer
          userId
        
        
        """
        
        
        # Prepare query parameters
        params = {}
        if pagenum is not None:
            params["pageNum"] = pagenum
            
        if pagesize is not None:
            params["pageSize"] = pagesize
            
        
        
        # Replace path parameters in URL
        path = "/loans/enquiry/loanPreNoticeList/{loanReference}"
        if loanreference is not None:
            path = path.replace("{loanReference}", str(loanreference))
        
        
        # Prepare headers
        headers = {}
        if accesstoken is not None:
            headers["Accesstoken"] = str(accesstoken)
        if channeltype is not None:
            headers["ChannelType"] = str(channeltype)
        if co_relationid is not None:
            headers["Co-Relationid"] = str(co_relationid)
        if initiatingsystem is not None:
            headers["InitiatingSystem"] = str(initiatingsystem)
        if servicemode is not None:
            headers["ServiceMode"] = str(servicemode)
        if uuidseqno is not None:
            headers["UUIDSeqNo"] = str(uuidseqno)
        if entity is not None:
            headers["entity"] = str(entity)
        if languagecode is not None:
            headers["languageCode"] = str(languagecode)
        if referenceid is not None:
            headers["referenceId"] = str(referenceid)
        if userid is not None:
            headers["userId"] = str(userid)
        
        
        return await make_api_request(
            "GET", 
            path, 
            
            params=params if params else None, 
            headers=headers if headers else None
        )
    
    
    
    @mcp.tool()
    async def cret1708_fetch_prepay_repay_holiday_txns_using_get(
        loanreference: str,
        pagenum: Optional[int] = None,
        pagesize: Optional[int] = None,
        accesstoken: Optional[str] = None,
        channeltype: Optional[int] = None,
        co_relationid: Optional[int] = None,
        initiatingsystem: Optional[str] = None,
        servicemode: Optional[int] = None,
        uuidseqno: Optional[int] = None,
        entity: Optional[str] = None,
        languagecode: Optional[int] = None,
        referenceid: Optional[str] = None,
        userid: Optional[int] = None
    ) -> Dict[str, Any]:
        """
        This service will list all transactions which are pending
        
        Generated from: GET /loans/enquiry/pendingtransactionList/{loanReference}
        Source: swagger_2_0
        Operation ID: CRET1708FetchPrepayRepayHolidayTxnsUsingGET
        
        
        Authentication: Not required
        
        Parameters:
        - loanReference: string (required)
          Reference Number generated for account based on configured scheme
        - pageNum: integer
          pageNum
        - pageSize: integer
          pageSize
        
        
        
        Headers:
        - Accesstoken: string
          Authorization token for identification of the caller
        - ChannelType: integer
          Channel identifier from where the TXN has originated (Internet, Mobile, ATM, Branch Channel )
        - Co-Relationid: integer
          Unique ID for the service invoked, will be set by the TXN system
        - InitiatingSystem: string
          Indicating the initiated system
        - ServiceMode: integer
          Used for branch channel to indicate the type of customer
        - UUIDSeqNo: integer
          UUID Sequence Number
        - entity: string
          entity
        - languageCode: integer
          languageCode
        - referenceId: string
          Place holder for Token based authentication
        - userId: integer
          userId
        
        
        """
        
        
        # Prepare query parameters
        params = {}
        if pagenum is not None:
            params["pageNum"] = pagenum
            
        if pagesize is not None:
            params["pageSize"] = pagesize
            
        
        
        # Replace path parameters in URL
        path = "/loans/enquiry/pendingtransactionList/{loanReference}"
        if loanreference is not None:
            path = path.replace("{loanReference}", str(loanreference))
        
        
        # Prepare headers
        headers = {}
        if accesstoken is not None:
            headers["Accesstoken"] = str(accesstoken)
        if channeltype is not None:
            headers["ChannelType"] = str(channeltype)
        if co_relationid is not None:
            headers["Co-Relationid"] = str(co_relationid)
        if initiatingsystem is not None:
            headers["InitiatingSystem"] = str(initiatingsystem)
        if servicemode is not None:
            headers["ServiceMode"] = str(servicemode)
        if uuidseqno is not None:
            headers["UUIDSeqNo"] = str(uuidseqno)
        if entity is not None:
            headers["entity"] = str(entity)
        if languagecode is not None:
            headers["languageCode"] = str(languagecode)
        if referenceid is not None:
            headers["referenceId"] = str(referenceid)
        if userid is not None:
            headers["userId"] = str(userid)
        
        
        return await make_api_request(
            "GET", 
            path, 
            
            params=params if params else None, 
            headers=headers if headers else None
        )
    
    
    
    @mcp.tool()
    async def cbcet2001_calc_rngbal_postusing_get(
        loanreference: str,
        fromdate: Optional[str] = None,
        todate: Optional[str] = None,
        fromamount: Optional[float] = None,
        movementdescription: Optional[str] = None,
        pagenum: Optional[int] = None,
        pagesize: Optional[int] = None,
        toamount: Optional[float] = None,
        transactionaccounttype: Optional[int] = None,
        transactionid: Optional[str] = None,
        accesstoken: Optional[str] = None,
        channeltype: Optional[int] = None,
        co_relationid: Optional[int] = None,
        initiatingsystem: Optional[str] = None,
        servicemode: Optional[int] = None,
        uuidseqno: Optional[int] = None,
        entity: Optional[str] = None,
        languagecode: Optional[int] = None,
        referenceid: Optional[str] = None,
        userid: Optional[int] = None
    ) -> Dict[str, Any]:
        """
        View Loan transactions along with running balance
        
        Generated from: GET /loans/enquiry/transactionList/{loanReference}
        Source: swagger_2_0
        Operation ID: CBCET2001CalcRNGBal_POSTUsingGET
        
        
        Authentication: Not required
        
        Parameters:
        - FromDate: string
          Transactions From Date(Date Format : YYYYMMDD)
        - ToDate: string
          Transactions To Date(Date Format : YYYYMMDD)
        - fromAmount: number
          Enter the From amount of the transaction
        - loanReference: string (required)
          Reference Number generated for account based on configured scheme
        - movementDescription: string
          Movement Description
        - pageNum: integer
          pageNum
        - pageSize: integer
          pageSize
        - toAmount: number
          enter the To amount of the transaction
        - transactionAccountType: integer
          Enter the transaction account type in the transaction (Domain Name: d_CrDrFlg) Eg : 1-Credit, 2-Debit
        - transactionId: string
          Transaction Id
        
        
        
        Headers:
        - Accesstoken: string
          Authorization token for identification of the caller
        - ChannelType: integer
          Channel identifier from where the TXN has originated (Internet, Mobile, ATM, Branch Channel )
        - Co-Relationid: integer
          Unique ID for the service invoked, will be set by the TXN system
        - InitiatingSystem: string
          Indicating the initiated system
        - ServiceMode: integer
          Used for branch channel to indicate the type of customer
        - UUIDSeqNo: integer
          UUID Sequence Number
        - entity: string
          entity
        - languageCode: integer
          languageCode
        - referenceId: string
          Place holder for Token based authentication
        - userId: integer
          userId
        
        
        """
        
        
        # Prepare query parameters
        params = {}
        if fromdate is not None:
            params["FromDate"] = fromdate
            
        if todate is not None:
            params["ToDate"] = todate
            
        if fromamount is not None:
            params["fromAmount"] = fromamount
            
        if movementdescription is not None:
            params["movementDescription"] = movementdescription
            
        if pagenum is not None:
            params["pageNum"] = pagenum
            
        if pagesize is not None:
            params["pageSize"] = pagesize
            
        if toamount is not None:
            params["toAmount"] = toamount
            
        if transactionaccounttype is not None:
            params["transactionAccountType"] = transactionaccounttype
            
        if transactionid is not None:
            params["transactionId"] = transactionid
            
        
        
        # Replace path parameters in URL
        path = "/loans/enquiry/transactionList/{loanReference}"
        if loanreference is not None:
            path = path.replace("{loanReference}", str(loanreference))
        
        
        # Prepare headers
        headers = {}
        if accesstoken is not None:
            headers["Accesstoken"] = str(accesstoken)
        if channeltype is not None:
            headers["ChannelType"] = str(channeltype)
        if co_relationid is not None:
            headers["Co-Relationid"] = str(co_relationid)
        if initiatingsystem is not None:
            headers["InitiatingSystem"] = str(initiatingsystem)
        if servicemode is not None:
            headers["ServiceMode"] = str(servicemode)
        if uuidseqno is not None:
            headers["UUIDSeqNo"] = str(uuidseqno)
        if entity is not None:
            headers["entity"] = str(entity)
        if languagecode is not None:
            headers["languageCode"] = str(languagecode)
        if referenceid is not None:
            headers["referenceId"] = str(referenceid)
        if userid is not None:
            headers["userId"] = str(userid)
        
        
        return await make_api_request(
            "GET", 
            path, 
            
            params=params if params else None, 
            headers=headers if headers else None
        )
    
    
    
    @mcp.tool()
    async def cbcetfetch_ssifor_loans_postusing_post(
        request_body:Dict[str, Any] ,  # SSIETFetchSSIForLoans_Resource,
        accesstoken: Optional[str] = None,
        channeltype: Optional[int] = None,
        co_relationid: Optional[int] = None,
        initiatingsystem: Optional[str] = None,
        servicemode: Optional[int] = None,
        uuidseqno: Optional[int] = None,
        entity: Optional[str] = None,
        languagecode: Optional[int] = None,
        referenceid: Optional[str] = None,
        requesthash: Optional[str] = None,
        userid: Optional[int] = None
    ) -> Dict[str, Any]:
        """
        List of SSI Details
        
        Generated from: POST /loans/fetchSSIDetails
        Source: swagger_2_0
        Operation ID: CBCETFetchSSIForLoans_POSTUsingPOST
        
        
        Authentication: Not required
        
        Parameters:
        - request_body: any (required)
          input
        
        
        
        Headers:
        - Accesstoken: string
          Authorization Token to validation the caller
        - ChannelType: integer
          Channel identifier from where the TXN has originated (Internet, Mobile, ATM, Branch Channel )
        - Co-Relationid: integer
          Unique ID for the service invoked, will be set by the TXN system
        - InitiatingSystem: string
          Indicating the initiated system
        - ServiceMode: integer
          Used for branch channel to indicate the type of customer
        - UUIDSeqNo: integer
          UUID Sequence Number
        - entity: string
          entity
        - languageCode: integer
          languageCode
        - referenceId: string
          Place holder for Token based authentication
        - requesthash: string
          Request payload for hash validation
        - userId: integer
          userId
        
        
        """
        
        
        # Prepare request data
        
        # Single body parameter - send directly
        data = request_body if request_body is not None else {}
        
        
        
        # Prepare query parameters
        params = {}
        
        
        # Replace path parameters in URL
        path = "/loans/fetchSSIDetails"
        
        
        # Prepare headers
        headers = {}
        if accesstoken is not None:
            headers["Accesstoken"] = str(accesstoken)
        if channeltype is not None:
            headers["ChannelType"] = str(channeltype)
        if co_relationid is not None:
            headers["Co-Relationid"] = str(co_relationid)
        if initiatingsystem is not None:
            headers["InitiatingSystem"] = str(initiatingsystem)
        if servicemode is not None:
            headers["ServiceMode"] = str(servicemode)
        if uuidseqno is not None:
            headers["UUIDSeqNo"] = str(uuidseqno)
        if entity is not None:
            headers["entity"] = str(entity)
        if languagecode is not None:
            headers["languageCode"] = str(languagecode)
        if referenceid is not None:
            headers["referenceId"] = str(referenceid)
        if requesthash is not None:
            headers["requesthash"] = str(requesthash)
        if userid is not None:
            headers["userId"] = str(userid)
        
        
        return await make_api_request(
            "POST", 
            path, 
            data=data, 
            params=params if params else None, 
            headers=headers if headers else None
        )
    
    
    
    @mcp.tool()
    async def crbt6067_crt_general_proceed_cltrl_using_post(
        request_body:Dict[str, Any] ,  # crtGeneralProceedCltrlResource,
        accesstoken: Optional[str] = None,
        channeltype: Optional[int] = None,
        co_relationid: Optional[int] = None,
        initiatingsystem: Optional[str] = None,
        servicemode: Optional[int] = None,
        uuidseqno: Optional[int] = None,
        entity: Optional[str] = None,
        languagecode: Optional[int] = None,
        referenceid: Optional[str] = None,
        requesthash: Optional[str] = None,
        userid: Optional[int] = None
    ) -> Dict[str, Any]:
        """
        Create General Assignment Proceed Collateral
        
        Generated from: POST /loans/generalAssignmentProceedCltrl/create
        Source: swagger_2_0
        Operation ID: CRBT6067CrtGeneralProceedCltrlUsingPOST
        
        
        Authentication: Not required
        
        Parameters:
        - request_body: any (required)
          input
        
        
        
        Headers:
        - Accesstoken: string
          Authorization token for identification of the caller
        - ChannelType: integer
          Channel identifier from where the TXN has originated (Internet, Mobile, ATM, Branch Channel )
        - Co-Relationid: integer
          Unique ID for the service invoked, will be set by the TXN system
        - InitiatingSystem: string
          Indicating the initiated system
        - ServiceMode: integer
          Used for branch channel to indicate the type of customer
        - UUIDSeqNo: integer
          UUID Sequence Number
        - entity: string
          entity
        - languageCode: integer
          languageCode
        - referenceId: string
          Place holder for Token based authentication
        - requesthash: string
          Request payload for hash validation
        - userId: integer
          userId
        
        
        """
        
        
        # Prepare request data
        
        # Single body parameter - send directly
        data = request_body if request_body is not None else {}
        
        
        
        # Prepare query parameters
        params = {}
        
        
        # Replace path parameters in URL
        path = "/loans/generalAssignmentProceedCltrl/create"
        
        
        # Prepare headers
        headers = {}
        if accesstoken is not None:
            headers["Accesstoken"] = str(accesstoken)
        if channeltype is not None:
            headers["ChannelType"] = str(channeltype)
        if co_relationid is not None:
            headers["Co-Relationid"] = str(co_relationid)
        if initiatingsystem is not None:
            headers["InitiatingSystem"] = str(initiatingsystem)
        if servicemode is not None:
            headers["ServiceMode"] = str(servicemode)
        if uuidseqno is not None:
            headers["UUIDSeqNo"] = str(uuidseqno)
        if entity is not None:
            headers["entity"] = str(entity)
        if languagecode is not None:
            headers["languageCode"] = str(languagecode)
        if referenceid is not None:
            headers["referenceId"] = str(referenceid)
        if requesthash is not None:
            headers["requesthash"] = str(requesthash)
        if userid is not None:
            headers["userId"] = str(userid)
        
        
        return await make_api_request(
            "POST", 
            path, 
            data=data, 
            params=params if params else None, 
            headers=headers if headers else None
        )
    
    
    
    @mcp.tool()
    async def crbt6067_general_proceed_modification_wrapper_postusing_post(
        request_body:Dict[str, Any] ,  # generalProceedModificationWrapperResource,
        accesstoken: Optional[str] = None,
        channeltype: Optional[int] = None,
        co_relationid: Optional[int] = None,
        initiatingsystem: Optional[str] = None,
        servicemode: Optional[int] = None,
        uuidseqno: Optional[int] = None,
        entity: Optional[str] = None,
        languagecode: Optional[int] = None,
        referenceid: Optional[str] = None,
        requesthash: Optional[str] = None,
        userid: Optional[int] = None
    ) -> Dict[str, Any]:
        """
        Modify General Assignment Proceed Collateral
        
        Generated from: POST /loans/generalAssignmentProceedcltrl/update
        Source: swagger_2_0
        Operation ID: CRBT6067GeneralProceedModificationWrapper_POSTUsingPOST
        
        
        Authentication: Not required
        
        Parameters:
        - request_body: any (required)
          input
        
        
        
        Headers:
        - Accesstoken: string
          Authorization token for identification of the caller
        - ChannelType: integer
          Channel identifier from where the TXN has originated (Internet, Mobile, ATM, Branch Channel )
        - Co-Relationid: integer
          Unique ID for the service invoked, will be set by the TXN system
        - InitiatingSystem: string
          Indicating the initiated system
        - ServiceMode: integer
          Used for branch channel to indicate the type of customer
        - UUIDSeqNo: integer
          UUID Sequence Number
        - entity: string
          entity
        - languageCode: integer
          languageCode
        - referenceId: string
          Place holder for Token based authentication
        - requesthash: string
          Request payload for hash validation
        - userId: integer
          userId
        
        
        """
        
        
        # Prepare request data
        
        # Single body parameter - send directly
        data = request_body if request_body is not None else {}
        
        
        
        # Prepare query parameters
        params = {}
        
        
        # Replace path parameters in URL
        path = "/loans/generalAssignmentProceedcltrl/update"
        
        
        # Prepare headers
        headers = {}
        if accesstoken is not None:
            headers["Accesstoken"] = str(accesstoken)
        if channeltype is not None:
            headers["ChannelType"] = str(channeltype)
        if co_relationid is not None:
            headers["Co-Relationid"] = str(co_relationid)
        if initiatingsystem is not None:
            headers["InitiatingSystem"] = str(initiatingsystem)
        if servicemode is not None:
            headers["ServiceMode"] = str(servicemode)
        if uuidseqno is not None:
            headers["UUIDSeqNo"] = str(uuidseqno)
        if entity is not None:
            headers["entity"] = str(entity)
        if languagecode is not None:
            headers["languageCode"] = str(languagecode)
        if referenceid is not None:
            headers["referenceId"] = str(referenceid)
        if requesthash is not None:
            headers["requesthash"] = str(requesthash)
        if userid is not None:
            headers["userId"] = str(userid)
        
        
        return await make_api_request(
            "POST", 
            path, 
            data=data, 
            params=params if params else None, 
            headers=headers if headers else None
        )
    
    
    
    @mcp.tool()
    async def cbcetget_loan_account_list_using_get(
        primaryborrowerid: int,
        islamicflag: Optional[int] = None,
        pagenum: Optional[int] = None,
        pagesize: Optional[int] = None,
        accesstoken: Optional[str] = None,
        channeltype: Optional[int] = None,
        co_relationid: Optional[int] = None,
        initiatingsystem: Optional[str] = None,
        servicemode: Optional[int] = None,
        uuidseqno: Optional[int] = None,
        entity: Optional[str] = None,
        languagecode: Optional[int] = None,
        referenceid: Optional[str] = None,
        userid: Optional[int] = None
    ) -> Dict[str, Any]:
        """
        Loan Account List screen. It displays all the retail loans that are created and in Active Status
        
        Generated from: GET /loans/listWithBalance/{primaryBorrowerId}
        Source: swagger_2_0
        Operation ID: CBCETGetLoanAccountListUsingGET
        
        
        Authentication: Not required
        
        Parameters:
        - islamicFlag: integer
          Islamic Flag  1- to fetch Islamic Loans, 2- to fetch conventional Loans
        - pageNum: integer
          pageNum
        - pageSize: integer
          pageSize
        - primaryBorrowerId: integer (required)
          Reference Number of the primary borrower of the Loan account
        
        
        
        Headers:
        - Accesstoken: string
          Authorization token for identification of the caller
        - ChannelType: integer
          Channel identifier from where the TXN has originated (Internet, Mobile, ATM, Branch Channel )
        - Co-Relationid: integer
          Unique ID for the service invoked, will be set by the TXN system
        - InitiatingSystem: string
          Indicating the initiated system
        - ServiceMode: integer
          Used for branch channel to indicate the type of customer
        - UUIDSeqNo: integer
          UUID Sequence Number
        - entity: string
          entity
        - languageCode: integer
          languageCode
        - referenceId: string
          Place holder for Token based authentication
        - userId: integer
          userId
        
        
        """
        
        
        # Prepare query parameters
        params = {}
        if islamicflag is not None:
            params["islamicFlag"] = islamicflag
            
        if pagenum is not None:
            params["pageNum"] = pagenum
            
        if pagesize is not None:
            params["pageSize"] = pagesize
            
        
        
        # Replace path parameters in URL
        path = "/loans/listWithBalance/{primaryBorrowerId}"
        if primaryborrowerid is not None:
            path = path.replace("{primaryBorrowerId}", str(primaryborrowerid))
        
        
        # Prepare headers
        headers = {}
        if accesstoken is not None:
            headers["Accesstoken"] = str(accesstoken)
        if channeltype is not None:
            headers["ChannelType"] = str(channeltype)
        if co_relationid is not None:
            headers["Co-Relationid"] = str(co_relationid)
        if initiatingsystem is not None:
            headers["InitiatingSystem"] = str(initiatingsystem)
        if servicemode is not None:
            headers["ServiceMode"] = str(servicemode)
        if uuidseqno is not None:
            headers["UUIDSeqNo"] = str(uuidseqno)
        if entity is not None:
            headers["entity"] = str(entity)
        if languagecode is not None:
            headers["languageCode"] = str(languagecode)
        if referenceid is not None:
            headers["referenceId"] = str(referenceid)
        if userid is not None:
            headers["userId"] = str(userid)
        
        
        return await make_api_request(
            "GET", 
            path, 
            
            params=params if params else None, 
            headers=headers if headers else None
        )
    
    
    
    @mcp.tool()
    async def crbt4210_create_loan_closmaster_wrapper_postusing_post(
        request_body:Dict[str, Any] ,  # loanCreateRequest,
        accesstoken: Optional[str] = None,
        channeltype: Optional[int] = None,
        co_relationid: Optional[int] = None,
        initiatingsystem: Optional[str] = None,
        servicemode: Optional[int] = None,
        uuidseqno: Optional[int] = None,
        entity: Optional[str] = None,
        languagecode: Optional[int] = None,
        referenceid: Optional[str] = None,
        requesthash: Optional[str] = None,
        userid: Optional[int] = None
    ) -> Dict[str, Any]:
        """
        This API creates the loan and the repayment schedule. This will also create disbursement based on auto disbursement flag.
        
        Generated from: POST /loans/loan
        Source: swagger_2_0
        Operation ID: CRBT4210CreateLoanCLOSMasterWrapper_POSTUsingPOST
        
        
        Authentication: Not required
        
        Parameters:
        - request_body: any (required)
          input
        
        
        
        Headers:
        - Accesstoken: string
          Authorization Token to validation the caller
        - ChannelType: integer
          Channel identifier from where the TXN has originated (Internet, Mobile, ATM, Branch Channel )
        - Co-Relationid: integer
          Unique ID for the service invoked, will be set by the TXN system
        - InitiatingSystem: string
          Indicating the initiated system
        - ServiceMode: integer
          Used for branch channel to indicate the type of customer
        - UUIDSeqNo: integer
          UUID Sequence Number
        - entity: string
          entity
        - languageCode: integer
          languageCode
        - referenceId: string
          Place holder for Token based authentication
        - requesthash: string
          Request payload for hash validation
        - userId: integer
          userId
        
        
        """
        
        
        # Prepare request data
        
        # Single body parameter - send directly
        data = request_body if request_body is not None else {}
        
        
        
        # Prepare query parameters
        params = {}
        
        
        # Replace path parameters in URL
        path = "/loans/loan"
        
        
        # Prepare headers
        headers = {}
        if accesstoken is not None:
            headers["Accesstoken"] = str(accesstoken)
        if channeltype is not None:
            headers["ChannelType"] = str(channeltype)
        if co_relationid is not None:
            headers["Co-Relationid"] = str(co_relationid)
        if initiatingsystem is not None:
            headers["InitiatingSystem"] = str(initiatingsystem)
        if servicemode is not None:
            headers["ServiceMode"] = str(servicemode)
        if uuidseqno is not None:
            headers["UUIDSeqNo"] = str(uuidseqno)
        if entity is not None:
            headers["entity"] = str(entity)
        if languagecode is not None:
            headers["languageCode"] = str(languagecode)
        if referenceid is not None:
            headers["referenceId"] = str(referenceid)
        if requesthash is not None:
            headers["requesthash"] = str(requesthash)
        if userid is not None:
            headers["userId"] = str(userid)
        
        
        return await make_api_request(
            "POST", 
            path, 
            data=data, 
            params=params if params else None, 
            headers=headers if headers else None
        )
    
    
    
    @mcp.tool()
    async def crbt4210_create_loan_losmaster_wrapper_postusing_post(
        request_body:Dict[str, Any] ,  # CR_LOAN_EXT_CRBT4210CreateLoanLOSMasterWrapper_Resource,
        accesstoken: Optional[str] = None,
        channeltype: Optional[int] = None,
        co_relationid: Optional[int] = None,
        initiatingsystem: Optional[str] = None,
        servicemode: Optional[int] = None,
        uuidseqno: Optional[int] = None,
        entity: Optional[str] = None,
        languagecode: Optional[int] = None,
        referenceid: Optional[str] = None,
        requesthash: Optional[str] = None,
        userid: Optional[int] = None
    ) -> Dict[str, Any]:
        """
        CRBT4210CreateLoanLOSMasterWrapper
        
        Generated from: POST /loans/loan/create
        Source: swagger_2_0
        Operation ID: CRBT4210CreateLoanLOSMasterWrapper_POSTUsingPOST
        
        
        Authentication: Not required
        
        Parameters:
        - request_body: any (required)
          input
        
        
        
        Headers:
        - Accesstoken: string
          Authorization Token to validation the caller
        - ChannelType: integer
          Channel identifier from where the TXN has originated (Internet, Mobile, ATM, Branch Channel )
        - Co-Relationid: integer
          Unique ID for the service invoked, will be set by the TXN system
        - InitiatingSystem: string
          Indicating the initiated system
        - ServiceMode: integer
          Used for branch channel to indicate the type of customer
        - UUIDSeqNo: integer
          UUID Sequence Number
        - entity: string
          entity
        - languageCode: integer
          languageCode
        - referenceId: string
          Place holder for Token based authentication
        - requesthash: string
          Request payload for hash validation
        - userId: integer
          userId
        
        
        """
        
        
        # Prepare request data
        
        # Single body parameter - send directly
        data = request_body if request_body is not None else {}
        
        
        
        # Prepare query parameters
        params = {}
        
        
        # Replace path parameters in URL
        path = "/loans/loan/create"
        
        
        # Prepare headers
        headers = {}
        if accesstoken is not None:
            headers["Accesstoken"] = str(accesstoken)
        if channeltype is not None:
            headers["ChannelType"] = str(channeltype)
        if co_relationid is not None:
            headers["Co-Relationid"] = str(co_relationid)
        if initiatingsystem is not None:
            headers["InitiatingSystem"] = str(initiatingsystem)
        if servicemode is not None:
            headers["ServiceMode"] = str(servicemode)
        if uuidseqno is not None:
            headers["UUIDSeqNo"] = str(uuidseqno)
        if entity is not None:
            headers["entity"] = str(entity)
        if languagecode is not None:
            headers["languageCode"] = str(languagecode)
        if referenceid is not None:
            headers["referenceId"] = str(referenceid)
        if requesthash is not None:
            headers["requesthash"] = str(requesthash)
        if userid is not None:
            headers["userId"] = str(userid)
        
        
        return await make_api_request(
            "POST", 
            path, 
            data=data, 
            params=params if params else None, 
            headers=headers if headers else None
        )
    
    
    
    @mcp.tool()
    async def cbcetget_loan_details_ibusing_get(
        loanreference: str,
        # loanreference: str,
        primaryborrowerid: Optional[int] = None,
        accesstoken: Optional[str] = None,
        channeltype: Optional[int] = None,
        co_relationid: Optional[int] = None,
        initiatingsystem: Optional[str] = None,
        servicemode: Optional[int] = None,
        uuidseqno: Optional[int] = None,
        entity: Optional[str] = None,
        languagecode: Optional[int] = None,
        referenceid: Optional[str] = None,
        userid: Optional[int] = None
    ) -> Dict[str, Any]:
        """
        View Loan Details
        
        Generated from: GET /loans/loan/detailsIB/{loanReference}
        Source: swagger_2_0
        Operation ID: CBCETGetLoanDetailsIBUsingGET
        
        
        Authentication: Not required
        
        Parameters:
        - loanReference: string (required)
          Reference Number generated for account based on configured scheme
        - primaryBorrowerId: integer
          Primary borrower id of the Loan account
        - loanReference: string (required)
          Path parameter loanReference
        
        
        
        Headers:
        - Accesstoken: string
          Authorization token for identification of the caller
        - ChannelType: integer
          Channel identifier from where the TXN has originated (Internet, Mobile, ATM, Branch Channel )
        - Co-Relationid: integer
          Unique ID for the service invoked, will be set by the TXN system
        - InitiatingSystem: string
          Indicating the initiated system
        - ServiceMode: integer
          Used for branch channel to indicate the type of customer
        - UUIDSeqNo: integer
          UUID Sequence Number
        - entity: string
          entity
        - languageCode: integer
          languageCode
        - referenceId: string
          Place holder for Token based authentication
        - userId: integer
          userId
        
        
        """
        
        
        # Prepare query parameters
        params = {}
        if loanreference is not None:
            params["loanReference"] = loanreference
            
        if primaryborrowerid is not None:
            params["primaryBorrowerId"] = primaryborrowerid
            
        
        
        # Replace path parameters in URL
        path = "/loans/loan/detailsIB/{loanReference}"
        if loanreference is not None:
            path = path.replace("{loanReference}", str(loanreference))
        
        
        # Prepare headers
        headers = {}
        if accesstoken is not None:
            headers["Accesstoken"] = str(accesstoken)
        if channeltype is not None:
            headers["ChannelType"] = str(channeltype)
        if co_relationid is not None:
            headers["Co-Relationid"] = str(co_relationid)
        if initiatingsystem is not None:
            headers["InitiatingSystem"] = str(initiatingsystem)
        if servicemode is not None:
            headers["ServiceMode"] = str(servicemode)
        if uuidseqno is not None:
            headers["UUIDSeqNo"] = str(uuidseqno)
        if entity is not None:
            headers["entity"] = str(entity)
        if languagecode is not None:
            headers["languageCode"] = str(languagecode)
        if referenceid is not None:
            headers["referenceId"] = str(referenceid)
        if userid is not None:
            headers["userId"] = str(userid)
        
        
        return await make_api_request(
            "GET", 
            path, 
            
            params=params if params else None, 
            headers=headers if headers else None
        )
    
    
    
    @mcp.tool()
    async def crbt0318_auth_rpymnt_postusing_post(
        request_body:Dict[str, Any] ,  # repaymentRequest,
        access_token: Optional[str] = None,
        channeltype: Optional[int] = None,
        co_relationid: Optional[int] = None,
        initiatingsystem: Optional[str] = None,
        servicemode: Optional[int] = None,
        uuidseqno: Optional[int] = None,
        entity: Optional[str] = None,
        languagecode: Optional[int] = None,
        referenceid: Optional[str] = None,
        requesthash: Optional[str] = None,
        userid: Optional[int] = None
    ) -> Dict[str, Any]:
        """
        This API used to perform Repayment Auth
        
        Generated from: POST /loans/loan/transaction/AuthRepayment
        Source: swagger_2_0
        Operation ID: CRBT0318AuthRpymnt_POSTUsingPOST
        
        
        Authentication: Not required
        
        Parameters:
        - request_body: any (required)
          input
        
        
        
        Headers:
        - Access token: string
          Authorisation token for identifiaction of the caller
        - ChannelType: integer
          Channel identifier from where the TXN has originated (Internet, Mobile, ATM, Branch Channel )
        - Co-Relationid: integer
          Unique ID for the service invoked, will be set by the TXN system
        - InitiatingSystem: string
          Indicating the initiated system
        - ServiceMode: integer
          Used for branch channel to indicate the type of customer
        - UUIDSeqNo: integer
          UUID Sequence Number
        - entity: string
          entity
        - languageCode: integer
          languageCode
        - referenceId: string
          Place holder for Token based authentication
        - requesthash: string
          Request payload for hash validation
        - userId: integer
          userId
        
        
        """
        
        
        # Prepare request data
        
        # Single body parameter - send directly
        data = request_body if request_body is not None else {}
        
        
        
        # Prepare query parameters
        params = {}
        
        
        # Replace path parameters in URL
        path = "/loans/loan/transaction/AuthRepayment"
        
        
        # Prepare headers
        headers = {}
        if access_token is not None:
            headers["Access token"] = str(access_token)
        if channeltype is not None:
            headers["ChannelType"] = str(channeltype)
        if co_relationid is not None:
            headers["Co-Relationid"] = str(co_relationid)
        if initiatingsystem is not None:
            headers["InitiatingSystem"] = str(initiatingsystem)
        if servicemode is not None:
            headers["ServiceMode"] = str(servicemode)
        if uuidseqno is not None:
            headers["UUIDSeqNo"] = str(uuidseqno)
        if entity is not None:
            headers["entity"] = str(entity)
        if languagecode is not None:
            headers["languageCode"] = str(languagecode)
        if referenceid is not None:
            headers["referenceId"] = str(referenceid)
        if requesthash is not None:
            headers["requesthash"] = str(requesthash)
        if userid is not None:
            headers["userId"] = str(userid)
        
        
        return await make_api_request(
            "POST", 
            path, 
            data=data, 
            params=params if params else None, 
            headers=headers if headers else None
        )
    
    
    
    @mcp.tool()
    async def crbt1740_modify_crloan_basic_details_using_put(
        loanreference: str,
        request_body:Dict[str, Any] ,  # modifyLoanBasicDetailsResource,
        accesstoken: Optional[str] = None,
        channeltype: Optional[int] = None,
        co_relationid: Optional[int] = None,
        initiatingsystem: Optional[str] = None,
        servicemode: Optional[int] = None,
        uuidseqno: Optional[int] = None,
        entity: Optional[str] = None,
        languagecode: Optional[int] = None,
        referenceid: Optional[str] = None,
        requesthash: Optional[str] = None,
        userid: Optional[int] = None
    ) -> Dict[str, Any]:
        """
        Loan API to amend basic details in 'modified onhold' status
        
        Generated from: PUT /loans/loanBasicDetails/{loanReference}
        Source: swagger_2_0
        Operation ID: CRBT1740ModifyCRLoanBasicDetailsUsingPUT
        
        
        Authentication: Not required
        
        Parameters:
        - loanReference: string (required)
          Reference Number generated for account based on configured scheme
        - request_body: any (required)
          input
        
        
        
        Headers:
        - Accesstoken: string
          Authorization Token to validation the caller
        - ChannelType: integer
          Channel identifier from where the TXN has originated (Internet, Mobile, ATM, Branch Channel )
        - Co-Relationid: integer
          Unique ID for the service invoked, will be set by the TXN system
        - InitiatingSystem: string
          Indicating the initiated system
        - ServiceMode: integer
          Used for branch channel to indicate the type of customer
        - UUIDSeqNo: integer
          UUID Sequence Number
        - entity: string
          entity
        - languageCode: integer
          languageCode
        - referenceId: string
          Place holder for Token based authentication
        - requesthash: string
          Request payload for hash validation
        - userId: integer
          userId
        
        
        """
        
        
        # Prepare request data
        
        # Single body parameter - send directly
        data = request_body if request_body is not None else {}
        
        
        
        # Prepare query parameters
        params = {}
        
        
        # Replace path parameters in URL
        path = "/loans/loanBasicDetails/{loanReference}"
        if loanreference is not None:
            path = path.replace("{loanReference}", str(loanreference))
        
        
        # Prepare headers
        headers = {}
        if accesstoken is not None:
            headers["Accesstoken"] = str(accesstoken)
        if channeltype is not None:
            headers["ChannelType"] = str(channeltype)
        if co_relationid is not None:
            headers["Co-Relationid"] = str(co_relationid)
        if initiatingsystem is not None:
            headers["InitiatingSystem"] = str(initiatingsystem)
        if servicemode is not None:
            headers["ServiceMode"] = str(servicemode)
        if uuidseqno is not None:
            headers["UUIDSeqNo"] = str(uuidseqno)
        if entity is not None:
            headers["entity"] = str(entity)
        if languagecode is not None:
            headers["languageCode"] = str(languagecode)
        if referenceid is not None:
            headers["referenceId"] = str(referenceid)
        if requesthash is not None:
            headers["requesthash"] = str(requesthash)
        if userid is not None:
            headers["userId"] = str(userid)
        
        
        return await make_api_request(
            "PUT", 
            path, 
            data=data, 
            params=params if params else None, 
            headers=headers if headers else None
        )
    
    
    
    @mcp.tool()
    async def crbt1710_crloan_mon_hld_to_mpndng_auth_using_put(
        loanreference: str,
        accesstoken: Optional[str] = None,
        channeltype: Optional[int] = None,
        co_relationid: Optional[int] = None,
        initiatingsystem: Optional[str] = None,
        servicemode: Optional[int] = None,
        uuidseqno: Optional[int] = None,
        entity: Optional[str] = None,
        languagecode: Optional[int] = None,
        referenceid: Optional[str] = None,
        userid: Optional[int] = None
    ) -> Dict[str, Any]:
        """
        Loan status Change from modify on hold to modify Pending authorization status
        
        Generated from: PUT /loans/loanBasicDetails/{loanReference}/mOnHoldToMPndngAuth
        Source: swagger_2_0
        Operation ID: CRBT1710CRLoanMOnHldToMPndngAuthUsingPUT
        
        
        Authentication: Not required
        
        Parameters:
        - loanReference: string (required)
          Reference Number generated for account based on configured scheme
        
        
        
        Headers:
        - Accesstoken: string
          Authorization Token to validation the caller
        - ChannelType: integer
          Channel identifier from where the TXN has originated (Internet, Mobile, ATM, Branch Channel )
        - Co-Relationid: integer
          Unique ID for the service invoked, will be set by the TXN system
        - InitiatingSystem: string
          Indicating the initiated system
        - ServiceMode: integer
          Used for branch channel to indicate the type of customer
        - UUIDSeqNo: integer
          UUID Sequence Number
        - entity: string
          entity
        - languageCode: integer
          languageCode
        - referenceId: string
          Place holder for Token based authentication
        - userId: integer
          userId
        
        
        """
        
        
        # Prepare query parameters
        params = {}
        
        
        # Replace path parameters in URL
        path = "/loans/loanBasicDetails/{loanReference}/mOnHoldToMPndngAuth"
        if loanreference is not None:
            path = path.replace("{loanReference}", str(loanreference))
        
        
        # Prepare headers
        headers = {}
        if accesstoken is not None:
            headers["Accesstoken"] = str(accesstoken)
        if channeltype is not None:
            headers["ChannelType"] = str(channeltype)
        if co_relationid is not None:
            headers["Co-Relationid"] = str(co_relationid)
        if initiatingsystem is not None:
            headers["InitiatingSystem"] = str(initiatingsystem)
        if servicemode is not None:
            headers["ServiceMode"] = str(servicemode)
        if uuidseqno is not None:
            headers["UUIDSeqNo"] = str(uuidseqno)
        if entity is not None:
            headers["entity"] = str(entity)
        if languagecode is not None:
            headers["languageCode"] = str(languagecode)
        if referenceid is not None:
            headers["referenceId"] = str(referenceid)
        if userid is not None:
            headers["userId"] = str(userid)
        
        
        return await make_api_request(
            "PUT", 
            path, 
            
            params=params if params else None, 
            headers=headers if headers else None
        )
    
    
    
    @mcp.tool()
    async def crbt1710_crloan_mpndng_auth_to_active_using_put(
        loanreference: str,
        verauthflag: int,
        accesstoken: Optional[str] = None,
        channeltype: Optional[int] = None,
        co_relationid: Optional[int] = None,
        initiatingsystem: Optional[str] = None,
        servicemode: Optional[int] = None,
        uuidseqno: Optional[int] = None,
        entity: Optional[str] = None,
        languagecode: Optional[int] = None,
        referenceid: Optional[str] = None,
        requesthash: Optional[str] = None,
        userid: Optional[int] = None
    ) -> Dict[str, Any]:
        """
        Loan status Change from modify Pending authorization to active status
        
        Generated from: PUT /loans/loanBasicDetails/{loanReference}/{verAuthFlag}/mPndngAuthToActive
        Source: swagger_2_0
        Operation ID: CRBT1710CRLoanMPndngAuthToActiveUsingPUT
        
        
        Authentication: Not required
        
        Parameters:
        - loanReference: string (required)
          Reference Number generated for account based on configured scheme
        - verAuthFlag: integer (required)
          Authorization flag (Domain: d_VerAuthFlg) 1-Authorised, 2-Rejected, 3-SentBack
        
        
        
        Headers:
        - Accesstoken: string
          Authorization Token to validation the caller
        - ChannelType: integer
          Channel identifier from where the TXN has originated (Internet, Mobile, ATM, Branch Channel )
        - Co-Relationid: integer
          Unique ID for the service invoked, will be set by the TXN system
        - InitiatingSystem: string
          Indicating the initiated system
        - ServiceMode: integer
          Used for branch channel to indicate the type of customer
        - UUIDSeqNo: integer
          UUID Sequence Number
        - entity: string
          entity
        - languageCode: integer
          languageCode
        - referenceId: string
          Place holder for Token based authentication
        - requesthash: string
          Request payload for hash validation
        - userId: integer
          userId
        
        
        """
        
        
        # Prepare query parameters
        params = {}
        
        
        # Replace path parameters in URL
        path = "/loans/loanBasicDetails/{loanReference}/{verAuthFlag}/mPndngAuthToActive"
        if loanreference is not None:
            path = path.replace("{loanReference}", str(loanreference))
        if verauthflag is not None:
            path = path.replace("{verAuthFlag}", str(verauthflag))
        
        
        # Prepare headers
        headers = {}
        if accesstoken is not None:
            headers["Accesstoken"] = str(accesstoken)
        if channeltype is not None:
            headers["ChannelType"] = str(channeltype)
        if co_relationid is not None:
            headers["Co-Relationid"] = str(co_relationid)
        if initiatingsystem is not None:
            headers["InitiatingSystem"] = str(initiatingsystem)
        if servicemode is not None:
            headers["ServiceMode"] = str(servicemode)
        if uuidseqno is not None:
            headers["UUIDSeqNo"] = str(uuidseqno)
        if entity is not None:
            headers["entity"] = str(entity)
        if languagecode is not None:
            headers["languageCode"] = str(languagecode)
        if referenceid is not None:
            headers["referenceId"] = str(referenceid)
        if requesthash is not None:
            headers["requesthash"] = str(requesthash)
        if userid is not None:
            headers["userId"] = str(userid)
        
        
        return await make_api_request(
            "PUT", 
            path, 
            
            params=params if params else None, 
            headers=headers if headers else None
        )
    
    
    
    @mcp.tool()
    async def cretget_loan_event_reg_enquiry_using_get(
        dischargedate: str,
        loanreference: str,
        purposeindicator: int,
        principalpaidamount: Optional[float] = None,
        accesstoken: Optional[str] = None,
        channeltype: Optional[int] = None,
        co_relationid: Optional[int] = None,
        initiatingsystem: Optional[str] = None,
        servicemode: Optional[int] = None,
        uuidseqno: Optional[int] = None,
        entity: Optional[str] = None,
        languagecode: Optional[int] = None,
        referenceid: Optional[str] = None,
        userid: Optional[int] = None
    ) -> Dict[str, Any]:
        """
        Fetch Prepayment Details
        
        Generated from: GET /loans/loanPrePaymentChargeEnquiry
        Source: swagger_2_0
        Operation ID: CRETGetLoanEventRegEnquiryUsingGET
        
        
        Authentication: Not required
        
        Parameters:
        - dischargeDate: string (required)
          Charge effective from(Date Format:YYYYMMDD)
        - loanReference: string (required)
          Reference Number generated for account based on the configured scheme
        - principalPaidAmount: number
          Paid principal amount
        - purposeIndicator: integer (required)
          Loan purpose indicator (Domain: d_LoanEventPurpose)18-PrePayment,2-Discharge
        
        
        
        Headers:
        - Accesstoken: string
          Authorization token for identification of the caller
        - ChannelType: integer
          Channel identifier from where the TXN has originated (Internet, Mobile, ATM, Branch Channel )
        - Co-Relationid: integer
          Unique ID for the service invoked, will be set by the TXN system
        - InitiatingSystem: string
          Indicating the initiated system
        - ServiceMode: integer
          Used for branch channel to indicate the type of customer
        - UUIDSeqNo: integer
          UUID Sequence Number
        - entity: string
          entity
        - languageCode: integer
          languageCode
        - referenceId: string
          Place holder for Token based authentication
        - userId: integer
          userId
        
        
        """
        
        
        # Prepare query parameters
        params = {}
        if dischargedate is not None:
            params["dischargeDate"] = dischargedate
            
        if loanreference is not None:
            params["loanReference"] = loanreference
            
        if principalpaidamount is not None:
            params["principalPaidAmount"] = principalpaidamount
            
        if purposeindicator is not None:
            params["purposeIndicator"] = purposeindicator
            
        
        
        # Replace path parameters in URL
        path = "/loans/loanPrePaymentChargeEnquiry"
        
        
        # Prepare headers
        headers = {}
        if accesstoken is not None:
            headers["Accesstoken"] = str(accesstoken)
        if channeltype is not None:
            headers["ChannelType"] = str(channeltype)
        if co_relationid is not None:
            headers["Co-Relationid"] = str(co_relationid)
        if initiatingsystem is not None:
            headers["InitiatingSystem"] = str(initiatingsystem)
        if servicemode is not None:
            headers["ServiceMode"] = str(servicemode)
        if uuidseqno is not None:
            headers["UUIDSeqNo"] = str(uuidseqno)
        if entity is not None:
            headers["entity"] = str(entity)
        if languagecode is not None:
            headers["languageCode"] = str(languagecode)
        if referenceid is not None:
            headers["referenceId"] = str(referenceid)
        if userid is not None:
            headers["userId"] = str(userid)
        
        
        return await make_api_request(
            "GET", 
            path, 
            
            params=params if params else None, 
            headers=headers if headers else None
        )
    
    
    
    @mcp.tool()
    async def crbt2021_update_eclprovision_wrapper_using_put(
        accountreference: str,
        request_body:Dict[str, Any] ,  # updateECLProvisionWrapperResource,
        accesstoken: Optional[str] = None,
        channeltype: Optional[int] = None,
        co_relationid: Optional[int] = None,
        initiatingsystem: Optional[str] = None,
        servicemode: Optional[int] = None,
        uuidseqno: Optional[int] = None,
        entity: Optional[str] = None,
        languagecode: Optional[int] = None,
        referenceid: Optional[str] = None,
        requesthash: Optional[str] = None,
        userid: Optional[int] = None
    ) -> Dict[str, Any]:
        """
        Update ECL Provision externally
        
        Generated from: PUT /loans/npa/eclProvision/{accountReference}
        Source: swagger_2_0
        Operation ID: CRBT2021UpdateECLProvisionWrapperUsingPUT
        
        
        Authentication: Not required
        
        Parameters:
        - accountReference: string (required)
          Parent Reference Number
        - request_body: any (required)
          input
        
        
        
        Headers:
        - Accesstoken: string
          Authorization Token to validation the caller
        - ChannelType: integer
          Channel identifier from where the TXN has originated (Internet, Mobile, ATM, Branch Channel )
        - Co-Relationid: integer
          Unique ID for the service invoked, will be set by the TXN system
        - InitiatingSystem: string
          Indicating the initiated system
        - ServiceMode: integer
          Used for branch channel to indicate the type of customer
        - UUIDSeqNo: integer
          UUID Sequence Number
        - entity: string
          entity
        - languageCode: integer
          languageCode
        - referenceId: string
          Place holder for Token based authentication
        - requestHash: string
          Request payload for hash validation
        - userId: integer
          userId
        
        
        """
        
        
        # Prepare request data
        
        # Single body parameter - send directly
        data = request_body if request_body is not None else {}
        
        
        
        # Prepare query parameters
        params = {}
        
        
        # Replace path parameters in URL
        path = "/loans/npa/eclProvision/{accountReference}"
        if accountreference is not None:
            path = path.replace("{accountReference}", str(accountreference))
        
        
        # Prepare headers
        headers = {}
        if accesstoken is not None:
            headers["Accesstoken"] = str(accesstoken)
        if channeltype is not None:
            headers["ChannelType"] = str(channeltype)
        if co_relationid is not None:
            headers["Co-Relationid"] = str(co_relationid)
        if initiatingsystem is not None:
            headers["InitiatingSystem"] = str(initiatingsystem)
        if servicemode is not None:
            headers["ServiceMode"] = str(servicemode)
        if uuidseqno is not None:
            headers["UUIDSeqNo"] = str(uuidseqno)
        if entity is not None:
            headers["entity"] = str(entity)
        if languagecode is not None:
            headers["languageCode"] = str(languagecode)
        if referenceid is not None:
            headers["referenceId"] = str(referenceid)
        if requesthash is not None:
            headers["requestHash"] = str(requesthash)
        if userid is not None:
            headers["userId"] = str(userid)
        
        
        return await make_api_request(
            "PUT", 
            path, 
            data=data, 
            params=params if params else None, 
            headers=headers if headers else None
        )
    
    
    
    @mcp.tool()
    async def cretget_principal_subsidyclaim_lst_using_get(
        bulkrequestid: Optional[str] = None,
        loanreference: Optional[str] = None,
        requestdate: Optional[str] = None,
        requestid: Optional[int] = None,
        status: Optional[int] = None,
        accesstoken: Optional[str] = None,
        channeltype: Optional[int] = None,
        co_relationid: Optional[int] = None,
        initiatingsystem: Optional[str] = None,
        servicemode: Optional[int] = None,
        uuidseqno: Optional[int] = None,
        entity: Optional[str] = None,
        languagecode: Optional[int] = None,
        referenceid: Optional[str] = None,
        userid: Optional[int] = None
    ) -> Dict[str, Any]:
        """
        View Principal Guarantee Claim Requests
        
        Generated from: GET /loans/principalGuarante/claimList
        Source: swagger_2_0
        Operation ID: CRETGetPrincipalSubsidyclaimLstUsingGET
        
        
        Authentication: Not required
        
        Parameters:
        - bulkRequestId: string
          Bulk request id of the claim
        - loanReference: string
          Reference Number generated for account based on configured scheme
        - requestDate: string
          Request date of the claim (Date Format:YYYYMMDD)
        - requestId: integer
          Request Id of the claim
        - status: integer
          Status of the claim. 1-Active,2-Inactive,3-Computed,4-PendingAuthorisation,5-PendingDebit(Domain Name: d_Status)
        
        
        
        Headers:
        - Accesstoken: string
          Authorization token for identification of the caller
        - ChannelType: integer
          Channel identifier from where the TXN has originated (Internet, Mobile, ATM, Branch Channel )
        - Co-Relationid: integer
          Unique ID for the service invoked, will be set by the TXN system
        - InitiatingSystem: string
          Indicating the initiated system
        - ServiceMode: integer
          Used for branch channel to indicate the type of customer
        - UUIDSeqNo: integer
          UUID Sequence Number
        - entity: string
          entity
        - languageCode: integer
          languageCode
        - referenceId: string
          Place holder for Token based authentication
        - userId: integer
          userId
        
        
        """
        
        
        # Prepare query parameters
        params = {}
        if bulkrequestid is not None:
            params["bulkRequestId"] = bulkrequestid
            
        if loanreference is not None:
            params["loanReference"] = loanreference
            
        if requestdate is not None:
            params["requestDate"] = requestdate
            
        if requestid is not None:
            params["requestId"] = requestid
            
        if status is not None:
            params["status"] = status
            
        
        
        # Replace path parameters in URL
        path = "/loans/principalGuarante/claimList"
        
        
        # Prepare headers
        headers = {}
        if accesstoken is not None:
            headers["Accesstoken"] = str(accesstoken)
        if channeltype is not None:
            headers["ChannelType"] = str(channeltype)
        if co_relationid is not None:
            headers["Co-Relationid"] = str(co_relationid)
        if initiatingsystem is not None:
            headers["InitiatingSystem"] = str(initiatingsystem)
        if servicemode is not None:
            headers["ServiceMode"] = str(servicemode)
        if uuidseqno is not None:
            headers["UUIDSeqNo"] = str(uuidseqno)
        if entity is not None:
            headers["entity"] = str(entity)
        if languagecode is not None:
            headers["languageCode"] = str(languagecode)
        if referenceid is not None:
            headers["referenceId"] = str(referenceid)
        if userid is not None:
            headers["userId"] = str(userid)
        
        
        return await make_api_request(
            "GET", 
            path, 
            
            params=params if params else None, 
            headers=headers if headers else None
        )
    
    
    
    @mcp.tool()
    async def crbtcreate_principal_subsidyclaim_using_post(
        request_body:Dict[str, Any] ,  # createPrincipalGuaranteeClaimResource,
        accesstoken: Optional[str] = None,
        channeltype: Optional[int] = None,
        co_relationid: Optional[int] = None,
        initiatingsystem: Optional[str] = None,
        servicemode: Optional[int] = None,
        uuidseqno: Optional[int] = None,
        entity: Optional[str] = None,
        languagecode: Optional[int] = None,
        referenceid: Optional[str] = None,
        requesthash: Optional[str] = None,
        userid: Optional[int] = None
    ) -> Dict[str, Any]:
        """
        Creation/Modification/Deletion of Principal Guarantee Claims
        
        Generated from: POST /loans/principalGuarante/principalGuaranteeClaim
        Source: swagger_2_0
        Operation ID: CRBTCreatePrincipalSubsidyclaimUsingPOST
        
        
        Authentication: Not required
        
        Parameters:
        - request_body: any (required)
          input
        
        
        
        Headers:
        - Accesstoken: string
          Authorization token for identification of the caller
        - ChannelType: integer
          Channel identifier from where the TXN has originated (Internet, Mobile, ATM, Branch Channel )
        - Co-Relationid: integer
          Unique ID for the service invoked, will be set by the TXN system
        - InitiatingSystem: string
          Indicating the initiated system
        - ServiceMode: integer
          Used for branch channel to indicate the type of customer
        - UUIDSeqNo: integer
          UUID Sequence Number
        - entity: string
          entity
        - languageCode: integer
          languageCode
        - referenceId: string
          Place holder for Token based authentication
        - requesthash: string
          Request payload for hash validation
        - userId: integer
          userId
        
        
        """
        
        
        # Prepare request data
        
        # Single body parameter - send directly
        data = request_body if request_body is not None else {}
        
        
        
        # Prepare query parameters
        params = {}
        
        
        # Replace path parameters in URL
        path = "/loans/principalGuarante/principalGuaranteeClaim"
        
        
        # Prepare headers
        headers = {}
        if accesstoken is not None:
            headers["Accesstoken"] = str(accesstoken)
        if channeltype is not None:
            headers["ChannelType"] = str(channeltype)
        if co_relationid is not None:
            headers["Co-Relationid"] = str(co_relationid)
        if initiatingsystem is not None:
            headers["InitiatingSystem"] = str(initiatingsystem)
        if servicemode is not None:
            headers["ServiceMode"] = str(servicemode)
        if uuidseqno is not None:
            headers["UUIDSeqNo"] = str(uuidseqno)
        if entity is not None:
            headers["entity"] = str(entity)
        if languagecode is not None:
            headers["languageCode"] = str(languagecode)
        if referenceid is not None:
            headers["referenceId"] = str(referenceid)
        if requesthash is not None:
            headers["requesthash"] = str(requesthash)
        if userid is not None:
            headers["userId"] = str(userid)
        
        
        return await make_api_request(
            "POST", 
            path, 
            data=data, 
            params=params if params else None, 
            headers=headers if headers else None
        )
    
    
    
    @mcp.tool()
    async def crbtauth_principal_subsidyclaim_using_put(
        modeflag: int,
        requestid: int,
        accesstoken: Optional[str] = None,
        channeltype: Optional[int] = None,
        co_relationid: Optional[int] = None,
        initiatingsystem: Optional[str] = None,
        servicemode: Optional[int] = None,
        uuidseqno: Optional[int] = None,
        entity: Optional[str] = None,
        languagecode: Optional[int] = None,
        referenceid: Optional[str] = None,
        requesthash: Optional[str] = None,
        userid: Optional[int] = None
    ) -> Dict[str, Any]:
        """
        Authorization of Principal Guarantee Claims
        
        Generated from: PUT /loans/principalGuarante/principalGuaranteeClaim/authorize
        Source: swagger_2_0
        Operation ID: CRBTAuthPrincipalSubsidyclaimUsingPUT
        
        
        Authentication: Not required
        
        Parameters:
        - modeFlag: integer (required)
          Mode Flag 1-Authorised,2-Rejected,3-SentBack(Domain Name: d_VerAuthFlg)
        - requestId: integer (required)
          request ID of claim
        
        
        
        Headers:
        - Accesstoken: string
          Authorization token for identification of the caller
        - ChannelType: integer
          Channel identifier from where the TXN has originated (Internet, Mobile, ATM, Branch Channel )
        - Co-Relationid: integer
          Unique ID for the service invoked, will be set by the TXN system
        - InitiatingSystem: string
          Indicating the initiated system
        - ServiceMode: integer
          Used for branch channel to indicate the type of customer
        - UUIDSeqNo: integer
          UUID Sequence Number
        - entity: string
          entity
        - languageCode: integer
          languageCode
        - referenceId: string
          Place holder for Token based authentication
        - requesthash: string
          Request payload for hash validation
        - userId: integer
          userId
        
        
        """
        
        
        # Prepare query parameters
        params = {}
        if modeflag is not None:
            params["modeFlag"] = modeflag
            
        if requestid is not None:
            params["requestId"] = requestid
            
        
        
        # Replace path parameters in URL
        path = "/loans/principalGuarante/principalGuaranteeClaim/authorize"
        
        
        # Prepare headers
        headers = {}
        if accesstoken is not None:
            headers["Accesstoken"] = str(accesstoken)
        if channeltype is not None:
            headers["ChannelType"] = str(channeltype)
        if co_relationid is not None:
            headers["Co-Relationid"] = str(co_relationid)
        if initiatingsystem is not None:
            headers["InitiatingSystem"] = str(initiatingsystem)
        if servicemode is not None:
            headers["ServiceMode"] = str(servicemode)
        if uuidseqno is not None:
            headers["UUIDSeqNo"] = str(uuidseqno)
        if entity is not None:
            headers["entity"] = str(entity)
        if languagecode is not None:
            headers["languageCode"] = str(languagecode)
        if referenceid is not None:
            headers["referenceId"] = str(referenceid)
        if requesthash is not None:
            headers["requesthash"] = str(requesthash)
        if userid is not None:
            headers["userId"] = str(userid)
        
        
        return await make_api_request(
            "PUT", 
            path, 
            
            params=params if params else None, 
            headers=headers if headers else None
        )
    
    
    
    @mcp.tool()
    async def cbcet6618_fetch_loan_product_details_using_get(
        instrumentid: int,
        pagenum: Optional[int] = None,
        pagesize: Optional[int] = None,
        accesstoken: Optional[str] = None,
        channeltype: Optional[int] = None,
        co_relationid: Optional[int] = None,
        initiatingsystem: Optional[str] = None,
        servicemode: Optional[int] = None,
        uuidseqno: Optional[int] = None,
        entity: Optional[str] = None,
        languagecode: Optional[int] = None,
        referenceid: Optional[str] = None,
        userid: Optional[int] = None
    ) -> Dict[str, Any]:
        """
        Fetch Details of a Loan Instrument
        
        Generated from: GET /loans/product/loanProductDetails/{instrumentId}
        Source: swagger_2_0
        Operation ID: CBCET6618FetchLoanProductDetailsUsingGET
        
        
        Authentication: Not required
        
        Parameters:
        - instrumentId: integer (required)
          Loan Instrument Id in BaNCS
        - pageNum: integer
          pageNum
        - pageSize: integer
          pageSize
        
        
        
        Headers:
        - Accesstoken: string
          Authorization token for identification of the caller
        - ChannelType: integer
          Channel identifier from where the TXN has originated (Internet, Mobile, ATM, Branch Channel )
        - Co-Relationid: integer
          Unique ID for the service invoked, will be set by the TXN system
        - InitiatingSystem: string
          Indicating the initiated system
        - ServiceMode: integer
          Used for branch channel to indicate the type of customer
        - UUIDSeqNo: integer
          UUID Sequence Number
        - entity: string
          entity
        - languageCode: integer
          languageCode
        - referenceId: string
          Place holder for Token based authentication
        - userId: integer
          userId
        
        
        """
        
        
        # Prepare query parameters
        params = {}
        if pagenum is not None:
            params["pageNum"] = pagenum
            
        if pagesize is not None:
            params["pageSize"] = pagesize
            
        
        
        # Replace path parameters in URL
        path = "/loans/product/loanProductDetails/{instrumentId}"
        if instrumentid is not None:
            path = path.replace("{instrumentId}", str(instrumentid))
        
        
        # Prepare headers
        headers = {}
        if accesstoken is not None:
            headers["Accesstoken"] = str(accesstoken)
        if channeltype is not None:
            headers["ChannelType"] = str(channeltype)
        if co_relationid is not None:
            headers["Co-Relationid"] = str(co_relationid)
        if initiatingsystem is not None:
            headers["InitiatingSystem"] = str(initiatingsystem)
        if servicemode is not None:
            headers["ServiceMode"] = str(servicemode)
        if uuidseqno is not None:
            headers["UUIDSeqNo"] = str(uuidseqno)
        if entity is not None:
            headers["entity"] = str(entity)
        if languagecode is not None:
            headers["languageCode"] = str(languagecode)
        if referenceid is not None:
            headers["referenceId"] = str(referenceid)
        if userid is not None:
            headers["userId"] = str(userid)
        
        
        return await make_api_request(
            "GET", 
            path, 
            
            params=params if params else None, 
            headers=headers if headers else None
        )
    
    
    
    @mcp.tool()
    async def cbcet0333_get_latest_inrt_postusing_get(
        currency: str,
        loanproductid: int,
        pagenum: Optional[int] = None,
        pagesize: Optional[int] = None,
        accesstoken: Optional[str] = None,
        channeltype: Optional[int] = None,
        co_relationid: Optional[int] = None,
        initiatingsystem: Optional[str] = None,
        servicemode: Optional[int] = None,
        uuidseqno: Optional[int] = None,
        entity: Optional[str] = None,
        languagecode: Optional[int] = None,
        referenceid: Optional[str] = None,
        userid: Optional[int] = None
    ) -> Dict[str, Any]:
        """
        Fetch Interest Rates
        
        Generated from: GET /loans/product/loanProductInterestRate
        Source: swagger_2_0
        Operation ID: CBCET0333GetLatestINRT_POSTUsingGET
        
        
        Authentication: Not required
        
        Parameters:
        - currency: string (required)
          Loan Prouduct Currency ISO Currency codes USD,EUR,INR,ILS (Domain: d_Currcode)
        - loanProductId: integer (required)
          System Generated internal identifier of the product of the loan account
        - pageNum: integer
          pageNum
        - pageSize: integer
          pageSize
        
        
        
        Headers:
        - Accesstoken: string
          Authorization Token to validation the caller
        - ChannelType: integer
          Channel identifier from where the TXN has originated (Internet, Mobile, ATM, Branch Channel )
        - Co-Relationid: integer
          Unique ID for the service invoked, will be set by the TXN system
        - InitiatingSystem: string
          Indicating the initiated system
        - ServiceMode: integer
          Used for branch channel to indicate the type of customer
        - UUIDSeqNo: integer
          UUID Sequence Number
        - entity: string
          entity
        - languageCode: integer
          languageCode
        - referenceId: string
          Place holder for Token based authentication
        - userId: integer
          userId
        
        
        """
        
        
        # Prepare query parameters
        params = {}
        if currency is not None:
            params["currency"] = currency
            
        if loanproductid is not None:
            params["loanProductId"] = loanproductid
            
        if pagenum is not None:
            params["pageNum"] = pagenum
            
        if pagesize is not None:
            params["pageSize"] = pagesize
            
        
        
        # Replace path parameters in URL
        path = "/loans/product/loanProductInterestRate"
        
        
        # Prepare headers
        headers = {}
        if accesstoken is not None:
            headers["Accesstoken"] = str(accesstoken)
        if channeltype is not None:
            headers["ChannelType"] = str(channeltype)
        if co_relationid is not None:
            headers["Co-Relationid"] = str(co_relationid)
        if initiatingsystem is not None:
            headers["InitiatingSystem"] = str(initiatingsystem)
        if servicemode is not None:
            headers["ServiceMode"] = str(servicemode)
        if uuidseqno is not None:
            headers["UUIDSeqNo"] = str(uuidseqno)
        if entity is not None:
            headers["entity"] = str(entity)
        if languagecode is not None:
            headers["languageCode"] = str(languagecode)
        if referenceid is not None:
            headers["referenceId"] = str(referenceid)
        if userid is not None:
            headers["userId"] = str(userid)
        
        
        return await make_api_request(
            "GET", 
            path, 
            
            params=params if params else None, 
            headers=headers if headers else None
        )
    
    
    
    @mcp.tool()
    async def cret4237_fetch_loan_product_list_using_get(
        instrumenttype: int,
        accounttype: Optional[int] = None,
        facilitytype: Optional[int] = None,
        instrumentname: Optional[str] = None,
        pagenum: Optional[int] = None,
        pagesize: Optional[int] = None,
        productcode: Optional[str] = None,
        accesstoken: Optional[str] = None,
        channeltype: Optional[int] = None,
        co_relationid: Optional[int] = None,
        initiatingsystem: Optional[str] = None,
        servicemode: Optional[int] = None,
        uuidseqno: Optional[int] = None,
        entity: Optional[str] = None,
        languagecode: Optional[int] = None,
        referenceid: Optional[str] = None,
        userid: Optional[int] = None
    ) -> Dict[str, Any]:
        """
        List all Products
        
        Generated from: GET /loans/product/loanProductList
        Source: swagger_2_0
        Operation ID: CRET4237FetchLoanProductListUsingGET
        
        
        Authentication: Not required
        
        Parameters:
        - accountType: integer
          ID of the AccountType . Maps to User Defined Data for AccountType e.g. 6: Personal Loans. This is based on Implementation 1-Current,2-CashPayment,3-Charges,6-Loan.(Domain Name: d_Acnt_Typ)
        - facilityType: integer
          Short Code of Facility Type e.g. 'LT'
        - instrumentName: string
          Instrument Name
        - instrumentType: integer (required)
          Type of the financial product, 34- money accounts,244 - Loans,401 - LoC.  Maps to Instrument Type of the Product (Domain Name: d_InstrTyp)
        - pageNum: integer
          pageNum
        - pageSize: integer
          pageSize
        - productCode: string
          Mapped to Product Code in User Defined where attribute name = Product Code
        
        
        
        Headers:
        - Accesstoken: string
          Authorization Token to validation the caller
        - ChannelType: integer
          Channel identifier from where the TXN has originated (Internet, Mobile, ATM, Branch Channel )
        - Co-Relationid: integer
          Unique ID for the service invoked, will be set by the TXN system
        - InitiatingSystem: string
          Indicating the initiated system
        - ServiceMode: integer
          Used for branch channel to indicate the type of customer
        - UUIDSeqNo: integer
          UUID Sequence Number
        - entity: string
          entity
        - languageCode: integer
          languageCode
        - referenceId: string
          Place holder for Token based authentication
        - userId: integer
          userId
        
        
        """
        
        
        # Prepare query parameters
        params = {}
        if accounttype is not None:
            params["accountType"] = accounttype
            
        if facilitytype is not None:
            params["facilityType"] = facilitytype
            
        if instrumentname is not None:
            params["instrumentName"] = instrumentname
            
        if instrumenttype is not None:
            params["instrumentType"] = instrumenttype
            
        if pagenum is not None:
            params["pageNum"] = pagenum
            
        if pagesize is not None:
            params["pageSize"] = pagesize
            
        if productcode is not None:
            params["productCode"] = productcode
            
        
        
        # Replace path parameters in URL
        path = "/loans/product/loanProductList"
        
        
        # Prepare headers
        headers = {}
        if accesstoken is not None:
            headers["Accesstoken"] = str(accesstoken)
        if channeltype is not None:
            headers["ChannelType"] = str(channeltype)
        if co_relationid is not None:
            headers["Co-Relationid"] = str(co_relationid)
        if initiatingsystem is not None:
            headers["InitiatingSystem"] = str(initiatingsystem)
        if servicemode is not None:
            headers["ServiceMode"] = str(servicemode)
        if uuidseqno is not None:
            headers["UUIDSeqNo"] = str(uuidseqno)
        if entity is not None:
            headers["entity"] = str(entity)
        if languagecode is not None:
            headers["languageCode"] = str(languagecode)
        if referenceid is not None:
            headers["referenceId"] = str(referenceid)
        if userid is not None:
            headers["userId"] = str(userid)
        
        
        return await make_api_request(
            "GET", 
            path, 
            
            params=params if params else None, 
            headers=headers if headers else None
        )
    
    
    
    @mcp.tool()
    async def cret0317_fetch_repymnt_list_using_get(
        customerreference: Optional[int] = None,
        debitaccountreference: Optional[str] = None,
        executiondatefrom: Optional[str] = None,
        executiondateto: Optional[str] = None,
        initiatingdatefrom: Optional[str] = None,
        initiatingdateto: Optional[str] = None,
        loanaccountreference: Optional[str] = None,
        pagenum: Optional[int] = None,
        pagesize: Optional[int] = None,
        status: Optional[int] = None,
        transactionreference: Optional[int] = None,
        transactiontype: Optional[int] = None,
        channeltype: Optional[int] = None,
        co_relationid: Optional[int] = None,
        initiatingsystem: Optional[str] = None,
        servicemode: Optional[int] = None,
        uuidseqno: Optional[int] = None,
        entity: Optional[str] = None,
        languagecode: Optional[int] = None,
        userid: Optional[int] = None
    ) -> Dict[str, Any]:
        """
        Repayment History
        
        Generated from: GET /loans/repaymentHistory
        Source: swagger_2_0
        Operation ID: CRET0317FetchRepymntListUsingGET
        
        
        Authentication: Not required
        
        Parameters:
        - customerReference: integer
          Customer Reference
        - debitAccountReference: string
          Account Reference
        - executionDateFrom: string
          Execution Date From
        - executionDateTo: string
          Execution Date To
        - initiatingDateFrom: string
          Initiating Date From
        - initiatingDateTo: string
          Initiating Date To
        - loanAccountReference: string
          Loan Account Reference
        - pageNum: integer
          pageNum
        - pageSize: integer
          pageSize
        - status: integer
          Status
        - transactionReference: integer
          Transaction Reference
        - transactionType: integer
          Transaction Type
        
        
        
        Headers:
        - ChannelType: integer
          Channel identifier from where the transaction has originated (Internet, Mobile, ATM, Branch Channel )
        - Co-Relationid: integer
          Unique ID for the service invoked, will be set by the transaction system
        - InitiatingSystem: string
          Indicating the initiated system
        - ServiceMode: integer
          Used for branch channel to indicate the type of customer
        - UUIDSeqNo: integer
          UUID Sequence Number
        - entity: string
          entity
        - languageCode: integer
          languageCode
        - userId: integer
          userId
        
        
        """
        
        
        # Prepare query parameters
        params = {}
        if customerreference is not None:
            params["customerReference"] = customerreference
            
        if debitaccountreference is not None:
            params["debitAccountReference"] = debitaccountreference
            
        if executiondatefrom is not None:
            params["executionDateFrom"] = executiondatefrom
            
        if executiondateto is not None:
            params["executionDateTo"] = executiondateto
            
        if initiatingdatefrom is not None:
            params["initiatingDateFrom"] = initiatingdatefrom
            
        if initiatingdateto is not None:
            params["initiatingDateTo"] = initiatingdateto
            
        if loanaccountreference is not None:
            params["loanAccountReference"] = loanaccountreference
            
        if pagenum is not None:
            params["pageNum"] = pagenum
            
        if pagesize is not None:
            params["pageSize"] = pagesize
            
        if status is not None:
            params["status"] = status
            
        if transactionreference is not None:
            params["transactionReference"] = transactionreference
            
        if transactiontype is not None:
            params["transactionType"] = transactiontype
            
        
        
        # Replace path parameters in URL
        path = "/loans/repaymentHistory"
        
        
        # Prepare headers
        headers = {}
        if channeltype is not None:
            headers["ChannelType"] = str(channeltype)
        if co_relationid is not None:
            headers["Co-Relationid"] = str(co_relationid)
        if initiatingsystem is not None:
            headers["InitiatingSystem"] = str(initiatingsystem)
        if servicemode is not None:
            headers["ServiceMode"] = str(servicemode)
        if uuidseqno is not None:
            headers["UUIDSeqNo"] = str(uuidseqno)
        if entity is not None:
            headers["entity"] = str(entity)
        if languagecode is not None:
            headers["languageCode"] = str(languagecode)
        if userid is not None:
            headers["userId"] = str(userid)
        
        
        return await make_api_request(
            "GET", 
            path, 
            
            params=params if params else None, 
            headers=headers if headers else None
        )
    
    
    
    @mcp.tool()
    async def cret2811_get_rpymnt_dtls_postusing_get(
        loanreference: str,
        repayoption: int,
        pagenum: Optional[int] = None,
        pagesize: Optional[int] = None,
        accesstoken: Optional[str] = None,
        channeltype: Optional[int] = None,
        co_relationid: Optional[int] = None,
        initiatingsystem: Optional[str] = None,
        servicemode: Optional[int] = None,
        uuidseqno: Optional[int] = None,
        entity: Optional[str] = None,
        languagecode: Optional[int] = None,
        referenceid: Optional[str] = None,
        userid: Optional[int] = None
    ) -> Dict[str, Any]:
        """
        This service is used to View Repayment Schedule
        
        Generated from: GET /loans/repaymentSchedule/{loanReference}
        Source: swagger_2_0
        Operation ID: CRET2811GetRpymntDtls_POSTUsingGET
        
        
        Authentication: Not required
        
        Parameters:
        - loanReference: string (required)
          Reference Loan account Number
        - pageNum: integer
          pageNum
        - pageSize: integer
          pageSize
        - repayOption: integer (required)
          Options (1-Default, 2-Future)
        
        
        
        Headers:
        - Accesstoken: string
          Authorization token for identification of the caller
        - ChannelType: integer
          Channel identifier from where the TXN has originated (Internet, Mobile, ATM, Branch Channel )
        - Co-Relationid: integer
          Unique ID for the service invoked, will be set by the TXN system
        - InitiatingSystem: string
          Indicating the initiated system
        - ServiceMode: integer
          Used for branch channel to indicate the type of customer
        - UUIDSeqNo: integer
          UUID Sequence Number
        - entity: string
          entity
        - languageCode: integer
          languageCode
        - referenceId: string
          Place holder for Token based authentication
        - userId: integer
          userId
        
        
        """
        
        
        # Prepare query parameters
        params = {}
        if pagenum is not None:
            params["pageNum"] = pagenum
            
        if pagesize is not None:
            params["pageSize"] = pagesize
            
        if repayoption is not None:
            params["repayOption"] = repayoption
            
        
        
        # Replace path parameters in URL
        path = "/loans/repaymentSchedule/{loanReference}"
        if loanreference is not None:
            path = path.replace("{loanReference}", str(loanreference))
        
        
        # Prepare headers
        headers = {}
        if accesstoken is not None:
            headers["Accesstoken"] = str(accesstoken)
        if channeltype is not None:
            headers["ChannelType"] = str(channeltype)
        if co_relationid is not None:
            headers["Co-Relationid"] = str(co_relationid)
        if initiatingsystem is not None:
            headers["InitiatingSystem"] = str(initiatingsystem)
        if servicemode is not None:
            headers["ServiceMode"] = str(servicemode)
        if uuidseqno is not None:
            headers["UUIDSeqNo"] = str(uuidseqno)
        if entity is not None:
            headers["entity"] = str(entity)
        if languagecode is not None:
            headers["languageCode"] = str(languagecode)
        if referenceid is not None:
            headers["referenceId"] = str(referenceid)
        if userid is not None:
            headers["userId"] = str(userid)
        
        
        return await make_api_request(
            "GET", 
            path, 
            
            params=params if params else None, 
            headers=headers if headers else None
        )
    
    
    
    @mcp.tool()
    async def crbt2912_creation_loan_reschedule_postusing_post(
        request_body:Dict[str, Any] ,  # creationLoanRescheduleResource,
        accesstoken: Optional[str] = None,
        channeltype: Optional[int] = None,
        co_relationid: Optional[int] = None,
        initiatingsystem: Optional[str] = None,
        servicemode: Optional[int] = None,
        uuidseqno: Optional[int] = None,
        entity: Optional[str] = None,
        languagecode: Optional[int] = None,
        referenceid: Optional[str] = None,
        requesthash: Optional[str] = None,
        userid: Optional[int] = None
    ) -> Dict[str, Any]:
        """
        Loan Reschedule
        
        Generated from: POST /loans/repayments/loanReSchedule
        Source: swagger_2_0
        Operation ID: CRBT2912CreationLoanReschedule_POSTUsingPOST
        
        
        Authentication: Not required
        
        Parameters:
        - request_body: any (required)
          input
        
        
        
        Headers:
        - Accesstoken: string
          Authorization Token to validation the caller
        - ChannelType: integer
          Channel identifier from where the TXN has originated (Internet, Mobile, ATM, Branch Channel )
        - Co-Relationid: integer
          Unique ID for the service invoked, will be set by the TXN system
        - InitiatingSystem: string
          Indicating the initiated system
        - ServiceMode: integer
          Used for branch channel to indicate the type of customer
        - UUIDSeqNo: integer
          UUID Sequence Number
        - entity: string
          entity
        - languageCode: integer
          languageCode
        - referenceId: string
          Place holder for Token based authentication
        - requesthash: string
          Request payload for hash validation
        - userId: integer
          userId
        
        
        """
        
        
        # Prepare request data
        
        # Single body parameter - send directly
        data = request_body if request_body is not None else {}
        
        
        
        # Prepare query parameters
        params = {}
        
        
        # Replace path parameters in URL
        path = "/loans/repayments/loanReSchedule"
        
        
        # Prepare headers
        headers = {}
        if accesstoken is not None:
            headers["Accesstoken"] = str(accesstoken)
        if channeltype is not None:
            headers["ChannelType"] = str(channeltype)
        if co_relationid is not None:
            headers["Co-Relationid"] = str(co_relationid)
        if initiatingsystem is not None:
            headers["InitiatingSystem"] = str(initiatingsystem)
        if servicemode is not None:
            headers["ServiceMode"] = str(servicemode)
        if uuidseqno is not None:
            headers["UUIDSeqNo"] = str(uuidseqno)
        if entity is not None:
            headers["entity"] = str(entity)
        if languagecode is not None:
            headers["languageCode"] = str(languagecode)
        if referenceid is not None:
            headers["referenceId"] = str(referenceid)
        if requesthash is not None:
            headers["requesthash"] = str(requesthash)
        if userid is not None:
            headers["userId"] = str(userid)
        
        
        return await make_api_request(
            "POST", 
            path, 
            data=data, 
            params=params if params else None, 
            headers=headers if headers else None
        )
    
    
    
    @mcp.tool()
    async def cret2912_simulate_repayment_evnts_using_get(
        changedtenurefrequency: int,
        changedtenureval: int,
        installementstartdate: str,
        installmentamount: float,
        installmenttype: int,
        loaneventpurpose: int,
        loaneventsubpurpose: int,
        loanreference: str,
        postponenextdate: Optional[int] = None,
        postponepastdate: Optional[int] = None,
        previousduedate: Optional[str] = None,
        profithandling: Optional[int] = None,
        reasoncode: Optional[int] = None,
        acntgmethod: Optional[int] = None,
        holidayendmonth: Optional[int] = None,
        holidayid: Optional[int] = None,
        holidayperiodfrequency: Optional[int] = None,
        holidayperiodval: Optional[int] = None,
        holidaystartmonth: Optional[int] = None,
        holidaystrtdt: Optional[str] = None,
        loanid: Optional[int] = None,
        overridehldy: Optional[int] = None,
        pagenum: Optional[int] = None,
        pagesize: Optional[int] = None,
        prepayamt: Optional[float] = None,
        regenoption: Optional[int] = None,
        repaymentday: Optional[int] = None,
        repaymentfrequency: Optional[int] = None,
        reschedulebasis: Optional[int] = None,
        validfrom: Optional[str] = None,
        accesstoken: Optional[str] = None,
        channeltype: Optional[int] = None,
        co_relationid: Optional[int] = None,
        initiatingsystem: Optional[str] = None,
        servicemode: Optional[int] = None,
        uuidseqno: Optional[int] = None,
        entity: Optional[str] = None,
        languagecode: Optional[int] = None,
        referenceid: Optional[str] = None,
        userid: Optional[int] = None
    ) -> Dict[str, Any]:
        """
        Simulate Repayment Schedule
        
        Generated from: GET /loans/repayments/simulateLoanReSchedule 
        Source: swagger_2_0
        Operation ID: CRET2912SimulateRepaymentEvntsUsingGET
        
        
        Authentication: Not required
        
        Parameters:
        - PostponeNextDate: integer
          Postpone Next Date Flag(1 - checked)
        - PostponePastDate: integer
          Postpone Past Date Flag (1 - checked If 1 enter PreviousDueDate value)
        - PreviousDueDate: string
          Previous Due Date (format : YYYYMMDD)
        - ProfitHandling: integer
          Profit Handling (Domain : d_UpfrontHandling 1 - Same Profit , 2 - Same Rate)
        - ReasonCode: integer
          Reason Code (1 - Customer Request , 2 - Royal Decree)
        - acntgMethod: integer
          to identify prepayment transaction in  Simulate
        - changedTenureFrequency: integer (required)
          Changed Loan tenure frequency. 1 - Day,2 - Fortnight,4 - Month,5 - Quarter,6 - SixMonth,7 - Week,8 - Year (Domain :d_FreqUnit)
        - changedTenureVal: integer (required)
          Changed Loan tenure frequency value
        - holidayEndMonth: integer
          For Seasonal Holiday applicable every year - End Month of Holiday
        - holidayId: integer
          holidayId num for cancelling existing holiday
        - holidayPeriodFrequency: integer
          For Adhoc Holiday - Holiday period in Months 1 - Day,2 - Fortnight,4 - Month,5 - Quarter,6 - SixMonth,7 - Week, 8 - Year (Domain :d_FreqUnit)
        - holidayPeriodVal: integer
          Holiday period frequency value
        - holidayStartMonth: integer
          For Seasonal Holiday applicable every year - Start Month of Holiday
        - holidayStrtDt: string
          For Adhoc Holiday Start Date of Holiday
        - installementStartDate: string (required)
          Repayment start date
        - installmentAmount: number (required)
          Principal / Installment Amount as applicable Based on instalment Type
        - installmentType: integer (required)
          Repayment type 1 - EI 2 - Equal 3 - IntrstOnly 4 - Negotiated 5 - Balloon 6 - Irregular 7 - PrinNegoRegIntrst (Domain: d_InstallmntType)
        - loanEventPurpose: integer (required)
          LoanPostponement 3, LoanWriteOff 7,LoanPartialWriteOff 8, LoanCancellation 9, LoanPrepayment 18, LoanAdvanceRpymnt 19, RetentionPayout 20, LeaseOut 21, LoanReschedule 4 (Code_name: d_LoanEventPurpose)
        - loanEventSubPurpose: integer (required)
          36 - Interest and Principal Holiday, 37 - Others, 11 - Principal Holiday, 46 - Cancel Existing Holiday, 45 - Seasonal Holiday, 52 - Postpone Repay Date (Code name:d_LoanEventSubPrps)
        - loanId: integer
          Technical reference of Loan account
        - loanReference: string (required)
          Reference Number generated for loan account based on configured scheme
        - overrideHldy: integer
          cancel Flag to cancel all existing holidays
        - pageNum: integer
          pageNum
        - pageSize: integer
          pageSize
        - prepayAmt: number
          Prepay Amount
        - regenOption: integer
          Loan Repayment schedule regenerate option, EMIChange 1,TenureChange 2, AmortizationChange 4 (Code name:d_EIRegenOption)
        - repaymentDay: integer
          The day on which repayment will due every month
        - repaymentFrequency: integer
          Frequency of Repayment Installment.1 - Day,2 - Fortnight,4 - Month,5 - Quarter,6 - SixMonth,7 - Week,8 - Year (Code name:d_FreqUnit)
        - rescheduleBasis: integer
          Loan Reschedule basis. OutstandingBal 1, ScheduleBal 2, PrincipalOutstandingBal 3,OdBal 5,OdPndI 6,OdXcMsc 7,PrncplIntBal 4. (Code name:d_LoanBalType)
        - validFrom: string
          Valid From of the schedule / installment Date (format : YYYYMMDD)
        
        
        
        Headers:
        - Accesstoken: string
          Authorization Token to validation the caller
        - ChannelType: integer
          Channel identifier from where the TXN has originated (Internet, Mobile, ATM, Branch Channel )
        - Co-Relationid: integer
          Unique ID for the service invoked, will be set by the TXN system
        - InitiatingSystem: string
          Indicating the initiated system
        - ServiceMode: integer
          Used for branch channel to indicate the type of customer
        - UUIDSeqNo: integer
          UUID Sequence Number
        - entity: string
          entity
        - languageCode: integer
          languageCode
        - referenceId: string
          Place holder for Token based authentication
        - userId: integer
          userId
        
        
        """
        
        
        # Prepare query parameters
        params = {}
        if postponenextdate is not None:
            params["PostponeNextDate"] = postponenextdate
            
        if postponepastdate is not None:
            params["PostponePastDate"] = postponepastdate
            
        if previousduedate is not None:
            params["PreviousDueDate"] = previousduedate
            
        if profithandling is not None:
            params["ProfitHandling"] = profithandling
            
        if reasoncode is not None:
            params["ReasonCode"] = reasoncode
            
        if acntgmethod is not None:
            params["acntgMethod"] = acntgmethod
            
        if changedtenurefrequency is not None:
            params["changedTenureFrequency"] = changedtenurefrequency
            
        if changedtenureval is not None:
            params["changedTenureVal"] = changedtenureval
            
        if holidayendmonth is not None:
            params["holidayEndMonth"] = holidayendmonth
            
        if holidayid is not None:
            params["holidayId"] = holidayid
            
        if holidayperiodfrequency is not None:
            params["holidayPeriodFrequency"] = holidayperiodfrequency
            
        if holidayperiodval is not None:
            params["holidayPeriodVal"] = holidayperiodval
            
        if holidaystartmonth is not None:
            params["holidayStartMonth"] = holidaystartmonth
            
        if holidaystrtdt is not None:
            params["holidayStrtDt"] = holidaystrtdt
            
        if installementstartdate is not None:
            params["installementStartDate"] = installementstartdate
            
        if installmentamount is not None:
            params["installmentAmount"] = installmentamount
            
        if installmenttype is not None:
            params["installmentType"] = installmenttype
            
        if loaneventpurpose is not None:
            params["loanEventPurpose"] = loaneventpurpose
            
        if loaneventsubpurpose is not None:
            params["loanEventSubPurpose"] = loaneventsubpurpose
            
        if loanid is not None:
            params["loanId"] = loanid
            
        if loanreference is not None:
            params["loanReference"] = loanreference
            
        if overridehldy is not None:
            params["overrideHldy"] = overridehldy
            
        if pagenum is not None:
            params["pageNum"] = pagenum
            
        if pagesize is not None:
            params["pageSize"] = pagesize
            
        if prepayamt is not None:
            params["prepayAmt"] = prepayamt
            
        if regenoption is not None:
            params["regenOption"] = regenoption
            
        if repaymentday is not None:
            params["repaymentDay"] = repaymentday
            
        if repaymentfrequency is not None:
            params["repaymentFrequency"] = repaymentfrequency
            
        if reschedulebasis is not None:
            params["rescheduleBasis"] = reschedulebasis
            
        if validfrom is not None:
            params["validFrom"] = validfrom
            
        
        
        # Replace path parameters in URL
        path = "/loans/repayments/simulateLoanReSchedule "
        
        
        # Prepare headers
        headers = {}
        if accesstoken is not None:
            headers["Accesstoken"] = str(accesstoken)
        if channeltype is not None:
            headers["ChannelType"] = str(channeltype)
        if co_relationid is not None:
            headers["Co-Relationid"] = str(co_relationid)
        if initiatingsystem is not None:
            headers["InitiatingSystem"] = str(initiatingsystem)
        if servicemode is not None:
            headers["ServiceMode"] = str(servicemode)
        if uuidseqno is not None:
            headers["UUIDSeqNo"] = str(uuidseqno)
        if entity is not None:
            headers["entity"] = str(entity)
        if languagecode is not None:
            headers["languageCode"] = str(languagecode)
        if referenceid is not None:
            headers["referenceId"] = str(referenceid)
        if userid is not None:
            headers["userId"] = str(userid)
        
        
        return await make_api_request(
            "GET", 
            path, 
            
            params=params if params else None, 
            headers=headers if headers else None
        )
    
    
    
    @mcp.tool()
    async def cret2912_simulate_repayment_evnts_islamic_postusing_get(
        currency: str,
        installmentfrequency: int,
        installmenttype: int,
        loanamount: float,
        loanproductid: int,
        loantenurefreq: int,
        loantenureunit: int,
        enddate: Optional[str] = None,
        holidaytenurefreq: Optional[int] = None,
        holidaytenurevalue: Optional[int] = None,
        installmentstartdate: Optional[str] = None,
        interestinstallmentfrequencyforirregular: Optional[int] = None,
        interestpractice: Optional[int] = None,
        morotoriumperiodfreq: Optional[int] = None,
        morotoriumperiodfreqvalue: Optional[int] = None,
        morotoriumtype: Optional[int] = None,
        netdrrate: Optional[float] = None,
        principleinstallmentstartdateforirregular: Optional[str] = None,
        repaymentsimulator: Optional[int] = None,
        startdate: Optional[str] = None,
        subsidypercentage: Optional[float] = None,
        tentativedisbursementdate: Optional[str] = None,
        totalupfrontcharg: Optional[float] = None,
        accesstoken: Optional[str] = None,
        channeltype: Optional[int] = None,
        co_relationid: Optional[int] = None,
        initiatingsystem: Optional[str] = None,
        servicemode: Optional[int] = None,
        uuidseqno: Optional[int] = None,
        entity: Optional[str] = None,
        languagecode: Optional[int] = None,
        referenceid: Optional[str] = None,
        userid: Optional[int] = None
    ) -> Dict[str, Any]:
        """
        Calculate Upfront Profit
        
        Generated from: GET /loans/repayments/simulateLoanSchedule
        Source: swagger_2_0
        Operation ID: CRET2912SimulateRepaymentEvntsIslamic_POSTUsingGET
        
        
        Authentication: Not required
        
        Parameters:
        - currency: string (required)
          Loan currency ISO currency codes USD,EUR,INR,ILS.(Domain: d_CurrCode)
        - endDate: string
          End Date of Holiday
        - holidayTenureFreq: integer
          Holiday Tenure Frequency
        - holidayTenureValue: integer
          Number of Months of upfront holiday requested
        - installmentFrequency: integer (required)
          Loan Repayment Frequency / Principle Repayment Frequency Incase of Irregular
        - installmentStartDate: string
          First Instalment Due Date / Interest Payment Start Date Incase Of Irregular
        - installmentType: integer (required)
          Repayment Type for Loan 1-EMI, 9 - Negotiated 2-Equal
        - interestInstallmentFrequencyForIrregular: integer
          Interest Repayment Frequency Incase of Irregular
        - interestPractice: integer
          Day Count Convention to be applied for interest computation 1 - 30By360 2 - ActualBy360 3 - Actual By Actual 4 - 30 By Actual 5 - ActualBy365 6 - 30By365 7 - 30E By 360
        - loanAmount: number (required)
          Loan Application Amount
        - loanProductID: integer (required)
          Loan product id
        - loanTenureFreq: integer (required)
          Loan Tenure Frequency 1 - Day 2 - Fortnight 3 - Hour 4 - Month 5 - Quarter 6 - Six Month 7 - Week 8 - Year
        - loanTenureUnit: integer (required)
          Loan Tenure
        - morotoriumPeriodFreq: integer
          Morotorium Period Frequency
        - morotoriumPeriodFreqValue: integer
          Morotorium Frequency Value
        - morotoriumType: integer
          Morotorium Type
        - netDrRate: number
          Net Debit Rate
        - principleInstallmentStartDateForIrregular: string
          Principle Payment Start Date Incase Of Irregular
        - repaymentSimulator: integer
          repayment Simulator Flag Value - 1
        - startDate: string
          Start Date of Holiday
        - subsidyPercentage: number
          Subsidy Percentage
        - tentativeDisbursementDate: string
          Tentative Disbursement Date
        - totalUpfrontCharg: number
          Total Upfront Loan Charge which is used for computation of Effective Interest rate on loan
        
        
        
        Headers:
        - Accesstoken: string
          Authorization Token to validation the caller
        - ChannelType: integer
          Channel identifier from where the TXN has originated (Internet, Mobile, ATM, Branch Channel )
        - Co-Relationid: integer
          Unique ID for the service invoked, will be set by the TXN system
        - InitiatingSystem: string
          Indicating the initiated system
        - ServiceMode: integer
          Used for branch channel to indicate the type of customer
        - UUIDSeqNo: integer
          UUID Sequence Number
        - entity: string
          entity
        - languageCode: integer
          languageCode
        - referenceId: string
          Place holder for Token based authentication
        - userId: integer
          userId
        
        
        """
        
        
        # Prepare query parameters
        params = {}
        if currency is not None:
            params["currency"] = currency
            
        if enddate is not None:
            params["endDate"] = enddate
            
        if holidaytenurefreq is not None:
            params["holidayTenureFreq"] = holidaytenurefreq
            
        if holidaytenurevalue is not None:
            params["holidayTenureValue"] = holidaytenurevalue
            
        if installmentfrequency is not None:
            params["installmentFrequency"] = installmentfrequency
            
        if installmentstartdate is not None:
            params["installmentStartDate"] = installmentstartdate
            
        if installmenttype is not None:
            params["installmentType"] = installmenttype
            
        if interestinstallmentfrequencyforirregular is not None:
            params["interestInstallmentFrequencyForIrregular"] = interestinstallmentfrequencyforirregular
            
        if interestpractice is not None:
            params["interestPractice"] = interestpractice
            
        if loanamount is not None:
            params["loanAmount"] = loanamount
            
        if loanproductid is not None:
            params["loanProductID"] = loanproductid
            
        if loantenurefreq is not None:
            params["loanTenureFreq"] = loantenurefreq
            
        if loantenureunit is not None:
            params["loanTenureUnit"] = loantenureunit
            
        if morotoriumperiodfreq is not None:
            params["morotoriumPeriodFreq"] = morotoriumperiodfreq
            
        if morotoriumperiodfreqvalue is not None:
            params["morotoriumPeriodFreqValue"] = morotoriumperiodfreqvalue
            
        if morotoriumtype is not None:
            params["morotoriumType"] = morotoriumtype
            
        if netdrrate is not None:
            params["netDrRate"] = netdrrate
            
        if principleinstallmentstartdateforirregular is not None:
            params["principleInstallmentStartDateForIrregular"] = principleinstallmentstartdateforirregular
            
        if repaymentsimulator is not None:
            params["repaymentSimulator"] = repaymentsimulator
            
        if startdate is not None:
            params["startDate"] = startdate
            
        if subsidypercentage is not None:
            params["subsidyPercentage"] = subsidypercentage
            
        if tentativedisbursementdate is not None:
            params["tentativeDisbursementDate"] = tentativedisbursementdate
            
        if totalupfrontcharg is not None:
            params["totalUpfrontCharg"] = totalupfrontcharg
            
        
        
        # Replace path parameters in URL
        path = "/loans/repayments/simulateLoanSchedule"
        
        
        # Prepare headers
        headers = {}
        if accesstoken is not None:
            headers["Accesstoken"] = str(accesstoken)
        if channeltype is not None:
            headers["ChannelType"] = str(channeltype)
        if co_relationid is not None:
            headers["Co-Relationid"] = str(co_relationid)
        if initiatingsystem is not None:
            headers["InitiatingSystem"] = str(initiatingsystem)
        if servicemode is not None:
            headers["ServiceMode"] = str(servicemode)
        if uuidseqno is not None:
            headers["UUIDSeqNo"] = str(uuidseqno)
        if entity is not None:
            headers["entity"] = str(entity)
        if languagecode is not None:
            headers["languageCode"] = str(languagecode)
        if referenceid is not None:
            headers["referenceId"] = str(referenceid)
        if userid is not None:
            headers["userId"] = str(userid)
        
        
        return await make_api_request(
            "GET", 
            path, 
            
            params=params if params else None, 
            headers=headers if headers else None
        )
    
    
    
    @mcp.tool()
    async def crbt6812_crt_ln_rollover_inst_postusing_post(
        request_body:Dict[str, Any] ,  # ROLLOVER_INSTRUCTION_CRBT6812CrtLnRolloverInst_Resource,
        accesstoken: Optional[str] = None,
        channeltype: Optional[int] = None,
        co_relationid: Optional[int] = None,
        initiatingsystem: Optional[str] = None,
        servicemode: Optional[int] = None,
        uuidseqno: Optional[int] = None,
        entity: Optional[str] = None,
        languagecode: Optional[int] = None,
        referenceid: Optional[str] = None,
        requesthash: Optional[str] = None,
        userid: Optional[int] = None
    ) -> Dict[str, Any]:
        """
        Creation of loan Rollover
        
        Generated from: POST /loans/rollover/create
        Source: swagger_2_0
        Operation ID: CRBT6812CrtLnRolloverInst_POSTUsingPOST
        
        
        Authentication: Not required
        
        Parameters:
        - request_body: any (required)
          input
        
        
        
        Headers:
        - Accesstoken: string
          Authorization token for identification of the caller
        - ChannelType: integer
          Channel identifier from where the TXN has originated (Internet, Mobile, ATM, Branch Channel )
        - Co-Relationid: integer
          Unique ID for the service invoked, will be set by the TXN system
        - InitiatingSystem: string
          Indicating the initiated system
        - ServiceMode: integer
          Used for branch channel to indicate the type of customer
        - UUIDSeqNo: integer
          UUID Sequence Number
        - entity: string
          entity
        - languageCode: integer
          languageCode
        - referenceId: string
          Place holder for Token based authentication
        - requesthash: string
          Request payload for hash validation
        - userId: integer
          userId
        
        
        """
        
        
        # Prepare request data
        
        # Single body parameter - send directly
        data = request_body if request_body is not None else {}
        
        
        
        # Prepare query parameters
        params = {}
        
        
        # Replace path parameters in URL
        path = "/loans/rollover/create"
        
        
        # Prepare headers
        headers = {}
        if accesstoken is not None:
            headers["Accesstoken"] = str(accesstoken)
        if channeltype is not None:
            headers["ChannelType"] = str(channeltype)
        if co_relationid is not None:
            headers["Co-Relationid"] = str(co_relationid)
        if initiatingsystem is not None:
            headers["InitiatingSystem"] = str(initiatingsystem)
        if servicemode is not None:
            headers["ServiceMode"] = str(servicemode)
        if uuidseqno is not None:
            headers["UUIDSeqNo"] = str(uuidseqno)
        if entity is not None:
            headers["entity"] = str(entity)
        if languagecode is not None:
            headers["languageCode"] = str(languagecode)
        if referenceid is not None:
            headers["referenceId"] = str(referenceid)
        if requesthash is not None:
            headers["requesthash"] = str(requesthash)
        if userid is not None:
            headers["userId"] = str(userid)
        
        
        return await make_api_request(
            "POST", 
            path, 
            data=data, 
            params=params if params else None, 
            headers=headers if headers else None
        )
    
    
    
    @mcp.tool()
    async def cbcbtcreate_ssiloans_on_hold_using_post(
        request_body:Dict[str, Any] ,  # loanOnHoldResource,
        accesstoken: Optional[str] = None,
        channeltype: Optional[int] = None,
        co_relationid: Optional[int] = None,
        initiatingsystem: Optional[str] = None,
        servicemode: Optional[int] = None,
        uuidseqno: Optional[int] = None,
        entity: Optional[str] = None,
        languagecode: Optional[int] = None,
        referenceid: Optional[str] = None,
        requesthash: Optional[str] = None,
        userid: Optional[int] = None
    ) -> Dict[str, Any]:
        """
        Loan Settlement Account Creation with Authorisation
        
        Generated from: POST /loans/settlementInstruction
        Source: swagger_2_0
        Operation ID: CBCBTCreateSSILoansOnHoldUsingPOST
        
        
        Authentication: Not required
        
        Parameters:
        - request_body: any (required)
          input
        
        
        
        Headers:
        - Accesstoken: string
          Authorization token for identification of the caller
        - ChannelType: integer
          Channel identifier from where the TXN has originated (Internet, Mobile, ATM, Branch Channel )
        - Co-Relationid: integer
          Unique ID for the service invoked, will be set by the TXN system
        - InitiatingSystem: string
          Indicating the initiated system
        - ServiceMode: integer
          Used for branch channel to indicate the type of customer
        - UUIDSeqNo: integer
          UUID Sequence Number
        - entity: string
          entity
        - languageCode: integer
          languageCode
        - referenceId: string
          Place holder for Token based authentication
        - requesthash: string
          Request payload for hash validation
        - userId: integer
          userId
        
        
        """
        
        
        # Prepare request data
        
        # Single body parameter - send directly
        data = request_body if request_body is not None else {}
        
        
        
        # Prepare query parameters
        params = {}
        
        
        # Replace path parameters in URL
        path = "/loans/settlementInstruction"
        
        
        # Prepare headers
        headers = {}
        if accesstoken is not None:
            headers["Accesstoken"] = str(accesstoken)
        if channeltype is not None:
            headers["ChannelType"] = str(channeltype)
        if co_relationid is not None:
            headers["Co-Relationid"] = str(co_relationid)
        if initiatingsystem is not None:
            headers["InitiatingSystem"] = str(initiatingsystem)
        if servicemode is not None:
            headers["ServiceMode"] = str(servicemode)
        if uuidseqno is not None:
            headers["UUIDSeqNo"] = str(uuidseqno)
        if entity is not None:
            headers["entity"] = str(entity)
        if languagecode is not None:
            headers["languageCode"] = str(languagecode)
        if referenceid is not None:
            headers["referenceId"] = str(referenceid)
        if requesthash is not None:
            headers["requesthash"] = str(requesthash)
        if userid is not None:
            headers["userId"] = str(userid)
        
        
        return await make_api_request(
            "POST", 
            path, 
            data=data, 
            params=params if params else None, 
            headers=headers if headers else None
        )
    
    
    
    @mcp.tool()
    async def crbt1900_crt_rollover_inst_postusing_post(
        request_body:Dict[str, Any] ,  # ROLLOVER_INSTRUCTION_CRBT1900CrtRolloverInst_Resource,
        accesstoken: Optional[str] = None,
        channeltype: Optional[int] = None,
        co_relationid: Optional[int] = None,
        initiatingsystem: Optional[str] = None,
        servicemode: Optional[int] = None,
        uuidseqno: Optional[int] = None,
        entity: Optional[str] = None,
        languagecode: Optional[int] = None,
        referenceid: Optional[str] = None,
        requesthash: Optional[str] = None,
        userid: Optional[int] = None
    ) -> Dict[str, Any]:
        """
        Creation of loan topup
        
        Generated from: POST /loans/topup/create
        Source: swagger_2_0
        Operation ID: CRBT1900CrtRolloverInst_POSTUsingPOST
        
        
        Authentication: Not required
        
        Parameters:
        - request_body: any (required)
          input
        
        
        
        Headers:
        - Accesstoken: string
          Authorization token for identification of the caller
        - ChannelType: integer
          Channel identifier from where the TXN has originated (Internet, Mobile, ATM, Branch Channel )
        - Co-Relationid: integer
          Unique ID for the service invoked, will be set by the TXN system
        - InitiatingSystem: string
          Indicating the initiated system
        - ServiceMode: integer
          Used for branch channel to indicate the type of customer
        - UUIDSeqNo: integer
          UUID Sequence Number
        - entity: string
          entity
        - languageCode: integer
          languageCode
        - referenceId: string
          Place holder for Token based authentication
        - requesthash: string
          Request payload for hash validation
        - userId: integer
          userId
        
        
        """
        
        
        # Prepare request data
        
        # Single body parameter - send directly
        data = request_body if request_body is not None else {}
        
        
        
        # Prepare query parameters
        params = {}
        
        
        # Replace path parameters in URL
        path = "/loans/topup/create"
        
        
        # Prepare headers
        headers = {}
        if accesstoken is not None:
            headers["Accesstoken"] = str(accesstoken)
        if channeltype is not None:
            headers["ChannelType"] = str(channeltype)
        if co_relationid is not None:
            headers["Co-Relationid"] = str(co_relationid)
        if initiatingsystem is not None:
            headers["InitiatingSystem"] = str(initiatingsystem)
        if servicemode is not None:
            headers["ServiceMode"] = str(servicemode)
        if uuidseqno is not None:
            headers["UUIDSeqNo"] = str(uuidseqno)
        if entity is not None:
            headers["entity"] = str(entity)
        if languagecode is not None:
            headers["languageCode"] = str(languagecode)
        if referenceid is not None:
            headers["referenceId"] = str(referenceid)
        if requesthash is not None:
            headers["requesthash"] = str(requesthash)
        if userid is not None:
            headers["userId"] = str(userid)
        
        
        return await make_api_request(
            "POST", 
            path, 
            data=data, 
            params=params if params else None, 
            headers=headers if headers else None
        )
    
    
    
    @mcp.tool()
    async def crbt0319_rej_rpymnt_reqst_postusing_post(
        request_body:Dict[str, Any] ,  # loanAuthRejectRequest,
        accesstoken: Optional[str] = None,
        channeltype: Optional[int] = None,
        co_relationid: Optional[int] = None,
        initiatingsystem: Optional[str] = None,
        servicemode: Optional[int] = None,
        uuidseqno: Optional[int] = None,
        entity: Optional[str] = None,
        languagecode: Optional[int] = None,
        referenceid: Optional[str] = None,
        requesthash: Optional[str] = None,
        userid: Optional[int] = None
    ) -> Dict[str, Any]:
        """
        To Reject Loan Repayment
        
        Generated from: POST /loans/transactions/auth/loan rejection
        Source: swagger_2_0
        Operation ID: CRBT0319RejRpymntReqst_POSTUsingPOST
        
        
        Authentication: Not required
        
        Parameters:
        - request_body: any (required)
          input
        
        
        
        Headers:
        - Accesstoken: string
          Authorization token for identification of the caller
        - ChannelType: integer
          Channel identifier from where the TXN has originated (Internet, Mobile, ATM, Branch Channel )
        - Co-Relationid: integer
          Unique ID for the service invoked, will be set by the TXN system
        - InitiatingSystem: string
          Indicating the initiated system
        - ServiceMode: integer
          Used for branch channel to indicate the type of customer
        - UUIDSeqNo: integer
          UUID Sequence Number
        - entity: string
          entity
        - languageCode: integer
          languageCode
        - referenceId: string
          Place holder for Token based authentication
        - requesthash: string
          Request payload for hash validation
        - userId: integer
          userId
        
        
        """
        
        
        # Prepare request data
        
        # Single body parameter - send directly
        data = request_body if request_body is not None else {}
        
        
        
        # Prepare query parameters
        params = {}
        
        
        # Replace path parameters in URL
        path = "/loans/transactions/auth/loan rejection"
        
        
        # Prepare headers
        headers = {}
        if accesstoken is not None:
            headers["Accesstoken"] = str(accesstoken)
        if channeltype is not None:
            headers["ChannelType"] = str(channeltype)
        if co_relationid is not None:
            headers["Co-Relationid"] = str(co_relationid)
        if initiatingsystem is not None:
            headers["InitiatingSystem"] = str(initiatingsystem)
        if servicemode is not None:
            headers["ServiceMode"] = str(servicemode)
        if uuidseqno is not None:
            headers["UUIDSeqNo"] = str(uuidseqno)
        if entity is not None:
            headers["entity"] = str(entity)
        if languagecode is not None:
            headers["languageCode"] = str(languagecode)
        if referenceid is not None:
            headers["referenceId"] = str(referenceid)
        if requesthash is not None:
            headers["requesthash"] = str(requesthash)
        if userid is not None:
            headers["userId"] = str(userid)
        
        
        return await make_api_request(
            "POST", 
            path, 
            data=data, 
            params=params if params else None, 
            headers=headers if headers else None
        )
    
    
    
    @mcp.tool()
    async def crbt1811_create_loan_closure_write_off_postusing_post(
        request_body:Dict[str, Any] ,  # earlySettlementByTransferResource,
        accesstoken: Optional[str] = None,
        channeltype: Optional[int] = None,
        co_relationid: Optional[int] = None,
        initiatingsystem: Optional[str] = None,
        servicemode: Optional[int] = None,
        uuidseqno: Optional[int] = None,
        entity: Optional[str] = None,
        languagecode: Optional[int] = None,
        referenceid: Optional[str] = None,
        requesthash: Optional[str] = None,
        userid: Optional[int] = None
    ) -> Dict[str, Any]:
        """
        Pre-close Active Loan
        
        Generated from: POST /loans/transactions/loanEarlySettlementByTransfer
        Source: swagger_2_0
        Operation ID: CRBT1811CreateLoanClosureWriteOff_POSTUsingPOST
        
        
        Authentication: Not required
        
        Parameters:
        - request_body: any (required)
          input
        
        
        
        Headers:
        - Accesstoken: string
          Authorization Token to validation the caller
        - ChannelType: integer
          Channel identifier from where the TXN has originated (Internet, Mobile, ATM, Branch Channel )
        - Co-Relationid: integer
          Unique ID for the service invoked, will be set by the TXN system
        - InitiatingSystem: string
          Indicating the initiated system
        - ServiceMode: integer
          Used for branch channel to indicate the type of customer
        - UUIDSeqNo: integer
          UUID Sequence Number
        - entity: string
          entity
        - languageCode: integer
          languageCode
        - referenceId: string
          Place holder for Token based authentication
        - requesthash: string
          Request payload for hash validation
        - userId: integer
          userId
        
        
        """
        
        
        # Prepare request data
        
        # Single body parameter - send directly
        data = request_body if request_body is not None else {}
        
        
        
        # Prepare query parameters
        params = {}
        
        
        # Replace path parameters in URL
        path = "/loans/transactions/loanEarlySettlementByTransfer"
        
        
        # Prepare headers
        headers = {}
        if accesstoken is not None:
            headers["Accesstoken"] = str(accesstoken)
        if channeltype is not None:
            headers["ChannelType"] = str(channeltype)
        if co_relationid is not None:
            headers["Co-Relationid"] = str(co_relationid)
        if initiatingsystem is not None:
            headers["InitiatingSystem"] = str(initiatingsystem)
        if servicemode is not None:
            headers["ServiceMode"] = str(servicemode)
        if uuidseqno is not None:
            headers["UUIDSeqNo"] = str(uuidseqno)
        if entity is not None:
            headers["entity"] = str(entity)
        if languagecode is not None:
            headers["languageCode"] = str(languagecode)
        if referenceid is not None:
            headers["referenceId"] = str(referenceid)
        if requesthash is not None:
            headers["requesthash"] = str(requesthash)
        if userid is not None:
            headers["userId"] = str(userid)
        
        
        return await make_api_request(
            "POST", 
            path, 
            data=data, 
            params=params if params else None, 
            headers=headers if headers else None
        )
    
    
    
    @mcp.tool()
    async def crbtcreate_loan_event_reg_postusing_post(
        request_body:Dict[str, Any] ,  # prePaymentRequest,
        accesstoken: Optional[str] = None,
        channeltype: Optional[int] = None,
        co_relationid: Optional[int] = None,
        initiatingsystem: Optional[str] = None,
        servicemode: Optional[int] = None,
        uuidseqno: Optional[int] = None,
        entity: Optional[str] = None,
        languagecode: Optional[int] = None,
        referenceid: Optional[str] = None,
        requesthash: Optional[str] = None,
        userid: Optional[int] = None
    ) -> Dict[str, Any]:
        """
        LoanPrePaymentByTransfer
        
        Generated from: POST /loans/transactions/loanPrePaymentByTransfer
        Source: swagger_2_0
        Operation ID: CRBTCreateLoanEventReg_POSTUsingPOST
        
        
        Authentication: Not required
        
        Parameters:
        - request_body: any (required)
          input
        
        
        
        Headers:
        - Accesstoken: string
          Authorization token for identification of the caller
        - ChannelType: integer
          Channel identifier from where the TXN has originated (Internet, Mobile, ATM, Branch Channel )
        - Co-Relationid: integer
          Unique ID for the service invoked, will be set by the TXN system
        - InitiatingSystem: string
          Indicating the initiated system
        - ServiceMode: integer
          Used for branch channel to indicate the type of customer
        - UUIDSeqNo: integer
          UUID Sequence Number
        - entity: string
          entity
        - languageCode: integer
          languageCode
        - referenceId: string
          Place holder for Token based authentication
        - requesthash: string
          Request payload for hash validation
        - userId: integer
          userId
        
        
        """
        
        
        # Prepare request data
        
        # Single body parameter - send directly
        data = request_body if request_body is not None else {}
        
        
        
        # Prepare query parameters
        params = {}
        
        
        # Replace path parameters in URL
        path = "/loans/transactions/loanPrePaymentByTransfer"
        
        
        # Prepare headers
        headers = {}
        if accesstoken is not None:
            headers["Accesstoken"] = str(accesstoken)
        if channeltype is not None:
            headers["ChannelType"] = str(channeltype)
        if co_relationid is not None:
            headers["Co-Relationid"] = str(co_relationid)
        if initiatingsystem is not None:
            headers["InitiatingSystem"] = str(initiatingsystem)
        if servicemode is not None:
            headers["ServiceMode"] = str(servicemode)
        if uuidseqno is not None:
            headers["UUIDSeqNo"] = str(uuidseqno)
        if entity is not None:
            headers["entity"] = str(entity)
        if languagecode is not None:
            headers["languageCode"] = str(languagecode)
        if referenceid is not None:
            headers["referenceId"] = str(referenceid)
        if requesthash is not None:
            headers["requesthash"] = str(requesthash)
        if userid is not None:
            headers["userId"] = str(userid)
        
        
        return await make_api_request(
            "POST", 
            path, 
            data=data, 
            params=params if params else None, 
            headers=headers if headers else None
        )
    
    
    
    @mcp.tool()
    async def crbt0315_init_rpymnt_postusing_post(
        request_body:Dict[str, Any] ,  # loanRepaymentRequest,
        accesstoken: Optional[str] = None,
        channeltype: Optional[int] = None,
        co_relationid: Optional[int] = None,
        initiatingsystem: Optional[str] = None,
        servicemode: Optional[int] = None,
        uuidseqno: Optional[int] = None,
        entity: Optional[str] = None,
        languagecode: Optional[int] = None,
        referenceid: Optional[str] = None,
        requesthash: Optional[str] = None,
        userid: Optional[int] = None
    ) -> Dict[str, Any]:
        """
        Repay the loan with the amount sent
        
        Generated from: POST /loans/transactions/loanRepayByTransfer
        Source: swagger_2_0
        Operation ID: CRBT0315InitRpymnt_POSTUsingPOST
        
        
        Authentication: Not required
        
        Parameters:
        - request_body: any (required)
          input
        
        
        
        Headers:
        - Accesstoken: string
          Authorization token for identification of the caller
        - ChannelType: integer
          Channel identifier from where the TXN has originated (Internet, Mobile, ATM, Branch Channel )
        - Co-Relationid: integer
          Unique ID for the service invoked, will be set by the TXN system
        - InitiatingSystem: string
          Indicating the initiated system
        - ServiceMode: integer
          Used for branch channel to indicate the type of customer
        - UUIDSeqNo: integer
          UUID Sequence Number
        - entity: string
          entity
        - languageCode: integer
          languageCode
        - referenceId: string
          Place holder for Token based authentication
        - requesthash: string
          Request payload for hash validation
        - userId: integer
          userId
        
        
        """
        
        
        # Prepare request data
        
        # Single body parameter - send directly
        data = request_body if request_body is not None else {}
        
        
        
        # Prepare query parameters
        params = {}
        
        
        # Replace path parameters in URL
        path = "/loans/transactions/loanRepayByTransfer"
        
        
        # Prepare headers
        headers = {}
        if accesstoken is not None:
            headers["Accesstoken"] = str(accesstoken)
        if channeltype is not None:
            headers["ChannelType"] = str(channeltype)
        if co_relationid is not None:
            headers["Co-Relationid"] = str(co_relationid)
        if initiatingsystem is not None:
            headers["InitiatingSystem"] = str(initiatingsystem)
        if servicemode is not None:
            headers["ServiceMode"] = str(servicemode)
        if uuidseqno is not None:
            headers["UUIDSeqNo"] = str(uuidseqno)
        if entity is not None:
            headers["entity"] = str(entity)
        if languagecode is not None:
            headers["languageCode"] = str(languagecode)
        if referenceid is not None:
            headers["referenceId"] = str(referenceid)
        if requesthash is not None:
            headers["requesthash"] = str(requesthash)
        if userid is not None:
            headers["userId"] = str(userid)
        
        
        return await make_api_request(
            "POST", 
            path, 
            data=data, 
            params=params if params else None, 
            headers=headers if headers else None
        )
    
    
    
    @mcp.tool()
    async def cret5789_view_psalist_getusing_get(
        sfaacctreference: str,
        slposnum: int,
        slpostype: int,
        applicationid: Optional[str] = None,
        entity: Optional[str] = None
    ) -> Dict[str, Any]:
        """
        Fetch PSA Loan Details
        
        Generated from: GET /loans/viewPSALoan
        Source: swagger_2_0
        Operation ID: CRET5789ViewPSAList_GETUsingGET
        
        
        Authentication: Not required
        
        Parameters:
        - sfaAcctReference: string (required)
          Account Reference of syndication contract
        - slPosNum: integer (required)
          Pos Num of syndication contract
        - slPosType: integer (required)
          Pos Type of syndication contract
        
        
        
        Headers:
        - applicationId: string
          applicationId
        - entity: string
          entity
        
        
        """
        
        
        # Prepare query parameters
        params = {}
        if sfaacctreference is not None:
            params["sfaAcctReference"] = sfaacctreference
            
        if slposnum is not None:
            params["slPosNum"] = slposnum
            
        if slpostype is not None:
            params["slPosType"] = slpostype
            
        
        
        # Replace path parameters in URL
        path = "/loans/viewPSALoan"
        
        
        # Prepare headers
        headers = {}
        if applicationid is not None:
            headers["applicationId"] = str(applicationid)
        if entity is not None:
            headers["entity"] = str(entity)
        
        
        return await make_api_request(
            "GET", 
            path, 
            
            params=params if params else None, 
            headers=headers if headers else None
        )
    
    
    
    @mcp.tool()
    async def cret6827_fetch_loan_writeoff_dtls_using_get_1(
        balancetype: int,
        businessdate: str,
        loanreference: str,
        accesstoken: Optional[str] = None,
        channeltype: Optional[int] = None,
        co_relationid: Optional[int] = None,
        initiatingsystem: Optional[str] = None,
        servicemode: Optional[int] = None,
        uuidseqno: Optional[int] = None,
        entity: Optional[str] = None,
        languagecode: Optional[int] = None,
        referenceid: Optional[str] = None,
        userid: Optional[int] = None
    ) -> Dict[str, Any]:
        """
        Fetch LOC Balance
        
        Generated from: GET /loc/enquiry/loanDischargeEnquiry
        Source: swagger_2_0
        Operation ID: CRET6827FetchLoanWriteoffDtlsUsingGET_1
        
        
        Authentication: Not required
        
        Parameters:
        - balanceType: integer (required)
          Indicates the balance component:1 - Interest,2 - Fees,4 - Penal,5 - Principal,6 - ODPrincipal,7 - ODInterest,8 - ODPenalInterest,9 - ODFees,31 - InsuranceBal.More balance type refer d_CmpntTyp
        - businessDate: string (required)
          Date on which Balance of the loan account is derived(Date format : YYYYMMDD).
        - loanReference: string (required)
          Reference Number generated for account based on configured scheme
        
        
        
        Headers:
        - Accesstoken: string
          Authorization token for identification of the caller
        - ChannelType: integer
          Channel identifier from where the TXN has originated (Internet, Mobile, ATM, Branch Channel )
        - Co-Relationid: integer
          Unique ID for the service invoked, will be set by the TXN system
        - InitiatingSystem: string
          Indicating the initiated system
        - ServiceMode: integer
          Used for branch channel to indicate the type of customer
        - UUIDSeqNo: integer
          UUID Sequence Number
        - entity: string
          entity
        - languageCode: integer
          languageCode
        - referenceId: string
          Place holder for Token based authentication
        - userId: integer
          userId
        
        
        """
        
        
        # Prepare query parameters
        params = {}
        if balancetype is not None:
            params["balanceType"] = balancetype
            
        if businessdate is not None:
            params["businessDate"] = businessdate
            
        if loanreference is not None:
            params["loanReference"] = loanreference
            
        
        
        # Replace path parameters in URL
        path = "/loc/enquiry/loanDischargeEnquiry"
        
        
        # Prepare headers
        headers = {}
        if accesstoken is not None:
            headers["Accesstoken"] = str(accesstoken)
        if channeltype is not None:
            headers["ChannelType"] = str(channeltype)
        if co_relationid is not None:
            headers["Co-Relationid"] = str(co_relationid)
        if initiatingsystem is not None:
            headers["InitiatingSystem"] = str(initiatingsystem)
        if servicemode is not None:
            headers["ServiceMode"] = str(servicemode)
        if uuidseqno is not None:
            headers["UUIDSeqNo"] = str(uuidseqno)
        if entity is not None:
            headers["entity"] = str(entity)
        if languagecode is not None:
            headers["languageCode"] = str(languagecode)
        if referenceid is not None:
            headers["referenceId"] = str(referenceid)
        if userid is not None:
            headers["userId"] = str(userid)
        
        
        return await make_api_request(
            "GET", 
            path, 
            
            params=params if params else None, 
            headers=headers if headers else None
        )
    
    
    
    @mcp.tool()
    async def crbtcrt_frzng_txn_wrapper_postusing_post(
        request_body:Dict[str, Any] ,  # crFrznTxnCrbtCrtFrzngTxnWrapperResource,
        accesstoken: Optional[str] = None,
        channeltype: Optional[int] = None,
        co_relationid: Optional[int] = None,
        initiatingsystem: Optional[str] = None,
        servicemode: Optional[int] = None,
        uuidseqno: Optional[int] = None,
        entity: Optional[str] = None,
        languagecode: Optional[int] = None,
        referenceid: Optional[str] = None,
        requesthash: Optional[str] = None,
        userid: Optional[int] = None
    ) -> Dict[str, Any]:
        """
        This API is used to apply freeze on LOC account
        
        Generated from: POST /loc/freezeloc
        Source: swagger_2_0
        Operation ID: CRBTCrtFrzngTxnWrapper_POSTUsingPOST
        
        
        Authentication: Not required
        
        Parameters:
        - request_body: any (required)
          input
        
        
        
        Headers:
        - Accesstoken: string
          Authorization token for identification of the caller
        - ChannelType: integer
          Channel identifier from where the TXN has originated (Internet, Mobile, ATM, Branch Channel )
        - Co-Relationid: integer
          Unique ID for the service invoked, will be set by the TXN system
        - InitiatingSystem: string
          Indicating the initiated system
        - ServiceMode: integer
          Used for branch channel to indicate the type of customer
        - UUIDSeqNo: integer
          UUID Sequence Number
        - entity: string
          entity
        - languageCode: integer
          languageCode
        - referenceId: string
          Place holder for Token based authentication
        - requesthash: string
          Request payload for hash validation
        - userId: integer
          userId
        
        
        """
        
        
        # Prepare request data
        
        # Single body parameter - send directly
        data = request_body if request_body is not None else {}
        
        
        
        # Prepare query parameters
        params = {}
        
        
        # Replace path parameters in URL
        path = "/loc/freezeloc"
        
        
        # Prepare headers
        headers = {}
        if accesstoken is not None:
            headers["Accesstoken"] = str(accesstoken)
        if channeltype is not None:
            headers["ChannelType"] = str(channeltype)
        if co_relationid is not None:
            headers["Co-Relationid"] = str(co_relationid)
        if initiatingsystem is not None:
            headers["InitiatingSystem"] = str(initiatingsystem)
        if servicemode is not None:
            headers["ServiceMode"] = str(servicemode)
        if uuidseqno is not None:
            headers["UUIDSeqNo"] = str(uuidseqno)
        if entity is not None:
            headers["entity"] = str(entity)
        if languagecode is not None:
            headers["languageCode"] = str(languagecode)
        if referenceid is not None:
            headers["referenceId"] = str(referenceid)
        if requesthash is not None:
            headers["requesthash"] = str(requesthash)
        if userid is not None:
            headers["userId"] = str(userid)
        
        
        return await make_api_request(
            "POST", 
            path, 
            data=data, 
            params=params if params else None, 
            headers=headers if headers else None
        )
    
    
    
    @mcp.tool()
    async def cret2913_view_line_of_credit_basic_details_postusing_get(
        locreference: str,
        pagenum: Optional[int] = None,
        pagesize: Optional[int] = None,
        accesstoken: Optional[str] = None,
        channeltype: Optional[int] = None,
        co_relationid: Optional[int] = None,
        initiatingsystem: Optional[str] = None,
        servicemode: Optional[int] = None,
        uuidseqno: Optional[int] = None,
        entity: Optional[str] = None,
        languagecode: Optional[int] = None,
        referenceid: Optional[str] = None,
        requesthash: Optional[str] = None,
        userid: Optional[int] = None
    ) -> Dict[str, Any]:
        """
        View Line of Credit Basic Details
        
        Generated from: GET /loc/lineOfCreditDetails/{LOCReference}
        Source: swagger_2_0
        Operation ID: CRET2913ViewLineOfCreditBasicDetails_POSTUsingGET
        
        
        Authentication: Not required
        
        Parameters:
        - LOCReference: string (required)
          LOC Reference
        - pageNum: integer
          pageNum
        - pageSize: integer
          pageSize
        
        
        
        Headers:
        - Accesstoken: string
          Authorization Token to validation the caller
        - ChannelType: integer
          Channel identifier from where the TXN has originated (Internet, Mobile, ATM, Branch Channel )
        - Co-Relationid: integer
          Unique ID for the service invoked, will be set by the TXN system
        - InitiatingSystem: string
          Indicating the initiated system
        - ServiceMode: integer
          Used for branch channel to indicate the type of customer
        - UUIDSeqNo: integer
          UUID Sequence Number
        - entity: string
          entity
        - languageCode: integer
          languageCode
        - referenceId: string
          Place holder for Token based authentication
        - requesthash: string
          Request payload for hash validation
        - userId: integer
          userId
        
        
        """
        
        
        # Prepare query parameters
        params = {}
        if pagenum is not None:
            params["pageNum"] = pagenum
            
        if pagesize is not None:
            params["pageSize"] = pagesize
            
        
        
        # Replace path parameters in URL
        path = "/loc/lineOfCreditDetails/{LOCReference}"
        if locreference is not None:
            path = path.replace("{LOCReference}", str(locreference))
        
        
        # Prepare headers
        headers = {}
        if accesstoken is not None:
            headers["Accesstoken"] = str(accesstoken)
        if channeltype is not None:
            headers["ChannelType"] = str(channeltype)
        if co_relationid is not None:
            headers["Co-Relationid"] = str(co_relationid)
        if initiatingsystem is not None:
            headers["InitiatingSystem"] = str(initiatingsystem)
        if servicemode is not None:
            headers["ServiceMode"] = str(servicemode)
        if uuidseqno is not None:
            headers["UUIDSeqNo"] = str(uuidseqno)
        if entity is not None:
            headers["entity"] = str(entity)
        if languagecode is not None:
            headers["languageCode"] = str(languagecode)
        if referenceid is not None:
            headers["referenceId"] = str(referenceid)
        if requesthash is not None:
            headers["requesthash"] = str(requesthash)
        if userid is not None:
            headers["userId"] = str(userid)
        
        
        return await make_api_request(
            "GET", 
            path, 
            
            params=params if params else None, 
            headers=headers if headers else None
        )
    
    
    
    @mcp.tool()
    async def cret2913_fetch_line_of_credit_list_getusing_get(
        customerreference: int,
        businessstatus: Optional[int] = None,
        pagenum: Optional[int] = None,
        pagesize: Optional[int] = None,
        accesstoken: Optional[str] = None,
        channeltype: Optional[int] = None,
        co_relationid: Optional[int] = None,
        initiatingsystem: Optional[str] = None,
        servicemode: Optional[int] = None,
        uuidseqno: Optional[int] = None,
        entity: Optional[str] = None,
        languagecode: Optional[int] = None,
        referenceid: Optional[str] = None,
        userid: Optional[int] = None
    ) -> Dict[str, Any]:
        """
        Fetch LOC Account List
        
        Generated from: GET /loc/lineOfCreditList/{customerReference}
        Source: swagger_2_0
        Operation ID: CRET2913FetchLineOfCreditList_GETUsingGET
        
        
        Authentication: Not required
        
        Parameters:
        - businessStatus: integer
          Business Status 24-Active,20-InProgress,21-Grant,37-PendingWithdrwl,38-PendingAuth,36-Frozen,39-DebitFrozen,27-Closed (Domain Name:d_LoanStatus)
        - customerReference: integer (required)
          Customer Reference
        - pageNum: integer
          pageNum
        - pageSize: integer
          pageSize
        
        
        
        Headers:
        - Accesstoken: string
          Authorization token for identification of the caller
        - ChannelType: integer
          Channel identifier from where the TXN has originated (Internet, Mobile, ATM, Branch Channel )
        - Co-Relationid: integer
          Unique ID for the service invoked, will be set by the TXN system
        - InitiatingSystem: string
          Indicating the initiated system
        - ServiceMode: integer
          Used for branch channel to indicate the type of customer
        - UUIDSeqNo: integer
          UUID Sequence Number
        - entity: string
          entity
        - languageCode: integer
          languageCode
        - referenceId: string
          Place holder for Token based authentication
        - userId: integer
          userId
        
        
        """
        
        
        # Prepare query parameters
        params = {}
        if businessstatus is not None:
            params["businessStatus"] = businessstatus
            
        if pagenum is not None:
            params["pageNum"] = pagenum
            
        if pagesize is not None:
            params["pageSize"] = pagesize
            
        
        
        # Replace path parameters in URL
        path = "/loc/lineOfCreditList/{customerReference}"
        if customerreference is not None:
            path = path.replace("{customerReference}", str(customerreference))
        
        
        # Prepare headers
        headers = {}
        if accesstoken is not None:
            headers["Accesstoken"] = str(accesstoken)
        if channeltype is not None:
            headers["ChannelType"] = str(channeltype)
        if co_relationid is not None:
            headers["Co-Relationid"] = str(co_relationid)
        if initiatingsystem is not None:
            headers["InitiatingSystem"] = str(initiatingsystem)
        if servicemode is not None:
            headers["ServiceMode"] = str(servicemode)
        if uuidseqno is not None:
            headers["UUIDSeqNo"] = str(uuidseqno)
        if entity is not None:
            headers["entity"] = str(entity)
        if languagecode is not None:
            headers["languageCode"] = str(languagecode)
        if referenceid is not None:
            headers["referenceId"] = str(referenceid)
        if userid is not None:
            headers["userId"] = str(userid)
        
        
        return await make_api_request(
            "GET", 
            path, 
            
            params=params if params else None, 
            headers=headers if headers else None
        )
    
    
    
    @mcp.tool()
    async def crbt2913_creation_line_of_credit_using_post(
        request_body:Dict[str, Any] ,  # createLOCResource,
        accesstoken: Optional[str] = None,
        channeltype: Optional[int] = None,
        co_relationid: Optional[int] = None,
        initiatingsystem: Optional[str] = None,
        servicemode: Optional[int] = None,
        uuidseqno: Optional[int] = None,
        entity: Optional[str] = None,
        languagecode: Optional[int] = None,
        referenceid: Optional[str] = None,
        requesthash: Optional[str] = None,
        userid: Optional[int] = None
    ) -> Dict[str, Any]:
        """
        LOC Creation
        
        Generated from: POST /loc/loc/onHold
        Source: swagger_2_0
        Operation ID: CRBT2913CreationLineOfCreditUsingPOST
        
        
        Authentication: Not required
        
        Parameters:
        - request_body: any (required)
          input
        
        
        
        Headers:
        - Accesstoken: string
          Authorization token for identification of the caller
        - ChannelType: integer
          Channel identifier from where the TXN has originated (Internet, Mobile, ATM, Branch Channel )
        - Co-Relationid: integer
          Unique ID for the service invoked, will be set by the TXN system
        - InitiatingSystem: string
          Indicating the initiated system
        - ServiceMode: integer
          Used for branch channel to indicate the type of customer
        - UUIDSeqNo: integer
          UUID Sequence Number
        - entity: string
          entity
        - languageCode: integer
          languageCode
        - referenceId: string
          Place holder for Token based authentication
        - requesthash: string
          Request payload for hash validation
        - userId: integer
          userId
        
        
        """
        
        
        # Prepare request data
        
        # Single body parameter - send directly
        data = request_body if request_body is not None else {}
        
        
        
        # Prepare query parameters
        params = {}
        
        
        # Replace path parameters in URL
        path = "/loc/loc/onHold"
        
        
        # Prepare headers
        headers = {}
        if accesstoken is not None:
            headers["Accesstoken"] = str(accesstoken)
        if channeltype is not None:
            headers["ChannelType"] = str(channeltype)
        if co_relationid is not None:
            headers["Co-Relationid"] = str(co_relationid)
        if initiatingsystem is not None:
            headers["InitiatingSystem"] = str(initiatingsystem)
        if servicemode is not None:
            headers["ServiceMode"] = str(servicemode)
        if uuidseqno is not None:
            headers["UUIDSeqNo"] = str(uuidseqno)
        if entity is not None:
            headers["entity"] = str(entity)
        if languagecode is not None:
            headers["languageCode"] = str(languagecode)
        if referenceid is not None:
            headers["referenceId"] = str(referenceid)
        if requesthash is not None:
            headers["requesthash"] = str(requesthash)
        if userid is not None:
            headers["userId"] = str(userid)
        
        
        return await make_api_request(
            "POST", 
            path, 
            data=data, 
            params=params if params else None, 
            headers=headers if headers else None
        )
    
    
    
    @mcp.tool()
    async def crbtcrt_rollover_inst_wrapper_postusing_post(
        request_body:Dict[str, Any] ,  # rolloverInstructionWrapperResource,
        accesstoken: Optional[str] = None,
        channeltype: Optional[int] = None,
        co_relationid: Optional[int] = None,
        initiatingsystem: Optional[str] = None,
        servicemode: Optional[int] = None,
        uuidseqno: Optional[int] = None,
        entity: Optional[str] = None,
        languagecode: Optional[int] = None,
        referenceid: Optional[str] = None,
        requesthash: Optional[str] = None,
        userid: Optional[int] = None
    ) -> Dict[str, Any]:
        """
        Create Rollover of LOC
        
        Generated from: POST /loc/rollOver
        Source: swagger_2_0
        Operation ID: CRBTCrtRolloverInstWrapper_POSTUsingPOST
        
        
        Authentication: Not required
        
        Parameters:
        - request_body: any (required)
          input
        
        
        
        Headers:
        - Accesstoken: string
          Authorization token for identification of the caller
        - ChannelType: integer
          Channel identifier from where the TXN has originated (Internet, Mobile, ATM, Branch Channel )
        - Co-Relationid: integer
          Unique ID for the service invoked, will be set by the TXN system
        - InitiatingSystem: string
          Indicating the initiated system
        - ServiceMode: integer
          Used for branch channel to indicate the type of customer
        - UUIDSeqNo: integer
          UUID Sequence Number
        - entity: string
          entity
        - languageCode: integer
          languageCode
        - referenceId: string
          Place holder for Token based authentication
        - requesthash: string
          Request payload for hash validation
        - userId: integer
          userId
        
        
        """
        
        
        # Prepare request data
        
        # Single body parameter - send directly
        data = request_body if request_body is not None else {}
        
        
        
        # Prepare query parameters
        params = {}
        
        
        # Replace path parameters in URL
        path = "/loc/rollOver"
        
        
        # Prepare headers
        headers = {}
        if accesstoken is not None:
            headers["Accesstoken"] = str(accesstoken)
        if channeltype is not None:
            headers["ChannelType"] = str(channeltype)
        if co_relationid is not None:
            headers["Co-Relationid"] = str(co_relationid)
        if initiatingsystem is not None:
            headers["InitiatingSystem"] = str(initiatingsystem)
        if servicemode is not None:
            headers["ServiceMode"] = str(servicemode)
        if uuidseqno is not None:
            headers["UUIDSeqNo"] = str(uuidseqno)
        if entity is not None:
            headers["entity"] = str(entity)
        if languagecode is not None:
            headers["languageCode"] = str(languagecode)
        if referenceid is not None:
            headers["referenceId"] = str(referenceid)
        if requesthash is not None:
            headers["requesthash"] = str(requesthash)
        if userid is not None:
            headers["userId"] = str(userid)
        
        
        return await make_api_request(
            "POST", 
            path, 
            data=data, 
            params=params if params else None, 
            headers=headers if headers else None
        )
    
    
    
    @mcp.tool()
    async def mibt1201_crt_ibrtusing_post(
        request_body:Dict[str, Any] ,  # Exchange_Rate_CreateExchangeRate_Resource,
        accesstoken: Optional[str] = None,
        channeltype: Optional[int] = None,
        co_relationid: Optional[int] = None,
        initiatingsystem: Optional[str] = None,
        servicemode: Optional[int] = None,
        uuidseqno: Optional[int] = None,
        entity: Optional[str] = None,
        languagecode: Optional[int] = None,
        referenceid: Optional[str] = None,
        requesthash: Optional[str] = None,
        userid: Optional[int] = None
    ) -> Dict[str, Any]:
        """
        Create Inter Bank Exchange Rate
        
        Generated from: POST /marketInformation/CreateInterBankExchangeRate
        Source: swagger_2_0
        Operation ID: MIBT1201CrtIBRTUsingPOST
        
        
        Authentication: Not required
        
        Parameters:
        - request_body: any (required)
          input
        
        
        
        Headers:
        - Accesstoken: string
          Authorization token for identification of the caller
        - ChannelType: integer
          Channel identifier from where the TXN has originated (Internet, Mobile, ATM, Branch Channel )
        - Co-Relationid: integer
          Unique ID for the service invoked, will be set by the TXN system
        - InitiatingSystem: string
          Indicating the initiated system
        - ServiceMode: integer
          Used for branch channel to indicate the type of customer
        - UUIDSeqNo: integer
          UUID Sequence Number
        - entity: string
          entity
        - languageCode: integer
          languageCode
        - referenceId: string
          Place holder for Token based authentication
        - requesthash: string
          Request payload for hash validation
        - userId: integer
          userId
        
        
        """
        
        
        # Prepare request data
        
        # Single body parameter - send directly
        data = request_body if request_body is not None else {}
        
        
        
        # Prepare query parameters
        params = {}
        
        
        # Replace path parameters in URL
        path = "/marketInformation/CreateInterBankExchangeRate"
        
        
        # Prepare headers
        headers = {}
        if accesstoken is not None:
            headers["Accesstoken"] = str(accesstoken)
        if channeltype is not None:
            headers["ChannelType"] = str(channeltype)
        if co_relationid is not None:
            headers["Co-Relationid"] = str(co_relationid)
        if initiatingsystem is not None:
            headers["InitiatingSystem"] = str(initiatingsystem)
        if servicemode is not None:
            headers["ServiceMode"] = str(servicemode)
        if uuidseqno is not None:
            headers["UUIDSeqNo"] = str(uuidseqno)
        if entity is not None:
            headers["entity"] = str(entity)
        if languagecode is not None:
            headers["languageCode"] = str(languagecode)
        if referenceid is not None:
            headers["referenceId"] = str(referenceid)
        if requesthash is not None:
            headers["requesthash"] = str(requesthash)
        if userid is not None:
            headers["userId"] = str(userid)
        
        
        return await make_api_request(
            "POST", 
            path, 
            data=data, 
            params=params if params else None, 
            headers=headers if headers else None
        )
    
    
    
    @mcp.tool()
    async def mibt1101_crt_inrt_postusing_post(
        request_body:Dict[str, Any] ,  # Interest_Rate_CreateInterestRate_Resource,
        entity: Optional[str] = None
    ) -> Dict[str, Any]:
        """
        Create Interest Rate
        
        Generated from: POST /marketInformation/CreateInterestRate
        Source: swagger_2_0
        Operation ID: MIBT1101CrtINRT_POSTUsingPOST
        
        
        Authentication: Not required
        
        Parameters:
        - request_body: any (required)
          input
        
        
        
        Headers:
        - entity: string
          entity
        
        
        """
        
        
        # Prepare request data
        
        # Single body parameter - send directly
        data = request_body if request_body is not None else {}
        
        
        
        # Prepare query parameters
        params = {}
        
        
        # Replace path parameters in URL
        path = "/marketInformation/CreateInterestRate"
        
        
        # Prepare headers
        headers = {}
        if entity is not None:
            headers["entity"] = str(entity)
        
        
        return await make_api_request(
            "POST", 
            path, 
            data=data, 
            params=params if params else None, 
            headers=headers if headers else None
        )
    
    
    
    @mcp.tool()
    async def mibt2202_del_exrl_postusing_post(
        request_body:Dict[str, Any] ,  # ExchangeMarginRuleRequest,
        accesstoken: Optional[str] = None,
        channeltype: Optional[int] = None,
        co_relationid: Optional[int] = None,
        initiatingsystem: Optional[str] = None,
        servicemode: Optional[int] = None,
        uuidseqno: Optional[int] = None,
        entity: Optional[str] = None,
        languagecode: Optional[int] = None,
        referenceid: Optional[str] = None,
        userid: Optional[int] = None
    ) -> Dict[str, Any]:
        """
        MIBT2202DelEXRL
        
        Generated from: POST /marketInformation/CustomerMargin/Delete
        Source: swagger_2_0
        Operation ID: MIBT2202DelEXRL_POSTUsingPOST
        
        
        Authentication: Not required
        
        Parameters:
        - request_body: any (required)
          input
        
        
        
        Headers:
        - Accesstoken: string
          Authorization token for identification of the caller
        - ChannelType: integer
          Channel identifier from where the TXN has originated (Internet, Mobile, ATM, Branch Channel )
        - Co-Relationid: integer
          Unique ID for the service invoked, will be set by the TXN system
        - InitiatingSystem: string
          Indicating the initiated system
        - ServiceMode: integer
          Used for branch channel to indicate the type of customer
        - UUIDSeqNo: integer
          UUID Sequence Number
        - entity: string
          entity
        - languageCode: integer
          languageCode
        - referenceId: string
          Place holder for Token based authentication
        - userId: integer
          userId
        
        
        """
        
        
        # Prepare request data
        
        # Single body parameter - send directly
        data = request_body if request_body is not None else {}
        
        
        
        # Prepare query parameters
        params = {}
        
        
        # Replace path parameters in URL
        path = "/marketInformation/CustomerMargin/Delete"
        
        
        # Prepare headers
        headers = {}
        if accesstoken is not None:
            headers["Accesstoken"] = str(accesstoken)
        if channeltype is not None:
            headers["ChannelType"] = str(channeltype)
        if co_relationid is not None:
            headers["Co-Relationid"] = str(co_relationid)
        if initiatingsystem is not None:
            headers["InitiatingSystem"] = str(initiatingsystem)
        if servicemode is not None:
            headers["ServiceMode"] = str(servicemode)
        if uuidseqno is not None:
            headers["UUIDSeqNo"] = str(uuidseqno)
        if entity is not None:
            headers["entity"] = str(entity)
        if languagecode is not None:
            headers["languageCode"] = str(languagecode)
        if referenceid is not None:
            headers["referenceId"] = str(referenceid)
        if userid is not None:
            headers["userId"] = str(userid)
        
        
        return await make_api_request(
            "POST", 
            path, 
            data=data, 
            params=params if params else None, 
            headers=headers if headers else None
        )
    
    
    
    @mcp.tool()
    async def mibt2201_set_exrl_postusing_post(
        request_body:Dict[str, Any] ,  # ExchangeMarginRuleResource,
        accesstoken: Optional[str] = None,
        channeltype: Optional[int] = None,
        co_relationid: Optional[int] = None,
        initiatingsystem: Optional[str] = None,
        servicemode: Optional[int] = None,
        uuidseqno: Optional[int] = None,
        entity: Optional[str] = None,
        languagecode: Optional[int] = None,
        referenceid: Optional[str] = None,
        userid: Optional[int] = None
    ) -> Dict[str, Any]:
        """
        MIBT2201SetEXRL
        
        Generated from: POST /marketInformation/CustomerMargin/Set
        Source: swagger_2_0
        Operation ID: MIBT2201SetEXRL_POSTUsingPOST
        
        
        Authentication: Not required
        
        Parameters:
        - request_body: any (required)
          input
        
        
        
        Headers:
        - Accesstoken: string
          Authorization token for identification of the caller
        - ChannelType: integer
          Channel identifier from where the TXN has originated (Internet, Mobile, ATM, Branch Channel )
        - Co-Relationid: integer
          Unique ID for the service invoked, will be set by the TXN system
        - InitiatingSystem: string
          Indicating the initiated system
        - ServiceMode: integer
          Used for branch channel to indicate the type of customer
        - UUIDSeqNo: integer
          UUID Sequence Number
        - entity: string
          entity
        - languageCode: integer
          languageCode
        - referenceId: string
          Place holder for Token based authentication
        - userId: integer
          userId
        
        
        """
        
        
        # Prepare request data
        
        # Single body parameter - send directly
        data = request_body if request_body is not None else {}
        
        
        
        # Prepare query parameters
        params = {}
        
        
        # Replace path parameters in URL
        path = "/marketInformation/CustomerMargin/Set"
        
        
        # Prepare headers
        headers = {}
        if accesstoken is not None:
            headers["Accesstoken"] = str(accesstoken)
        if channeltype is not None:
            headers["ChannelType"] = str(channeltype)
        if co_relationid is not None:
            headers["Co-Relationid"] = str(co_relationid)
        if initiatingsystem is not None:
            headers["InitiatingSystem"] = str(initiatingsystem)
        if servicemode is not None:
            headers["ServiceMode"] = str(servicemode)
        if uuidseqno is not None:
            headers["UUIDSeqNo"] = str(uuidseqno)
        if entity is not None:
            headers["entity"] = str(entity)
        if languagecode is not None:
            headers["languageCode"] = str(languagecode)
        if referenceid is not None:
            headers["referenceId"] = str(referenceid)
        if userid is not None:
            headers["userId"] = str(userid)
        
        
        return await make_api_request(
            "POST", 
            path, 
            data=data, 
            params=params if params else None, 
            headers=headers if headers else None
        )
    
    
    
    @mcp.tool()
    async def miet2202_view_exrl_getusing_get(
        remarks: str,
        countrycurrencyid: Optional[str] = None,
        entitycode: Optional[str] = None,
        ratepurpose: Optional[int] = None,
        referencecurrencyid: Optional[str] = None,
        ruledate: Optional[str] = None,
        pagenum: Optional[int] = None,
        pagesize: Optional[int] = None,
        accesstoken: Optional[str] = None,
        channeltype: Optional[int] = None,
        co_relationid: Optional[int] = None,
        initiatingsystem: Optional[str] = None,
        servicemode: Optional[int] = None,
        uuidseqno: Optional[int] = None,
        entity: Optional[str] = None,
        languagecode: Optional[int] = None,
        referenceid: Optional[str] = None,
        userid: Optional[int] = None
    ) -> Dict[str, Any]:
        """
        MIET2202ViewEXRL
        
        Generated from: GET /marketInformation/CustomerMargin/View
        Source: swagger_2_0
        Operation ID: MIET2202ViewEXRL_GETUsingGET
        
        
        Authentication: Not required
        
        Parameters:
        - CountryCurrencyID: string
          CNTR_CRNCY_ID
        - EntityCode: string
          ENTITY_CODE
        - RatePurpose: integer
          RATE_PRPS
        - ReferenceCurrencyID: string
          REF_CRNCY_ID
        - Remarks: string (required)
          REMARKS
        - RuleDate: string
          RULE_DT
        - pageNum: integer
          pageNum
        - pageSize: integer
          pageSize
        
        
        
        Headers:
        - Accesstoken: string
          Authorization token for identification of the caller
        - ChannelType: integer
          Channel identifier from where the TXN has originated (Internet, Mobile, ATM, Branch Channel )
        - Co-Relationid: integer
          Unique ID for the service invoked, will be set by the TXN system
        - InitiatingSystem: string
          Indicating the initiated system
        - ServiceMode: integer
          Used for branch channel to indicate the type of customer
        - UUIDSeqNo: integer
          UUID Sequence Number
        - entity: string
          entity
        - languageCode: integer
          languageCode
        - referenceId: string
          Place holder for Token based authentication
        - userId: integer
          userId
        
        
        """
        
        
        # Prepare query parameters
        params = {}
        if countrycurrencyid is not None:
            params["CountryCurrencyID"] = countrycurrencyid
            
        if entitycode is not None:
            params["EntityCode"] = entitycode
            
        if ratepurpose is not None:
            params["RatePurpose"] = ratepurpose
            
        if referencecurrencyid is not None:
            params["ReferenceCurrencyID"] = referencecurrencyid
            
        if remarks is not None:
            params["Remarks"] = remarks
            
        if ruledate is not None:
            params["RuleDate"] = ruledate
            
        if pagenum is not None:
            params["pageNum"] = pagenum
            
        if pagesize is not None:
            params["pageSize"] = pagesize
            
        
        
        # Replace path parameters in URL
        path = "/marketInformation/CustomerMargin/View"
        
        
        # Prepare headers
        headers = {}
        if accesstoken is not None:
            headers["Accesstoken"] = str(accesstoken)
        if channeltype is not None:
            headers["ChannelType"] = str(channeltype)
        if co_relationid is not None:
            headers["Co-Relationid"] = str(co_relationid)
        if initiatingsystem is not None:
            headers["InitiatingSystem"] = str(initiatingsystem)
        if servicemode is not None:
            headers["ServiceMode"] = str(servicemode)
        if uuidseqno is not None:
            headers["UUIDSeqNo"] = str(uuidseqno)
        if entity is not None:
            headers["entity"] = str(entity)
        if languagecode is not None:
            headers["languageCode"] = str(languagecode)
        if referenceid is not None:
            headers["referenceId"] = str(referenceid)
        if userid is not None:
            headers["userId"] = str(userid)
        
        
        return await make_api_request(
            "GET", 
            path, 
            
            params=params if params else None, 
            headers=headers if headers else None
        )
    
    
    
    @mcp.tool()
    async def cbcbtupd_rate_avln_cncl_postusing_post(
        request_body:Dict[str, Any] ,  # CBC_MO_DUMMY_STP_CBCBTUpdRateAvlnCncl_Resource,
        accesstoken: Optional[str] = None,
        channeltype: Optional[int] = None,
        co_relationid: Optional[int] = None,
        initiatingsystem: Optional[str] = None,
        servicemode: Optional[int] = None,
        uuidseqno: Optional[int] = None,
        entity: Optional[str] = None,
        languagecode: Optional[int] = None,
        referenceid: Optional[str] = None,
        userid: Optional[int] = None
    ) -> Dict[str, Any]:
        """
        CBCBTUpdRateAvlnCncl
        
        Generated from: POST /marketInformation/cbcbtupdrateavlncncl
        Source: swagger_2_0
        Operation ID: CBCBTUpdRateAvlnCncl_POSTUsingPOST
        
        
        Authentication: Not required
        
        Parameters:
        - request_body: any (required)
          input
        
        
        
        Headers:
        - Accesstoken: string
          Authorization Token to validation the caller
        - ChannelType: integer
          Channel identifier from where the TXN has originated (Internet, Mobile, ATM, Branch Channel )
        - Co-Relationid: integer
          Unique ID for the service invoked, will be set by the TXN system
        - InitiatingSystem: string
          Indicating the initiated system
        - ServiceMode: integer
          Used for branch channel to indicate the type of customer
        - UUIDSeqNo: integer
          UUID Sequence Number
        - entity: string
          entity
        - languageCode: integer
          languageCode
        - referenceId: string
          Place holder for Token based authentication
        - userId: integer
          userId
        
        
        """
        
        
        # Prepare request data
        
        # Single body parameter - send directly
        data = request_body if request_body is not None else {}
        
        
        
        # Prepare query parameters
        params = {}
        
        
        # Replace path parameters in URL
        path = "/marketInformation/cbcbtupdrateavlncncl"
        
        
        # Prepare headers
        headers = {}
        if accesstoken is not None:
            headers["Accesstoken"] = str(accesstoken)
        if channeltype is not None:
            headers["ChannelType"] = str(channeltype)
        if co_relationid is not None:
            headers["Co-Relationid"] = str(co_relationid)
        if initiatingsystem is not None:
            headers["InitiatingSystem"] = str(initiatingsystem)
        if servicemode is not None:
            headers["ServiceMode"] = str(servicemode)
        if uuidseqno is not None:
            headers["UUIDSeqNo"] = str(uuidseqno)
        if entity is not None:
            headers["entity"] = str(entity)
        if languagecode is not None:
            headers["languageCode"] = str(languagecode)
        if referenceid is not None:
            headers["referenceId"] = str(referenceid)
        if userid is not None:
            headers["userId"] = str(userid)
        
        
        return await make_api_request(
            "POST", 
            path, 
            data=data, 
            params=params if params else None, 
            headers=headers if headers else None
        )
    
    
    
    @mcp.tool()
    async def cbcet1401_get_exrtusing_get(
        broughtcurrency: str,
        soldcurrency: str,
        broughtamount: Optional[float] = None,
        businessprice: Optional[int] = None,
        accesstoken: Optional[str] = None,
        channeltype: Optional[int] = None,
        co_relationid: Optional[int] = None,
        initiatingsystem: Optional[str] = None,
        servicemode: Optional[int] = None,
        uuidseqno: Optional[int] = None,
        entity: Optional[str] = None,
        languagecode: Optional[int] = None,
        referenceid: Optional[str] = None,
        userid: Optional[int] = None
    ) -> Dict[str, Any]:
        """
        Fetch Applicable Exchange Rate
        
        Generated from: GET /marketInformation/directory/exchangeRate
        Source: swagger_2_0
        Operation ID: CBCET1401GetEXRTUsingGET
        
        
        Authentication: Not required
        
        Parameters:
        - BroughtAmount: number
          Enter the amount to be converted
        - BroughtCurrency: string (required)
          Enter the base currency of amount
        - BusinessPrice: integer
          Enter the business purpose (2-CA Client : 3-Payment Order  : 16-FX Order)
        - SoldCurrency: string (required)
          Enter the currency to which amount to be converted
        
        
        
        Headers:
        - Accesstoken: string
          Authorization token for identification of the caller
        - ChannelType: integer
          Channel identifier from where the TXN has originated (Internet, Mobile, ATM, Branch Channel )
        - Co-Relationid: integer
          Unique ID for the service invoked, will be set by the TXN system
        - InitiatingSystem: string
          Indicating the initiated system
        - ServiceMode: integer
          Used for branch channel to indicate the type of customer
        - UUIDSeqNo: integer
          UUID Sequence Number
        - entity: string
          entity
        - languageCode: integer
          languageCode
        - referenceId: string
          Place holder for Token based authentication
        - userId: integer
          userId
        
        
        """
        
        
        # Prepare query parameters
        params = {}
        if broughtamount is not None:
            params["BroughtAmount"] = broughtamount
            
        if broughtcurrency is not None:
            params["BroughtCurrency"] = broughtcurrency
            
        if businessprice is not None:
            params["BusinessPrice"] = businessprice
            
        if soldcurrency is not None:
            params["SoldCurrency"] = soldcurrency
            
        
        
        # Replace path parameters in URL
        path = "/marketInformation/directory/exchangeRate"
        
        
        # Prepare headers
        headers = {}
        if accesstoken is not None:
            headers["Accesstoken"] = str(accesstoken)
        if channeltype is not None:
            headers["ChannelType"] = str(channeltype)
        if co_relationid is not None:
            headers["Co-Relationid"] = str(co_relationid)
        if initiatingsystem is not None:
            headers["InitiatingSystem"] = str(initiatingsystem)
        if servicemode is not None:
            headers["ServiceMode"] = str(servicemode)
        if uuidseqno is not None:
            headers["UUIDSeqNo"] = str(uuidseqno)
        if entity is not None:
            headers["entity"] = str(entity)
        if languagecode is not None:
            headers["languageCode"] = str(languagecode)
        if referenceid is not None:
            headers["referenceId"] = str(referenceid)
        if userid is not None:
            headers["userId"] = str(userid)
        
        
        return await make_api_request(
            "GET", 
            path, 
            
            params=params if params else None, 
            headers=headers if headers else None
        )
    
    
    
    @mcp.tool()
    async def cbcet0003_get_fxfwd_contract_list_postusing_get(
        cifid: str,
        dealid: int,
        buycurrency: Optional[str] = None,
        dealcurrency: Optional[str] = None,
        dealdate: Optional[str] = None,
        sellcurrency: Optional[str] = None,
        channeltype: Optional[int] = None,
        co_relationid: Optional[int] = None,
        initiatingsystem: Optional[str] = None,
        servicemode: Optional[int] = None,
        uuidseqno: Optional[int] = None,
        entity: Optional[str] = None,
        languagecode: Optional[int] = None,
        userid: Optional[int] = None
    ) -> Dict[str, Any]:
        """
        Fetch forward/spot contracts from treasury
        
        Generated from: GET /marketInformation/directory/treasury/{cifId}/{dealId}
        Source: swagger_2_0
        Operation ID: CBCET0003GetFXFwdContractList_POSTUsingGET
        
        
        Authentication: Not required
        
        Parameters:
        - buyCurrency: string
          Buy Currency of the bank
        - cifId: string (required)
          cif Id
        - dealCurrency: string
          Deal Currency
        - dealDate: string
          Deal Date
        - dealId: integer (required)
          deal Id
        - sellCurrency: string
          Sell Currency
        
        
        
        Headers:
        - ChannelType: integer
          Channel identifier from where the TXN has originated (Internet, Mobile, ATM, Branch Channel )
        - Co-Relationid: integer
          Unique ID for the service invoked, will be set by the TXN system
        - InitiatingSystem: string
          Indicating the initiated system
        - ServiceMode: integer
          Used for branch channel to indicate the type of customer
        - UUIDSeqNo: integer
          UUID Sequence Number
        - entity: string
          entity
        - languageCode: integer
          languageCode
        - userId: integer
          userId
        
        
        """
        
        
        # Prepare query parameters
        params = {}
        if buycurrency is not None:
            params["buyCurrency"] = buycurrency
            
        if dealcurrency is not None:
            params["dealCurrency"] = dealcurrency
            
        if dealdate is not None:
            params["dealDate"] = dealdate
            
        if sellcurrency is not None:
            params["sellCurrency"] = sellcurrency
            
        
        
        # Replace path parameters in URL
        path = "/marketInformation/directory/treasury/{cifId}/{dealId}"
        if cifid is not None:
            path = path.replace("{cifId}", str(cifid))
        if dealid is not None:
            path = path.replace("{dealId}", str(dealid))
        
        
        # Prepare headers
        headers = {}
        if channeltype is not None:
            headers["ChannelType"] = str(channeltype)
        if co_relationid is not None:
            headers["Co-Relationid"] = str(co_relationid)
        if initiatingsystem is not None:
            headers["InitiatingSystem"] = str(initiatingsystem)
        if servicemode is not None:
            headers["ServiceMode"] = str(servicemode)
        if uuidseqno is not None:
            headers["UUIDSeqNo"] = str(uuidseqno)
        if entity is not None:
            headers["entity"] = str(entity)
        if languagecode is not None:
            headers["languageCode"] = str(languagecode)
        if userid is not None:
            headers["userId"] = str(userid)
        
        
        return await make_api_request(
            "GET", 
            path, 
            
            params=params if params else None, 
            headers=headers if headers else None
        )
    
    
    
    @mcp.tool()
    async def miet1210_list_othr_prps_exrtusing_get(
        pagenum: Optional[int] = None,
        pagesize: Optional[int] = None,
        quotedcurrency: Optional[str] = None,
        ratedate: Optional[str] = None,
        ratepurpose: Optional[str] = None,
        referencecurrency: Optional[str] = None,
        sanitystatus: Optional[str] = None,
        accesstoken: Optional[str] = None,
        channeltype: Optional[int] = None,
        co_relationid: Optional[int] = None,
        initiatingsystem: Optional[str] = None,
        servicemode: Optional[int] = None,
        uuidseqno: Optional[int] = None,
        entity: Optional[str] = None,
        languagecode: Optional[int] = None,
        referenceid: Optional[str] = None,
        userid: Optional[int] = None
    ) -> Dict[str, Any]:
        """
        View exchange rates as on date
        
        Generated from: GET /marketInformation/exchangeRatesAsOnDate
        Source: swagger_2_0
        Operation ID: MIET1210ListOthrPrpsEXRTUsingGET
        
        
        Authentication: Not required
        
        Parameters:
        - pageNum: integer
          pageNum
        - pageSize: integer
          pageSize
        - quotedCurrency: string
          Quoted Currency is the currency for which conversion is required (SAR,USD,EUR,CHF,GBP,SEK,INR,AUD Code Name: d_CurrCode)
        - rateDate: string
          Date as on which the exchange rate is given ( format : YYYYMMDD )
        - ratePurpose: string
          Rate purpose for which conversion has been done for the Quoted Currency (Valuation-1, Taxation-2, Interbank-3, GIRO Rate-4, Employees-5, ClientNotes-6, BalanceSheet-7, LimitUtilisation-8, YearEnd_B_S - 9, TravellersCheque-10, RevaluationMid-11, RevaluationBidAsk-12, InterBankAsk-13, InterBankBid-14, LIBOR-15, LIBID-16, EZBRate-17, CashRate 22, Code Name: d_RatePurpose)
        - referenceCurrency: string
          Reference Currency will be the OU currency (SAR,USD,EUR,CHF,GBP,SEK,INR,AUD Code Name: d_CurrCode)
        - sanityStatus: string
          Exchange rate validation status (Passed-1, Failed-2, Overridden-3, NoCheck-4 Code Name: d_SanityStatus)
        
        
        
        Headers:
        - Accesstoken: string
          Authorization Token to validation the caller
        - ChannelType: integer
          Channel identifier from where the TXN has originated (Internet, Mobile, ATM, Branch Channel )
        - Co-Relationid: integer
          Unique ID for the service invoked, will be set by the TXN system
        - InitiatingSystem: string
          Indicating the initiated system
        - ServiceMode: integer
          Used for branch channel to indicate the type of customer
        - UUIDSeqNo: integer
          UUID Sequence Number
        - entity: string
          entity
        - languageCode: integer
          languageCode
        - referenceId: string
          Place holder for Token based authentication
        - userId: integer
          userId
        
        
        """
        
        
        # Prepare query parameters
        params = {}
        if pagenum is not None:
            params["pageNum"] = pagenum
            
        if pagesize is not None:
            params["pageSize"] = pagesize
            
        if quotedcurrency is not None:
            params["quotedCurrency"] = quotedcurrency
            
        if ratedate is not None:
            params["rateDate"] = ratedate
            
        if ratepurpose is not None:
            params["ratePurpose"] = ratepurpose
            
        if referencecurrency is not None:
            params["referenceCurrency"] = referencecurrency
            
        if sanitystatus is not None:
            params["sanityStatus"] = sanitystatus
            
        
        
        # Replace path parameters in URL
        path = "/marketInformation/exchangeRatesAsOnDate"
        
        
        # Prepare headers
        headers = {}
        if accesstoken is not None:
            headers["Accesstoken"] = str(accesstoken)
        if channeltype is not None:
            headers["ChannelType"] = str(channeltype)
        if co_relationid is not None:
            headers["Co-Relationid"] = str(co_relationid)
        if initiatingsystem is not None:
            headers["InitiatingSystem"] = str(initiatingsystem)
        if servicemode is not None:
            headers["ServiceMode"] = str(servicemode)
        if uuidseqno is not None:
            headers["UUIDSeqNo"] = str(uuidseqno)
        if entity is not None:
            headers["entity"] = str(entity)
        if languagecode is not None:
            headers["languageCode"] = str(languagecode)
        if referenceid is not None:
            headers["referenceId"] = str(referenceid)
        if userid is not None:
            headers["userId"] = str(userid)
        
        
        return await make_api_request(
            "GET", 
            path, 
            
            params=params if params else None, 
            headers=headers if headers else None
        )
    
    
    
    @mcp.tool()
    async def prbt0002_auth_orgntng_txn_postusing_post(
        request_body:Dict[str, Any] ,  # authoriseOriginatingTransactionResource,
        accesstoken: Optional[str] = None,
        channeltype: Optional[int] = None,
        co_relationid: Optional[int] = None,
        initiatingsystem: Optional[str] = None,
        servicemode: Optional[int] = None,
        uuidseqno: Optional[int] = None,
        entity: Optional[str] = None,
        languagecode: Optional[int] = None,
        mu_id: Optional[str] = None,
        referenceid: Optional[str] = None,
        runmode: Optional[int] = None,
        userid: Optional[int] = None
    ) -> Dict[str, Any]:
        """
        Authorise Originating Transaction
        
        Generated from: POST /payableReceivable/originatingTransaction/authorise
        Source: swagger_2_0
        Operation ID: PRBT0002AuthOrgntngTxn_POSTUsingPOST
        
        
        Authentication: Not required
        
        Parameters:
        - request_body: any (required)
          input
        
        
        
        Headers:
        - Accesstoken: string
          Authorization token for identification of the caller
        - ChannelType: integer
          Channel identifier from where the TXN has originated (Internet, Mobile, ATM, Branch Channel )
        - Co-Relationid: integer
          Unique ID for the service invoked, will be set by the TXN system
        - InitiatingSystem: string
          Indicating the initiated system
        - ServiceMode: integer
          Used for branch channel to indicate the type of customer
        - UUIDSeqNo: integer
          UUID Sequence Number
        - entity: string
          entity
        - languageCode: integer
          languageCode
        - mu_Id: string
          mu_Id
        - referenceId: string
          Place holder for Token based authentication
        - runMode: integer
          runMode
        - userId: integer
          userId
        
        
        """
        
        
        # Prepare request data
        
        # Single body parameter - send directly
        data = request_body if request_body is not None else {}
        
        
        
        # Prepare query parameters
        params = {}
        
        
        # Replace path parameters in URL
        path = "/payableReceivable/originatingTransaction/authorise"
        
        
        # Prepare headers
        headers = {}
        if accesstoken is not None:
            headers["Accesstoken"] = str(accesstoken)
        if channeltype is not None:
            headers["ChannelType"] = str(channeltype)
        if co_relationid is not None:
            headers["Co-Relationid"] = str(co_relationid)
        if initiatingsystem is not None:
            headers["InitiatingSystem"] = str(initiatingsystem)
        if servicemode is not None:
            headers["ServiceMode"] = str(servicemode)
        if uuidseqno is not None:
            headers["UUIDSeqNo"] = str(uuidseqno)
        if entity is not None:
            headers["entity"] = str(entity)
        if languagecode is not None:
            headers["languageCode"] = str(languagecode)
        if mu_id is not None:
            headers["mu_Id"] = str(mu_id)
        if referenceid is not None:
            headers["referenceId"] = str(referenceid)
        if runmode is not None:
            headers["runMode"] = str(runmode)
        if userid is not None:
            headers["userId"] = str(userid)
        
        
        return await make_api_request(
            "POST", 
            path, 
            data=data, 
            params=params if params else None, 
            headers=headers if headers else None
        )
    
    
    
    @mcp.tool()
    async def prbt0001_crt_orgntng_txn_postusing_post(
        request_body:Dict[str, Any] ,  # createOriginatingTransactionResource,
        channeltype: Optional[int] = None,
        co_relationid: Optional[int] = None,
        initiatingsystem: Optional[str] = None,
        servicemode: Optional[int] = None,
        uuidseqno: Optional[int] = None,
        entity: Optional[str] = None,
        languagecode: Optional[int] = None,
        mu_id: Optional[str] = None,
        runmode: Optional[int] = None,
        userid: Optional[int] = None
    ) -> Dict[str, Any]:
        """
        Create Originating Transaction
        
        Generated from: POST /payableReceivable/originatingTransaction/create
        Source: swagger_2_0
        Operation ID: PRBT0001CrtOrgntngTxn_POSTUsingPOST
        
        
        Authentication: Not required
        
        Parameters:
        - request_body: any (required)
          input
        
        
        
        Headers:
        - ChannelType: integer
          Channel identifier from where the TXN has originated (Internet, Mobile, ATM, Branch Channel )
        - Co-Relationid: integer
          Unique ID for the service invoked, will be set by the TXN system
        - InitiatingSystem: string
          Indicating the initiated system
        - ServiceMode: integer
          Used for branch channel to indicate the type of customer
        - UUIDSeqNo: integer
          UUID Sequence Number
        - entity: string
          entity
        - languageCode: integer
          languageCode
        - mu_Id: string
          mu_Id
        - runMode: integer
          runMode
        - userId: integer
          userId
        
        
        """
        
        
        # Prepare request data
        
        # Single body parameter - send directly
        data = request_body if request_body is not None else {}
        
        
        
        # Prepare query parameters
        params = {}
        
        
        # Replace path parameters in URL
        path = "/payableReceivable/originatingTransaction/create"
        
        
        # Prepare headers
        headers = {}
        if channeltype is not None:
            headers["ChannelType"] = str(channeltype)
        if co_relationid is not None:
            headers["Co-Relationid"] = str(co_relationid)
        if initiatingsystem is not None:
            headers["InitiatingSystem"] = str(initiatingsystem)
        if servicemode is not None:
            headers["ServiceMode"] = str(servicemode)
        if uuidseqno is not None:
            headers["UUIDSeqNo"] = str(uuidseqno)
        if entity is not None:
            headers["entity"] = str(entity)
        if languagecode is not None:
            headers["languageCode"] = str(languagecode)
        if mu_id is not None:
            headers["mu_Id"] = str(mu_id)
        if runmode is not None:
            headers["runMode"] = str(runmode)
        if userid is not None:
            headers["userId"] = str(userid)
        
        
        return await make_api_request(
            "POST", 
            path, 
            data=data, 
            params=params if params else None, 
            headers=headers if headers else None
        )
    
    
    
    @mcp.tool()
    async def pret0003_fetch_orgntng_txn_postusing_get(
        branchid: Optional[str] = None,
        businessstatus: Optional[int] = None,
        instrumentid: Optional[int] = None,
        originatingtype: Optional[int] = None,
        originationfromdate: Optional[str] = None,
        originationtodate: Optional[str] = None,
        pagenum: Optional[int] = None,
        pagesize: Optional[int] = None,
        referencenumber: Optional[str] = None,
        transactionamount: Optional[float] = None,
        transactioncurrency: Optional[str] = None,
        transactionreference: Optional[str] = None,
        accesstoken: Optional[str] = None,
        servicemode_: Optional[int] = None,
        entity: Optional[str] = None,
        languagecode: Optional[int] = None,
        userid: Optional[int] = None
    ) -> Dict[str, Any]:
        """
        Fetch Originating Transactions
        
        Generated from: GET /payableReceivable/originatingTransaction/list
        Source: swagger_2_0
        Operation ID: PRET0003FetchOrgntngTxn_POSTUsingGET
        
        
        Authentication: Not required
        
        Parameters:
        - branchId: string
          Branch of the transaction.
        - businessStatus: integer
           Business Status of the originating transaction(Domain Name: d_PR_Stat)
        - instrumentId: integer
          Instrument Id 
        - originatingType: integer
          Originating Type of the Transaction.Possible Values: 1- Debit Origination,2 - Credit Origination(Domain Name: d_ReconciliationGL)
        - originationFromDate: string
          Origination From Date 
        - originationTODate: string
          Origination TO Date 
        - pageNum: integer
          pageNum
        - pageSize: integer
          pageSize
        - referenceNumber: string
          Reference Number
        - transactionAmount: number
          The Amount which corresponds to the Originating Transactions.
        - transactionCurrency: string
          The Currency which corresponds to the specific Transactions.(Domain Name: d_CurrCode / 3 character ISO currency code) Eg : MXN, EUR, USD, INR
        - transactionReference: string
          Originating transaction Reference
        
        
        
        Headers:
        - Accesstoken: string
          Authorization token for identification of the caller
        - ServiceMode : integer
          Used for branch channel to indicate the type of customer
        - entity: string
          entity
        - languageCode: integer
          languageCode
        - userId: integer
          userId
        
        
        """
        
        
        # Prepare query parameters
        params = {}
        if branchid is not None:
            params["branchId"] = branchid
            
        if businessstatus is not None:
            params["businessStatus"] = businessstatus
            
        if instrumentid is not None:
            params["instrumentId"] = instrumentid
            
        if originatingtype is not None:
            params["originatingType"] = originatingtype
            
        if originationfromdate is not None:
            params["originationFromDate"] = originationfromdate
            
        if originationtodate is not None:
            params["originationTODate"] = originationtodate
            
        if pagenum is not None:
            params["pageNum"] = pagenum
            
        if pagesize is not None:
            params["pageSize"] = pagesize
            
        if referencenumber is not None:
            params["referenceNumber"] = referencenumber
            
        if transactionamount is not None:
            params["transactionAmount"] = transactionamount
            
        if transactioncurrency is not None:
            params["transactionCurrency"] = transactioncurrency
            
        if transactionreference is not None:
            params["transactionReference"] = transactionreference
            
        
        
        # Replace path parameters in URL
        path = "/payableReceivable/originatingTransaction/list"
        
        
        # Prepare headers
        headers = {}
        if accesstoken is not None:
            headers["Accesstoken"] = str(accesstoken)
        if servicemode_ is not None:
            headers["ServiceMode "] = str(servicemode_)
        if entity is not None:
            headers["entity"] = str(entity)
        if languagecode is not None:
            headers["languageCode"] = str(languagecode)
        if userid is not None:
            headers["userId"] = str(userid)
        
        
        return await make_api_request(
            "GET", 
            path, 
            
            params=params if params else None, 
            headers=headers if headers else None
        )
    
    
    
    @mcp.tool()
    async def pret0010_get_orgntng_txn_postusing_get(
        transactionid: int,
        transactiontype: int,
        accesstoken: Optional[str] = None,
        channeltype: Optional[int] = None,
        co_relationid: Optional[int] = None,
        initiatingsystem: Optional[str] = None,
        servicemode: Optional[int] = None,
        uuidseqno: Optional[int] = None,
        entity: Optional[str] = None,
        languagecode: Optional[int] = None,
        referenceid: Optional[str] = None,
        userid: Optional[int] = None
    ) -> Dict[str, Any]:
        """
        View Originating Transactions
        
        Generated from: GET /payableReceivable/originatingTransaction/view
        Source: swagger_2_0
        Operation ID: PRET0010GetOrgntngTxn_POSTUsingGET
        
        
        Authentication: Not required
        
        Parameters:
        - transactionId: integer (required)
          Transaction ID of the originating Transaction
        - transactionType: integer (required)
          Type of the originating Transaction.Possible Values: 185 - APAR Origination,186 - APAR Responding(Domain Name: d_PosTyp)
        
        
        
        Headers:
        - Accesstoken: string
          Authorization token for identification of the caller
        - ChannelType: integer
          Channel identifier from where the TXN has originated (Internet, Mobile, ATM, Branch Channel )
        - Co-Relationid: integer
          Unique ID for the service invoked, will be set by the TXN system
        - InitiatingSystem: string
          Indicating the initiated system
        - ServiceMode: integer
          Used for branch channel to indicate the type of customer
        - UUIDSeqNo: integer
          UUID Sequence Number
        - entity: string
          entity
        - languageCode: integer
          languageCode
        - referenceId: string
          Place holder for Token based authentication
        - userId: integer
          userId
        
        
        """
        
        
        # Prepare query parameters
        params = {}
        if transactionid is not None:
            params["transactionId"] = transactionid
            
        if transactiontype is not None:
            params["transactionType"] = transactiontype
            
        
        
        # Replace path parameters in URL
        path = "/payableReceivable/originatingTransaction/view"
        
        
        # Prepare headers
        headers = {}
        if accesstoken is not None:
            headers["Accesstoken"] = str(accesstoken)
        if channeltype is not None:
            headers["ChannelType"] = str(channeltype)
        if co_relationid is not None:
            headers["Co-Relationid"] = str(co_relationid)
        if initiatingsystem is not None:
            headers["InitiatingSystem"] = str(initiatingsystem)
        if servicemode is not None:
            headers["ServiceMode"] = str(servicemode)
        if uuidseqno is not None:
            headers["UUIDSeqNo"] = str(uuidseqno)
        if entity is not None:
            headers["entity"] = str(entity)
        if languagecode is not None:
            headers["languageCode"] = str(languagecode)
        if referenceid is not None:
            headers["referenceId"] = str(referenceid)
        if userid is not None:
            headers["userId"] = str(userid)
        
        
        return await make_api_request(
            "GET", 
            path, 
            
            params=params if params else None, 
            headers=headers if headers else None
        )
    
    
    
    @mcp.tool()
    async def prbt0007_auth_rspnd_txn_postusing_post(
        request_body:Dict[str, Any] ,  # authoriseResponseTransactionResource,
        accesstoken: Optional[str] = None,
        channeltype: Optional[int] = None,
        co_relationid: Optional[int] = None,
        initiatingsystem: Optional[str] = None,
        servicemode: Optional[int] = None,
        uuidseqno: Optional[int] = None,
        entity: Optional[str] = None,
        languagecode: Optional[int] = None,
        mu_id: Optional[str] = None,
        referenceid: Optional[str] = None,
        runmode: Optional[int] = None,
        userid: Optional[int] = None
    ) -> Dict[str, Any]:
        """
        Autorise Responding Transaction
        
        Generated from: POST /payableReceivable/respondingTransaction/authorise
        Source: swagger_2_0
        Operation ID: PRBT0007AuthRspndTxn_POSTUsingPOST
        
        
        Authentication: Not required
        
        Parameters:
        - request_body: any (required)
          input
        
        
        
        Headers:
        - Accesstoken: string
          Authorization token for identification of the caller
        - ChannelType: integer
          Channel identifier from where the TXN has originated (Internet, Mobile, ATM, Branch Channel )
        - Co-Relationid: integer
          Unique ID for the service invoked, will be set by the TXN system
        - InitiatingSystem: string
          Indicating the initiated system
        - ServiceMode: integer
          Used for branch channel to indicate the type of customer
        - UUIDSeqNo: integer
          UUID Sequence Number
        - entity: string
          entity
        - languageCode: integer
          languageCode
        - mu_Id: string
          mu_Id
        - referenceId: string
          Place holder for Token based authentication
        - runMode: integer
          runMode
        - userId: integer
          userId
        
        
        """
        
        
        # Prepare request data
        
        # Single body parameter - send directly
        data = request_body if request_body is not None else {}
        
        
        
        # Prepare query parameters
        params = {}
        
        
        # Replace path parameters in URL
        path = "/payableReceivable/respondingTransaction/authorise"
        
        
        # Prepare headers
        headers = {}
        if accesstoken is not None:
            headers["Accesstoken"] = str(accesstoken)
        if channeltype is not None:
            headers["ChannelType"] = str(channeltype)
        if co_relationid is not None:
            headers["Co-Relationid"] = str(co_relationid)
        if initiatingsystem is not None:
            headers["InitiatingSystem"] = str(initiatingsystem)
        if servicemode is not None:
            headers["ServiceMode"] = str(servicemode)
        if uuidseqno is not None:
            headers["UUIDSeqNo"] = str(uuidseqno)
        if entity is not None:
            headers["entity"] = str(entity)
        if languagecode is not None:
            headers["languageCode"] = str(languagecode)
        if mu_id is not None:
            headers["mu_Id"] = str(mu_id)
        if referenceid is not None:
            headers["referenceId"] = str(referenceid)
        if runmode is not None:
            headers["runMode"] = str(runmode)
        if userid is not None:
            headers["userId"] = str(userid)
        
        
        return await make_api_request(
            "POST", 
            path, 
            data=data, 
            params=params if params else None, 
            headers=headers if headers else None
        )
    
    
    
    @mcp.tool()
    async def prbt0005_rspnd_leg_adntn_postusing_post(
        request_body:Dict[str, Any] ,  # responseLegAdditionResource,
        accesstoken: Optional[str] = None,
        channeltype: Optional[int] = None,
        co_relationid: Optional[int] = None,
        initiatingsystem: Optional[str] = None,
        servicemode: Optional[int] = None,
        uuidseqno: Optional[int] = None,
        entity: Optional[str] = None,
        languagecode: Optional[int] = None,
        mu_id: Optional[str] = None,
        referenceid: Optional[str] = None,
        runmode: Optional[int] = None,
        userid: Optional[int] = None
    ) -> Dict[str, Any]:
        """
        Add Responding Transaction Legs
        
        Generated from: POST /payableReceivable/respondingTransaction/create/addLeg
        Source: swagger_2_0
        Operation ID: PRBT0005RspndLegAdntn_POSTUsingPOST
        
        
        Authentication: Not required
        
        Parameters:
        - request_body: any (required)
          input
        
        
        
        Headers:
        - Accesstoken: string
          Authorization token for identification of the caller
        - ChannelType: integer
          Channel identifier from where the TXN has originated (Internet, Mobile, ATM, Branch Channel )
        - Co-Relationid: integer
          Unique ID for the service invoked, will be set by the TXN system
        - InitiatingSystem: string
          Indicating the initiated system
        - ServiceMode: integer
          Used for branch channel to indicate the type of customer
        - UUIDSeqNo: integer
          UUID Sequence Number
        - entity: string
          entity
        - languageCode: integer
          languageCode
        - mu_Id: string
          mu_Id
        - referenceId: string
          Place holder for Token based authentication
        - runMode: integer
          runMode
        - userId: integer
          userId
        
        
        """
        
        
        # Prepare request data
        
        # Single body parameter - send directly
        data = request_body if request_body is not None else {}
        
        
        
        # Prepare query parameters
        params = {}
        
        
        # Replace path parameters in URL
        path = "/payableReceivable/respondingTransaction/create/addLeg"
        
        
        # Prepare headers
        headers = {}
        if accesstoken is not None:
            headers["Accesstoken"] = str(accesstoken)
        if channeltype is not None:
            headers["ChannelType"] = str(channeltype)
        if co_relationid is not None:
            headers["Co-Relationid"] = str(co_relationid)
        if initiatingsystem is not None:
            headers["InitiatingSystem"] = str(initiatingsystem)
        if servicemode is not None:
            headers["ServiceMode"] = str(servicemode)
        if uuidseqno is not None:
            headers["UUIDSeqNo"] = str(uuidseqno)
        if entity is not None:
            headers["entity"] = str(entity)
        if languagecode is not None:
            headers["languageCode"] = str(languagecode)
        if mu_id is not None:
            headers["mu_Id"] = str(mu_id)
        if referenceid is not None:
            headers["referenceId"] = str(referenceid)
        if runmode is not None:
            headers["runMode"] = str(runmode)
        if userid is not None:
            headers["userId"] = str(userid)
        
        
        return await make_api_request(
            "POST", 
            path, 
            data=data, 
            params=params if params else None, 
            headers=headers if headers else None
        )
    
    
    
    @mcp.tool()
    async def prbt0004_crt_rspnd_onhold_postusing_post(
        request_body:Dict[str, Any] ,  # createResponseOnHoldResource,
        accesstoken: Optional[str] = None,
        channeltype: Optional[int] = None,
        co_relationid: Optional[int] = None,
        initiatingsystem: Optional[str] = None,
        servicemode: Optional[int] = None,
        uuidseqno: Optional[int] = None,
        entity: Optional[str] = None,
        languagecode: Optional[int] = None,
        mu_id: Optional[str] = None,
        referenceid: Optional[str] = None,
        runmode: Optional[int] = None,
        userid: Optional[int] = None
    ) -> Dict[str, Any]:
        """
        Create Responding Transaction Onhold
        
        Generated from: POST /payableReceivable/respondingTransaction/create/onHold
        Source: swagger_2_0
        Operation ID: PRBT0004CrtRspndOnhold_POSTUsingPOST
        
        
        Authentication: Not required
        
        Parameters:
        - request_body: any (required)
          input
        
        
        
        Headers:
        - Accesstoken: string
          Authorization token for identification of the caller
        - ChannelType: integer
          Channel identifier from where the TXN has originated (Internet, Mobile, ATM, Branch Channel )
        - Co-Relationid: integer
          Unique ID for the service invoked, will be set by the TXN system
        - InitiatingSystem: string
          Indicating the initiated system
        - ServiceMode: integer
          Used for branch channel to indicate the type of customer
        - UUIDSeqNo: integer
          UUID Sequence Number
        - entity: string
          entity
        - languageCode: integer
          languageCode
        - mu_Id: string
          mu_Id
        - referenceId: string
          Place holder for Token based authentication
        - runMode: integer
          runMode
        - userId: integer
          userId
        
        
        """
        
        
        # Prepare request data
        
        # Single body parameter - send directly
        data = request_body if request_body is not None else {}
        
        
        
        # Prepare query parameters
        params = {}
        
        
        # Replace path parameters in URL
        path = "/payableReceivable/respondingTransaction/create/onHold"
        
        
        # Prepare headers
        headers = {}
        if accesstoken is not None:
            headers["Accesstoken"] = str(accesstoken)
        if channeltype is not None:
            headers["ChannelType"] = str(channeltype)
        if co_relationid is not None:
            headers["Co-Relationid"] = str(co_relationid)
        if initiatingsystem is not None:
            headers["InitiatingSystem"] = str(initiatingsystem)
        if servicemode is not None:
            headers["ServiceMode"] = str(servicemode)
        if uuidseqno is not None:
            headers["UUIDSeqNo"] = str(uuidseqno)
        if entity is not None:
            headers["entity"] = str(entity)
        if languagecode is not None:
            headers["languageCode"] = str(languagecode)
        if mu_id is not None:
            headers["mu_Id"] = str(mu_id)
        if referenceid is not None:
            headers["referenceId"] = str(referenceid)
        if runmode is not None:
            headers["runMode"] = str(runmode)
        if userid is not None:
            headers["userId"] = str(userid)
        
        
        return await make_api_request(
            "POST", 
            path, 
            data=data, 
            params=params if params else None, 
            headers=headers if headers else None
        )
    
    
    
    @mcp.tool()
    async def prbt0006_rspnd_rlz_postusing_post(
        request_body:Dict[str, Any] ,  # responseReleaseResource,
        accesstoken: Optional[str] = None,
        channeltype: Optional[int] = None,
        co_relationid: Optional[int] = None,
        initiatingsystem: Optional[str] = None,
        servicemode: Optional[int] = None,
        uuidseqno: Optional[int] = None,
        entity: Optional[str] = None,
        languagecode: Optional[int] = None,
        mu_id: Optional[str] = None,
        referenceid: Optional[str] = None,
        runmode: Optional[int] = None,
        userid: Optional[int] = None
    ) -> Dict[str, Any]:
        """
        Responding Transaction List
        
        Generated from: POST /payableReceivable/respondingTransaction/create/release
        Source: swagger_2_0
        Operation ID: PRBT0006RspndRlz_POSTUsingPOST
        
        
        Authentication: Not required
        
        Parameters:
        - request_body: any (required)
          input
        
        
        
        Headers:
        - Accesstoken: string
          Authorization token for identification of the caller
        - ChannelType: integer
          Channel identifier from where the TXN has originated (Internet, Mobile, ATM, Branch Channel )
        - Co-Relationid: integer
          Unique ID for the service invoked, will be set by the TXN system
        - InitiatingSystem: string
          Indicating the initiated system
        - ServiceMode: integer
          Used for branch channel to indicate the type of customer
        - UUIDSeqNo: integer
          UUID Sequence Number
        - entity: string
          entity
        - languageCode: integer
          languageCode
        - mu_Id: string
          mu_Id
        - referenceId: string
          Place holder for Token based authentication
        - runMode: integer
          runMode
        - userId: integer
          userId
        
        
        """
        
        
        # Prepare request data
        
        # Single body parameter - send directly
        data = request_body if request_body is not None else {}
        
        
        
        # Prepare query parameters
        params = {}
        
        
        # Replace path parameters in URL
        path = "/payableReceivable/respondingTransaction/create/release"
        
        
        # Prepare headers
        headers = {}
        if accesstoken is not None:
            headers["Accesstoken"] = str(accesstoken)
        if channeltype is not None:
            headers["ChannelType"] = str(channeltype)
        if co_relationid is not None:
            headers["Co-Relationid"] = str(co_relationid)
        if initiatingsystem is not None:
            headers["InitiatingSystem"] = str(initiatingsystem)
        if servicemode is not None:
            headers["ServiceMode"] = str(servicemode)
        if uuidseqno is not None:
            headers["UUIDSeqNo"] = str(uuidseqno)
        if entity is not None:
            headers["entity"] = str(entity)
        if languagecode is not None:
            headers["languageCode"] = str(languagecode)
        if mu_id is not None:
            headers["mu_Id"] = str(mu_id)
        if referenceid is not None:
            headers["referenceId"] = str(referenceid)
        if runmode is not None:
            headers["runMode"] = str(runmode)
        if userid is not None:
            headers["userId"] = str(userid)
        
        
        return await make_api_request(
            "POST", 
            path, 
            data=data, 
            params=params if params else None, 
            headers=headers if headers else None
        )
    
    
    
    @mcp.tool()
    async def pret0009_view_rspnd_dtls_postusing_get(
        transactionposid: int,
        transactionpostype: int,
        pagenum: Optional[int] = None,
        pagesize: Optional[int] = None,
        accesstoken: Optional[str] = None,
        channeltype: Optional[int] = None,
        co_relationid: Optional[int] = None,
        initiatingsystem: Optional[str] = None,
        servicemode: Optional[int] = None,
        uuidseqno: Optional[int] = None,
        entity: Optional[str] = None,
        languagecode: Optional[int] = None,
        referenceid: Optional[str] = None,
        userid: Optional[int] = None
    ) -> Dict[str, Any]:
        """
        View Responding Details
        
        Generated from: GET /payableReceivable/respondingTransaction/legList
        Source: swagger_2_0
        Operation ID: PRET0009ViewRspndDtls_POSTUsingGET
        
        
        Authentication: Not required
        
        Parameters:
        - pageNum: integer
          pageNum
        - pageSize: integer
          pageSize
        - transactionPosId: integer (required)
          transactionPosId
        - transactionPosType: integer (required)
          transactionPosType
        
        
        
        Headers:
        - Accesstoken: string
          Authorization token for identification of the caller
        - ChannelType: integer
          Channel identifier from where the TXN has originated (Internet, Mobile, ATM, Branch Channel )
        - Co-Relationid: integer
          Unique ID for the service invoked, will be set by the TXN system
        - InitiatingSystem: string
          Indicating the initiated system
        - ServiceMode: integer
          Used for branch channel to indicate the type of customer
        - UUIDSeqNo: integer
          UUID Sequence Number
        - entity: string
          entity
        - languageCode: integer
          languageCode
        - referenceId: string
          Place holder for Token based authentication
        - userId: integer
          userId
        
        
        """
        
        
        # Prepare query parameters
        params = {}
        if pagenum is not None:
            params["pageNum"] = pagenum
            
        if pagesize is not None:
            params["pageSize"] = pagesize
            
        if transactionposid is not None:
            params["transactionPosId"] = transactionposid
            
        if transactionpostype is not None:
            params["transactionPosType"] = transactionpostype
            
        
        
        # Replace path parameters in URL
        path = "/payableReceivable/respondingTransaction/legList"
        
        
        # Prepare headers
        headers = {}
        if accesstoken is not None:
            headers["Accesstoken"] = str(accesstoken)
        if channeltype is not None:
            headers["ChannelType"] = str(channeltype)
        if co_relationid is not None:
            headers["Co-Relationid"] = str(co_relationid)
        if initiatingsystem is not None:
            headers["InitiatingSystem"] = str(initiatingsystem)
        if servicemode is not None:
            headers["ServiceMode"] = str(servicemode)
        if uuidseqno is not None:
            headers["UUIDSeqNo"] = str(uuidseqno)
        if entity is not None:
            headers["entity"] = str(entity)
        if languagecode is not None:
            headers["languageCode"] = str(languagecode)
        if referenceid is not None:
            headers["referenceId"] = str(referenceid)
        if userid is not None:
            headers["userId"] = str(userid)
        
        
        return await make_api_request(
            "GET", 
            path, 
            
            params=params if params else None, 
            headers=headers if headers else None
        )
    
    
    
    @mcp.tool()
    async def pret0008_fetch_rspnd_list_postusing_get(
        branchid: Optional[str] = None,
        originatingtransactionreference: Optional[str] = None,
        pagenum: Optional[int] = None,
        pagesize: Optional[int] = None,
        respondingtype: Optional[int] = None,
        status: Optional[int] = None,
        transactionid: Optional[str] = None,
        accesstoken: Optional[str] = None,
        channeltype: Optional[int] = None,
        co_relationid: Optional[int] = None,
        initiatingsystem: Optional[str] = None,
        servicemode: Optional[int] = None,
        uuidseqno: Optional[int] = None,
        entity: Optional[str] = None,
        languagecode: Optional[int] = None,
        referenceid: Optional[str] = None,
        userid: Optional[int] = None
    ) -> Dict[str, Any]:
        """
        Responding Transaction List
        
        Generated from: GET /payableReceivable/respondingTransaction/list
        Source: swagger_2_0
        Operation ID: PRET0008FetchRspndList_POSTUsingGET
        
        
        Authentication: Not required
        
        Parameters:
        - branchId: string
          Branch of the transaction
        - originatingTransactionReference: string
          Originating transaction Reference
        - pageNum: integer
          pageNum
        - pageSize: integer
          pageSize
        - respondingType: integer
          Responding Type of the Transaction.Possible Values: 1- Debit Origination,2 - Credit Origination(Domain Name: d_ReconciliationGL)
        - status: integer
          Status of the originating Transaction.(Domain Name: d_PR_Stat)
        - transactionId: string
          Transaction ID of the Responding Transaction
        
        
        
        Headers:
        - Accesstoken: string
          Authorization token for identification of the caller
        - ChannelType: integer
          Channel identifier from where the TXN has originated (Internet, Mobile, ATM, Branch Channel )
        - Co-Relationid: integer
          Unique ID for the service invoked, will be set by the TXN system
        - InitiatingSystem: string
          Indicating the initiated system
        - ServiceMode: integer
          Used for branch channel to indicate the type of customer
        - UUIDSeqNo: integer
          UUID Sequence Number
        - entity: string
          entity
        - languageCode: integer
          languageCode
        - referenceId: string
          Place holder for Token based authentication
        - userId: integer
          userId
        
        
        """
        
        
        # Prepare query parameters
        params = {}
        if branchid is not None:
            params["branchId"] = branchid
            
        if originatingtransactionreference is not None:
            params["originatingTransactionReference"] = originatingtransactionreference
            
        if pagenum is not None:
            params["pageNum"] = pagenum
            
        if pagesize is not None:
            params["pageSize"] = pagesize
            
        if respondingtype is not None:
            params["respondingType"] = respondingtype
            
        if status is not None:
            params["status"] = status
            
        if transactionid is not None:
            params["transactionId"] = transactionid
            
        
        
        # Replace path parameters in URL
        path = "/payableReceivable/respondingTransaction/list"
        
        
        # Prepare headers
        headers = {}
        if accesstoken is not None:
            headers["Accesstoken"] = str(accesstoken)
        if channeltype is not None:
            headers["ChannelType"] = str(channeltype)
        if co_relationid is not None:
            headers["Co-Relationid"] = str(co_relationid)
        if initiatingsystem is not None:
            headers["InitiatingSystem"] = str(initiatingsystem)
        if servicemode is not None:
            headers["ServiceMode"] = str(servicemode)
        if uuidseqno is not None:
            headers["UUIDSeqNo"] = str(uuidseqno)
        if entity is not None:
            headers["entity"] = str(entity)
        if languagecode is not None:
            headers["languageCode"] = str(languagecode)
        if referenceid is not None:
            headers["referenceId"] = str(referenceid)
        if userid is not None:
            headers["userId"] = str(userid)
        
        
        return await make_api_request(
            "GET", 
            path, 
            
            params=params if params else None, 
            headers=headers if headers else None
        )
    
    
    
    @mcp.tool()
    async def pret0011_view_rspnd_leg_dtls_postusing_get(
        entryid: int,
        transactionid: int,
        accesstoken: Optional[str] = None,
        channeltype: Optional[int] = None,
        co_relationid: Optional[int] = None,
        initiatingsystem: Optional[str] = None,
        servicemode: Optional[int] = None,
        uuidseqno: Optional[int] = None,
        referenceid: Optional[str] = None
    ) -> Dict[str, Any]:
        """
        View Responding Leg Details
        
        Generated from: GET /payableReceivable/respondingTransaction/viewLeg
        Source: swagger_2_0
        Operation ID: PRET0011ViewRspndLegDtls_POSTUsingGET
        
        
        Authentication: Not required
        
        Parameters:
        - entryId: integer (required)
          Leg Sequence id 
        - transactionId: integer (required)
          Transaction Pos Id of the Responding Transaction
        
        
        
        Headers:
        - Accesstoken: string
          Authorization token for identification of the caller
        - ChannelType: integer
          Channel identifier from where the TXN has originated (Internet, Mobile, ATM, Branch Channel )
        - Co-Relationid: integer
          Unique ID for the service invoked, will be set by the TXN system
        - InitiatingSystem: string
          Indicating the initiated system
        - ServiceMode: integer
          Used for branch channel to indicate the type of customer
        - UUIDSeqNo: integer
          UUID Sequence Number
        - referenceId: string
          Place holder for Token based authentication
        
        
        """
        
        
        # Prepare query parameters
        params = {}
        if entryid is not None:
            params["entryId"] = entryid
            
        if transactionid is not None:
            params["transactionId"] = transactionid
            
        
        
        # Replace path parameters in URL
        path = "/payableReceivable/respondingTransaction/viewLeg"
        
        
        # Prepare headers
        headers = {}
        if accesstoken is not None:
            headers["Accesstoken"] = str(accesstoken)
        if channeltype is not None:
            headers["ChannelType"] = str(channeltype)
        if co_relationid is not None:
            headers["Co-Relationid"] = str(co_relationid)
        if initiatingsystem is not None:
            headers["InitiatingSystem"] = str(initiatingsystem)
        if servicemode is not None:
            headers["ServiceMode"] = str(servicemode)
        if uuidseqno is not None:
            headers["UUIDSeqNo"] = str(uuidseqno)
        if referenceid is not None:
            headers["referenceId"] = str(referenceid)
        
        
        return await make_api_request(
            "GET", 
            path, 
            
            params=params if params else None, 
            headers=headers if headers else None
        )
    
    
    
    @mcp.tool()
    async def amebt1622_ameauth_to_reverse_postusing_post(
        request_body:Dict[str, Any] ,  # AuthToReverseResource,
        accesstoken: Optional[str] = None,
        channeltype: Optional[int] = None,
        co_relationid: Optional[int] = None,
        initiatingsystem: Optional[str] = None,
        servicemode: Optional[int] = None,
        uuidseqno: Optional[int] = None,
        entity: Optional[str] = None,
        languagecode: Optional[int] = None,
        referenceid: Optional[str] = None,
        userid: Optional[int] = None
    ) -> Dict[str, Any]:
        """
        Reversal function
        
        Generated from: POST /payments/authreverse
        Source: swagger_2_0
        Operation ID: AMEBT1622AMEAuthToReverse_POSTUsingPOST
        
        
        Authentication: Not required
        
        Parameters:
        - request_body: any (required)
          input
        
        
        
        Headers:
        - Accesstoken: string
          Authorization Token to validation the caller
        - ChannelType: integer
          Channel identifier from where the TXN has originated (Internet, Mobile, ATM, Branch Channel )
        - Co-Relationid: integer
          Unique ID for the service invoked, will be set by the TXN system
        - InitiatingSystem: string
          Indicating the initiated system
        - ServiceMode: integer
          Used for branch channel to indicate the type of customer
        - UUIDSeqNo: integer
          UUID Sequence Number
        - entity: string
          entity
        - languageCode: integer
          languageCode
        - referenceId: string
          Place holder for Token based authentication
        - userId: integer
          userId
        
        
        """
        
        
        # Prepare request data
        
        # Single body parameter - send directly
        data = request_body if request_body is not None else {}
        
        
        
        # Prepare query parameters
        params = {}
        
        
        # Replace path parameters in URL
        path = "/payments/authreverse"
        
        
        # Prepare headers
        headers = {}
        if accesstoken is not None:
            headers["Accesstoken"] = str(accesstoken)
        if channeltype is not None:
            headers["ChannelType"] = str(channeltype)
        if co_relationid is not None:
            headers["Co-Relationid"] = str(co_relationid)
        if initiatingsystem is not None:
            headers["InitiatingSystem"] = str(initiatingsystem)
        if servicemode is not None:
            headers["ServiceMode"] = str(servicemode)
        if uuidseqno is not None:
            headers["UUIDSeqNo"] = str(uuidseqno)
        if entity is not None:
            headers["entity"] = str(entity)
        if languagecode is not None:
            headers["languageCode"] = str(languagecode)
        if referenceid is not None:
            headers["referenceId"] = str(referenceid)
        if userid is not None:
            headers["userId"] = str(userid)
        
        
        return await make_api_request(
            "POST", 
            path, 
            data=data, 
            params=params if params else None, 
            headers=headers if headers else None
        )
    
    
    
    @mcp.tool()
    async def ameet2021_crypto_acnt_disp_holding_postusing_get(
        accountreference: str,
        accesstoken: Optional[str] = None,
        channeltype: Optional[int] = None,
        co_relationid: Optional[int] = None,
        initiatingsystem: Optional[str] = None,
        servicemode: Optional[int] = None,
        uuidseqno: Optional[int] = None,
        entity: Optional[str] = None,
        languagecode: Optional[int] = None,
        referenceid: Optional[str] = None,
        userid: Optional[int] = None
    ) -> Dict[str, Any]:
        """
        Crypto Account Disposable Holding
        
        Generated from: GET /payments/crypto/account/disposableHolding/{accountReference}
        Source: swagger_2_0
        Operation ID: AMEET2021CryptoAcntDispHolding_POSTUsingGET
        
        
        Authentication: Not required
        
        Parameters:
        - accountReference: string (required)
          Account Reference
        
        
        
        Headers:
        - Accesstoken: string
          Authorization token for identification of the caller
        - ChannelType: integer
          Channel identifier from where the transaction has originated (Internet, Mobile, ATM, Branch Channel )
        - Co-Relationid: integer
          Unique ID for the service invoked, will be set by the transaction system
        - InitiatingSystem: string
          Indicating the initiated system
        - ServiceMode: integer
          Used for branch channel to indicate the type of customer
        - UUIDSeqNo: integer
          UUID Sequence Number
        - entity: string
          entity
        - languageCode: integer
          languageCode
        - referenceId: string
          Place holder for Token based authentication
        - userId: integer
          userId
        
        
        """
        
        
        # Prepare query parameters
        params = {}
        
        
        # Replace path parameters in URL
        path = "/payments/crypto/account/disposableHolding/{accountReference}"
        if accountreference is not None:
            path = path.replace("{accountReference}", str(accountreference))
        
        
        # Prepare headers
        headers = {}
        if accesstoken is not None:
            headers["Accesstoken"] = str(accesstoken)
        if channeltype is not None:
            headers["ChannelType"] = str(channeltype)
        if co_relationid is not None:
            headers["Co-Relationid"] = str(co_relationid)
        if initiatingsystem is not None:
            headers["InitiatingSystem"] = str(initiatingsystem)
        if servicemode is not None:
            headers["ServiceMode"] = str(servicemode)
        if uuidseqno is not None:
            headers["UUIDSeqNo"] = str(uuidseqno)
        if entity is not None:
            headers["entity"] = str(entity)
        if languagecode is not None:
            headers["languageCode"] = str(languagecode)
        if referenceid is not None:
            headers["referenceId"] = str(referenceid)
        if userid is not None:
            headers["userId"] = str(userid)
        
        
        return await make_api_request(
            "GET", 
            path, 
            
            params=params if params else None, 
            headers=headers if headers else None
        )
    
    
    
    @mcp.tool()
    async def amebt1701_rebal_on_off_acnt_using_put(
        request_body:Dict[str, Any] ,  # cryptoRebalanceOnOffAccountResource,
        accesstoken: Optional[str] = None,
        channeltype: Optional[int] = None,
        co_relationid: Optional[int] = None,
        initiatingsystem: Optional[str] = None,
        servicemode: Optional[int] = None,
        uuidseqno: Optional[str] = None,
        entity: Optional[str] = None,
        languagecode: Optional[int] = None,
        referenceid: Optional[str] = None,
        requesthash: Optional[str] = None,
        userid: Optional[int] = None
    ) -> Dict[str, Any]:
        """
        Rebalancing of the crypto On and Off account balances
        
        Generated from: PUT /payments/crypto/rebalance
        Source: swagger_2_0
        Operation ID: AMEBT1701RebalOnOffAcntUsingPUT
        
        
        Authentication: Not required
        
        Parameters:
        - request_body: any (required)
          input
        
        
        
        Headers:
        - Accesstoken: string
          Authorization token for identification of the caller
        - ChannelType: integer
          Channel identifier from where the transaction has originated (Internet, Mobile, ATM, Branch Channel)
        - Co-Relationid: integer
          Unique ID for the service invoked, will be set by the transaction system
        - InitiatingSystem: string
          Indicating the initiated system
        - ServiceMode: integer
          Used for branch channel to indicate the type of customer
        - UUIDSeqNo: string
          UUID Sequence Number
        - entity: string
          entity
        - languageCode: integer
          languageCode
        - referenceId: string
          Place holder for Token based authentication
        - requesthash: string
          Request payload for hash validation
        - userId: integer
          userId
        
        
        """
        
        
        # Prepare request data
        
        # Single body parameter - send directly
        data = request_body if request_body is not None else {}
        
        
        
        # Prepare query parameters
        params = {}
        
        
        # Replace path parameters in URL
        path = "/payments/crypto/rebalance"
        
        
        # Prepare headers
        headers = {}
        if accesstoken is not None:
            headers["Accesstoken"] = str(accesstoken)
        if channeltype is not None:
            headers["ChannelType"] = str(channeltype)
        if co_relationid is not None:
            headers["Co-Relationid"] = str(co_relationid)
        if initiatingsystem is not None:
            headers["InitiatingSystem"] = str(initiatingsystem)
        if servicemode is not None:
            headers["ServiceMode"] = str(servicemode)
        if uuidseqno is not None:
            headers["UUIDSeqNo"] = str(uuidseqno)
        if entity is not None:
            headers["entity"] = str(entity)
        if languagecode is not None:
            headers["languageCode"] = str(languagecode)
        if referenceid is not None:
            headers["referenceId"] = str(referenceid)
        if requesthash is not None:
            headers["requesthash"] = str(requesthash)
        if userid is not None:
            headers["userId"] = str(userid)
        
        
        return await make_api_request(
            "PUT", 
            path, 
            data=data, 
            params=params if params else None, 
            headers=headers if headers else None
        )
    
    
    
    @mcp.tool()
    async def amebt1702_rebalincexc_using_put(
        request_body:Dict[str, Any] ,  # cryptoRebalancingIncludeExcludeResource,
        accesstoken: Optional[str] = None,
        channeltype: Optional[int] = None,
        co_relationid: Optional[int] = None,
        initiatingsystem: Optional[str] = None,
        servicemode: Optional[int] = None,
        uuidseqno: Optional[int] = None,
        entity: Optional[str] = None,
        languagecode: Optional[int] = None,
        referenceid: Optional[str] = None,
        requesthash: Optional[str] = None,
        userid: Optional[int] = None
    ) -> Dict[str, Any]:
        """
        Updation of crypto account rebalancing flag
        
        Generated from: PUT /payments/crypto/rebalance/includeExclude
        Source: swagger_2_0
        Operation ID: AMEBT1702RebalincexcUsingPUT
        
        
        Authentication: Not required
        
        Parameters:
        - request_body: any (required)
          input
        
        
        
        Headers:
        - Accesstoken: string
          Authorization token for identification of the caller
        - ChannelType: integer
          Channel identifier from where the TXN has originated (Internet, Mobile, ATM, Branch Channel )
        - Co-Relationid: integer
          Unique ID for the service invoked, will be set by the TXN system
        - InitiatingSystem: string
          Indicating the initiated system
        - ServiceMode: integer
          Used for branch channel to indicate the type of customer
        - UUIDSeqNo: integer
          UUID Sequence Number
        - entity: string
          entity
        - languageCode: integer
          languageCode
        - referenceId: string
          Place holder for Token based authentication
        - requesthash: string
          Request payload for hash validation
        - userId: integer
          userId
        
        
        """
        
        
        # Prepare request data
        
        # Single body parameter - send directly
        data = request_body if request_body is not None else {}
        
        
        
        # Prepare query parameters
        params = {}
        
        
        # Replace path parameters in URL
        path = "/payments/crypto/rebalance/includeExclude"
        
        
        # Prepare headers
        headers = {}
        if accesstoken is not None:
            headers["Accesstoken"] = str(accesstoken)
        if channeltype is not None:
            headers["ChannelType"] = str(channeltype)
        if co_relationid is not None:
            headers["Co-Relationid"] = str(co_relationid)
        if initiatingsystem is not None:
            headers["InitiatingSystem"] = str(initiatingsystem)
        if servicemode is not None:
            headers["ServiceMode"] = str(servicemode)
        if uuidseqno is not None:
            headers["UUIDSeqNo"] = str(uuidseqno)
        if entity is not None:
            headers["entity"] = str(entity)
        if languagecode is not None:
            headers["languageCode"] = str(languagecode)
        if referenceid is not None:
            headers["referenceId"] = str(referenceid)
        if requesthash is not None:
            headers["requesthash"] = str(requesthash)
        if userid is not None:
            headers["userId"] = str(userid)
        
        
        return await make_api_request(
            "PUT", 
            path, 
            data=data, 
            params=params if params else None, 
            headers=headers if headers else None
        )
    
    
    
    @mcp.tool()
    async def ameet2021_fetch_rebal_list_postusing_get(
        onbalanceaccountbalancecondition: Optional[int] = None,
        onbalanceaccountbalancetype: Optional[int] = None,
        currency: Optional[str] = None,
        customerreference: Optional[int] = None,
        onbalanceaccount: Optional[str] = None,
        onbalanceaccountbalance: Optional[float] = None,
        pagenum: Optional[int] = None,
        pagesize: Optional[int] = None,
        accesstoken: Optional[str] = None,
        channeltype: Optional[int] = None,
        co_relationid: Optional[int] = None,
        initiatingsystem: Optional[str] = None,
        servicemode: Optional[int] = None,
        uuidseqno: Optional[int] = None,
        entity: Optional[str] = None,
        languagecode: Optional[int] = None,
        referenceid: Optional[str] = None,
        userid: Optional[int] = None
    ) -> Dict[str, Any]:
        """
        List of crypto account balances
        
        Generated from: GET /payments/crypto/rebalance/list
        Source: swagger_2_0
        Operation ID: AMEET2021FetchRebalList_POSTUsingGET
        
        
        Authentication: Not required
        
        Parameters:
        - OnBalanceAccountBalanceCondition: integer
          On balance account balance 1-Above,2-Below,3-EqualTo (Domain Name: d_OnBalAcntBalance)
        - OnBalanceAccountBalanceType: integer
          On balance account balance type 1-Debit,2-Credit,3-Zero,4-All (Domain Name : d_OnBalAcntBalanceType)
        - currency: string
          Currency for crypto accounts (VND-188, JPY-189, EUR-190, USD-191, Code Name: d_CurrCode)
        - customerReference: integer
          Customer Reference of Crypto Accounts
        - onBalanceAccount: string
          Crypto On balance account IBAN
        - onBalanceAccountBalance: number
          On balance account balance
        - pageNum: integer
          pageNum
        - pageSize: integer
          pageSize
        
        
        
        Headers:
        - Accesstoken: string
          Authorization token for identification of the caller
        - ChannelType: integer
          Channel identifier from where the transaction has originated (Internet, Mobile, ATM, Branch Channel )
        - Co-Relationid: integer
          Unique ID for the service invoked, will be set by the transaction system
        - InitiatingSystem: string
          Indicating the initiated system
        - ServiceMode: integer
          Used for branch channel to indicate the type of customer
        - UUIDSeqNo: integer
          UUID Sequence Number
        - entity: string
          entity
        - languageCode: integer
          languageCode
        - referenceId: string
          Place holder for Token based authentication
        - userId: integer
          userId
        
        
        """
        
        
        # Prepare query parameters
        params = {}
        if onbalanceaccountbalancecondition is not None:
            params["OnBalanceAccountBalanceCondition"] = onbalanceaccountbalancecondition
            
        if onbalanceaccountbalancetype is not None:
            params["OnBalanceAccountBalanceType"] = onbalanceaccountbalancetype
            
        if currency is not None:
            params["currency"] = currency
            
        if customerreference is not None:
            params["customerReference"] = customerreference
            
        if onbalanceaccount is not None:
            params["onBalanceAccount"] = onbalanceaccount
            
        if onbalanceaccountbalance is not None:
            params["onBalanceAccountBalance"] = onbalanceaccountbalance
            
        if pagenum is not None:
            params["pageNum"] = pagenum
            
        if pagesize is not None:
            params["pageSize"] = pagesize
            
        
        
        # Replace path parameters in URL
        path = "/payments/crypto/rebalance/list"
        
        
        # Prepare headers
        headers = {}
        if accesstoken is not None:
            headers["Accesstoken"] = str(accesstoken)
        if channeltype is not None:
            headers["ChannelType"] = str(channeltype)
        if co_relationid is not None:
            headers["Co-Relationid"] = str(co_relationid)
        if initiatingsystem is not None:
            headers["InitiatingSystem"] = str(initiatingsystem)
        if servicemode is not None:
            headers["ServiceMode"] = str(servicemode)
        if uuidseqno is not None:
            headers["UUIDSeqNo"] = str(uuidseqno)
        if entity is not None:
            headers["entity"] = str(entity)
        if languagecode is not None:
            headers["languageCode"] = str(languagecode)
        if referenceid is not None:
            headers["referenceId"] = str(referenceid)
        if userid is not None:
            headers["userId"] = str(userid)
        
        
        return await make_api_request(
            "GET", 
            path, 
            
            params=params if params else None, 
            headers=headers if headers else None
        )
    
    
    
    @mcp.tool()
    async def amebtstaking_plac_exit_auth_postusing_post(
        orderid: int,
        ordertransactiontype: int,
        accesstoken: Optional[str] = None,
        channeltype: Optional[int] = None,
        co_relationid: Optional[int] = None,
        initiatingsystem: Optional[str] = None,
        servicemode: Optional[int] = None,
        uuidseqno: Optional[int] = None,
        entity: Optional[str] = None,
        languagecode: Optional[int] = None,
        referenceid: Optional[str] = None,
        requesthash: Optional[str] = None,
        userid: Optional[int] = None
    ) -> Dict[str, Any]:
        """
        Authorization of Staking Order
        
        Generated from: POST /payments/crypto/stakeOrder/authorize/{orderId}/{orderTransactionType}
        Source: swagger_2_0
        Operation ID: AMEBTStakingPlacExitAuth_POSTUsingPOST
        
        
        Authentication: Not required
        
        Parameters:
        - orderId: integer (required)
          Transaction reference of staking order
        - orderTransactionType: integer (required)
          Transaction type for staking order (Placement-1803, Exit-1804, Code Name: d_PosTyp)
        
        
        
        Headers:
        - Accesstoken: string
          Authorization token for identification of the caller
        - ChannelType: integer
          Channel identifier from where the TXN has originated (Internet, Mobile, ATM, Branch Channel )
        - Co-Relationid: integer
          Unique ID for the service invoked, will be set by the TXN system
        - InitiatingSystem: string
          Indicating the initiated system
        - ServiceMode: integer
          Used for branch channel to indicate the type of customer
        - UUIDSeqNo: integer
          UUID Sequence Number
        - entity: string
          entity
        - languageCode: integer
          languageCode
        - referenceId: string
          Place holder for Token based authentication
        - requesthash: string
          Request payload for hash validation
        - userId: integer
          userId
        
        
        """
        
        
        # Prepare query parameters
        params = {}
        
        
        # Replace path parameters in URL
        path = "/payments/crypto/stakeOrder/authorize/{orderId}/{orderTransactionType}"
        if orderid is not None:
            path = path.replace("{orderId}", str(orderid))
        if ordertransactiontype is not None:
            path = path.replace("{orderTransactionType}", str(ordertransactiontype))
        
        
        # Prepare headers
        headers = {}
        if accesstoken is not None:
            headers["Accesstoken"] = str(accesstoken)
        if channeltype is not None:
            headers["ChannelType"] = str(channeltype)
        if co_relationid is not None:
            headers["Co-Relationid"] = str(co_relationid)
        if initiatingsystem is not None:
            headers["InitiatingSystem"] = str(initiatingsystem)
        if servicemode is not None:
            headers["ServiceMode"] = str(servicemode)
        if uuidseqno is not None:
            headers["UUIDSeqNo"] = str(uuidseqno)
        if entity is not None:
            headers["entity"] = str(entity)
        if languagecode is not None:
            headers["languageCode"] = str(languagecode)
        if referenceid is not None:
            headers["referenceId"] = str(referenceid)
        if requesthash is not None:
            headers["requesthash"] = str(requesthash)
        if userid is not None:
            headers["userId"] = str(userid)
        
        
        return await make_api_request(
            "POST", 
            path, 
            
            params=params if params else None, 
            headers=headers if headers else None
        )
    
    
    
    @mcp.tool()
    async def ameetget_staking_account_using_get(
        customerreference: int,
        ordercurrency: str,
        stakingproductid: int,
        accesstoken: Optional[str] = None,
        channeltype: Optional[int] = None,
        co_relationid: Optional[int] = None,
        initiatingsystem: Optional[str] = None,
        servicemode: Optional[int] = None,
        uuidseqno: Optional[int] = None,
        entity: Optional[str] = None,
        languagecode: Optional[int] = None,
        referenceid: Optional[str] = None,
        userid: Optional[int] = None
    ) -> Dict[str, Any]:
        """
        Fetching of staking Account
        
        Generated from: GET /payments/crypto/stakeOrder/details/{customerReference}/{orderCurrency}/{stakingProductId}
        Source: swagger_2_0
        Operation ID: AMEETGetStakingAccountUsingGET
        
        
        Authentication: Not required
        
        Parameters:
        - customerReference: integer (required)
          Customer reference for which staking order is to be initiated
        - orderCurrency: string (required)
          Order currency is the staking currency (VND-188, JPY-189, EUR-190, USD-191, Code Name: d_CurrCode)
        - stakingProductId: integer (required)
          Product ID of the staking Account(Domain Name : d_ProductId)
        
        
        
        Headers:
        - Accesstoken: string
          Authorization token for identification of the caller
        - ChannelType: integer
          Channel identifier from where the TXN has originated (Internet, Mobile, ATM, Branch Channel )
        - Co-Relationid: integer
          Unique ID for the service invoked, will be set by the TXN system
        - InitiatingSystem: string
          Indicating the initiated system
        - ServiceMode: integer
          Used for branch channel to indicate the type of customer
        - UUIDSeqNo: integer
          UUID Sequence Number
        - entity: string
          entity
        - languageCode: integer
          languageCode
        - referenceId: string
          Place holder for Token based authentication
        - userId: integer
          userId
        
        
        """
        
        
        # Prepare query parameters
        params = {}
        
        
        # Replace path parameters in URL
        path = "/payments/crypto/stakeOrder/details/{customerReference}/{orderCurrency}/{stakingProductId}"
        if customerreference is not None:
            path = path.replace("{customerReference}", str(customerreference))
        if ordercurrency is not None:
            path = path.replace("{orderCurrency}", str(ordercurrency))
        if stakingproductid is not None:
            path = path.replace("{stakingProductId}", str(stakingproductid))
        
        
        # Prepare headers
        headers = {}
        if accesstoken is not None:
            headers["Accesstoken"] = str(accesstoken)
        if channeltype is not None:
            headers["ChannelType"] = str(channeltype)
        if co_relationid is not None:
            headers["Co-Relationid"] = str(co_relationid)
        if initiatingsystem is not None:
            headers["InitiatingSystem"] = str(initiatingsystem)
        if servicemode is not None:
            headers["ServiceMode"] = str(servicemode)
        if uuidseqno is not None:
            headers["UUIDSeqNo"] = str(uuidseqno)
        if entity is not None:
            headers["entity"] = str(entity)
        if languagecode is not None:
            headers["languageCode"] = str(languagecode)
        if referenceid is not None:
            headers["referenceId"] = str(referenceid)
        if userid is not None:
            headers["userId"] = str(userid)
        
        
        return await make_api_request(
            "GET", 
            path, 
            
            params=params if params else None, 
            headers=headers if headers else None
        )
    
    
    
    @mcp.tool()
    async def amebtstaking_plac_exit_onhld_using_post(
        request_body:Dict[str, Any] ,  # cryptoStakingOrderOnholdResource,
        accesstoken: Optional[str] = None,
        channeltype: Optional[int] = None,
        co_relationid: Optional[int] = None,
        initiatingsystem: Optional[str] = None,
        servicemode: Optional[int] = None,
        uuidseqno: Optional[int] = None,
        entity: Optional[str] = None,
        languagecode: Optional[int] = None,
        referenceid: Optional[str] = None,
        requesthash: Optional[str] = None
    ) -> Dict[str, Any]:
        """
        Initiate of staking order in onHold status 
        
        Generated from: POST /payments/crypto/stakeOrder/onHold
        Source: swagger_2_0
        Operation ID: AMEBTStakingPlacExitOnhldUsingPOST
        
        
        Authentication: Not required
        
        Parameters:
        - request_body: any (required)
          input
        
        
        
        Headers:
        - Accesstoken: string
          Authorization token for identification of the caller
        - ChannelType: integer
          Channel identifier from where the TXN has originated (Internet, Mobile, ATM, Branch Channel )
        - Co-Relationid: integer
          Unique ID for the service invoked, will be set by the TXN system
        - InitiatingSystem: string
          Indicating the initiated system
        - ServiceMode: integer
          Used for branch channel to indicate the type of customer
        - UUIDSeqNo: integer
          UUID Sequence Number
        - entity: string
          entity
        - languageCode: integer
          languageCode
        - referenceId: string
          Place holder for Token based authentication
        - requesthash: string
          Request payload for hash validation
        
        
        """
        
        
        # Prepare request data
        
        # Single body parameter - send directly
        data = request_body if request_body is not None else {}
        
        
        
        # Prepare query parameters
        params = {}
        
        
        # Replace path parameters in URL
        path = "/payments/crypto/stakeOrder/onHold"
        
        
        # Prepare headers
        headers = {}
        if accesstoken is not None:
            headers["Accesstoken"] = str(accesstoken)
        if channeltype is not None:
            headers["ChannelType"] = str(channeltype)
        if co_relationid is not None:
            headers["Co-Relationid"] = str(co_relationid)
        if initiatingsystem is not None:
            headers["InitiatingSystem"] = str(initiatingsystem)
        if servicemode is not None:
            headers["ServiceMode"] = str(servicemode)
        if uuidseqno is not None:
            headers["UUIDSeqNo"] = str(uuidseqno)
        if entity is not None:
            headers["entity"] = str(entity)
        if languagecode is not None:
            headers["languageCode"] = str(languagecode)
        if referenceid is not None:
            headers["referenceId"] = str(referenceid)
        if requesthash is not None:
            headers["requesthash"] = str(requesthash)
        
        
        return await make_api_request(
            "POST", 
            path, 
            data=data, 
            params=params if params else None, 
            headers=headers if headers else None
        )
    
    
    
    @mcp.tool()
    async def amebtstaking_plac_exit_rej_postusing_post(
        orderid: int,
        ordertransactiontype: int,
        accesstoken: Optional[str] = None,
        channeltype: Optional[int] = None,
        co_relationid: Optional[int] = None,
        initiatingsystem: Optional[str] = None,
        servicemode: Optional[int] = None,
        uuidseqno: Optional[int] = None,
        entity: Optional[str] = None,
        languagecode: Optional[int] = None,
        referenceid: Optional[str] = None,
        requesthash: Optional[str] = None,
        userid: Optional[int] = None
    ) -> Dict[str, Any]:
        """
        Rejection of Staking Order
        
        Generated from: POST /payments/crypto/stakeOrder/reject/{orderId}/{orderTransactionType}
        Source: swagger_2_0
        Operation ID: AMEBTStakingPlacExitRej_POSTUsingPOST
        
        
        Authentication: Not required
        
        Parameters:
        - orderId: integer (required)
          Transaction reference of staking order
        - orderTransactionType: integer (required)
          Transaction type for staking order (Placement-1803, Exit-1804, Code Name: d_PosTyp)
        
        
        
        Headers:
        - Accesstoken: string
          Authorization token for identification of the caller
        - ChannelType: integer
          Channel identifier from where the TXN has originated (Internet, Mobile, ATM, Branch Channel )
        - Co-Relationid: integer
          Unique ID for the service invoked, will be set by the TXN system
        - InitiatingSystem: string
          Indicating the initiated system
        - ServiceMode: integer
          Used for branch channel to indicate the type of customer
        - UUIDSeqNo: integer
          UUID Sequence Number
        - entity: string
          entity
        - languageCode: integer
          languageCode
        - referenceId: string
          Place holder for Token based authentication
        - requesthash: string
          Request payload for hash validation
        - userId: integer
          userId
        
        
        """
        
        
        # Prepare query parameters
        params = {}
        
        
        # Replace path parameters in URL
        path = "/payments/crypto/stakeOrder/reject/{orderId}/{orderTransactionType}"
        if orderid is not None:
            path = path.replace("{orderId}", str(orderid))
        if ordertransactiontype is not None:
            path = path.replace("{orderTransactionType}", str(ordertransactiontype))
        
        
        # Prepare headers
        headers = {}
        if accesstoken is not None:
            headers["Accesstoken"] = str(accesstoken)
        if channeltype is not None:
            headers["ChannelType"] = str(channeltype)
        if co_relationid is not None:
            headers["Co-Relationid"] = str(co_relationid)
        if initiatingsystem is not None:
            headers["InitiatingSystem"] = str(initiatingsystem)
        if servicemode is not None:
            headers["ServiceMode"] = str(servicemode)
        if uuidseqno is not None:
            headers["UUIDSeqNo"] = str(uuidseqno)
        if entity is not None:
            headers["entity"] = str(entity)
        if languagecode is not None:
            headers["languageCode"] = str(languagecode)
        if referenceid is not None:
            headers["referenceId"] = str(referenceid)
        if requesthash is not None:
            headers["requesthash"] = str(requesthash)
        if userid is not None:
            headers["userId"] = str(userid)
        
        
        return await make_api_request(
            "POST", 
            path, 
            
            params=params if params else None, 
            headers=headers if headers else None
        )
    
    
    
    @mcp.tool()
    async def amebtstaking_plac_exit_rel_using_post(
        request_body:Dict[str, Any] ,  # cryptoStakingOrderReleaseResource,
        accesstoken: Optional[str] = None,
        channeltype: Optional[int] = None,
        co_relationid: Optional[int] = None,
        initiatingsystem: Optional[str] = None,
        servicemode: Optional[int] = None,
        uuidseqno: Optional[int] = None,
        entity: Optional[str] = None,
        referenceid: Optional[str] = None,
        requesthash: Optional[str] = None
    ) -> Dict[str, Any]:
        """
        Initiation of staking order in release status
        
        Generated from: POST /payments/crypto/stakeOrder/release
        Source: swagger_2_0
        Operation ID: AMEBTStakingPlacExitRelUsingPOST
        
        
        Authentication: Not required
        
        Parameters:
        - request_body: any (required)
          input
        
        
        
        Headers:
        - Accesstoken: string
          Authorization token for identification of the caller
        - ChannelType: integer
          Channel identifier from where the TXN has originated (Internet, Mobile, ATM, Branch Channel )
        - Co-Relationid: integer
          Unique ID for the service invoked, will be set by the TXN system
        - InitiatingSystem: string
          Indicating the initiated system
        - ServiceMode: integer
          Used for branch channel to indicate the type of customer
        - UUIDSeqNo: integer
          UUID Sequence Number
        - entity: string
          entity
        - referenceId: string
          Place holder for Token based authentication
        - requesthash: string
          Request payload for hash validation
        
        
        """
        
        
        # Prepare request data
        
        # Single body parameter - send directly
        data = request_body if request_body is not None else {}
        
        
        
        # Prepare query parameters
        params = {}
        
        
        # Replace path parameters in URL
        path = "/payments/crypto/stakeOrder/release"
        
        
        # Prepare headers
        headers = {}
        if accesstoken is not None:
            headers["Accesstoken"] = str(accesstoken)
        if channeltype is not None:
            headers["ChannelType"] = str(channeltype)
        if co_relationid is not None:
            headers["Co-Relationid"] = str(co_relationid)
        if initiatingsystem is not None:
            headers["InitiatingSystem"] = str(initiatingsystem)
        if servicemode is not None:
            headers["ServiceMode"] = str(servicemode)
        if uuidseqno is not None:
            headers["UUIDSeqNo"] = str(uuidseqno)
        if entity is not None:
            headers["entity"] = str(entity)
        if referenceid is not None:
            headers["referenceId"] = str(referenceid)
        if requesthash is not None:
            headers["requesthash"] = str(requesthash)
        
        
        return await make_api_request(
            "POST", 
            path, 
            data=data, 
            params=params if params else None, 
            headers=headers if headers else None
        )
    
    
    
    @mcp.tool()
    async def cbpetgettransactions_by_date_using_get_1(
        transactionid: str,
        fromdate: Optional[str] = None,
        todate: Optional[str] = None,
        accountreference: Optional[str] = None,
        pagenum: Optional[int] = None,
        pagesize: Optional[int] = None,
        accesstoken: Optional[str] = None,
        channeltype: Optional[int] = None,
        co_relationid: Optional[int] = None,
        initiatingsystem: Optional[str] = None,
        servicemode: Optional[int] = None,
        uuidseqno: Optional[int] = None,
        entity: Optional[str] = None,
        languagecode: Optional[int] = None,
        referenceid: Optional[str] = None,
        userid: Optional[int] = None
    ) -> Dict[str, Any]:
        """
        Fetch Transactions By Date
        
        Generated from: GET /payments/financialAccounting/account/transactions/{transactionId}
        Source: swagger_2_0
        Operation ID: CBPETGettransactionsByDateUsingGET_1
        
        
        Authentication: Not required
        
        Parameters:
        - FromDate: string
          Enter the transaction start date(format : YYYYMMDD)
        - ToDate: string
          Enter the transaction end date(format : YYYYMMDD)
        - accountReference: string
          Enter the Account Reference
        - pageNum: integer
          pageNum
        - pageSize: integer
          pageSize
        - transactionId: string (required)
          Enter the transaction ID
        
        
        
        Headers:
        - Accesstoken: string
          Authorization token for identification of the caller
        - ChannelType: integer
          Channel identifier from where the TXN has originated (Internet, Mobile, ATM, Branch Channel )
        - Co-Relationid: integer
          Unique ID for the service invoked, will be set by the TXN system
        - InitiatingSystem: string
          Indicating the initiated system
        - ServiceMode: integer
          Used for branch channel to indicate the type of customer
        - UUIDSeqNo: integer
          UUID Sequence Number
        - entity: string
          entity
        - languageCode: integer
          languageCode
        - referenceId: string
          Place holder for Token based authentication
        - userId: integer
          userId
        
        
        """
        
        
        # Prepare query parameters
        params = {}
        if fromdate is not None:
            params["FromDate"] = fromdate
            
        if todate is not None:
            params["ToDate"] = todate
            
        if accountreference is not None:
            params["accountReference"] = accountreference
            
        if pagenum is not None:
            params["pageNum"] = pagenum
            
        if pagesize is not None:
            params["pageSize"] = pagesize
            
        
        
        # Replace path parameters in URL
        path = "/payments/financialAccounting/account/transactions/{transactionId}"
        if transactionid is not None:
            path = path.replace("{transactionId}", str(transactionid))
        
        
        # Prepare headers
        headers = {}
        if accesstoken is not None:
            headers["Accesstoken"] = str(accesstoken)
        if channeltype is not None:
            headers["ChannelType"] = str(channeltype)
        if co_relationid is not None:
            headers["Co-Relationid"] = str(co_relationid)
        if initiatingsystem is not None:
            headers["InitiatingSystem"] = str(initiatingsystem)
        if servicemode is not None:
            headers["ServiceMode"] = str(servicemode)
        if uuidseqno is not None:
            headers["UUIDSeqNo"] = str(uuidseqno)
        if entity is not None:
            headers["entity"] = str(entity)
        if languagecode is not None:
            headers["languageCode"] = str(languagecode)
        if referenceid is not None:
            headers["referenceId"] = str(referenceid)
        if userid is not None:
            headers["userId"] = str(userid)
        
        
        return await make_api_request(
            "GET", 
            path, 
            
            params=params if params else None, 
            headers=headers if headers else None
        )
    
    
    
    @mcp.tool()
    async def amebt2021_ame_wrapper_postusing_post(
        request_body:Dict[str, Any] ,  # createAuthPaymentResource,
        accesstoken: Optional[str] = None,
        channeltype: Optional[int] = None,
        co_relationid: Optional[int] = None,
        initiatingsystem: Optional[str] = None,
        servicemode: Optional[int] = None,
        uuidseqno: Optional[int] = None,
        entity: Optional[str] = None,
        languagecode: Optional[int] = None,
        referenceid: Optional[str] = None,
        requesthash: Optional[str] = None,
        userid: Optional[int] = None
    ) -> Dict[str, Any]:
        """
        Create in authorization pending status
        
        Generated from: POST /payments/fundTransfer/create
        Source: swagger_2_0
        Operation ID: AMEBT2021AmeWrapper_POSTUsingPOST
        
        
        Authentication: Not required
        
        Parameters:
        - request_body: any (required)
          input
        
        
        
        Headers:
        - Accesstoken: string
          Authorization Token to validation the caller
        - ChannelType: integer
          Channel identifier from where the TXN has originated (Internet, Mobile, ATM, Branch Channel )
        - Co-Relationid: integer
          Unique ID for the service invoked, will be set by the TXN system
        - InitiatingSystem: string
          Indicating the initiated system
        - ServiceMode: integer
          Used for branch channel to indicate the type of customer
        - UUIDSeqNo: integer
          UUID Sequence Number
        - entity: string
          entity
        - languageCode: integer
          languageCode
        - referenceId: string
          Place holder for Token based authentication
        - requesthash: string
          Request payload for hash validation
        - userId: integer
          userId
        
        
        """
        
        
        # Prepare request data
        
        # Single body parameter - send directly
        data = request_body if request_body is not None else {}
        
        
        
        # Prepare query parameters
        params = {}
        
        
        # Replace path parameters in URL
        path = "/payments/fundTransfer/create"
        
        
        # Prepare headers
        headers = {}
        if accesstoken is not None:
            headers["Accesstoken"] = str(accesstoken)
        if channeltype is not None:
            headers["ChannelType"] = str(channeltype)
        if co_relationid is not None:
            headers["Co-Relationid"] = str(co_relationid)
        if initiatingsystem is not None:
            headers["InitiatingSystem"] = str(initiatingsystem)
        if servicemode is not None:
            headers["ServiceMode"] = str(servicemode)
        if uuidseqno is not None:
            headers["UUIDSeqNo"] = str(uuidseqno)
        if entity is not None:
            headers["entity"] = str(entity)
        if languagecode is not None:
            headers["languageCode"] = str(languagecode)
        if referenceid is not None:
            headers["referenceId"] = str(referenceid)
        if requesthash is not None:
            headers["requesthash"] = str(requesthash)
        if userid is not None:
            headers["userId"] = str(userid)
        
        
        return await make_api_request(
            "POST", 
            path, 
            data=data, 
            params=params if params else None, 
            headers=headers if headers else None
        )
    
    
    
    @mcp.tool()
    async def amebt2021_vldt_ame_wrapper_postusing_post(
        request_body:Dict[str, Any] ,  # validateFundTransferResource,
        accesstoken: Optional[str] = None,
        channeltype: Optional[int] = None,
        co_relationid: Optional[int] = None,
        initiatingsystem: Optional[str] = None,
        servicemode: Optional[int] = None,
        uuidseqno: Optional[int] = None,
        entity: Optional[str] = None,
        languagecode: Optional[int] = None,
        referenceid: Optional[str] = None,
        requesthash: Optional[str] = None,
        userid: Optional[int] = None
    ) -> Dict[str, Any]:
        """
        Validate services for own account
        
        Generated from: POST /payments/fundTransfer/validate
        Source: swagger_2_0
        Operation ID: AMEBT2021VldtAmeWrapper_POSTUsingPOST
        
        
        Authentication: Not required
        
        Parameters:
        - request_body: any (required)
          input
        
        
        
        Headers:
        - Accesstoken: string
          Authorization Token to validation the caller
        - ChannelType: integer
          Channel identifier from where the TXN has originated (Internet, Mobile, ATM, Branch Channel )
        - Co-Relationid: integer
          Unique ID for the service invoked, will be set by the TXN system
        - InitiatingSystem: string
          Indicating the initiated system
        - ServiceMode: integer
          Used for branch channel to indicate the type of customer
        - UUIDSeqNo: integer
          UUID Sequence Number
        - entity: string
          entity
        - languageCode: integer
          languageCode
        - referenceId: string
          Place holder for Token based authentication
        - requesthash: string
          Request payload for hash validation
        - userId: integer
          userId
        
        
        """
        
        
        # Prepare request data
        
        # Single body parameter - send directly
        data = request_body if request_body is not None else {}
        
        
        
        # Prepare query parameters
        params = {}
        
        
        # Replace path parameters in URL
        path = "/payments/fundTransfer/validate"
        
        
        # Prepare headers
        headers = {}
        if accesstoken is not None:
            headers["Accesstoken"] = str(accesstoken)
        if channeltype is not None:
            headers["ChannelType"] = str(channeltype)
        if co_relationid is not None:
            headers["Co-Relationid"] = str(co_relationid)
        if initiatingsystem is not None:
            headers["InitiatingSystem"] = str(initiatingsystem)
        if servicemode is not None:
            headers["ServiceMode"] = str(servicemode)
        if uuidseqno is not None:
            headers["UUIDSeqNo"] = str(uuidseqno)
        if entity is not None:
            headers["entity"] = str(entity)
        if languagecode is not None:
            headers["languageCode"] = str(languagecode)
        if referenceid is not None:
            headers["referenceId"] = str(referenceid)
        if requesthash is not None:
            headers["requesthash"] = str(requesthash)
        if userid is not None:
            headers["userId"] = str(userid)
        
        
        return await make_api_request(
            "POST", 
            path, 
            data=data, 
            params=params if params else None, 
            headers=headers if headers else None
        )
    
    
    
    @mcp.tool()
    async def amebtfund_transfer_wrapper_ib_postusing_post(
        request_body:Dict[str, Any] ,  # createInternalPaymentResource,
        accesstoken: Optional[str] = None,
        channeltype: Optional[int] = None,
        co_relationid: Optional[int] = None,
        initiatingsystem: Optional[str] = None,
        servicemode: Optional[int] = None,
        uuidseqno: Optional[int] = None,
        entity: Optional[str] = None,
        languagecode: Optional[int] = None,
        referenceid: Optional[str] = None,
        requesthash: Optional[str] = None,
        userid: Optional[int] = None
    ) -> Dict[str, Any]:
        """
        Create Internal Payment Via Transfer/Cheque
        
        Generated from: POST /payments/payment
        Source: swagger_2_0
        Operation ID: AMEBTFundTransferWrapperIB_POSTUsingPOST
        
        
        Authentication: Not required
        
        Parameters:
        - request_body: any (required)
          input
        
        
        
        Headers:
        - Accesstoken: string
          Authorization Token to validation the caller
        - ChannelType: integer
          Channel identifier from where the TXN has originated (Internet, Mobile, ATM, Branch Channel )
        - Co-Relationid: integer
          Unique ID for the service invoked, will be set by the TXN system
        - InitiatingSystem: string
          Indicating the initiated system
        - ServiceMode: integer
          Used for branch channel to indicate the type of customer
        - UUIDSeqNo: integer
          UUID Sequence Number
        - entity: string
          entity
        - languageCode: integer
          languageCode
        - referenceId: string
          Place holder for Token based authentication
        - requesthash: string
          Request payload for hash validation
        - userId: integer
          userId
        
        
        """
        
        
        # Prepare request data
        
        # Single body parameter - send directly
        data = request_body if request_body is not None else {}
        
        
        
        # Prepare query parameters
        params = {}
        
        
        # Replace path parameters in URL
        path = "/payments/payment"
        
        
        # Prepare headers
        headers = {}
        if accesstoken is not None:
            headers["Accesstoken"] = str(accesstoken)
        if channeltype is not None:
            headers["ChannelType"] = str(channeltype)
        if co_relationid is not None:
            headers["Co-Relationid"] = str(co_relationid)
        if initiatingsystem is not None:
            headers["InitiatingSystem"] = str(initiatingsystem)
        if servicemode is not None:
            headers["ServiceMode"] = str(servicemode)
        if uuidseqno is not None:
            headers["UUIDSeqNo"] = str(uuidseqno)
        if entity is not None:
            headers["entity"] = str(entity)
        if languagecode is not None:
            headers["languageCode"] = str(languagecode)
        if referenceid is not None:
            headers["referenceId"] = str(referenceid)
        if requesthash is not None:
            headers["requesthash"] = str(requesthash)
        if userid is not None:
            headers["userId"] = str(userid)
        
        
        return await make_api_request(
            "POST", 
            path, 
            data=data, 
            params=params if params else None, 
            headers=headers if headers else None
        )
    
    
    
    @mcp.tool()
    async def cbcbt1003_modify_future_fund_xfer_ib_postusing_put(
        transactionid: str,
        request_body:Dict[str, Any] ,  # ModifyPayment_Resource,
        accesstoken: Optional[str] = None,
        channeltype: Optional[int] = None,
        co_relationid: Optional[int] = None,
        initiatingsystem: Optional[str] = None,
        servicemode: Optional[int] = None,
        uuidseqno: Optional[int] = None,
        entity: Optional[str] = None,
        languagecode: Optional[int] = None,
        referenceid: Optional[str] = None,
        requesthash: Optional[str] = None,
        userid: Optional[int] = None
    ) -> Dict[str, Any]:
        """
        Modify Payment
        
        Generated from: PUT /payments/payment/{transactionId}/update
        Source: swagger_2_0
        Operation ID: CBCBT1003ModifyFutureFundXferIB_POSTUsingPUT
        
        
        Authentication: Not required
        
        Parameters:
        - transactionId: string (required)
          Path parameter transactionId
        - request_body: any (required)
          input
        
        
        
        Headers:
        - Accesstoken: string
          Authorization Token to validation the caller
        - ChannelType: integer
          Channel identifier from where the TXN has originated (Internet, Mobile, ATM, Branch Channel )
        - Co-Relationid: integer
          Unique ID for the service invoked, will be set by the TXN system
        - InitiatingSystem: string
          Indicating the initiated system
        - ServiceMode: integer
          Used for branch channel to indicate the type of customer
        - UUIDSeqNo: integer
          UUID Sequence Number
        - entity: string
          entity
        - languageCode: integer
          languageCode
        - referenceId: string
          Place holder for Token based authentication
        - requesthash: string
          Request payload for hash validation
        - userId: integer
          userId
        
        
        """
        
        
        # Prepare request data
        
        # Single body parameter - send directly
        data = request_body if request_body is not None else {}
        
        
        
        # Prepare query parameters
        params = {}
        
        
        # Replace path parameters in URL
        path = "/payments/payment/{transactionId}/update"
        if transactionid is not None:
            path = path.replace("{transactionId}", str(transactionid))
        
        
        # Prepare headers
        headers = {}
        if accesstoken is not None:
            headers["Accesstoken"] = str(accesstoken)
        if channeltype is not None:
            headers["ChannelType"] = str(channeltype)
        if co_relationid is not None:
            headers["Co-Relationid"] = str(co_relationid)
        if initiatingsystem is not None:
            headers["InitiatingSystem"] = str(initiatingsystem)
        if servicemode is not None:
            headers["ServiceMode"] = str(servicemode)
        if uuidseqno is not None:
            headers["UUIDSeqNo"] = str(uuidseqno)
        if entity is not None:
            headers["entity"] = str(entity)
        if languagecode is not None:
            headers["languageCode"] = str(languagecode)
        if referenceid is not None:
            headers["referenceId"] = str(referenceid)
        if requesthash is not None:
            headers["requesthash"] = str(requesthash)
        if userid is not None:
            headers["userId"] = str(userid)
        
        
        return await make_api_request(
            "PUT", 
            path, 
            data=data, 
            params=params if params else None, 
            headers=headers if headers else None
        )
    
    
    
    @mcp.tool()
    async def amebt1601_updt_ametxn_postusing_post(
        transactionid: str,
        request_body:Dict[str, Any] ,  # ModifyingAmeFeatureddateResource,
        accesstoken: Optional[str] = None,
        channeltype: Optional[int] = None,
        co_relationid: Optional[int] = None,
        initiatingsystem: Optional[str] = None,
        servicemode: Optional[int] = None,
        uuidseqno: Optional[int] = None,
        entity: Optional[str] = None,
        languagecode: Optional[int] = None,
        referenceid: Optional[str] = None,
        requesthash: Optional[str] = None,
        userid: Optional[int] = None
    ) -> Dict[str, Any]:
        """
        Modification of featured dates
        
        Generated from: POST /payments/payment/{transactionId}/update/modify
        Source: swagger_2_0
        Operation ID: AMEBT1601UpdtAMETxn_POSTUsingPOST
        
        
        Authentication: Not required
        
        Parameters:
        - transactionId: string (required)
          Path parameter transactionId
        - request_body: any (required)
          input
        
        
        
        Headers:
        - Accesstoken: string
          Authorization token for identification of the caller
        - ChannelType: integer
          Channel identifier from where the TXN has originated (Internet, Mobile, ATM, Branch Channel )
        - Co-Relationid: integer
          Unique ID for the service invoked, will be set by the TXN system
        - InitiatingSystem: string
          Indicating the initiated system
        - ServiceMode: integer
          Used for branch channel to indicate the type of customer
        - UUIDSeqNo: integer
          UUID Sequence Number
        - entity: string
          entity
        - languageCode: integer
          languageCode
        - referenceId: string
          Place holder for Token based authentication
        - requesthash: string
          Request payload for hash validation
        - userId: integer
          userId
        
        
        """
        
        
        # Prepare request data
        
        # Single body parameter - send directly
        data = request_body if request_body is not None else {}
        
        
        
        # Prepare query parameters
        params = {}
        
        
        # Replace path parameters in URL
        path = "/payments/payment/{transactionId}/update/modify"
        if transactionid is not None:
            path = path.replace("{transactionId}", str(transactionid))
        
        
        # Prepare headers
        headers = {}
        if accesstoken is not None:
            headers["Accesstoken"] = str(accesstoken)
        if channeltype is not None:
            headers["ChannelType"] = str(channeltype)
        if co_relationid is not None:
            headers["Co-Relationid"] = str(co_relationid)
        if initiatingsystem is not None:
            headers["InitiatingSystem"] = str(initiatingsystem)
        if servicemode is not None:
            headers["ServiceMode"] = str(servicemode)
        if uuidseqno is not None:
            headers["UUIDSeqNo"] = str(uuidseqno)
        if entity is not None:
            headers["entity"] = str(entity)
        if languagecode is not None:
            headers["languageCode"] = str(languagecode)
        if referenceid is not None:
            headers["referenceId"] = str(referenceid)
        if requesthash is not None:
            headers["requesthash"] = str(requesthash)
        if userid is not None:
            headers["userId"] = str(userid)
        
        
        return await make_api_request(
            "POST", 
            path, 
            data=data, 
            params=params if params else None, 
            headers=headers if headers else None
        )
    
    
    
    @mcp.tool()
    async def cbcbt1004_cancel_future_fund_xfer_ib_postusing_delete(
        transactionid: int,
        transactiontype: int,
        accesstoken: Optional[str] = None,
        channeltype: Optional[int] = None,
        co_relationid: Optional[int] = None,
        initiatingsystem: Optional[str] = None,
        servicemode: Optional[int] = None,
        uuidseqno: Optional[int] = None,
        entity: Optional[str] = None,
        languagecode: Optional[int] = None,
        referenceid: Optional[str] = None,
        requesthash: Optional[str] = None,
        userid: Optional[int] = None
    ) -> Dict[str, Any]:
        """
        Cancel Payment
        
        Generated from: DELETE /payments/payment/{transactionId}/{transactionType}/cancel
        Source: swagger_2_0
        Operation ID: CBCBT1004CancelFutureFundXferIB_POSTUsingDELETE
        
        
        Authentication: Not required
        
        Parameters:
        - transactionId: integer (required)
          Enter the ID of transfer to be cancelled
        - transactionType: integer (required)
          Enter the type of transfer to be cancelled (126-AME)
        
        
        
        Headers:
        - Accesstoken: string
          Authorization Token to validation the caller
        - ChannelType: integer
          Channel identifier from where the TXN has originated (Internet, Mobile, ATM, Branch Channel )
        - Co-Relationid: integer
          Unique ID for the service invoked, will be set by the TXN system
        - InitiatingSystem: string
          Indicating the initiated system
        - ServiceMode: integer
          Used for branch channel to indicate the type of customer
        - UUIDSeqNo: integer
          UUID Sequence Number
        - entity: string
          entity
        - languageCode: integer
          languageCode
        - referenceId: string
          Place holder for Token based authentication
        - requesthash: string
          Request payload for hash validation
        - userId: integer
          userId
        
        
        """
        
        
        # Prepare query parameters
        params = {}
        
        
        # Replace path parameters in URL
        path = "/payments/payment/{transactionId}/{transactionType}/cancel"
        if transactionid is not None:
            path = path.replace("{transactionId}", str(transactionid))
        if transactiontype is not None:
            path = path.replace("{transactionType}", str(transactiontype))
        
        
        # Prepare headers
        headers = {}
        if accesstoken is not None:
            headers["Accesstoken"] = str(accesstoken)
        if channeltype is not None:
            headers["ChannelType"] = str(channeltype)
        if co_relationid is not None:
            headers["Co-Relationid"] = str(co_relationid)
        if initiatingsystem is not None:
            headers["InitiatingSystem"] = str(initiatingsystem)
        if servicemode is not None:
            headers["ServiceMode"] = str(servicemode)
        if uuidseqno is not None:
            headers["UUIDSeqNo"] = str(uuidseqno)
        if entity is not None:
            headers["entity"] = str(entity)
        if languagecode is not None:
            headers["languageCode"] = str(languagecode)
        if referenceid is not None:
            headers["referenceId"] = str(referenceid)
        if requesthash is not None:
            headers["requesthash"] = str(requesthash)
        if userid is not None:
            headers["userId"] = str(userid)
        
        
        return await make_api_request(
            "DELETE", 
            path, 
            
            params=params if params else None, 
            headers=headers if headers else None
        )
    
    
    
    @mcp.tool()
    async def cbcet1001_future_fund_xfer_list_ib_postusing_get(
        accountreference: Optional[str] = None,
        amountfrom: Optional[float] = None,
        amountto: Optional[float] = None,
        customerid: Optional[int] = None,
        identifiertype: Optional[int] = None,
        identifiervalue: Optional[str] = None,
        transactionpurpose: Optional[int] = None,
        transactionstatus: Optional[int] = None,
        transfertype: Optional[str] = None,
        extensibilitymap: Optional[str] = None,
        pagenum: Optional[int] = None,
        pagesize: Optional[int] = None,
        accesstoken: Optional[str] = None,
        channeltype: Optional[int] = None,
        co_relationid: Optional[int] = None,
        initiatingsystem: Optional[str] = None,
        servicemode: Optional[int] = None,
        uuidseqno: Optional[int] = None,
        entity: Optional[str] = None,
        languagecode: Optional[int] = None,
        referenceid: Optional[str] = None,
        userid: Optional[int] = None
    ) -> Dict[str, Any]:
        """
        Fetch Payment List
        
        Generated from: GET /payments/payments/paymentList
        Source: swagger_2_0
        Operation ID: CBCET1001FutureFundXferListIB_POSTUsingGET
        
        
        Authentication: Not required
        
        Parameters:
        - AccountReference: string
          Account Reference
        - AmountFrom: number
          Amount From [Note :- If Amount From is given then Amount To is Mandatory ]
        - AmountTo: number
          Amount To
        - CustomerID: integer
          Customer ID
        - IdentifierType: integer
          Identifier Type
        - IdentifierValue: string
          Identifier Value
        - TransactionPurpose: integer
          Transaction Purpose [1029-Customer Initiated Request : 1050-Internal Adjustment : 1028-Other Purpose : 1055-Paper Remittance Payment : 1035-Salary Payment] (Domain Name: d_AMETxnType)
        - TransactionStatus: integer
          Transaction Status [Domain : d_PmntOrdStat] Ex : 2-Verified , 3-Authorised , 6-Cancelled , 21-ExeAwaited
        - TransferType: string
          Enter the TransferType either Own Account Transfer or Other Account Transfer
        - extensibilityMap: string
          Custom key - value pair of attributes for extensibility enablement
        - pageNum: integer
          pageNum
        - pageSize: integer
          pageSize
        
        
        
        Headers:
        - Accesstoken: string
          Authorization Token to validation the caller
        - ChannelType: integer
          Channel identifier from where the TXN has originated (Internet, Mobile, ATM, Branch Channel )
        - Co-Relationid: integer
          Unique ID for the service invoked, will be set by the TXN system
        - InitiatingSystem: string
          Indicating the initiated system
        - ServiceMode: integer
          Used for branch channel to indicate the type of customer
        - UUIDSeqNo: integer
          UUID Sequence Number
        - entity: string
          entity
        - languageCode: integer
          languageCode
        - referenceId: string
          Place holder for Token based authentication
        - userId: integer
          userId
        
        
        """
        
        
        # Prepare query parameters
        params = {}
        if accountreference is not None:
            params["AccountReference"] = accountreference
            
        if amountfrom is not None:
            params["AmountFrom"] = amountfrom
            
        if amountto is not None:
            params["AmountTo"] = amountto
            
        if customerid is not None:
            params["CustomerID"] = customerid
            
        if identifiertype is not None:
            params["IdentifierType"] = identifiertype
            
        if identifiervalue is not None:
            params["IdentifierValue"] = identifiervalue
            
        if transactionpurpose is not None:
            params["TransactionPurpose"] = transactionpurpose
            
        if transactionstatus is not None:
            params["TransactionStatus"] = transactionstatus
            
        if transfertype is not None:
            params["TransferType"] = transfertype
            
        if extensibilitymap is not None:
            params["extensibilityMap"] = extensibilitymap
            
        if pagenum is not None:
            params["pageNum"] = pagenum
            
        if pagesize is not None:
            params["pageSize"] = pagesize
            
        
        
        # Replace path parameters in URL
        path = "/payments/payments/paymentList"
        
        
        # Prepare headers
        headers = {}
        if accesstoken is not None:
            headers["Accesstoken"] = str(accesstoken)
        if channeltype is not None:
            headers["ChannelType"] = str(channeltype)
        if co_relationid is not None:
            headers["Co-Relationid"] = str(co_relationid)
        if initiatingsystem is not None:
            headers["InitiatingSystem"] = str(initiatingsystem)
        if servicemode is not None:
            headers["ServiceMode"] = str(servicemode)
        if uuidseqno is not None:
            headers["UUIDSeqNo"] = str(uuidseqno)
        if entity is not None:
            headers["entity"] = str(entity)
        if languagecode is not None:
            headers["languageCode"] = str(languagecode)
        if referenceid is not None:
            headers["referenceId"] = str(referenceid)
        if userid is not None:
            headers["userId"] = str(userid)
        
        
        return await make_api_request(
            "GET", 
            path, 
            
            params=params if params else None, 
            headers=headers if headers else None
        )
    
    
    
    @mcp.tool()
    async def faet1708_fetch_benefit_acnt_bal_postusing_get(
        accountiban: Optional[str] = None,
        accountreference: Optional[str] = None,
        bbannumber: Optional[str] = None,
        cryptogram: Optional[str] = None,
        requestid: Optional[str] = None,
        channeltype: Optional[int] = None,
        co_relationid: Optional[int] = None,
        initiatingsystem: Optional[str] = None,
        servicemode: Optional[int] = None,
        uuidseqno: Optional[int] = None,
        entity: Optional[str] = None,
        languagecode: Optional[int] = None,
        userid: Optional[int] = None
    ) -> Dict[str, Any]:
        """
        Account details which are registered through benefit Pay
        
        Generated from: GET /payments/payments/payments/benefitPay
        Source: swagger_2_0
        Operation ID: FAET1708FetchBenefitAcntBal_POSTUsingGET
        
        
        Authentication: Not required
        
        Parameters:
        - accountIban: string
          IBAN Number generated for account based on the configured scheme
        - accountReference: string
          Reference Number generated for account based on the configured scheme
        - bbanNumber: string
          BBAN Number generated for account based on the configured scheme
        - cryptogram: string
          Crptogram generated for account based on the configured scheme
        - requestId: string
          Request ID generated for account based on the configured scheme
        
        
        
        Headers:
        - ChannelType: integer
          Channel identifier from where the TXN has originated (Internet, Mobile, ATM, Branch Channel )
        - Co-Relationid: integer
          Unique ID for the service invoked, will be set by the TXN system
        - InitiatingSystem: string
          Indicating the initiated system
        - ServiceMode: integer
          Used for branch channel to indicate the type of customer
        - UUIDSeqNo: integer
          UUID Sequence Number
        - entity: string
          entity
        - languageCode: integer
          languageCode
        - userId: integer
          userId
        
        
        """
        
        
        # Prepare query parameters
        params = {}
        if accountiban is not None:
            params["accountIban"] = accountiban
            
        if accountreference is not None:
            params["accountReference"] = accountreference
            
        if bbannumber is not None:
            params["bbanNumber"] = bbannumber
            
        if cryptogram is not None:
            params["cryptogram"] = cryptogram
            
        if requestid is not None:
            params["requestId"] = requestid
            
        
        
        # Replace path parameters in URL
        path = "/payments/payments/payments/benefitPay"
        
        
        # Prepare headers
        headers = {}
        if channeltype is not None:
            headers["ChannelType"] = str(channeltype)
        if co_relationid is not None:
            headers["Co-Relationid"] = str(co_relationid)
        if initiatingsystem is not None:
            headers["InitiatingSystem"] = str(initiatingsystem)
        if servicemode is not None:
            headers["ServiceMode"] = str(servicemode)
        if uuidseqno is not None:
            headers["UUIDSeqNo"] = str(uuidseqno)
        if entity is not None:
            headers["entity"] = str(entity)
        if languagecode is not None:
            headers["languageCode"] = str(languagecode)
        if userid is not None:
            headers["userId"] = str(userid)
        
        
        return await make_api_request(
            "GET", 
            path, 
            
            params=params if params else None, 
            headers=headers if headers else None
        )
    
    
    
    @mcp.tool()
    async def cbcet1002_view_future_fund_xfer_ib_postusing_get(
        transactionid: int,
        accesstoken: Optional[str] = None,
        channeltype: Optional[int] = None,
        co_relationid: Optional[int] = None,
        initiatingsystem: Optional[str] = None,
        servicemode: Optional[int] = None,
        uuidseqno: Optional[int] = None,
        entity: Optional[str] = None,
        languagecode: Optional[int] = None,
        referenceid: Optional[str] = None,
        userid: Optional[int] = None
    ) -> Dict[str, Any]:
        """
        Fetch Payment Details
        
        Generated from: GET /payments/payments/{transactionId}
        Source: swagger_2_0
        Operation ID: CBCET1002ViewFutureFundXferIB_POSTUsingGET
        
        
        Authentication: Not required
        
        Parameters:
        - transactionId: integer (required)
          Enter the transaction ID
        
        
        
        Headers:
        - Accesstoken: string
          Authorization Token to validation the caller
        - ChannelType: integer
          Channel identifier from where the TXN has originated (Internet, Mobile, ATM, Branch Channel )
        - Co-Relationid: integer
          Unique ID for the service invoked, will be set by the TXN system
        - InitiatingSystem: string
          Indicating the initiated system
        - ServiceMode: integer
          Used for branch channel to indicate the type of customer
        - UUIDSeqNo: integer
          UUID Sequence Number
        - entity: string
          entity
        - languageCode: integer
          languageCode
        - referenceId: string
          Place holder for Token based authentication
        - userId: integer
          userId
        
        
        """
        
        
        # Prepare query parameters
        params = {}
        
        
        # Replace path parameters in URL
        path = "/payments/payments/{transactionId}"
        if transactionid is not None:
            path = path.replace("{transactionId}", str(transactionid))
        
        
        # Prepare headers
        headers = {}
        if accesstoken is not None:
            headers["Accesstoken"] = str(accesstoken)
        if channeltype is not None:
            headers["ChannelType"] = str(channeltype)
        if co_relationid is not None:
            headers["Co-Relationid"] = str(co_relationid)
        if initiatingsystem is not None:
            headers["InitiatingSystem"] = str(initiatingsystem)
        if servicemode is not None:
            headers["ServiceMode"] = str(servicemode)
        if uuidseqno is not None:
            headers["UUIDSeqNo"] = str(uuidseqno)
        if entity is not None:
            headers["entity"] = str(entity)
        if languagecode is not None:
            headers["languageCode"] = str(languagecode)
        if referenceid is not None:
            headers["referenceId"] = str(referenceid)
        if userid is not None:
            headers["userId"] = str(userid)
        
        
        return await make_api_request(
            "GET", 
            path, 
            
            params=params if params else None, 
            headers=headers if headers else None
        )
    
    
    
    @mcp.tool()
    async def amebt1603_auth_ametxn_postusing_post(
        transactionid: int,
        transactiontype: int,
        accesstoken: Optional[str] = None,
        channeltype: Optional[int] = None,
        co_relationid: Optional[int] = None,
        initiatingsystem: Optional[str] = None,
        servicemode: Optional[int] = None,
        uuidseqno: Optional[int] = None,
        entity: Optional[str] = None,
        languagecode: Optional[int] = None,
        referenceid: Optional[str] = None,
        userid: Optional[int] = None
    ) -> Dict[str, Any]:
        """
        Authorization Of Fund Transfer
        
        Generated from: POST /payments/transfers/authorize/{transactionId}/{transactionType}
        Source: swagger_2_0
        Operation ID: AMEBT1603AuthAMETxn_POSTUsingPOST
        
        
        Authentication: Not required
        
        Parameters:
        - transactionId: integer (required)
          Unique Transaction ID generated by Bancs
        - transactionType: integer (required)
          Type of the transaction initiated by the customer
        
        
        
        Headers:
        - Accesstoken: string
          Authorization token for identification of the caller
        - ChannelType: integer
          Channel identifier from where the TXN has originated (Internet, Mobile, ATM, Branch Channel )
        - Co-Relationid: integer
          Unique ID for the service invoked, will be set by the TXN system
        - InitiatingSystem: string
          Indicating the initiated system
        - ServiceMode: integer
          Used for branch channel to indicate the type of customer
        - UUIDSeqNo: integer
          UUID Sequence Number
        - entity: string
          entity
        - languageCode: integer
          languageCode
        - referenceId: string
          Place holder for Token based authentication
        - userId: integer
          userId
        
        
        """
        
        
        # Prepare query parameters
        params = {}
        
        
        # Replace path parameters in URL
        path = "/payments/transfers/authorize/{transactionId}/{transactionType}"
        if transactionid is not None:
            path = path.replace("{transactionId}", str(transactionid))
        if transactiontype is not None:
            path = path.replace("{transactionType}", str(transactiontype))
        
        
        # Prepare headers
        headers = {}
        if accesstoken is not None:
            headers["Accesstoken"] = str(accesstoken)
        if channeltype is not None:
            headers["ChannelType"] = str(channeltype)
        if co_relationid is not None:
            headers["Co-Relationid"] = str(co_relationid)
        if initiatingsystem is not None:
            headers["InitiatingSystem"] = str(initiatingsystem)
        if servicemode is not None:
            headers["ServiceMode"] = str(servicemode)
        if uuidseqno is not None:
            headers["UUIDSeqNo"] = str(uuidseqno)
        if entity is not None:
            headers["entity"] = str(entity)
        if languagecode is not None:
            headers["languageCode"] = str(languagecode)
        if referenceid is not None:
            headers["referenceId"] = str(referenceid)
        if userid is not None:
            headers["userId"] = str(userid)
        
        
        return await make_api_request(
            "POST", 
            path, 
            
            params=params if params else None, 
            headers=headers if headers else None
        )
    
    
    
    @mcp.tool()
    async def ameet1612_fetch_ametxn_list_postusing_get_1(
        daterangesearch: Optional[int] = None,
        customerreference: Optional[int] = None,
        executiondate: Optional[str] = None,
        initiatingaccount: Optional[str] = None,
        orderingsystem: Optional[int] = None,
        pagenum: Optional[int] = None,
        pagesize: Optional[int] = None,
        paymentpurpose: Optional[int] = None,
        status: Optional[int] = None,
        transactiondate: Optional[str] = None,
        transactiondatefrom: Optional[str] = None,
        transactiondateto: Optional[str] = None,
        transactionreference: Optional[int] = None,
        transactionsource: Optional[str] = None,
        valuedate: Optional[str] = None,
        accesstoken: Optional[str] = None,
        channeltype: Optional[int] = None,
        co_relationid: Optional[int] = None,
        initiatingsystem: Optional[str] = None,
        servicemode: Optional[int] = None,
        uuidseqno: Optional[int] = None,
        entity: Optional[str] = None,
        languagecode: Optional[int] = None,
        referenceid: Optional[str] = None,
        userid: Optional[int] = None
    ) -> Dict[str, Any]:
        """
        Fetch Fund  Transfer List
        
        Generated from: GET /payments/transfers/list
        Source: swagger_2_0
        Operation ID: AMEET1612FetchAMETxnList_POSTUsingGET_1
        
        
        Authentication: Not required
        
        Parameters:
        - DateRangeSearch: integer
          Iniating Date Range Search 1-Yes, 2-No
        - customerReference: integer
          This field describes the customer reference
        - executionDate: string
          Execution Date(Date Format:YYYYMMDD)
        - initiatingAccount: string
          Add Initiating account
        - orderingSystem: integer
          Ordering system of the Transactionor Sub system of the transaction(Domain Name: d_OSId ) Eg : 27-Mobile, 28-Branch, 29-BTCS_SYSTEM, 26-NetBanking
        - pageNum: integer
          pageNum
        - pageSize: integer
          pageSize
        - paymentPurpose: integer
          Transaction Type Manual-1035, Fee-1094,Withdrawl -1095,Deposit -1096(Domain Name:d_AMETxnType)
        - status: integer
          Transaction Status AuthAwaited-22,Executed-23,Blocked-24,Authorized-3,Awaiting Authorization-1514,Rejected-4,Released-7,Execution Awaited-721,Pending Execution-1702,onHold-8(Domain Name:d_PmntOrdStat)
        - transactionDate: string
          Transaction Date(Date Format:YYYYMMDD)
        - transactionDateFrom: string
          Transaction Date From (Date format:YYYYMMDD)
        - transactionDateTo: string
          Transaction Date To (Date format:YYYYMMDD)
        - transactionReference: integer
          Unique reference generated in BaNCS
        - transactionSource: string
          Source system of the Transaction(Domain Name: d_BCServiceMode ) Eg : 12-WalkIn, 13-PasserBy, 1-InPersn, 16-Messenger
        - valueDate: string
          Value Date(Date Format:YYYYMMDD)
        
        
        
        Headers:
        - Accesstoken: string
          Authorization token for identification of the caller
        - ChannelType: integer
          Channel identifier from where the TXN has originated (Internet, Mobile, ATM, Branch Channel )
        - Co-Relationid: integer
          Unique ID for the service invoked, will be set by the TXN system
        - InitiatingSystem: string
          Indicating the initiated system
        - ServiceMode: integer
          Used for branch channel to indicate the type of customer
        - UUIDSeqNo: integer
          UUID Sequence Number
        - entity: string
          entity
        - languageCode: integer
          languageCode
        - referenceId: string
          Place holder for Token based authentication
        - userId: integer
          userId
        
        
        """
        
        
        # Prepare query parameters
        params = {}
        if daterangesearch is not None:
            params["DateRangeSearch"] = daterangesearch
            
        if customerreference is not None:
            params["customerReference"] = customerreference
            
        if executiondate is not None:
            params["executionDate"] = executiondate
            
        if initiatingaccount is not None:
            params["initiatingAccount"] = initiatingaccount
            
        if orderingsystem is not None:
            params["orderingSystem"] = orderingsystem
            
        if pagenum is not None:
            params["pageNum"] = pagenum
            
        if pagesize is not None:
            params["pageSize"] = pagesize
            
        if paymentpurpose is not None:
            params["paymentPurpose"] = paymentpurpose
            
        if status is not None:
            params["status"] = status
            
        if transactiondate is not None:
            params["transactionDate"] = transactiondate
            
        if transactiondatefrom is not None:
            params["transactionDateFrom"] = transactiondatefrom
            
        if transactiondateto is not None:
            params["transactionDateTo"] = transactiondateto
            
        if transactionreference is not None:
            params["transactionReference"] = transactionreference
            
        if transactionsource is not None:
            params["transactionSource"] = transactionsource
            
        if valuedate is not None:
            params["valueDate"] = valuedate
            
        
        
        # Replace path parameters in URL
        path = "/payments/transfers/list"
        
        
        # Prepare headers
        headers = {}
        if accesstoken is not None:
            headers["Accesstoken"] = str(accesstoken)
        if channeltype is not None:
            headers["ChannelType"] = str(channeltype)
        if co_relationid is not None:
            headers["Co-Relationid"] = str(co_relationid)
        if initiatingsystem is not None:
            headers["InitiatingSystem"] = str(initiatingsystem)
        if servicemode is not None:
            headers["ServiceMode"] = str(servicemode)
        if uuidseqno is not None:
            headers["UUIDSeqNo"] = str(uuidseqno)
        if entity is not None:
            headers["entity"] = str(entity)
        if languagecode is not None:
            headers["languageCode"] = str(languagecode)
        if referenceid is not None:
            headers["referenceId"] = str(referenceid)
        if userid is not None:
            headers["userId"] = str(userid)
        
        
        return await make_api_request(
            "GET", 
            path, 
            
            params=params if params else None, 
            headers=headers if headers else None
        )
    
    
    
    @mcp.tool()
    async def amebt1609_png_cncl_ametxn_postusing_post(
        transactionid: int,
        transactiontype: int,
        accesstoken: Optional[str] = None,
        channeltype: Optional[int] = None,
        co_relationid: Optional[int] = None,
        initiatingsystem: Optional[str] = None,
        servicemode: Optional[int] = None,
        uuidseqno: Optional[int] = None,
        entity: Optional[str] = None,
        languagecode: Optional[int] = None,
        referenceid: Optional[str] = None,
        userid: Optional[int] = None
    ) -> Dict[str, Any]:
        """
        Cancel Modify future Date
        
        Generated from: POST /payments/transfers/pendingcancel/{transactionId}/{transactionType}
        Source: swagger_2_0
        Operation ID: AMEBT1609PngCnclAMETxn_POSTUsingPOST
        
        
        Authentication: Not required
        
        Parameters:
        - transactionId: integer (required)
          Unique Transaction ID generated by Bancs
        - transactionType: integer (required)
          Type of the transaction initiated by the customer
        
        
        
        Headers:
        - Accesstoken: string
          Authorization token for identification of the caller
        - ChannelType: integer
          Channel identifier from where the TXN has originated (Internet, Mobile, ATM, Branch Channel )
        - Co-Relationid: integer
          Unique ID for the service invoked, will be set by the TXN system
        - InitiatingSystem: string
          Indicating the initiated system
        - ServiceMode: integer
          Used for branch channel to indicate the type of customer
        - UUIDSeqNo: integer
          UUID Sequence Number
        - entity: string
          entity
        - languageCode: integer
          languageCode
        - referenceId: string
          Place holder for Token based authentication
        - userId: integer
          userId
        
        
        """
        
        
        # Prepare query parameters
        params = {}
        
        
        # Replace path parameters in URL
        path = "/payments/transfers/pendingcancel/{transactionId}/{transactionType}"
        if transactionid is not None:
            path = path.replace("{transactionId}", str(transactionid))
        if transactiontype is not None:
            path = path.replace("{transactionType}", str(transactiontype))
        
        
        # Prepare headers
        headers = {}
        if accesstoken is not None:
            headers["Accesstoken"] = str(accesstoken)
        if channeltype is not None:
            headers["ChannelType"] = str(channeltype)
        if co_relationid is not None:
            headers["Co-Relationid"] = str(co_relationid)
        if initiatingsystem is not None:
            headers["InitiatingSystem"] = str(initiatingsystem)
        if servicemode is not None:
            headers["ServiceMode"] = str(servicemode)
        if uuidseqno is not None:
            headers["UUIDSeqNo"] = str(uuidseqno)
        if entity is not None:
            headers["entity"] = str(entity)
        if languagecode is not None:
            headers["languageCode"] = str(languagecode)
        if referenceid is not None:
            headers["referenceId"] = str(referenceid)
        if userid is not None:
            headers["userId"] = str(userid)
        
        
        return await make_api_request(
            "POST", 
            path, 
            
            params=params if params else None, 
            headers=headers if headers else None
        )
    
    
    
    @mcp.tool()
    async def amebt1610_cncl_ametxn_postusing_post(
        transactionid: int,
        transactiontype: int,
        verauthflag: int,
        accesstoken: Optional[str] = None,
        channeltype: Optional[int] = None,
        co_relationid: Optional[int] = None,
        initiatingsystem: Optional[str] = None,
        servicemode: Optional[int] = None,
        uuidseqno: Optional[int] = None,
        entity: Optional[str] = None,
        languagecode: Optional[int] = None,
        referenceid: Optional[str] = None,
        userid: Optional[int] = None
    ) -> Dict[str, Any]:
        """
        Rejection Of Fund Transfer
        
        Generated from: POST /payments/transfers/reject/{transactionId}/{transactionType}/{verAuthFlag}
        Source: swagger_2_0
        Operation ID: AMEBT1610CnclAMETxn_POSTUsingPOST
        
        
        Authentication: Not required
        
        Parameters:
        - transactionId: integer (required)
          Unique Transaction ID generated by Bancs
        - transactionType: integer (required)
          Type of the transaction initiated by the customer
        - verAuthFlag: integer (required)
          Authorization flag is used to aprove or reject the transaction
        
        
        
        Headers:
        - Accesstoken: string
          Authorization token for identification of the caller
        - ChannelType: integer
          Channel identifier from where the TXN has originated (Internet, Mobile, ATM, Branch Channel )
        - Co-Relationid: integer
          Unique ID for the service invoked, will be set by the TXN system
        - InitiatingSystem: string
          Indicating the initiated system
        - ServiceMode: integer
          Used for branch channel to indicate the type of customer
        - UUIDSeqNo: integer
          UUID Sequence Number
        - entity: string
          entity
        - languageCode: integer
          languageCode
        - referenceId: string
          Place holder for Token based authentication
        - userId: integer
          userId
        
        
        """
        
        
        # Prepare query parameters
        params = {}
        
        
        # Replace path parameters in URL
        path = "/payments/transfers/reject/{transactionId}/{transactionType}/{verAuthFlag}"
        if transactionid is not None:
            path = path.replace("{transactionId}", str(transactionid))
        if transactiontype is not None:
            path = path.replace("{transactionType}", str(transactiontype))
        if verauthflag is not None:
            path = path.replace("{verAuthFlag}", str(verauthflag))
        
        
        # Prepare headers
        headers = {}
        if accesstoken is not None:
            headers["Accesstoken"] = str(accesstoken)
        if channeltype is not None:
            headers["ChannelType"] = str(channeltype)
        if co_relationid is not None:
            headers["Co-Relationid"] = str(co_relationid)
        if initiatingsystem is not None:
            headers["InitiatingSystem"] = str(initiatingsystem)
        if servicemode is not None:
            headers["ServiceMode"] = str(servicemode)
        if uuidseqno is not None:
            headers["UUIDSeqNo"] = str(uuidseqno)
        if entity is not None:
            headers["entity"] = str(entity)
        if languagecode is not None:
            headers["languageCode"] = str(languagecode)
        if referenceid is not None:
            headers["referenceId"] = str(referenceid)
        if userid is not None:
            headers["userId"] = str(userid)
        
        
        return await make_api_request(
            "POST", 
            path, 
            
            params=params if params else None, 
            headers=headers if headers else None
        )
    
    
    
    @mcp.tool()
    async def ameet1612_fetch_ameleg_txn_list_using_get_1(
        externalreference: Optional[str] = None,
        destinationaccount: Optional[str] = None,
        destinationcustomerref: Optional[int] = None,
        executiondate: Optional[str] = None,
        initiatingaccount: Optional[str] = None,
        initiatingcustomerref: Optional[int] = None,
        orderingsystem: Optional[int] = None,
        pagenum: Optional[int] = None,
        pagesize: Optional[int] = None,
        status: Optional[int] = None,
        transactiondate: Optional[str] = None,
        transactiondatefrom: Optional[str] = None,
        transactiondateto: Optional[str] = None,
        transactionref: Optional[int] = None,
        accesstoken: Optional[str] = None,
        channeltype: Optional[int] = None,
        co_relationid: Optional[int] = None,
        initiatingsystem: Optional[str] = None,
        servicemode: Optional[int] = None,
        uuidseqno: Optional[int] = None,
        entity: Optional[str] = None,
        languagecode: Optional[int] = None,
        referenceid: Optional[str] = None,
        userid: Optional[int] = None
    ) -> Dict[str, Any]:
        """
        View Fund Transfer Record
        
        Generated from: GET /payments/transfers/view
        Source: swagger_2_0
        Operation ID: AMEET1612FetchAMELegTxnListUsingGET_1
        
        
        Authentication: Not required
        
        Parameters:
        - Externalreference: string
          Unique Transaction reference generated in external system
        - destinationAccount: string
          Destination Account
        - destinationCustomerRef: integer
          Destination Customer Reference
        - executionDate: string
          Execution Date (Date Format : YYYYMMDD)
        - initiatingAccount: string
          Initiating Account
        - initiatingCustomerRef: integer
          Initiating Customer Reference
        - orderingSystem: integer
          Ordering System
        - pageNum: integer
          pageNum
        - pageSize: integer
          pageSize
        - status: integer
          Transaction Status AuthAwaited-22,Executed-23,Blocked-24,Authorized-3,Awaiting Authorization-1514,Rejected-4,Released-7,Execution Awaited-721,Pending Execution-1702,onHold-8(Domain Name:d_PmntOrdStat)
        - transactionDate: string
          Transaction Date (Date Format : YYYYMMDD)
        - transactionDateFrom: string
          Transaction Date From (Date Format : YYYYMMDD)
        - transactionDateTo: string
          Transaction Date To(Date Format : YYYYMMDD)
        - transactionRef: integer
          Transaction Reference
        
        
        
        Headers:
        - Accesstoken: string
          Authorization token for identification of the caller
        - ChannelType: integer
          Channel identifier from where the TXN has originated (Internet, Mobile, ATM, Branch Channel )
        - Co-Relationid: integer
          Unique ID for the service invoked, will be set by the TXN system
        - InitiatingSystem: string
          Indicating the initiated system
        - ServiceMode: integer
          Used for branch channel to indicate the type of customer
        - UUIDSeqNo: integer
          UUID Sequence Number
        - entity: string
          entity
        - languageCode: integer
          languageCode
        - referenceId: string
          Place holder for Token based authentication
        - userId: integer
          userId
        
        
        """
        
        
        # Prepare query parameters
        params = {}
        if externalreference is not None:
            params["Externalreference"] = externalreference
            
        if destinationaccount is not None:
            params["destinationAccount"] = destinationaccount
            
        if destinationcustomerref is not None:
            params["destinationCustomerRef"] = destinationcustomerref
            
        if executiondate is not None:
            params["executionDate"] = executiondate
            
        if initiatingaccount is not None:
            params["initiatingAccount"] = initiatingaccount
            
        if initiatingcustomerref is not None:
            params["initiatingCustomerRef"] = initiatingcustomerref
            
        if orderingsystem is not None:
            params["orderingSystem"] = orderingsystem
            
        if pagenum is not None:
            params["pageNum"] = pagenum
            
        if pagesize is not None:
            params["pageSize"] = pagesize
            
        if status is not None:
            params["status"] = status
            
        if transactiondate is not None:
            params["transactionDate"] = transactiondate
            
        if transactiondatefrom is not None:
            params["transactionDateFrom"] = transactiondatefrom
            
        if transactiondateto is not None:
            params["transactionDateTo"] = transactiondateto
            
        if transactionref is not None:
            params["transactionRef"] = transactionref
            
        
        
        # Replace path parameters in URL
        path = "/payments/transfers/view"
        
        
        # Prepare headers
        headers = {}
        if accesstoken is not None:
            headers["Accesstoken"] = str(accesstoken)
        if channeltype is not None:
            headers["ChannelType"] = str(channeltype)
        if co_relationid is not None:
            headers["Co-Relationid"] = str(co_relationid)
        if initiatingsystem is not None:
            headers["InitiatingSystem"] = str(initiatingsystem)
        if servicemode is not None:
            headers["ServiceMode"] = str(servicemode)
        if uuidseqno is not None:
            headers["UUIDSeqNo"] = str(uuidseqno)
        if entity is not None:
            headers["entity"] = str(entity)
        if languagecode is not None:
            headers["languageCode"] = str(languagecode)
        if referenceid is not None:
            headers["referenceId"] = str(referenceid)
        if userid is not None:
            headers["userId"] = str(userid)
        
        
        return await make_api_request(
            "GET", 
            path, 
            
            params=params if params else None, 
            headers=headers if headers else None
        )
    
    
    
    @mcp.tool()
    async def psbt2022_auth_upfrnt_chrgs_using_post(
        request_body:Dict[str, Any] ,  # AuthUpfrntChrgsRequest,
        accesstoken: Optional[str] = None,
        channeltype: Optional[int] = None,
        co_relationid: Optional[int] = None,
        initiatingsystem: Optional[str] = None,
        servicemode: Optional[int] = None,
        uuidseqno: Optional[int] = None,
        entity: Optional[str] = None,
        languagecode: Optional[int] = None,
        referenceid: Optional[str] = None,
        requesthash: Optional[str] = None,
        userid: Optional[int] = None
    ) -> Dict[str, Any]:
        """
        PSBT2022AuthUpfrntChrgs
        
        Generated from: POST /pricingServices/Auth/UpFrontCharges
        Source: swagger_2_0
        Operation ID: PSBT2022AuthUpfrntChrgsUsingPOST
        
        
        Authentication: Not required
        
        Parameters:
        - request_body: any (required)
          input
        
        
        
        Headers:
        - Accesstoken: string
          Authorization token for identification of the caller
        - ChannelType: integer
          Channel identifier from where the TXN has originated (Internet, Mobile, ATM, Branch Channel )
        - Co-Relationid: integer
          Unique ID for the service invoked, will be set by the TXN system
        - InitiatingSystem: string
          Indicating the initiated system
        - ServiceMode: integer
          Used for branch channel to indicate the type of customer
        - UUIDSeqNo: integer
          UUID Sequence Number
        - entity: string
          entity
        - languageCode: integer
          languageCode
        - referenceId: string
          Place holder for Token based authentication
        - requesthash: string
          Request payload for hash validation
        - userId: integer
          userId
        
        
        """
        
        
        # Prepare request data
        
        # Single body parameter - send directly
        data = request_body if request_body is not None else {}
        
        
        
        # Prepare query parameters
        params = {}
        
        
        # Replace path parameters in URL
        path = "/pricingServices/Auth/UpFrontCharges"
        
        
        # Prepare headers
        headers = {}
        if accesstoken is not None:
            headers["Accesstoken"] = str(accesstoken)
        if channeltype is not None:
            headers["ChannelType"] = str(channeltype)
        if co_relationid is not None:
            headers["Co-Relationid"] = str(co_relationid)
        if initiatingsystem is not None:
            headers["InitiatingSystem"] = str(initiatingsystem)
        if servicemode is not None:
            headers["ServiceMode"] = str(servicemode)
        if uuidseqno is not None:
            headers["UUIDSeqNo"] = str(uuidseqno)
        if entity is not None:
            headers["entity"] = str(entity)
        if languagecode is not None:
            headers["languageCode"] = str(languagecode)
        if referenceid is not None:
            headers["referenceId"] = str(referenceid)
        if requesthash is not None:
            headers["requesthash"] = str(requesthash)
        if userid is not None:
            headers["userId"] = str(userid)
        
        
        return await make_api_request(
            "POST", 
            path, 
            data=data, 
            params=params if params else None, 
            headers=headers if headers else None
        )
    
    
    
    @mcp.tool()
    async def psbt2021_crt_ext_chrgs_postusing_post(
        request_body:Dict[str, Any] ,  # adhocChargesResource,
        entity: Optional[str] = None,
        languagecode: Optional[int] = None,
        userid: Optional[int] = None
    ) -> Dict[str, Any]:
        """
        Apply Adhoc Charges
        
        Generated from: POST /pricingServices/adhocCharges
        Source: swagger_2_0
        Operation ID: PSBT2021CrtExtChrgs_POSTUsingPOST
        
        
        Authentication: Not required
        
        Parameters:
        - request_body: any (required)
          input
        
        
        
        Headers:
        - entity: string
          entity
        - languageCode: integer
          languageCode
        - userId: integer
          userId
        
        
        """
        
        
        # Prepare request data
        
        # Single body parameter - send directly
        data = request_body if request_body is not None else {}
        
        
        
        # Prepare query parameters
        params = {}
        
        
        # Replace path parameters in URL
        path = "/pricingServices/adhocCharges"
        
        
        # Prepare headers
        headers = {}
        if entity is not None:
            headers["entity"] = str(entity)
        if languagecode is not None:
            headers["languageCode"] = str(languagecode)
        if userid is not None:
            headers["userId"] = str(userid)
        
        
        return await make_api_request(
            "POST", 
            path, 
            data=data, 
            params=params if params else None, 
            headers=headers if headers else None
        )
    
    
    
    @mcp.tool()
    async def pset1726_pstxn_chrg_md_using_get(
        accountreference: str,
        chargeitemid: int,
        customerreference: int,
        entityid: str,
        accesstoken: Optional[str] = None,
        channeltype: Optional[int] = None,
        co_relationid: Optional[int] = None,
        initiatingsystem: Optional[str] = None,
        servicemode: Optional[int] = None,
        uuidseqno: Optional[int] = None,
        entity: Optional[str] = None,
        languagecode: Optional[int] = None,
        referenceid: Optional[str] = None,
        userid: Optional[int] = None
    ) -> Dict[str, Any]:
        """
        Computes External Charges
        
        Generated from: GET /pricingServices/computeExternalCharges
        Source: swagger_2_0
        Operation ID: PSET1726PSTxnChrgMdUsingGET
        
        
        Authentication: Not required
        
        Parameters:
        - accountReference: string (required)
          Account Reference
        - chargeItemId: integer (required)
          Charge Item Id
        - customerReference: integer (required)
          Customer Reference
        - entityId: string (required)
          Entity Id
        
        
        
        Headers:
        - Accesstoken: string
          Authorization token for identification of the caller
        - ChannelType: integer
          Channel identifier from where the transaction has originated (Internet, Mobile, ATM, Branch Channel )
        - Co-Relationid: integer
          Unique ID for the service invoked, will be set by the transaction system
        - InitiatingSystem: string
          Indicating the initiated system
        - ServiceMode: integer
          Used for branch channel to indicate the type of customer
        - UUIDSeqNo: integer
          UUID Sequence Number
        - entity: string
          entity
        - languageCode: integer
          languageCode
        - referenceId: string
          Place holder for Token based authentication
        - userId: integer
          userId
        
        
        """
        
        
        # Prepare query parameters
        params = {}
        if accountreference is not None:
            params["accountReference"] = accountreference
            
        if chargeitemid is not None:
            params["chargeItemId"] = chargeitemid
            
        if customerreference is not None:
            params["customerReference"] = customerreference
            
        if entityid is not None:
            params["entityId"] = entityid
            
        
        
        # Replace path parameters in URL
        path = "/pricingServices/computeExternalCharges"
        
        
        # Prepare headers
        headers = {}
        if accesstoken is not None:
            headers["Accesstoken"] = str(accesstoken)
        if channeltype is not None:
            headers["ChannelType"] = str(channeltype)
        if co_relationid is not None:
            headers["Co-Relationid"] = str(co_relationid)
        if initiatingsystem is not None:
            headers["InitiatingSystem"] = str(initiatingsystem)
        if servicemode is not None:
            headers["ServiceMode"] = str(servicemode)
        if uuidseqno is not None:
            headers["UUIDSeqNo"] = str(uuidseqno)
        if entity is not None:
            headers["entity"] = str(entity)
        if languagecode is not None:
            headers["languageCode"] = str(languagecode)
        if referenceid is not None:
            headers["referenceId"] = str(referenceid)
        if userid is not None:
            headers["userId"] = str(userid)
        
        
        return await make_api_request(
            "GET", 
            path, 
            
            params=params if params else None, 
            headers=headers if headers else None
        )
    
    
    
    @mcp.tool()
    async def psbt2021_reverse_cc_postusing_post(
        request_body:Dict[str, Any] ,  # reverseComputeChargeResource,
        accesstoken: Optional[str] = None,
        channeltype: Optional[int] = None,
        co_relationid: Optional[int] = None,
        initiatingsystem: Optional[str] = None,
        servicemode: Optional[int] = None,
        uuidseqno: Optional[int] = None,
        entity: Optional[str] = None,
        languagecode: Optional[int] = None,
        referenceid: Optional[str] = None,
        requesthash: Optional[str] = None,
        userid: Optional[int] = None
    ) -> Dict[str, Any]:
        """
        Reversing the computed charge
        
        Generated from: POST /pricingServices/computedCharge/reversal
        Source: swagger_2_0
        Operation ID: PSBT2021ReverseCC_POSTUsingPOST
        
        
        Authentication: Not required
        
        Parameters:
        - request_body: any (required)
          input
        
        
        
        Headers:
        - Accesstoken: string
          Authorization token for identification of the caller
        - ChannelType: integer
          Channel identifier from where the TXN has originated (Internet, Mobile, ATM, Branch Channel )
        - Co-Relationid: integer
          Unique ID for the service invoked, will be set by the TXN system
        - InitiatingSystem: string
          Indicating the initiated system
        - ServiceMode: integer
          Used for branch channel to indicate the type of customer
        - UUIDSeqNo: integer
          UUID Sequence Number
        - entity: string
          entity
        - languageCode: integer
          languageCode
        - referenceId: string
          Place holder for Token based authentication
        - requesthash: string
          Request payload for hash validation
        - userId: integer
          userId
        
        
        """
        
        
        # Prepare request data
        
        # Single body parameter - send directly
        data = request_body if request_body is not None else {}
        
        
        
        # Prepare query parameters
        params = {}
        
        
        # Replace path parameters in URL
        path = "/pricingServices/computedCharge/reversal"
        
        
        # Prepare headers
        headers = {}
        if accesstoken is not None:
            headers["Accesstoken"] = str(accesstoken)
        if channeltype is not None:
            headers["ChannelType"] = str(channeltype)
        if co_relationid is not None:
            headers["Co-Relationid"] = str(co_relationid)
        if initiatingsystem is not None:
            headers["InitiatingSystem"] = str(initiatingsystem)
        if servicemode is not None:
            headers["ServiceMode"] = str(servicemode)
        if uuidseqno is not None:
            headers["UUIDSeqNo"] = str(uuidseqno)
        if entity is not None:
            headers["entity"] = str(entity)
        if languagecode is not None:
            headers["languageCode"] = str(languagecode)
        if referenceid is not None:
            headers["referenceId"] = str(referenceid)
        if requesthash is not None:
            headers["requesthash"] = str(requesthash)
        if userid is not None:
            headers["userId"] = str(userid)
        
        
        return await make_api_request(
            "POST", 
            path, 
            data=data, 
            params=params if params else None, 
            headers=headers if headers else None
        )
    
    
    
    @mcp.tool()
    async def psbt2023_auth_reverse_cc_postusing_post(
        computedchargereference: int,
        accesstoken: Optional[str] = None,
        channeltype: Optional[int] = None,
        co_relationid: Optional[int] = None,
        initiatingsystem: Optional[str] = None,
        servicemode: Optional[int] = None,
        uuidseqno: Optional[int] = None,
        entity: Optional[str] = None,
        languagecode: Optional[int] = None,
        referenceid: Optional[str] = None,
        userid: Optional[int] = None
    ) -> Dict[str, Any]:
        """
        Authorization of reverse computed charge
        
        Generated from: POST /pricingServices/computedCharge/reversal/authorize/{computedChargeReference}
        Source: swagger_2_0
        Operation ID: PSBT2023AuthReverseCC_POSTUsingPOST
        
        
        Authentication: Not required
        
        Parameters:
        - computedChargeReference: integer (required)
          Unique transaction reference of computed charge
        
        
        
        Headers:
        - Accesstoken: string
          Authorization token for identification of the caller
        - ChannelType: integer
          Channel identifier from where the TXN has originated (Internet, Mobile, ATM, Branch Channel )
        - Co-Relationid: integer
          Unique ID for the service invoked, will be set by the TXN system
        - InitiatingSystem: string
          Indicating the initiated system
        - ServiceMode: integer
          Used for branch channel to indicate the type of customer
        - UUIDSeqNo: integer
          UUID Sequence Number
        - entity: string
          entity
        - languageCode: integer
          languageCode
        - referenceId: string
          Place holder for Token based authentication
        - userId: integer
          userId
        
        
        """
        
        
        # Prepare query parameters
        params = {}
        
        
        # Replace path parameters in URL
        path = "/pricingServices/computedCharge/reversal/authorize/{computedChargeReference}"
        if computedchargereference is not None:
            path = path.replace("{computedChargeReference}", str(computedchargereference))
        
        
        # Prepare headers
        headers = {}
        if accesstoken is not None:
            headers["Accesstoken"] = str(accesstoken)
        if channeltype is not None:
            headers["ChannelType"] = str(channeltype)
        if co_relationid is not None:
            headers["Co-Relationid"] = str(co_relationid)
        if initiatingsystem is not None:
            headers["InitiatingSystem"] = str(initiatingsystem)
        if servicemode is not None:
            headers["ServiceMode"] = str(servicemode)
        if uuidseqno is not None:
            headers["UUIDSeqNo"] = str(uuidseqno)
        if entity is not None:
            headers["entity"] = str(entity)
        if languagecode is not None:
            headers["languageCode"] = str(languagecode)
        if referenceid is not None:
            headers["referenceId"] = str(referenceid)
        if userid is not None:
            headers["userId"] = str(userid)
        
        
        return await make_api_request(
            "POST", 
            path, 
            
            params=params if params else None, 
            headers=headers if headers else None
        )
    
    
    
    @mcp.tool()
    async def psbt2025_reject_reverse_ccpostusing_post(
        computedchargereference: int,
        accesstoken: Optional[str] = None,
        channeltype: Optional[int] = None,
        co_relationid: Optional[int] = None,
        initiatingsystem: Optional[str] = None,
        servicemode: Optional[int] = None,
        uuidseqno: Optional[int] = None,
        entity: Optional[str] = None,
        languagecode: Optional[int] = None,
        referenceid: Optional[str] = None,
        userid: Optional[int] = None
    ) -> Dict[str, Any]:
        """
        Reject the reversal of computed charge
        
        Generated from: POST /pricingServices/computedCharge/reversal/reject/{computedChargeReference}
        Source: swagger_2_0
        Operation ID: PSBT2025RejectReverseCCPOSTUsingPOST
        
        
        Authentication: Not required
        
        Parameters:
        - computedChargeReference: integer (required)
          Unique transaction reference of computed charge
        
        
        
        Headers:
        - Accesstoken: string
          Authorization token for identification of the caller
        - ChannelType: integer
          Channel identifier from where the TXN has originated (Internet, Mobile, ATM, Branch Channel )
        - Co-Relationid: integer
          Unique ID for the service invoked, will be set by the TXN system
        - InitiatingSystem: string
          Indicating the initiated system
        - ServiceMode: integer
          Used for branch channel to indicate the type of customer
        - UUIDSeqNo: integer
          UUID Sequence Number
        - entity: string
          entity
        - languageCode: integer
          languageCode
        - referenceId: string
          Place holder for Token based authentication
        - userId: integer
          userId
        
        
        """
        
        
        # Prepare query parameters
        params = {}
        
        
        # Replace path parameters in URL
        path = "/pricingServices/computedCharge/reversal/reject/{computedChargeReference}"
        if computedchargereference is not None:
            path = path.replace("{computedChargeReference}", str(computedchargereference))
        
        
        # Prepare headers
        headers = {}
        if accesstoken is not None:
            headers["Accesstoken"] = str(accesstoken)
        if channeltype is not None:
            headers["ChannelType"] = str(channeltype)
        if co_relationid is not None:
            headers["Co-Relationid"] = str(co_relationid)
        if initiatingsystem is not None:
            headers["InitiatingSystem"] = str(initiatingsystem)
        if servicemode is not None:
            headers["ServiceMode"] = str(servicemode)
        if uuidseqno is not None:
            headers["UUIDSeqNo"] = str(uuidseqno)
        if entity is not None:
            headers["entity"] = str(entity)
        if languagecode is not None:
            headers["languageCode"] = str(languagecode)
        if referenceid is not None:
            headers["referenceId"] = str(referenceid)
        if userid is not None:
            headers["userId"] = str(userid)
        
        
        return await make_api_request(
            "POST", 
            path, 
            
            params=params if params else None, 
            headers=headers if headers else None
        )
    
    
    
    @mcp.tool()
    async def pset0402_get_cc_postusing_get(
        computedchargereference: str,
        # computedchargereference: int,
        accesstoken: Optional[str] = None,
        channeltype: Optional[int] = None,
        co_relationid: Optional[int] = None,
        initiatingsystem: Optional[str] = None,
        servicemode: Optional[int] = None,
        uuidseqno: Optional[int] = None,
        entity: Optional[str] = None,
        languagecode: Optional[int] = None,
        referenceid: Optional[str] = None,
        userid: Optional[int] = None
    ) -> Dict[str, Any]:
        """
        View of Computed charges
        
        Generated from: GET /pricingServices/computedCharge/view/{computedChargeReference}
        Source: swagger_2_0
        Operation ID: PSET0402GetCC_POSTUsingGET
        
        
        Authentication: Not required
        
        Parameters:
        - computedChargeReference: integer (required)
          Unique transaction reference of computed charge
        - computedChargeReference: string (required)
          Path parameter computedChargeReference
        
        
        
        Headers:
        - Accesstoken: string
          Authorization token for identification of the caller
        - ChannelType: integer
          Channel identifier from where the transaction has originated (Internet, Mobile, ATM, Branch Channel )
        - Co-Relationid: integer
          Unique ID for the service invoked, will be set by the transaction system
        - InitiatingSystem: string
          Indicating the initiated system
        - ServiceMode: integer
          Used for branch channel to indicate the type of customer
        - UUIDSeqNo: integer
          UUID Sequence Number
        - entity: string
          entity
        - languageCode: integer
          languageCode
        - referenceId: string
          Place holder for Token based authentication
        - userId: integer
          userId
        
        
        """
        
        
        # Prepare query parameters
        params = {}
        if computedchargereference is not None:
            params["computedChargeReference"] = computedchargereference
            
        
        
        # Replace path parameters in URL
        path = "/pricingServices/computedCharge/view/{computedChargeReference}"
        if computedchargereference is not None:
            path = path.replace("{computedChargeReference}", str(computedchargereference))
        
        
        # Prepare headers
        headers = {}
        if accesstoken is not None:
            headers["Accesstoken"] = str(accesstoken)
        if channeltype is not None:
            headers["ChannelType"] = str(channeltype)
        if co_relationid is not None:
            headers["Co-Relationid"] = str(co_relationid)
        if initiatingsystem is not None:
            headers["InitiatingSystem"] = str(initiatingsystem)
        if servicemode is not None:
            headers["ServiceMode"] = str(servicemode)
        if uuidseqno is not None:
            headers["UUIDSeqNo"] = str(uuidseqno)
        if entity is not None:
            headers["entity"] = str(entity)
        if languagecode is not None:
            headers["languageCode"] = str(languagecode)
        if referenceid is not None:
            headers["referenceId"] = str(referenceid)
        if userid is not None:
            headers["userId"] = str(userid)
        
        
        return await make_api_request(
            "GET", 
            path, 
            
            params=params if params else None, 
            headers=headers if headers else None
        )
    
    
    
    @mcp.tool()
    async def psbtcalc_tax_wrapper_postusing_post(
        request_body:Dict[str, Any] ,  # calculateTaxWrapperResource,
        accesstoken: Optional[str] = None,
        channeltype: Optional[int] = None,
        co_relationid: Optional[int] = None,
        initiatingsystem: Optional[str] = None,
        servicemode: Optional[int] = None,
        uuidseqno: Optional[int] = None,
        entity: Optional[str] = None,
        languagecode: Optional[int] = None,
        referenceid: Optional[str] = None,
        requesthash: Optional[str] = None,
        userid: Optional[int] = None
    ) -> Dict[str, Any]:
        """
        Fetch Computed Tax
        
        Generated from: POST /pricingServices/computedTax
        Source: swagger_2_0
        Operation ID: PSBTCalcTaxWrapper_POSTUsingPOST
        
        
        Authentication: Not required
        
        Parameters:
        - request_body: any (required)
          input
        
        
        
        Headers:
        - Accesstoken: string
          Authorization token for identification of the caller
        - ChannelType: integer
          Channel identifier from where the TXN has originated (Internet, Mobile, ATM, Branch Channel )
        - Co-Relationid: integer
          Unique ID for the service invoked, will be set by the TXN system
        - InitiatingSystem: string
          Indicating the initiated system
        - ServiceMode: integer
          Used for branch channel to indicate the type of customer
        - UUIDSeqNo: integer
          UUID Sequence Number
        - entity: string
          entity
        - languageCode: integer
          languageCode
        - referenceId: string
          Place holder for Token based authentication
        - requesthash: string
          Request payload for hash validation
        - userId: integer
          userId
        
        
        """
        
        
        # Prepare request data
        
        # Single body parameter - send directly
        data = request_body if request_body is not None else {}
        
        
        
        # Prepare query parameters
        params = {}
        
        
        # Replace path parameters in URL
        path = "/pricingServices/computedTax"
        
        
        # Prepare headers
        headers = {}
        if accesstoken is not None:
            headers["Accesstoken"] = str(accesstoken)
        if channeltype is not None:
            headers["ChannelType"] = str(channeltype)
        if co_relationid is not None:
            headers["Co-Relationid"] = str(co_relationid)
        if initiatingsystem is not None:
            headers["InitiatingSystem"] = str(initiatingsystem)
        if servicemode is not None:
            headers["ServiceMode"] = str(servicemode)
        if uuidseqno is not None:
            headers["UUIDSeqNo"] = str(uuidseqno)
        if entity is not None:
            headers["entity"] = str(entity)
        if languagecode is not None:
            headers["languageCode"] = str(languagecode)
        if referenceid is not None:
            headers["referenceId"] = str(referenceid)
        if requesthash is not None:
            headers["requesthash"] = str(requesthash)
        if userid is not None:
            headers["userId"] = str(userid)
        
        
        return await make_api_request(
            "POST", 
            path, 
            data=data, 
            params=params if params else None, 
            headers=headers if headers else None
        )
    
    
    
    @mcp.tool()
    async def psbt2022_create_upfrnt_chrgs_using_post(
        request_body:Dict[str, Any] ,  # CreateUpfrntChrgsRequest,
        accesstoken: Optional[str] = None,
        channeltype: Optional[int] = None,
        co_relationid: Optional[int] = None,
        initiatingsystem: Optional[str] = None,
        servicemode: Optional[int] = None,
        uuidseqno: Optional[int] = None,
        entity: Optional[str] = None,
        languagecode: Optional[int] = None,
        referenceid: Optional[str] = None,
        requesthash: Optional[str] = None,
        userid: Optional[int] = None
    ) -> Dict[str, Any]:
        """
        This API is used to Create Upfront Charges
        
        Generated from: POST /pricingServices/create/upfrontCharges
        Source: swagger_2_0
        Operation ID: PSBT2022CreateUpfrntChrgsUsingPOST
        
        
        Authentication: Not required
        
        Parameters:
        - request_body: any (required)
          input
        
        
        
        Headers:
        - Accesstoken: string
          Authorization token for identification of the caller
        - ChannelType: integer
          Channel identifier from where the TXN has originated (Internet, Mobile, ATM, Branch Channel )
        - Co-Relationid: integer
          Unique ID for the service invoked, will be set by the TXN system
        - InitiatingSystem: string
          Indicating the initiated system
        - ServiceMode: integer
          Used for branch channel to indicate the type of customer
        - UUIDSeqNo: integer
          UUID Sequence Number
        - entity: string
          entity
        - languageCode: integer
          languageCode
        - referenceId: string
          Place holder for Token based authentication
        - requesthash: string
          Request payload for hash validation
        - userId: integer
          userId
        
        
        """
        
        
        # Prepare request data
        
        # Single body parameter - send directly
        data = request_body if request_body is not None else {}
        
        
        
        # Prepare query parameters
        params = {}
        
        
        # Replace path parameters in URL
        path = "/pricingServices/create/upfrontCharges"
        
        
        # Prepare headers
        headers = {}
        if accesstoken is not None:
            headers["Accesstoken"] = str(accesstoken)
        if channeltype is not None:
            headers["ChannelType"] = str(channeltype)
        if co_relationid is not None:
            headers["Co-Relationid"] = str(co_relationid)
        if initiatingsystem is not None:
            headers["InitiatingSystem"] = str(initiatingsystem)
        if servicemode is not None:
            headers["ServiceMode"] = str(servicemode)
        if uuidseqno is not None:
            headers["UUIDSeqNo"] = str(uuidseqno)
        if entity is not None:
            headers["entity"] = str(entity)
        if languagecode is not None:
            headers["languageCode"] = str(languagecode)
        if referenceid is not None:
            headers["referenceId"] = str(referenceid)
        if requesthash is not None:
            headers["requesthash"] = str(requesthash)
        if userid is not None:
            headers["userId"] = str(userid)
        
        
        return await make_api_request(
            "POST", 
            path, 
            data=data, 
            params=params if params else None, 
            headers=headers if headers else None
        )
    
    
    
    @mcp.tool()
    async def indet2024_get_tax_type_using_get(
        chargeitem: int,
        accesstoken: Optional[str] = None,
        channeltype: Optional[int] = None,
        co_relationid: Optional[int] = None,
        initiatingsystem: Optional[str] = None,
        servicemode: Optional[int] = None,
        uuidseqno: Optional[int] = None,
        entity: Optional[str] = None,
        referenceid: Optional[str] = None,
        userid: Optional[int] = None
    ) -> Dict[str, Any]:
        """
        TaxType
        
        Generated from: GET /pricingServices/getTaxType
        Source: swagger_2_0
        Operation ID: INDET2024GetTaxTypeUsingGET
        
        
        Authentication: Not required
        
        Parameters:
        - chargeItem: integer (required)
          Charge item for which the tax type to be known:3718,3058,3060.Name:d_ChargeItemId
        
        
        
        Headers:
        - Accesstoken: string
          Authorization token for identification of the caller
        - ChannelType: integer
          Channel identifier from where the TXN has originated (Internet, Mobile, ATM, Branch Channel )
        - Co-Relationid: integer
          Unique ID for the service invoked, will be set by the TXN system
        - InitiatingSystem: string
          Indicating the initiated system
        - ServiceMode: integer
          Used for branch channel to indicate the type of customer
        - UUIDSeqNo: integer
          UUID Sequence Number
        - entity: string
          entity
        - referenceId: string
          Place holder for Token based authentication
        - userId: integer
          userId
        
        
        """
        
        
        # Prepare query parameters
        params = {}
        if chargeitem is not None:
            params["chargeItem"] = chargeitem
            
        
        
        # Replace path parameters in URL
        path = "/pricingServices/getTaxType"
        
        
        # Prepare headers
        headers = {}
        if accesstoken is not None:
            headers["Accesstoken"] = str(accesstoken)
        if channeltype is not None:
            headers["ChannelType"] = str(channeltype)
        if co_relationid is not None:
            headers["Co-Relationid"] = str(co_relationid)
        if initiatingsystem is not None:
            headers["InitiatingSystem"] = str(initiatingsystem)
        if servicemode is not None:
            headers["ServiceMode"] = str(servicemode)
        if uuidseqno is not None:
            headers["UUIDSeqNo"] = str(uuidseqno)
        if entity is not None:
            headers["entity"] = str(entity)
        if referenceid is not None:
            headers["referenceId"] = str(referenceid)
        if userid is not None:
            headers["userId"] = str(userid)
        
        
        return await make_api_request(
            "GET", 
            path, 
            
            params=params if params else None, 
            headers=headers if headers else None
        )
    
    
    
    @mcp.tool()
    async def psbt2022_modify_upfrnt_chrgs_using_post(
        request_body:Dict[str, Any] ,  # ModifyUpfrntChrgsRequest,
        accesstoken: Optional[str] = None,
        channeltype: Optional[int] = None,
        co_relationid: Optional[int] = None,
        initiatingsystem: Optional[str] = None,
        servicemode: Optional[int] = None,
        uuidseqno: Optional[int] = None,
        entity: Optional[str] = None,
        languagecode: Optional[int] = None,
        referenceid: Optional[str] = None,
        requesthash: Optional[str] = None,
        userid: Optional[int] = None
    ) -> Dict[str, Any]:
        """
        This API is used to Modify Upfront Charges
        
        Generated from: POST /pricingServices/modify/upfrontCharges
        Source: swagger_2_0
        Operation ID: PSBT2022ModifyUpfrntChrgsUsingPOST
        
        
        Authentication: Not required
        
        Parameters:
        - request_body: any (required)
          input
        
        
        
        Headers:
        - Accesstoken: string
          Authorization token for identification of the caller
        - ChannelType: integer
          Channel identifier from where the TXN has originated (Internet, Mobile, ATM, Branch Channel )
        - Co-Relationid: integer
          Unique ID for the service invoked, will be set by the TXN system
        - InitiatingSystem: string
          Indicating the initiated system
        - ServiceMode: integer
          Used for branch channel to indicate the type of customer
        - UUIDSeqNo: integer
          UUID Sequence Number
        - entity: string
          entity
        - languageCode: integer
          languageCode
        - referenceId: string
          Place holder for Token based authentication
        - requesthash: string
          Request payload for hash validation
        - userId: integer
          userId
        
        
        """
        
        
        # Prepare request data
        
        # Single body parameter - send directly
        data = request_body if request_body is not None else {}
        
        
        
        # Prepare query parameters
        params = {}
        
        
        # Replace path parameters in URL
        path = "/pricingServices/modify/upfrontCharges"
        
        
        # Prepare headers
        headers = {}
        if accesstoken is not None:
            headers["Accesstoken"] = str(accesstoken)
        if channeltype is not None:
            headers["ChannelType"] = str(channeltype)
        if co_relationid is not None:
            headers["Co-Relationid"] = str(co_relationid)
        if initiatingsystem is not None:
            headers["InitiatingSystem"] = str(initiatingsystem)
        if servicemode is not None:
            headers["ServiceMode"] = str(servicemode)
        if uuidseqno is not None:
            headers["UUIDSeqNo"] = str(uuidseqno)
        if entity is not None:
            headers["entity"] = str(entity)
        if languagecode is not None:
            headers["languageCode"] = str(languagecode)
        if referenceid is not None:
            headers["referenceId"] = str(referenceid)
        if requesthash is not None:
            headers["requesthash"] = str(requesthash)
        if userid is not None:
            headers["userId"] = str(userid)
        
        
        return await make_api_request(
            "POST", 
            path, 
            data=data, 
            params=params if params else None, 
            headers=headers if headers else None
        )
    
    
    
    @mcp.tool()
    async def psbt5005_acnt_aplcbl_chrgs_crt_on_hld_postusing_post(
        request_body:Dict[str, Any] ,  # acntAplcblChrgsCrtOnHldResource,
        accesstoken: Optional[str] = None,
        channeltype: Optional[int] = None,
        co_relationid: Optional[int] = None,
        initiatingsystem: Optional[str] = None,
        servicemode: Optional[int] = None,
        uuidseqno: Optional[int] = None,
        entity: Optional[str] = None,
        languagecode: Optional[int] = None,
        referenceid: Optional[str] = None,
        requesthash: Optional[str] = None,
        userid: Optional[int] = None
    ) -> Dict[str, Any]:
        """
        This API is used to create price exemption
        
        Generated from: POST /pricingServices/price/exemption
        Source: swagger_2_0
        Operation ID: PSBT5005AcntAplcblChrgsCrtOnHld_POSTUsingPOST
        
        
        Authentication: Not required
        
        Parameters:
        - request_body: any (required)
          input
        
        
        
        Headers:
        - Accesstoken: string
          Authorization token for identification of the caller
        - ChannelType: integer
          Channel identifier from where the TXN has originated (Internet, Mobile, ATM, Branch Channel )
        - Co-Relationid: integer
          Unique ID for the service invoked, will be set by the TXN system
        - InitiatingSystem: string
          Indicating the initiated system
        - ServiceMode: integer
          Used for branch channel to indicate the type of customer
        - UUIDSeqNo: integer
          UUID Sequence Number
        - entity: string
          entity
        - languageCode: integer
          languageCode
        - referenceId: string
          Place holder for Token based authentication
        - requesthash: string
          Request payload for hash validation
        - userId: integer
          userId
        
        
        """
        
        
        # Prepare request data
        
        # Single body parameter - send directly
        data = request_body if request_body is not None else {}
        
        
        
        # Prepare query parameters
        params = {}
        
        
        # Replace path parameters in URL
        path = "/pricingServices/price/exemption"
        
        
        # Prepare headers
        headers = {}
        if accesstoken is not None:
            headers["Accesstoken"] = str(accesstoken)
        if channeltype is not None:
            headers["ChannelType"] = str(channeltype)
        if co_relationid is not None:
            headers["Co-Relationid"] = str(co_relationid)
        if initiatingsystem is not None:
            headers["InitiatingSystem"] = str(initiatingsystem)
        if servicemode is not None:
            headers["ServiceMode"] = str(servicemode)
        if uuidseqno is not None:
            headers["UUIDSeqNo"] = str(uuidseqno)
        if entity is not None:
            headers["entity"] = str(entity)
        if languagecode is not None:
            headers["languageCode"] = str(languagecode)
        if referenceid is not None:
            headers["referenceId"] = str(referenceid)
        if requesthash is not None:
            headers["requesthash"] = str(requesthash)
        if userid is not None:
            headers["userId"] = str(userid)
        
        
        return await make_api_request(
            "POST", 
            path, 
            data=data, 
            params=params if params else None, 
            headers=headers if headers else None
        )
    
    
    
    @mcp.tool()
    async def pset2022_list_upfrnt_chrgs_using_get(
        tfreference: Optional[str] = None,
        accountnumber: Optional[str] = None,
        customername: Optional[str] = None,
        customerreference: Optional[int] = None,
        loanreference: Optional[str] = None,
        pagenum: Optional[int] = None,
        pagesize: Optional[int] = None,
        status: Optional[int] = None,
        transactionposid: Optional[int] = None,
        transactionpostype: Optional[int] = None,
        accesstoken: Optional[str] = None,
        channeltype: Optional[int] = None,
        co_relationid: Optional[int] = None,
        initiatingsystem: Optional[str] = None,
        servicemode: Optional[int] = None,
        uuidseqno: Optional[int] = None,
        entity: Optional[str] = None,
        languagecode: Optional[int] = None,
        referenceid: Optional[str] = None,
        requesthash: Optional[str] = None,
        userid: Optional[int] = None
    ) -> Dict[str, Any]:
        """
        PSET2022ListUpfrntChrgs
        
        Generated from: GET /pricingServices/upFrontCharges/list
        Source: swagger_2_0
        Operation ID: PSET2022ListUpfrntChrgsUsingGET
        
        
        Authentication: Not required
        
        Parameters:
        - TFReference: string
          TFReference
        - accountNumber: string
          accountNumber
        - customerName: string
          customerName
        - customerReference: integer
          customerReference
        - loanReference: string
          loanReference
        - pageNum: integer
          pageNum
        - pageSize: integer
          pageSize
        - status: integer
          status
        - transactionPosId: integer
          transactionPosId
        - transactionPosType: integer
          transactionPosType
        
        
        
        Headers:
        - Accesstoken: string
          Authorization token for identification of the caller
        - ChannelType: integer
          Channel identifier from where the TXN has originated (Internet, Mobile, ATM, Branch Channel )
        - Co-Relationid: integer
          Unique ID for the service invoked, will be set by the TXN system
        - InitiatingSystem: string
          Indicating the initiated system
        - ServiceMode: integer
          Used for branch channel to indicate the type of customer
        - UUIDSeqNo: integer
          UUID Sequence Number
        - entity: string
          entity
        - languageCode: integer
          languageCode
        - referenceId: string
          Place holder for Token based authentication
        - requesthash: string
          Request payload for hash validation
        - userId: integer
          userId
        
        
        """
        
        
        # Prepare query parameters
        params = {}
        if tfreference is not None:
            params["TFReference"] = tfreference
            
        if accountnumber is not None:
            params["accountNumber"] = accountnumber
            
        if customername is not None:
            params["customerName"] = customername
            
        if customerreference is not None:
            params["customerReference"] = customerreference
            
        if loanreference is not None:
            params["loanReference"] = loanreference
            
        if pagenum is not None:
            params["pageNum"] = pagenum
            
        if pagesize is not None:
            params["pageSize"] = pagesize
            
        if status is not None:
            params["status"] = status
            
        if transactionposid is not None:
            params["transactionPosId"] = transactionposid
            
        if transactionpostype is not None:
            params["transactionPosType"] = transactionpostype
            
        
        
        # Replace path parameters in URL
        path = "/pricingServices/upFrontCharges/list"
        
        
        # Prepare headers
        headers = {}
        if accesstoken is not None:
            headers["Accesstoken"] = str(accesstoken)
        if channeltype is not None:
            headers["ChannelType"] = str(channeltype)
        if co_relationid is not None:
            headers["Co-Relationid"] = str(co_relationid)
        if initiatingsystem is not None:
            headers["InitiatingSystem"] = str(initiatingsystem)
        if servicemode is not None:
            headers["ServiceMode"] = str(servicemode)
        if uuidseqno is not None:
            headers["UUIDSeqNo"] = str(uuidseqno)
        if entity is not None:
            headers["entity"] = str(entity)
        if languagecode is not None:
            headers["languageCode"] = str(languagecode)
        if referenceid is not None:
            headers["referenceId"] = str(referenceid)
        if requesthash is not None:
            headers["requesthash"] = str(requesthash)
        if userid is not None:
            headers["userId"] = str(userid)
        
        
        return await make_api_request(
            "GET", 
            path, 
            
            params=params if params else None, 
            headers=headers if headers else None
        )
    
    
    
    @mcp.tool()
    async def pset2022_view_upfrnt_chrgs_using_get(
        transactionposid: int,
        transactionpostype: int,
        pagenum: Optional[int] = None,
        pagesize: Optional[int] = None,
        accesstoken: Optional[str] = None,
        channeltype: Optional[int] = None,
        co_relationid: Optional[int] = None,
        initiatingsystem: Optional[str] = None,
        servicemode: Optional[int] = None,
        uuidseqno: Optional[int] = None,
        entity: Optional[str] = None,
        languagecode: Optional[int] = None,
        referenceid: Optional[str] = None,
        requesthash: Optional[str] = None,
        userid: Optional[int] = None
    ) -> Dict[str, Any]:
        """
        PSET2022ViewUpfrntChrgs
        
        Generated from: GET /pricingServices/upFrontCharges/view
        Source: swagger_2_0
        Operation ID: PSET2022ViewUpfrntChrgsUsingGET
        
        
        Authentication: Not required
        
        Parameters:
        - pageNum: integer
          pageNum
        - pageSize: integer
          pageSize
        - transactionPosId: integer (required)
          transactionPosId
        - transactionPosType: integer (required)
          transactionPosType
        
        
        
        Headers:
        - Accesstoken: string
          Authorization token for identification of the caller
        - ChannelType: integer
          Channel identifier from where the TXN has originated (Internet, Mobile, ATM, Branch Channel )
        - Co-Relationid: integer
          Unique ID for the service invoked, will be set by the TXN system
        - InitiatingSystem: string
          Indicating the initiated system
        - ServiceMode: integer
          Used for branch channel to indicate the type of customer
        - UUIDSeqNo: integer
          UUID Sequence Number
        - entity: string
          entity
        - languageCode: integer
          languageCode
        - referenceId: string
          Place holder for Token based authentication
        - requesthash: string
          Request payload for hash validation
        - userId: integer
          userId
        
        
        """
        
        
        # Prepare query parameters
        params = {}
        if pagenum is not None:
            params["pageNum"] = pagenum
            
        if pagesize is not None:
            params["pageSize"] = pagesize
            
        if transactionposid is not None:
            params["transactionPosId"] = transactionposid
            
        if transactionpostype is not None:
            params["transactionPosType"] = transactionpostype
            
        
        
        # Replace path parameters in URL
        path = "/pricingServices/upFrontCharges/view"
        
        
        # Prepare headers
        headers = {}
        if accesstoken is not None:
            headers["Accesstoken"] = str(accesstoken)
        if channeltype is not None:
            headers["ChannelType"] = str(channeltype)
        if co_relationid is not None:
            headers["Co-Relationid"] = str(co_relationid)
        if initiatingsystem is not None:
            headers["InitiatingSystem"] = str(initiatingsystem)
        if servicemode is not None:
            headers["ServiceMode"] = str(servicemode)
        if uuidseqno is not None:
            headers["UUIDSeqNo"] = str(uuidseqno)
        if entity is not None:
            headers["entity"] = str(entity)
        if languagecode is not None:
            headers["languageCode"] = str(languagecode)
        if referenceid is not None:
            headers["referenceId"] = str(referenceid)
        if requesthash is not None:
            headers["requesthash"] = str(requesthash)
        if userid is not None:
            headers["userId"] = str(userid)
        
        
        return await make_api_request(
            "GET", 
            path, 
            
            params=params if params else None, 
            headers=headers if headers else None
        )
    
    
    
    @mcp.tool()
    async def fibt1401_crt_crncy_intr_postusing_post(
        request_body:Dict[str, Any] ,  # CreateCurrencyInterestResource,
        entity: Optional[str] = None,
        languagecode: Optional[int] = None,
        userid: Optional[int] = None
    ) -> Dict[str, Any]:
        """
        Create Currency Interest
        
        Generated from: POST /productSetUp/instruments/currencyInterest
        Source: swagger_2_0
        Operation ID: FIBT1401CrtCrncyIntr_POSTUsingPOST
        
        
        Authentication: Not required
        
        Parameters:
        - request_body: any (required)
          input
        
        
        
        Headers:
        - entity: string
          entity
        - languageCode: integer
          languageCode
        - userId: integer
          userId
        
        
        """
        
        
        # Prepare request data
        
        # Single body parameter - send directly
        data = request_body if request_body is not None else {}
        
        
        
        # Prepare query parameters
        params = {}
        
        
        # Replace path parameters in URL
        path = "/productSetUp/instruments/currencyInterest"
        
        
        # Prepare headers
        headers = {}
        if entity is not None:
            headers["entity"] = str(entity)
        if languagecode is not None:
            headers["languageCode"] = str(languagecode)
        if userid is not None:
            headers["userId"] = str(userid)
        
        
        return await make_api_request(
            "POST", 
            path, 
            data=data, 
            params=params if params else None, 
            headers=headers if headers else None
        )
    
    
    
    @mcp.tool()
    async def fiet1402_get_crncy_intr_postusing_get(
        currency: str,
        instrumentreference: int,
        interestconditionnumber: int,
        accesstoken: Optional[str] = None,
        channeltype: Optional[int] = None,
        co_relationid: Optional[int] = None,
        initiatingsystem: Optional[str] = None,
        servicemode: Optional[int] = None,
        uuidseqno: Optional[int] = None,
        entity: Optional[str] = None,
        languagecode: Optional[int] = None,
        referenceid: Optional[str] = None,
        userid: Optional[int] = None
    ) -> Dict[str, Any]:
        """
        Get Currency Interest
        
        Generated from: GET /productSetUp/instruments/currencyInterest/details
        Source: swagger_2_0
        Operation ID: FIET1402GetCrncyIntr_POSTUsingGET
        
        
        Authentication: Not required
        
        Parameters:
        - currency: string (required)
          Description of queryparameter
        - instrumentReference: integer (required)
          Description of queryparameter
        - interestConditionNumber: integer (required)
          Description of queryparameter
        
        
        
        Headers:
        - Accesstoken: string
          Authorization token for identification of the caller
        - ChannelType: integer
          Channel identifier from where the TXN has originated (Internet, Mobile, ATM, Branch Channel )
        - Co-Relationid: integer
          Unique ID for the service invoked, will be set by the TXN system
        - InitiatingSystem: string
          Indicating the initiated system
        - ServiceMode: integer
          Used for branch channel to indicate the type of customer
        - UUIDSeqNo: integer
          UUID Sequence Number
        - entity: string
          entity
        - languageCode: integer
          languageCode
        - referenceId: string
          Place holder for Token based authentication
        - userId: integer
          userId
        
        
        """
        
        
        # Prepare query parameters
        params = {}
        if currency is not None:
            params["currency"] = currency
            
        if instrumentreference is not None:
            params["instrumentReference"] = instrumentreference
            
        if interestconditionnumber is not None:
            params["interestConditionNumber"] = interestconditionnumber
            
        
        
        # Replace path parameters in URL
        path = "/productSetUp/instruments/currencyInterest/details"
        
        
        # Prepare headers
        headers = {}
        if accesstoken is not None:
            headers["Accesstoken"] = str(accesstoken)
        if channeltype is not None:
            headers["ChannelType"] = str(channeltype)
        if co_relationid is not None:
            headers["Co-Relationid"] = str(co_relationid)
        if initiatingsystem is not None:
            headers["InitiatingSystem"] = str(initiatingsystem)
        if servicemode is not None:
            headers["ServiceMode"] = str(servicemode)
        if uuidseqno is not None:
            headers["UUIDSeqNo"] = str(uuidseqno)
        if entity is not None:
            headers["entity"] = str(entity)
        if languagecode is not None:
            headers["languageCode"] = str(languagecode)
        if referenceid is not None:
            headers["referenceId"] = str(referenceid)
        if userid is not None:
            headers["userId"] = str(userid)
        
        
        return await make_api_request(
            "GET", 
            path, 
            
            params=params if params else None, 
            headers=headers if headers else None
        )
    
    
    
    @mcp.tool()
    async def fiet1401_get_crncy_intr_lst_postusing_get(
        instrumentreference: int,
        currency: Optional[str] = None,
        interestcategory: Optional[int] = None,
        accesstoken: Optional[str] = None,
        channeltype: Optional[int] = None,
        co_relationid: Optional[int] = None,
        initiatingsystem: Optional[str] = None,
        servicemode: Optional[int] = None,
        uuidseqno: Optional[int] = None,
        entity: Optional[str] = None,
        languagecode: Optional[int] = None,
        referenceid: Optional[str] = None,
        userid: Optional[int] = None
    ) -> Dict[str, Any]:
        """
        Currency Interest List
        
        Generated from: GET /productSetUp/instruments/currencyInterest/list
        Source: swagger_2_0
        Operation ID: FIET1401GetCrncyIntrLst_POSTUsingGET
        
        
        Authentication: Not required
        
        Parameters:
        - currency: string
          Description of queryparameter
        - instrumentReference: integer (required)
          Description of queryparameter
        - interestCategory: integer
          Description of queryparameter
        
        
        
        Headers:
        - Accesstoken: string
          Authorization token for identification of the caller
        - ChannelType: integer
          Channel identifier from where the TXN has originated (Internet, Mobile, ATM, Branch Channel )
        - Co-Relationid: integer
          Unique ID for the service invoked, will be set by the TXN system
        - InitiatingSystem: string
          Indicating the initiated system
        - ServiceMode: integer
          Used for branch channel to indicate the type of customer
        - UUIDSeqNo: integer
          UUID Sequence Number
        - entity: string
          entity
        - languageCode: integer
          languageCode
        - referenceId: string
          Place holder for Token based authentication
        - userId: integer
          userId
        
        
        """
        
        
        # Prepare query parameters
        params = {}
        if currency is not None:
            params["currency"] = currency
            
        if instrumentreference is not None:
            params["instrumentReference"] = instrumentreference
            
        if interestcategory is not None:
            params["interestCategory"] = interestcategory
            
        
        
        # Replace path parameters in URL
        path = "/productSetUp/instruments/currencyInterest/list"
        
        
        # Prepare headers
        headers = {}
        if accesstoken is not None:
            headers["Accesstoken"] = str(accesstoken)
        if channeltype is not None:
            headers["ChannelType"] = str(channeltype)
        if co_relationid is not None:
            headers["Co-Relationid"] = str(co_relationid)
        if initiatingsystem is not None:
            headers["InitiatingSystem"] = str(initiatingsystem)
        if servicemode is not None:
            headers["ServiceMode"] = str(servicemode)
        if uuidseqno is not None:
            headers["UUIDSeqNo"] = str(uuidseqno)
        if entity is not None:
            headers["entity"] = str(entity)
        if languagecode is not None:
            headers["languageCode"] = str(languagecode)
        if referenceid is not None:
            headers["referenceId"] = str(referenceid)
        if userid is not None:
            headers["userId"] = str(userid)
        
        
        return await make_api_request(
            "GET", 
            path, 
            
            params=params if params else None, 
            headers=headers if headers else None
        )
    
    
    
    @mcp.tool()
    async def fiet4301_get_cintr_dtls_getusing_get(
        interestconditionnumber: int,
        instrumentreference: int,
        currency: Optional[str] = None,
        pagenum: Optional[int] = None,
        pagesize: Optional[int] = None,
        accesstoken_: Optional[str] = None,
        channeltype: Optional[int] = None,
        co_relationid: Optional[int] = None,
        initiatingsystem: Optional[str] = None,
        servicemode: Optional[int] = None,
        uuidseqno: Optional[int] = None,
        entity: Optional[str] = None,
        languagecode: Optional[int] = None,
        referenceid: Optional[str] = None,
        userid: Optional[int] = None
    ) -> Dict[str, Any]:
        """
        Fetch Currency Interest Details
        
        Generated from: GET /productSetUp/instruments/currencyInterestDetails/{interestConditionNumber}
        Source: swagger_2_0
        Operation ID: FIET4301GetCIntrDtls_GETUsingGET
        
        
        Authentication: Not required
        
        Parameters:
        - currency: string
          currency
        - instrumentReference: integer (required)
          instrumentReference
        - interestConditionNumber: integer (required)
          Description of queryparameter
        - pageNum: integer
          pageNum
        - pageSize: integer
          pageSize
        
        
        
        Headers:
        - Accesstoken : string
          Authorization Token for identification of  the caller
        - ChannelType: integer
          Channel identifier from where the TXN has originated (Internet, Mobile, ATM, Branch Channel )
        - Co-Relationid: integer
          Unique ID for the service invoked, will be set by the TXN system
        - InitiatingSystem: string
          Indicating the initiated system
        - ServiceMode: integer
          Used for branch channel to indicate the type of customer
        - UUIDSeqNo: integer
          UUID Sequence Number
        - entity: string
          entity
        - languageCode: integer
          languageCode
        - referenceId: string
          Identified reference field for authorization
        - userId: integer
          userId
        
        
        """
        
        
        # Prepare query parameters
        params = {}
        if currency is not None:
            params["currency"] = currency
            
        if instrumentreference is not None:
            params["instrumentReference"] = instrumentreference
            
        if pagenum is not None:
            params["pageNum"] = pagenum
            
        if pagesize is not None:
            params["pageSize"] = pagesize
            
        
        
        # Replace path parameters in URL
        path = "/productSetUp/instruments/currencyInterestDetails/{interestConditionNumber}"
        if interestconditionnumber is not None:
            path = path.replace("{interestConditionNumber}", str(interestconditionnumber))
        
        
        # Prepare headers
        headers = {}
        if accesstoken_ is not None:
            headers["Accesstoken "] = str(accesstoken_)
        if channeltype is not None:
            headers["ChannelType"] = str(channeltype)
        if co_relationid is not None:
            headers["Co-Relationid"] = str(co_relationid)
        if initiatingsystem is not None:
            headers["InitiatingSystem"] = str(initiatingsystem)
        if servicemode is not None:
            headers["ServiceMode"] = str(servicemode)
        if uuidseqno is not None:
            headers["UUIDSeqNo"] = str(uuidseqno)
        if entity is not None:
            headers["entity"] = str(entity)
        if languagecode is not None:
            headers["languageCode"] = str(languagecode)
        if referenceid is not None:
            headers["referenceId"] = str(referenceid)
        if userid is not None:
            headers["userId"] = str(userid)
        
        
        return await make_api_request(
            "GET", 
            path, 
            
            params=params if params else None, 
            headers=headers if headers else None
        )
    
    
    
    @mcp.tool()
    async def fiet1921_fetch_depreciation_data_getusing_get(
        assettype: int,
        instrumentid: int,
        accesstoken: Optional[str] = None,
        entity: Optional[str] = None,
        languagecode: Optional[int] = None,
        referenceid: Optional[str] = None,
        requesthash: Optional[str] = None,
        userid: Optional[int] = None
    ) -> Dict[str, Any]:
        """
        Fetch Depreciation Data
        
        Generated from: GET /productSetUp/instruments/depreciation/depreciationData
        Source: swagger_2_0
        Operation ID: FIET1921FetchDepreciationData_GETUsingGET
        
        
        Authentication: Not required
        
        Parameters:
        - assetType: integer (required)
          asset type
        - instrumentId: integer (required)
          instrument id
        
        
        
        Headers:
        - Accesstoken: string
          Authorization token for identification of the caller
        - entity: string
          entity
        - languageCode: integer
          languageCode
        - referenceId: string
          Place holder for Token based authentication
        - requesthash: string
          Request payload for hash validation
        - userId: integer
          userId
        
        
        """
        
        
        # Prepare query parameters
        params = {}
        if assettype is not None:
            params["assetType"] = assettype
            
        if instrumentid is not None:
            params["instrumentId"] = instrumentid
            
        
        
        # Replace path parameters in URL
        path = "/productSetUp/instruments/depreciation/depreciationData"
        
        
        # Prepare headers
        headers = {}
        if accesstoken is not None:
            headers["Accesstoken"] = str(accesstoken)
        if entity is not None:
            headers["entity"] = str(entity)
        if languagecode is not None:
            headers["languageCode"] = str(languagecode)
        if referenceid is not None:
            headers["referenceId"] = str(referenceid)
        if requesthash is not None:
            headers["requesthash"] = str(requesthash)
        if userid is not None:
            headers["userId"] = str(userid)
        
        
        return await make_api_request(
            "GET", 
            path, 
            
            params=params if params else None, 
            headers=headers if headers else None
        )
    
    
    
    @mcp.tool()
    async def fiet1903_fetch_depreciation_prop_postusing_get(
        instrumentid: int,
        accesstoken: Optional[str] = None,
        channeltype: Optional[int] = None,
        co_relationid: Optional[int] = None,
        initiatingsystem: Optional[str] = None,
        servicemode: Optional[int] = None,
        uuidseqno: Optional[int] = None,
        entity: Optional[str] = None,
        languagecode: Optional[int] = None,
        referenceid: Optional[str] = None,
        userid: Optional[int] = None
    ) -> Dict[str, Any]:
        """
        Fetch Depreciation Property
        
        Generated from: GET /productSetUp/instruments/depreciation/depreciationProperty
        Source: swagger_2_0
        Operation ID: FIET1903FetchDepreciationProp_POSTUsingGET
        
        
        Authentication: Not required
        
        Parameters:
        - instrumentId: integer (required)
          instrument id
        
        
        
        Headers:
        - Accesstoken: string
          Authorization token for identification of the caller
        - ChannelType: integer
          Channel identifier from where the TXN has originated (Internet, Mobile, ATM, Branch Channel )
        - Co-Relationid: integer
          Unique ID for the service invoked, will be set by the TXN system
        - InitiatingSystem: string
          Indicating the initiated system
        - ServiceMode: integer
          Used for branch channel to indicate the type of customer
        - UUIDSeqNo: integer
          UUID Sequence Number
        - entity: string
          entity
        - languageCode: integer
          languageCode
        - referenceId: string
          Place holder for Token based authentication
        - userId: integer
          userId
        
        
        """
        
        
        # Prepare query parameters
        params = {}
        if instrumentid is not None:
            params["instrumentId"] = instrumentid
            
        
        
        # Replace path parameters in URL
        path = "/productSetUp/instruments/depreciation/depreciationProperty"
        
        
        # Prepare headers
        headers = {}
        if accesstoken is not None:
            headers["Accesstoken"] = str(accesstoken)
        if channeltype is not None:
            headers["ChannelType"] = str(channeltype)
        if co_relationid is not None:
            headers["Co-Relationid"] = str(co_relationid)
        if initiatingsystem is not None:
            headers["InitiatingSystem"] = str(initiatingsystem)
        if servicemode is not None:
            headers["ServiceMode"] = str(servicemode)
        if uuidseqno is not None:
            headers["UUIDSeqNo"] = str(uuidseqno)
        if entity is not None:
            headers["entity"] = str(entity)
        if languagecode is not None:
            headers["languageCode"] = str(languagecode)
        if referenceid is not None:
            headers["referenceId"] = str(referenceid)
        if userid is not None:
            headers["userId"] = str(userid)
        
        
        return await make_api_request(
            "GET", 
            path, 
            
            params=params if params else None, 
            headers=headers if headers else None
        )
    
    
    
    @mcp.tool()
    async def fibt1901_process_depreciation_prop_postusing_post(
        request_body:Dict[str, Any] ,  # processDepreciationPropertyResource,
        accesstoken: Optional[str] = None,
        channeltype: Optional[int] = None,
        co_relationid: Optional[int] = None,
        initiatingsystem: Optional[str] = None,
        servicemode: Optional[int] = None,
        uuidseqno: Optional[int] = None,
        entity: Optional[str] = None,
        languagecode: Optional[int] = None,
        referenceid: Optional[str] = None,
        requesthash: Optional[str] = None,
        userid: Optional[int] = None
    ) -> Dict[str, Any]:
        """
        Process Depreciation Property
        
        Generated from: POST /productSetUp/instruments/depreciation/depreciationProperty/process
        Source: swagger_2_0
        Operation ID: FIBT1901ProcessDepreciationProp_POSTUsingPOST
        
        
        Authentication: Not required
        
        Parameters:
        - request_body: any (required)
          input
        
        
        
        Headers:
        - Accesstoken: string
          Authorization token for identification of the caller
        - ChannelType: integer
          Channel identifier from where the TXN has originated (Internet, Mobile, ATM, Branch Channel )
        - Co-Relationid: integer
          Unique ID for the service invoked, will be set by the TXN system
        - InitiatingSystem: string
          Indicating the initiated system
        - ServiceMode: integer
          Used for branch channel to indicate the type of customer
        - UUIDSeqNo: integer
          UUID Sequence Number
        - entity: string
          entity
        - languageCode: integer
          languageCode
        - referenceId: string
          Place holder for Token based authentication
        - requesthash: string
          Request payload for hash validation
        - userId: integer
          userId
        
        
        """
        
        
        # Prepare request data
        
        # Single body parameter - send directly
        data = request_body if request_body is not None else {}
        
        
        
        # Prepare query parameters
        params = {}
        
        
        # Replace path parameters in URL
        path = "/productSetUp/instruments/depreciation/depreciationProperty/process"
        
        
        # Prepare headers
        headers = {}
        if accesstoken is not None:
            headers["Accesstoken"] = str(accesstoken)
        if channeltype is not None:
            headers["ChannelType"] = str(channeltype)
        if co_relationid is not None:
            headers["Co-Relationid"] = str(co_relationid)
        if initiatingsystem is not None:
            headers["InitiatingSystem"] = str(initiatingsystem)
        if servicemode is not None:
            headers["ServiceMode"] = str(servicemode)
        if uuidseqno is not None:
            headers["UUIDSeqNo"] = str(uuidseqno)
        if entity is not None:
            headers["entity"] = str(entity)
        if languagecode is not None:
            headers["languageCode"] = str(languagecode)
        if referenceid is not None:
            headers["referenceId"] = str(referenceid)
        if requesthash is not None:
            headers["requesthash"] = str(requesthash)
        if userid is not None:
            headers["userId"] = str(userid)
        
        
        return await make_api_request(
            "POST", 
            path, 
            data=data, 
            params=params if params else None, 
            headers=headers if headers else None
        )
    
    
    
    @mcp.tool()
    async def fiet1920_fetch_asset_instrument_dtls_postusing_get(
        fixedassettype: Optional[int] = None,
        instrumentid: Optional[int] = None,
        accesstoken: Optional[str] = None,
        channeltype: Optional[int] = None,
        co_relationid: Optional[int] = None,
        initiatingsystem: Optional[str] = None,
        servicemode: Optional[int] = None,
        uuidseqno: Optional[int] = None,
        entity: Optional[str] = None,
        languagecode: Optional[int] = None,
        referenceid: Optional[str] = None,
        userid: Optional[int] = None
    ) -> Dict[str, Any]:
        """
        Fetch Fixed Asset Instrument Details
        
        Generated from: GET /productSetUp/instruments/fixedAsset/fetchAssetInstrumentDtls
        Source: swagger_2_0
        Operation ID: FIET1920FetchAssetInstrumentDtls_POSTUsingGET
        
        
        Authentication: Not required
        
        Parameters:
        - fixedAssetType: integer
          Fixed Asset Type
        - instrumentId: integer
          instrument id
        
        
        
        Headers:
        - Accesstoken: string
          Authorization token for identification of the caller
        - ChannelType: integer
          Channel identifier from where the TXN has originated (Internet, Mobile, ATM, Branch Channel )
        - Co-Relationid: integer
          Unique ID for the service invoked, will be set by the TXN system
        - InitiatingSystem: string
          Indicating the initiated system
        - ServiceMode: integer
          Used for branch channel to indicate the type of customer
        - UUIDSeqNo: integer
          UUID Sequence Number
        - entity: string
          entity
        - languageCode: integer
          languageCode
        - referenceId: string
          Place holder for Token based authentication
        - userId: integer
          userId
        
        
        """
        
        
        # Prepare query parameters
        params = {}
        if fixedassettype is not None:
            params["fixedAssetType"] = fixedassettype
            
        if instrumentid is not None:
            params["instrumentId"] = instrumentid
            
        
        
        # Replace path parameters in URL
        path = "/productSetUp/instruments/fixedAsset/fetchAssetInstrumentDtls"
        
        
        # Prepare headers
        headers = {}
        if accesstoken is not None:
            headers["Accesstoken"] = str(accesstoken)
        if channeltype is not None:
            headers["ChannelType"] = str(channeltype)
        if co_relationid is not None:
            headers["Co-Relationid"] = str(co_relationid)
        if initiatingsystem is not None:
            headers["InitiatingSystem"] = str(initiatingsystem)
        if servicemode is not None:
            headers["ServiceMode"] = str(servicemode)
        if uuidseqno is not None:
            headers["UUIDSeqNo"] = str(uuidseqno)
        if entity is not None:
            headers["entity"] = str(entity)
        if languagecode is not None:
            headers["languageCode"] = str(languagecode)
        if referenceid is not None:
            headers["referenceId"] = str(referenceid)
        if userid is not None:
            headers["userId"] = str(userid)
        
        
        return await make_api_request(
            "GET", 
            path, 
            
            params=params if params else None, 
            headers=headers if headers else None
        )
    
    
    
    @mcp.tool()
    async def fiet1902_fetch_fixed_asset_code_postusing_get(
        instrumentid: int,
        accesstoken: Optional[str] = None,
        channeltype: Optional[int] = None,
        co_relationid: Optional[int] = None,
        initiatingsystem: Optional[str] = None,
        servicemode: Optional[int] = None,
        uuidseqno: Optional[int] = None,
        entity: Optional[str] = None,
        languagecode: Optional[int] = None,
        referenceid: Optional[str] = None,
        userid: Optional[int] = None
    ) -> Dict[str, Any]:
        """
        Fetch fixed Asset Code
        
        Generated from: GET /productSetUp/instruments/fixedAsset/fixedAssetCode
        Source: swagger_2_0
        Operation ID: FIET1902FetchFixedAssetCode_POSTUsingGET
        
        
        Authentication: Not required
        
        Parameters:
        - instrumentId: integer (required)
          instrument id
        
        
        
        Headers:
        - Accesstoken: string
          Authorization token for identification of the caller
        - ChannelType: integer
          Channel identifier from where the TXN has originated (Internet, Mobile, ATM, Branch Channel )
        - Co-Relationid: integer
          Unique ID for the service invoked, will be set by the TXN system
        - InitiatingSystem: string
          Indicating the initiated system
        - ServiceMode: integer
          Used for branch channel to indicate the type of customer
        - UUIDSeqNo: integer
          UUID Sequence Number
        - entity: string
          entity
        - languageCode: integer
          languageCode
        - referenceId: string
          Place holder for Token based authentication
        - userId: integer
          userId
        
        
        """
        
        
        # Prepare query parameters
        params = {}
        if instrumentid is not None:
            params["instrumentId"] = instrumentid
            
        
        
        # Replace path parameters in URL
        path = "/productSetUp/instruments/fixedAsset/fixedAssetCode"
        
        
        # Prepare headers
        headers = {}
        if accesstoken is not None:
            headers["Accesstoken"] = str(accesstoken)
        if channeltype is not None:
            headers["ChannelType"] = str(channeltype)
        if co_relationid is not None:
            headers["Co-Relationid"] = str(co_relationid)
        if initiatingsystem is not None:
            headers["InitiatingSystem"] = str(initiatingsystem)
        if servicemode is not None:
            headers["ServiceMode"] = str(servicemode)
        if uuidseqno is not None:
            headers["UUIDSeqNo"] = str(uuidseqno)
        if entity is not None:
            headers["entity"] = str(entity)
        if languagecode is not None:
            headers["languageCode"] = str(languagecode)
        if referenceid is not None:
            headers["referenceId"] = str(referenceid)
        if userid is not None:
            headers["userId"] = str(userid)
        
        
        return await make_api_request(
            "GET", 
            path, 
            
            params=params if params else None, 
            headers=headers if headers else None
        )
    
    
    
    @mcp.tool()
    async def fibt1900_process_fixed_asset_code_postusing_post(
        request_body:Dict[str, Any] ,  # processFixedAssetCodeResource,
        accesstoken: Optional[str] = None,
        channeltype: Optional[int] = None,
        co_relationid: Optional[int] = None,
        initiatingsystem: Optional[str] = None,
        servicemode: Optional[int] = None,
        uuidseqno: Optional[int] = None,
        entity: Optional[str] = None,
        languagecode: Optional[int] = None,
        referenceid: Optional[str] = None,
        requesthash: Optional[str] = None,
        userid: Optional[int] = None
    ) -> Dict[str, Any]:
        """
        Process fixed Asset Code
        
        Generated from: POST /productSetUp/instruments/fixedAsset/process
        Source: swagger_2_0
        Operation ID: FIBT1900ProcessFixedAssetCode_POSTUsingPOST
        
        
        Authentication: Not required
        
        Parameters:
        - request_body: any (required)
          input
        
        
        
        Headers:
        - Accesstoken: string
          Authorization token for identification of the caller
        - ChannelType: integer
          Channel identifier from where the TXN has originated (Internet, Mobile, ATM, Branch Channel )
        - Co-Relationid: integer
          Unique ID for the service invoked, will be set by the TXN system
        - InitiatingSystem: string
          Indicating the initiated system
        - ServiceMode: integer
          Used for branch channel to indicate the type of customer
        - UUIDSeqNo: integer
          UUID Sequence Number
        - entity: string
          entity
        - languageCode: integer
          languageCode
        - referenceId: string
          Place holder for Token based authentication
        - requesthash: string
          Request payload for hash validation
        - userId: integer
          userId
        
        
        """
        
        
        # Prepare request data
        
        # Single body parameter - send directly
        data = request_body if request_body is not None else {}
        
        
        
        # Prepare query parameters
        params = {}
        
        
        # Replace path parameters in URL
        path = "/productSetUp/instruments/fixedAsset/process"
        
        
        # Prepare headers
        headers = {}
        if accesstoken is not None:
            headers["Accesstoken"] = str(accesstoken)
        if channeltype is not None:
            headers["ChannelType"] = str(channeltype)
        if co_relationid is not None:
            headers["Co-Relationid"] = str(co_relationid)
        if initiatingsystem is not None:
            headers["InitiatingSystem"] = str(initiatingsystem)
        if servicemode is not None:
            headers["ServiceMode"] = str(servicemode)
        if uuidseqno is not None:
            headers["UUIDSeqNo"] = str(uuidseqno)
        if entity is not None:
            headers["entity"] = str(entity)
        if languagecode is not None:
            headers["languageCode"] = str(languagecode)
        if referenceid is not None:
            headers["referenceId"] = str(referenceid)
        if requesthash is not None:
            headers["requesthash"] = str(requesthash)
        if userid is not None:
            headers["userId"] = str(userid)
        
        
        return await make_api_request(
            "POST", 
            path, 
            data=data, 
            params=params if params else None, 
            headers=headers if headers else None
        )
    
    
    
    @mcp.tool()
    async def fibt1542_lmt_crncy_prpty_postusing_post(
        request_body:Dict[str, Any] ,  # LimitCurrencyPropertyResource,
        accesstoken_: Optional[str] = None,
        channeltype: Optional[int] = None,
        co_relationid: Optional[int] = None,
        initiatingsystem: Optional[str] = None,
        servicemode: Optional[int] = None,
        uuidseqno: Optional[int] = None,
        entity: Optional[str] = None,
        languagecode: Optional[int] = None,
        referenceid: Optional[str] = None,
        requesthash: Optional[str] = None,
        userid: Optional[int] = None
    ) -> Dict[str, Any]:
        """
        Limit Currency Property
        
        Generated from: POST /productSetUp/instruments/limitCurrencyProperty
        Source: swagger_2_0
        Operation ID: FIBT1542LmtCrncyPrpty_POSTUsingPOST
        
        
        Authentication: Not required
        
        Parameters:
        - request_body: any (required)
          input
        
        
        
        Headers:
        - Accesstoken : string
          Authorization Token for identification of the call
        - ChannelType: integer
          Channel identifier from where the TXN has originated (Internet, Mobile, ATM, Branch Channel )
        - Co-Relationid: integer
          Unique ID for the service invoked, will be set by the TXN system
        - InitiatingSystem: string
          Indicating the initiated system
        - ServiceMode: integer
          Used for branch channel to indicate the type of customer
        - UUIDSeqNo: integer
          UUID Sequence Number
        - entity: string
          entity
        - languageCode: integer
          languageCode
        - referenceId: string
          Place holder for Token based authentication
        - requesthash: string
          Request payload for hash validation
        - userId: integer
          userId
        
        
        """
        
        
        # Prepare request data
        
        # Single body parameter - send directly
        data = request_body if request_body is not None else {}
        
        
        
        # Prepare query parameters
        params = {}
        
        
        # Replace path parameters in URL
        path = "/productSetUp/instruments/limitCurrencyProperty"
        
        
        # Prepare headers
        headers = {}
        if accesstoken_ is not None:
            headers["Accesstoken "] = str(accesstoken_)
        if channeltype is not None:
            headers["ChannelType"] = str(channeltype)
        if co_relationid is not None:
            headers["Co-Relationid"] = str(co_relationid)
        if initiatingsystem is not None:
            headers["InitiatingSystem"] = str(initiatingsystem)
        if servicemode is not None:
            headers["ServiceMode"] = str(servicemode)
        if uuidseqno is not None:
            headers["UUIDSeqNo"] = str(uuidseqno)
        if entity is not None:
            headers["entity"] = str(entity)
        if languagecode is not None:
            headers["languageCode"] = str(languagecode)
        if referenceid is not None:
            headers["referenceId"] = str(referenceid)
        if requesthash is not None:
            headers["requesthash"] = str(requesthash)
        if userid is not None:
            headers["userId"] = str(userid)
        
        
        return await make_api_request(
            "POST", 
            path, 
            data=data, 
            params=params if params else None, 
            headers=headers if headers else None
        )
    
    
    
    @mcp.tool()
    async def fibt1543_dlt_lmt_crncy_prpty_deleteusing_delete(
        request_body:Dict[str, Any] ,  # DeleteLimitCurrencyPropertyRequest,
        accesstoken_: Optional[str] = None,
        channeltype: Optional[int] = None,
        co_relationid: Optional[int] = None,
        initiatingsystem: Optional[str] = None,
        servicemode: Optional[int] = None,
        uuidseqno: Optional[int] = None,
        entity: Optional[str] = None,
        languagecode: Optional[int] = None,
        referenceid: Optional[str] = None,
        requesthash: Optional[str] = None,
        userid: Optional[int] = None
    ) -> Dict[str, Any]:
        """
        Delete Currency Property
        
        Generated from: DELETE /productSetUp/instruments/limitCurrencyProperty
        Source: swagger_2_0
        Operation ID: FIBT1543DltLmtCrncyPrpty_DELETEUsingDELETE
        
        
        Authentication: Not required
        
        Parameters:
        - request_body: any (required)
          input
        
        
        
        Headers:
        - Accesstoken : string
          Authorization Token for identification of caller
        - ChannelType: integer
          Channel identifier from where the TXN has originated (Internet, Mobile, ATM, Branch Channel )
        - Co-Relationid: integer
          Unique ID for the service invoked, will be set by the TXN system
        - InitiatingSystem: string
          Indicating the initiated system
        - ServiceMode: integer
          Used for branch channel to indicate the type of customer
        - UUIDSeqNo: integer
          UUID Sequence Number
        - entity: string
          entity
        - languageCode: integer
          languageCode
        - referenceId: string
          Place holder for Token based authentication
        - requesthash: string
          Request payload for hash validation
        - userId: integer
          userId
        
        
        """
        
        
        # Prepare request data
        
        # Single body parameter - send directly
        data = request_body if request_body is not None else {}
        
        
        
        # Prepare query parameters
        params = {}
        
        
        # Replace path parameters in URL
        path = "/productSetUp/instruments/limitCurrencyProperty"
        
        
        # Prepare headers
        headers = {}
        if accesstoken_ is not None:
            headers["Accesstoken "] = str(accesstoken_)
        if channeltype is not None:
            headers["ChannelType"] = str(channeltype)
        if co_relationid is not None:
            headers["Co-Relationid"] = str(co_relationid)
        if initiatingsystem is not None:
            headers["InitiatingSystem"] = str(initiatingsystem)
        if servicemode is not None:
            headers["ServiceMode"] = str(servicemode)
        if uuidseqno is not None:
            headers["UUIDSeqNo"] = str(uuidseqno)
        if entity is not None:
            headers["entity"] = str(entity)
        if languagecode is not None:
            headers["languageCode"] = str(languagecode)
        if referenceid is not None:
            headers["referenceId"] = str(referenceid)
        if requesthash is not None:
            headers["requesthash"] = str(requesthash)
        if userid is not None:
            headers["userId"] = str(userid)
        
        
        return await make_api_request(
            "DELETE", 
            path, 
            data=data, 
            params=params if params else None, 
            headers=headers if headers else None
        )
    
    
    
    @mcp.tool()
    async def fiet1542_lmt_crncy_prpty_getusing_get(
        instrumentreference: int,
        ccycurrency: Optional[str] = None,
        customergroup: Optional[int] = None,
        limitcurrencypropertyid: Optional[int] = None,
        pagenum: Optional[int] = None,
        pagesize: Optional[int] = None,
        smallbusinessind: Optional[int] = None,
        validfrom: Optional[str] = None,
        accesstoken_: Optional[str] = None,
        channeltype: Optional[int] = None,
        co_relationid: Optional[int] = None,
        initiatingsystem: Optional[str] = None,
        servicemode: Optional[int] = None,
        uuidseqno: Optional[int] = None,
        entity: Optional[str] = None,
        languagecode: Optional[int] = None,
        referenceid: Optional[str] = None,
        userid: Optional[int] = None
    ) -> Dict[str, Any]:
        """
        Fetch Currency Property
        
        Generated from: GET /productSetUp/instruments/limitCurrencyProperty/{instrumentReference}
        Source: swagger_2_0
        Operation ID: FIET1542LmtCrncyPrpty_GETUsingGET
        
        
        Authentication: Not required
        
        Parameters:
        - ccyCurrency: string
          ccyCurrency
        - customerGroup: integer
          Customer Group
        - instrumentReference: integer (required)
          instrumentReference
        - limitCurrencyPropertyId: integer
          limitCurrencyPropertyId
        - pageNum: integer
          pageNum
        - pageSize: integer
          pageSize
        - smallBusinessInd: integer
          smallBusinessInd
        - validFrom: string
          validFrom
        
        
        
        Headers:
        - Accesstoken : string
          Authorization Token for identification of the caller
        - ChannelType: integer
          Channel identifier from where the TXN has originated (Internet, Mobile, ATM, Branch Channel )
        - Co-Relationid: integer
          Unique ID for the service invoked, will be set by the TXN system
        - InitiatingSystem: string
          Indicating the initiated system
        - ServiceMode: integer
          Used for branch channel to indicate the type of customer
        - UUIDSeqNo: integer
          UUID Sequence Number
        - entity: string
          entity
        - languageCode: integer
          languageCode
        - referenceId: string
          Place holder for Token based authentication
        - userId: integer
          userId
        
        
        """
        
        
        # Prepare query parameters
        params = {}
        if ccycurrency is not None:
            params["ccyCurrency"] = ccycurrency
            
        if customergroup is not None:
            params["customerGroup"] = customergroup
            
        if limitcurrencypropertyid is not None:
            params["limitCurrencyPropertyId"] = limitcurrencypropertyid
            
        if pagenum is not None:
            params["pageNum"] = pagenum
            
        if pagesize is not None:
            params["pageSize"] = pagesize
            
        if smallbusinessind is not None:
            params["smallBusinessInd"] = smallbusinessind
            
        if validfrom is not None:
            params["validFrom"] = validfrom
            
        
        
        # Replace path parameters in URL
        path = "/productSetUp/instruments/limitCurrencyProperty/{instrumentReference}"
        if instrumentreference is not None:
            path = path.replace("{instrumentReference}", str(instrumentreference))
        
        
        # Prepare headers
        headers = {}
        if accesstoken_ is not None:
            headers["Accesstoken "] = str(accesstoken_)
        if channeltype is not None:
            headers["ChannelType"] = str(channeltype)
        if co_relationid is not None:
            headers["Co-Relationid"] = str(co_relationid)
        if initiatingsystem is not None:
            headers["InitiatingSystem"] = str(initiatingsystem)
        if servicemode is not None:
            headers["ServiceMode"] = str(servicemode)
        if uuidseqno is not None:
            headers["UUIDSeqNo"] = str(uuidseqno)
        if entity is not None:
            headers["entity"] = str(entity)
        if languagecode is not None:
            headers["languageCode"] = str(languagecode)
        if referenceid is not None:
            headers["referenceId"] = str(referenceid)
        if userid is not None:
            headers["userId"] = str(userid)
        
        
        return await make_api_request(
            "GET", 
            path, 
            
            params=params if params else None, 
            headers=headers if headers else None
        )
    
    
    
    @mcp.tool()
    async def fibt1541_lmt_prpty_postusing_post(
        request_body:Dict[str, Any] ,  # LimitPropertiesResource,
        accesstoken_: Optional[str] = None,
        channeltype: Optional[int] = None,
        co_relationid: Optional[int] = None,
        initiatingsystem: Optional[str] = None,
        servicemode: Optional[int] = None,
        uuidseqno: Optional[int] = None,
        entity: Optional[str] = None,
        languagecode: Optional[int] = None,
        referenceid: Optional[str] = None,
        requesthash: Optional[str] = None,
        userid: Optional[int] = None
    ) -> Dict[str, Any]:
        """
        Create Limit Properties
        
        Generated from: POST /productSetUp/instruments/limitProperties
        Source: swagger_2_0
        Operation ID: FIBT1541LmtPrpty_POSTUsingPOST
        
        
        Authentication: Not required
        
        Parameters:
        - request_body: any (required)
          input
        
        
        
        Headers:
        - Accesstoken : string
          Authorization Token for identification of the caller
        - ChannelType: integer
          Channel identifier from where the TXN has originated (Internet, Mobile, ATM, Branch Channel )
        - Co-Relationid: integer
          Unique ID for the service invoked, will be set by the TXN system
        - InitiatingSystem: string
          Indicating the initiated system
        - ServiceMode: integer
          Used for branch channel to indicate the type of customer
        - UUIDSeqNo: integer
          UUID Sequence Number
        - entity: string
          entity
        - languageCode: integer
          languageCode
        - referenceId: string
          Place holder for Token based authentication
        - requesthash: string
          Request payload for hash validation
        - userId: integer
          userId
        
        
        """
        
        
        # Prepare request data
        
        # Single body parameter - send directly
        data = request_body if request_body is not None else {}
        
        
        
        # Prepare query parameters
        params = {}
        
        
        # Replace path parameters in URL
        path = "/productSetUp/instruments/limitProperties"
        
        
        # Prepare headers
        headers = {}
        if accesstoken_ is not None:
            headers["Accesstoken "] = str(accesstoken_)
        if channeltype is not None:
            headers["ChannelType"] = str(channeltype)
        if co_relationid is not None:
            headers["Co-Relationid"] = str(co_relationid)
        if initiatingsystem is not None:
            headers["InitiatingSystem"] = str(initiatingsystem)
        if servicemode is not None:
            headers["ServiceMode"] = str(servicemode)
        if uuidseqno is not None:
            headers["UUIDSeqNo"] = str(uuidseqno)
        if entity is not None:
            headers["entity"] = str(entity)
        if languagecode is not None:
            headers["languageCode"] = str(languagecode)
        if referenceid is not None:
            headers["referenceId"] = str(referenceid)
        if requesthash is not None:
            headers["requesthash"] = str(requesthash)
        if userid is not None:
            headers["userId"] = str(userid)
        
        
        return await make_api_request(
            "POST", 
            path, 
            data=data, 
            params=params if params else None, 
            headers=headers if headers else None
        )
    
    
    
    @mcp.tool()
    async def fiet1541_get_lmt_prpty_getusing_get(
        instrumentreference: int,
        sequencenumber: int,
        validfrom: Optional[str] = None,
        channeltype: Optional[int] = None,
        co_relationid: Optional[int] = None,
        initiatingsystem: Optional[str] = None,
        servicemode: Optional[int] = None,
        uuidseqno: Optional[int] = None,
        authorization: Optional[str] = None,
        entity: Optional[str] = None,
        languagecode: Optional[int] = None,
        referenceid: Optional[str] = None,
        userid: Optional[int] = None
    ) -> Dict[str, Any]:
        """
        Fetch Limit Property
        
        Generated from: GET /productSetUp/instruments/limitProperties/{instrumentReference}/details
        Source: swagger_2_0
        Operation ID: FIET1541GetLmtPrpty_GETUsingGET
        
        
        Authentication: Not required
        
        Parameters:
        - instrumentReference: integer (required)
          instrumentReference
        - sequenceNumber: integer (required)
          SEQ_NO
        - validFrom: string
          VLD_FRM
        
        
        
        Headers:
        - ChannelType: integer
          Channel identifier from where the TXN has originated (Internet, Mobile, ATM, Branch Channel )
        - Co-Relationid: integer
          Unique ID for the service invoked, will be set by the TXN system
        - InitiatingSystem: string
          Indicating the initiated system
        - ServiceMode: integer
          Used for branch channel to indicate the type of customer
        - UUIDSeqNo: integer
          UUID Sequence Number
        - authorization: string
          Authorization Token to validation the caller
        - entity: string
          entity
        - languageCode: integer
          languageCode
        - referenceId: string
          Place holder for Token based authentication
        - userId: integer
          userId
        
        
        """
        
        
        # Prepare query parameters
        params = {}
        if sequencenumber is not None:
            params["sequenceNumber"] = sequencenumber
            
        if validfrom is not None:
            params["validFrom"] = validfrom
            
        
        
        # Replace path parameters in URL
        path = "/productSetUp/instruments/limitProperties/{instrumentReference}/details"
        if instrumentreference is not None:
            path = path.replace("{instrumentReference}", str(instrumentreference))
        
        
        # Prepare headers
        headers = {}
        if channeltype is not None:
            headers["ChannelType"] = str(channeltype)
        if co_relationid is not None:
            headers["Co-Relationid"] = str(co_relationid)
        if initiatingsystem is not None:
            headers["InitiatingSystem"] = str(initiatingsystem)
        if servicemode is not None:
            headers["ServiceMode"] = str(servicemode)
        if uuidseqno is not None:
            headers["UUIDSeqNo"] = str(uuidseqno)
        if authorization is not None:
            headers["authorization"] = str(authorization)
        if entity is not None:
            headers["entity"] = str(entity)
        if languagecode is not None:
            headers["languageCode"] = str(languagecode)
        if referenceid is not None:
            headers["referenceId"] = str(referenceid)
        if userid is not None:
            headers["userId"] = str(userid)
        
        
        return await make_api_request(
            "GET", 
            path, 
            
            params=params if params else None, 
            headers=headers if headers else None
        )
    
    
    
    @mcp.tool()
    async def fiet1541_get_lmt_prp_list_postusing_get(
        instrumentreference: int,
        pagenum: Optional[int] = None,
        pagesize: Optional[int] = None,
        accesstoken: Optional[str] = None,
        channeltype: Optional[int] = None,
        co_relationid: Optional[int] = None,
        initiatingsystem: Optional[str] = None,
        servicemode: Optional[int] = None,
        uuidseqno: Optional[int] = None,
        entity: Optional[str] = None,
        languagecode: Optional[int] = None,
        referenceid: Optional[str] = None,
        userid: Optional[int] = None
    ) -> Dict[str, Any]:
        """
        Get Limit Property List
        
        Generated from: GET /productSetUp/instruments/limitProperties/{instrumentReference}/list
        Source: swagger_2_0
        Operation ID: FIET1541GetLmtPrpList_POSTUsingGET
        
        
        Authentication: Not required
        
        Parameters:
        - instrumentReference: integer (required)
          instrumentReference
        - pageNum: integer
          pageNum
        - pageSize: integer
          pageSize
        
        
        
        Headers:
        - Accesstoken: string
          Authorization token for identification of the caller
        - ChannelType: integer
          Channel identifier from where the TXN has originated (Internet, Mobile, ATM, Branch Channel )
        - Co-Relationid: integer
          Unique ID for the service invoked, will be set by the TXN system
        - InitiatingSystem: string
          Indicating the initiated system
        - ServiceMode: integer
          Used for branch channel to indicate the type of customer
        - UUIDSeqNo: integer
          UUID Sequence Number
        - entity: string
          entity
        - languageCode: integer
          languageCode
        - referenceId: string
          Place holder for Token based authentication
        - userId: integer
          userId
        
        
        """
        
        
        # Prepare query parameters
        params = {}
        if pagenum is not None:
            params["pageNum"] = pagenum
            
        if pagesize is not None:
            params["pageSize"] = pagesize
            
        
        
        # Replace path parameters in URL
        path = "/productSetUp/instruments/limitProperties/{instrumentReference}/list"
        if instrumentreference is not None:
            path = path.replace("{instrumentReference}", str(instrumentreference))
        
        
        # Prepare headers
        headers = {}
        if accesstoken is not None:
            headers["Accesstoken"] = str(accesstoken)
        if channeltype is not None:
            headers["ChannelType"] = str(channeltype)
        if co_relationid is not None:
            headers["Co-Relationid"] = str(co_relationid)
        if initiatingsystem is not None:
            headers["InitiatingSystem"] = str(initiatingsystem)
        if servicemode is not None:
            headers["ServiceMode"] = str(servicemode)
        if uuidseqno is not None:
            headers["UUIDSeqNo"] = str(uuidseqno)
        if entity is not None:
            headers["entity"] = str(entity)
        if languagecode is not None:
            headers["languageCode"] = str(languagecode)
        if referenceid is not None:
            headers["referenceId"] = str(referenceid)
        if userid is not None:
            headers["userId"] = str(userid)
        
        
        return await make_api_request(
            "GET", 
            path, 
            
            params=params if params else None, 
            headers=headers if headers else None
        )
    
    
    
    @mcp.tool()
    async def fiet8004_ftch_fpfor_prdct_getusing_get(
        instrumentreference: int,
        pagenum: Optional[int] = None,
        pagesize: Optional[int] = None,
        accesstoken: Optional[str] = None,
        channeltype: Optional[int] = None,
        co_relationid: Optional[int] = None,
        initiatingsystem: Optional[str] = None,
        servicemode: Optional[int] = None,
        uuidseqno: Optional[int] = None,
        entity: Optional[str] = None,
        languagecode: Optional[int] = None,
        referenceid: Optional[str] = None,
        userid: Optional[int] = None
    ) -> Dict[str, Any]:
        """
        Fetch Records For Product Fee Setup
        
        Generated from: GET /productSetUp/instruments/productFee/{instrumentReference}
        Source: swagger_2_0
        Operation ID: FIET8004FtchFPForPrdct_GETUsingGET
        
        
        Authentication: Not required
        
        Parameters:
        - instrumentReference: integer (required)
          Instrument Reference
        - pageNum: integer
          pageNum
        - pageSize: integer
          pageSize
        
        
        
        Headers:
        - Accesstoken: string
          Authorization token for identification of the caller
        - ChannelType: integer
          Channel identifier from where the TXN has originated (Internet, Mobile, ATM, Branch Channel )
        - Co-Relationid: integer
          Unique ID for the service invoked, will be set by the TXN system
        - InitiatingSystem: string
          Indicating the initiated system
        - ServiceMode: integer
          Used for branch channel to indicate the type of customer
        - UUIDSeqNo: integer
          UUID Sequence Number
        - entity: string
          entity
        - languageCode: integer
          languageCode
        - referenceId: string
          Place holder for Token based authentication
        - userId: integer
          userId
        
        
        """
        
        
        # Prepare query parameters
        params = {}
        if pagenum is not None:
            params["pageNum"] = pagenum
            
        if pagesize is not None:
            params["pageSize"] = pagesize
            
        
        
        # Replace path parameters in URL
        path = "/productSetUp/instruments/productFee/{instrumentReference}"
        if instrumentreference is not None:
            path = path.replace("{instrumentReference}", str(instrumentreference))
        
        
        # Prepare headers
        headers = {}
        if accesstoken is not None:
            headers["Accesstoken"] = str(accesstoken)
        if channeltype is not None:
            headers["ChannelType"] = str(channeltype)
        if co_relationid is not None:
            headers["Co-Relationid"] = str(co_relationid)
        if initiatingsystem is not None:
            headers["InitiatingSystem"] = str(initiatingsystem)
        if servicemode is not None:
            headers["ServiceMode"] = str(servicemode)
        if uuidseqno is not None:
            headers["UUIDSeqNo"] = str(uuidseqno)
        if entity is not None:
            headers["entity"] = str(entity)
        if languagecode is not None:
            headers["languageCode"] = str(languagecode)
        if referenceid is not None:
            headers["referenceId"] = str(referenceid)
        if userid is not None:
            headers["userId"] = str(userid)
        
        
        return await make_api_request(
            "GET", 
            path, 
            
            params=params if params else None, 
            headers=headers if headers else None
        )
    
    
    
    @mcp.tool()
    async def fibt8003_crt_fpfor_prdct_postusing_post(
        request_body:Dict[str, Any] ,  # ProductFeeSetupResource,
        accesstoken_: Optional[str] = None,
        channeltype: Optional[int] = None,
        co_relationid: Optional[int] = None,
        initiatingsystem: Optional[str] = None,
        servicemode: Optional[int] = None,
        uuidseqno: Optional[int] = None,
        entity: Optional[str] = None,
        languagecode: Optional[int] = None,
        referenceid: Optional[str] = None,
        requesthash: Optional[str] = None,
        userid: Optional[int] = None
    ) -> Dict[str, Any]:
        """
        Create Product Fee Setup
        
        Generated from: POST /productSetUp/instruments/productFeeSetup
        Source: swagger_2_0
        Operation ID: FIBT8003CrtFPForPrdct_POSTUsingPOST
        
        
        Authentication: Not required
        
        Parameters:
        - request_body: any (required)
          input
        
        
        
        Headers:
        - Accesstoken : string
          Authorization Token for identification of the caller
        - ChannelType: integer
          Channel identifier from where the TXN has originated (Internet, Mobile, ATM, Branch Channel )
        - Co-Relationid: integer
          Unique ID for the service invoked, will be set by the TXN system
        - InitiatingSystem: string
          Indicating the initiated system
        - ServiceMode: integer
          Used for branch channel to indicate the type of customer
        - UUIDSeqNo: integer
          UUID Sequence Number
        - entity: string
          entity
        - languageCode: integer
          languageCode
        - referenceId: string
          Identified reference field for authorization
        - requesthash: string
          Request payload for hash validation
        - userId: integer
          userId
        
        
        """
        
        
        # Prepare request data
        
        # Single body parameter - send directly
        data = request_body if request_body is not None else {}
        
        
        
        # Prepare query parameters
        params = {}
        
        
        # Replace path parameters in URL
        path = "/productSetUp/instruments/productFeeSetup"
        
        
        # Prepare headers
        headers = {}
        if accesstoken_ is not None:
            headers["Accesstoken "] = str(accesstoken_)
        if channeltype is not None:
            headers["ChannelType"] = str(channeltype)
        if co_relationid is not None:
            headers["Co-Relationid"] = str(co_relationid)
        if initiatingsystem is not None:
            headers["InitiatingSystem"] = str(initiatingsystem)
        if servicemode is not None:
            headers["ServiceMode"] = str(servicemode)
        if uuidseqno is not None:
            headers["UUIDSeqNo"] = str(uuidseqno)
        if entity is not None:
            headers["entity"] = str(entity)
        if languagecode is not None:
            headers["languageCode"] = str(languagecode)
        if referenceid is not None:
            headers["referenceId"] = str(referenceid)
        if requesthash is not None:
            headers["requesthash"] = str(requesthash)
        if userid is not None:
            headers["userId"] = str(userid)
        
        
        return await make_api_request(
            "POST", 
            path, 
            data=data, 
            params=params if params else None, 
            headers=headers if headers else None
        )
    
    
    
    @mcp.tool()
    async def fibt2008_create_share_param_postusing_post(
        request_body:Dict[str, Any] ,  # createShareParamResource,
        accesstoken: Optional[str] = None,
        channeltype: Optional[int] = None,
        co_relationid: Optional[int] = None,
        initiatingsystem: Optional[str] = None,
        servicemode: Optional[int] = None,
        uuidseqno: Optional[int] = None,
        entity: Optional[str] = None,
        languagecode: Optional[int] = None,
        referenceid: Optional[str] = None,
        userid: Optional[int] = None
    ) -> Dict[str, Any]:
        """
        This service is used to create share parameters
        
        Generated from: POST /productSetUp/instruments/shareParam/create
        Source: swagger_2_0
        Operation ID: FIBT2008CreateShareParam_POSTUsingPOST
        
        
        Authentication: Not required
        
        Parameters:
        - request_body: any (required)
          input
        
        
        
        Headers:
        - Accesstoken: string
          Authorization token for identification of the caller
        - ChannelType: integer
          Channel identifier from where the TXN has originated (Internet, Mobile, ATM, Branch Channel )
        - Co-Relationid: integer
          Unique ID for the service invoked, will be set by the TXN system
        - InitiatingSystem: string
          Indicating the initiated system
        - ServiceMode: integer
          Used for branch channel to indicate the type of customer
        - UUIDSeqNo: integer
          UUID Sequence Number
        - entity: string
          entity
        - languageCode: integer
          languageCode
        - referenceId: string
          Place holder for Token based authentication
        - userId: integer
          userId
        
        
        """
        
        
        # Prepare request data
        
        # Single body parameter - send directly
        data = request_body if request_body is not None else {}
        
        
        
        # Prepare query parameters
        params = {}
        
        
        # Replace path parameters in URL
        path = "/productSetUp/instruments/shareParam/create"
        
        
        # Prepare headers
        headers = {}
        if accesstoken is not None:
            headers["Accesstoken"] = str(accesstoken)
        if channeltype is not None:
            headers["ChannelType"] = str(channeltype)
        if co_relationid is not None:
            headers["Co-Relationid"] = str(co_relationid)
        if initiatingsystem is not None:
            headers["InitiatingSystem"] = str(initiatingsystem)
        if servicemode is not None:
            headers["ServiceMode"] = str(servicemode)
        if uuidseqno is not None:
            headers["UUIDSeqNo"] = str(uuidseqno)
        if entity is not None:
            headers["entity"] = str(entity)
        if languagecode is not None:
            headers["languageCode"] = str(languagecode)
        if referenceid is not None:
            headers["referenceId"] = str(referenceid)
        if userid is not None:
            headers["userId"] = str(userid)
        
        
        return await make_api_request(
            "POST", 
            path, 
            data=data, 
            params=params if params else None, 
            headers=headers if headers else None
        )
    
    
    
    @mcp.tool()
    async def fiet2014_get_share_param_postusing_get(
        instrumentid: int,
        accesstoken: Optional[str] = None,
        channeltype: Optional[int] = None,
        co_relationid: Optional[int] = None,
        initiatingsystem: Optional[str] = None,
        servicemode: Optional[int] = None,
        uuidseqno: Optional[int] = None,
        entity: Optional[str] = None,
        languagecode: Optional[int] = None,
        referenceid: Optional[str] = None,
        userid: Optional[int] = None
    ) -> Dict[str, Any]:
        """
        This service is used to view share parameters
        
        Generated from: GET /productSetUp/instruments/shareParam/view/{instrumentId}
        Source: swagger_2_0
        Operation ID: FIET2014GetShareParam_POSTUsingGET
        
        
        Authentication: Not required
        
        Parameters:
        - instrumentId: integer (required)
          Instrument ID
        
        
        
        Headers:
        - Accesstoken: string
          Authorization token for identification of the caller
        - ChannelType: integer
          Channel identifier from where the TXN has originated (Internet, Mobile, ATM, Branch Channel )
        - Co-Relationid: integer
          Unique ID for the service invoked, will be set by the TXN system
        - InitiatingSystem: string
          Indicating the initiated system
        - ServiceMode: integer
          Used for branch channel to indicate the type of customer
        - UUIDSeqNo: integer
          UUID Sequence Number
        - entity: string
          entity
        - languageCode: integer
          languageCode
        - referenceId: string
          Place holder for Token based authentication
        - userId: integer
          userId
        
        
        """
        
        
        # Prepare query parameters
        params = {}
        
        
        # Replace path parameters in URL
        path = "/productSetUp/instruments/shareParam/view/{instrumentId}"
        if instrumentid is not None:
            path = path.replace("{instrumentId}", str(instrumentid))
        
        
        # Prepare headers
        headers = {}
        if accesstoken is not None:
            headers["Accesstoken"] = str(accesstoken)
        if channeltype is not None:
            headers["ChannelType"] = str(channeltype)
        if co_relationid is not None:
            headers["Co-Relationid"] = str(co_relationid)
        if initiatingsystem is not None:
            headers["InitiatingSystem"] = str(initiatingsystem)
        if servicemode is not None:
            headers["ServiceMode"] = str(servicemode)
        if uuidseqno is not None:
            headers["UUIDSeqNo"] = str(uuidseqno)
        if entity is not None:
            headers["entity"] = str(entity)
        if languagecode is not None:
            headers["languageCode"] = str(languagecode)
        if referenceid is not None:
            headers["referenceId"] = str(referenceid)
        if userid is not None:
            headers["userId"] = str(userid)
        
        
        return await make_api_request(
            "GET", 
            path, 
            
            params=params if params else None, 
            headers=headers if headers else None
        )
    
    
    
    @mcp.tool()
    async def fiet3302_get_pdt_crn_lst_getusing_get(
        currencyrestart: str,
        instrumentid: int,
        instrumentrestart: int,
        accesstoken: Optional[str] = None,
        channeltype: Optional[int] = None,
        co_relationid: Optional[int] = None,
        initiatingsystem: Optional[str] = None,
        servicemode: Optional[int] = None,
        uuidseqno: Optional[int] = None,
        entity: Optional[str] = None,
        languagecode: Optional[int] = None,
        referenceid: Optional[str] = None,
        requesthash: Optional[str] = None,
        userid: Optional[int] = None
    ) -> Dict[str, Any]:
        """
        FIET3302GetPdtCrnLst
        
        Generated from: GET /productSetUp/productCurrency/list
        Source: swagger_2_0
        Operation ID: FIET3302GetPdtCrnLst_GETUsingGET
        
        
        Authentication: Not required
        
        Parameters:
        - currencyRestart: string (required)
          InstrumentId
        - instrumentId: integer (required)
          InstrumentId
        - instrumentRestart: integer (required)
          InstrumentId
        
        
        
        Headers:
        - Accesstoken: string
          Authorization token for identification of the caller
        - ChannelType: integer
          Channel identifier from where the TXN has originated (Internet, Mobile, ATM, Branch Channel )
        - Co-Relationid: integer
          Unique ID for the service invoked, will be set by the TXN system
        - InitiatingSystem: string
          Indicating the initiated system
        - ServiceMode: integer
          Used for branch channel to indicate the type of customer
        - UUIDSeqNo: integer
          UUID Sequence Number
        - entity: string
          entity
        - languageCode: integer
          languageCode
        - referenceId: string
          Place holder for Token based authentication
        - requesthash: string
          Request payload for hash validation
        - userId: integer
          userId
        
        
        """
        
        
        # Prepare query parameters
        params = {}
        if currencyrestart is not None:
            params["currencyRestart"] = currencyrestart
            
        if instrumentid is not None:
            params["instrumentId"] = instrumentid
            
        if instrumentrestart is not None:
            params["instrumentRestart"] = instrumentrestart
            
        
        
        # Replace path parameters in URL
        path = "/productSetUp/productCurrency/list"
        
        
        # Prepare headers
        headers = {}
        if accesstoken is not None:
            headers["Accesstoken"] = str(accesstoken)
        if channeltype is not None:
            headers["ChannelType"] = str(channeltype)
        if co_relationid is not None:
            headers["Co-Relationid"] = str(co_relationid)
        if initiatingsystem is not None:
            headers["InitiatingSystem"] = str(initiatingsystem)
        if servicemode is not None:
            headers["ServiceMode"] = str(servicemode)
        if uuidseqno is not None:
            headers["UUIDSeqNo"] = str(uuidseqno)
        if entity is not None:
            headers["entity"] = str(entity)
        if languagecode is not None:
            headers["languageCode"] = str(languagecode)
        if referenceid is not None:
            headers["referenceId"] = str(referenceid)
        if requesthash is not None:
            headers["requesthash"] = str(requesthash)
        if userid is not None:
            headers["userId"] = str(userid)
        
        
        return await make_api_request(
            "GET", 
            path, 
            
            params=params if params else None, 
            headers=headers if headers else None
        )
    
    
    
    @mcp.tool()
    async def fiet2013_fetch_share_param_postusing_get(
        instrumentid: int,
        pagenum: Optional[int] = None,
        pagesize: Optional[int] = None,
        accesstoken: Optional[str] = None,
        channeltype: Optional[int] = None,
        co_relationid: Optional[int] = None,
        initiatingsystem: Optional[str] = None,
        servicemode: Optional[int] = None,
        uuidseqno: Optional[int] = None,
        entity: Optional[str] = None,
        languagecode: Optional[int] = None,
        referenceid: Optional[str] = None,
        userid: Optional[int] = None
    ) -> Dict[str, Any]:
        """
        This service is used to fetch share parameters
        
        Generated from: GET /productSetUp/shareParam/fetch/{instrumentId}
        Source: swagger_2_0
        Operation ID: FIET2013FetchShareParam_POSTUsingGET
        
        
        Authentication: Not required
        
        Parameters:
        - instrumentId: integer (required)
          Instrument ID
        - pageNum: integer
          pageNum
        - pageSize: integer
          pageSize
        
        
        
        Headers:
        - Accesstoken: string
          Authorization token for identification of the caller
        - ChannelType: integer
          Channel identifier from where the TXN has originated (Internet, Mobile, ATM, Branch Channel )
        - Co-Relationid: integer
          Unique ID for the service invoked, will be set by the TXN system
        - InitiatingSystem: string
          Indicating the initiated system
        - ServiceMode: integer
          Used for branch channel to indicate the type of customer
        - UUIDSeqNo: integer
          UUID Sequence Number
        - entity: string
          entity
        - languageCode: integer
          languageCode
        - referenceId: string
          Place holder for Token based authentication
        - userId: integer
          userId
        
        
        """
        
        
        # Prepare query parameters
        params = {}
        if pagenum is not None:
            params["pageNum"] = pagenum
            
        if pagesize is not None:
            params["pageSize"] = pagesize
            
        
        
        # Replace path parameters in URL
        path = "/productSetUp/shareParam/fetch/{instrumentId}"
        if instrumentid is not None:
            path = path.replace("{instrumentId}", str(instrumentid))
        
        
        # Prepare headers
        headers = {}
        if accesstoken is not None:
            headers["Accesstoken"] = str(accesstoken)
        if channeltype is not None:
            headers["ChannelType"] = str(channeltype)
        if co_relationid is not None:
            headers["Co-Relationid"] = str(co_relationid)
        if initiatingsystem is not None:
            headers["InitiatingSystem"] = str(initiatingsystem)
        if servicemode is not None:
            headers["ServiceMode"] = str(servicemode)
        if uuidseqno is not None:
            headers["UUIDSeqNo"] = str(uuidseqno)
        if entity is not None:
            headers["entity"] = str(entity)
        if languagecode is not None:
            headers["languageCode"] = str(languagecode)
        if referenceid is not None:
            headers["referenceId"] = str(referenceid)
        if userid is not None:
            headers["userId"] = str(userid)
        
        
        return await make_api_request(
            "GET", 
            path, 
            
            params=params if params else None, 
            headers=headers if headers else None
        )
    
    
    
    @mcp.tool()
    async def bset0202_get_mudtls_using_get(
        bankcode: str,
        accesstoken: Optional[str] = None,
        channeltype: Optional[int] = None,
        co_relationid: Optional[int] = None,
        initiatingsystem: Optional[str] = None,
        servicemode: Optional[int] = None,
        uuidseqno: Optional[int] = None,
        entity: Optional[str] = None,
        languagecode: Optional[int] = None,
        referenceid: Optional[str] = None,
        userid: Optional[int] = None
    ) -> Dict[str, Any]:
        """
        Fetch Bank Details
        
        Generated from: GET /referenceData/bank/details/{bankCode}
        Source: swagger_2_0
        Operation ID: BSET0202GetMUDtlsUsingGET
        
        
        Authentication: Not required
        
        Parameters:
        - bankCode: string (required)
          Enter the bank code for which data to be retrieved
        
        
        
        Headers:
        - Accesstoken: string
          Authorization Token to validation the caller
        - ChannelType: integer
          Channel identifier from where the TXN has originated (Internet, Mobile, ATM, Branch Channel )
        - Co-Relationid: integer
          Unique ID for the service invoked, will be set by the TXN system
        - InitiatingSystem: string
          Indicating the initiated system
        - ServiceMode: integer
          Used for branch channel to indicate the type of customer
        - UUIDSeqNo: integer
          UUID Sequence Number
        - entity: string
          entity
        - languageCode: integer
          languageCode
        - referenceId: string
          Place holder for Token based authentication
        - userId: integer
          userId
        
        
        """
        
        
        # Prepare query parameters
        params = {}
        
        
        # Replace path parameters in URL
        path = "/referenceData/bank/details/{bankCode}"
        if bankcode is not None:
            path = path.replace("{bankCode}", str(bankcode))
        
        
        # Prepare headers
        headers = {}
        if accesstoken is not None:
            headers["Accesstoken"] = str(accesstoken)
        if channeltype is not None:
            headers["ChannelType"] = str(channeltype)
        if co_relationid is not None:
            headers["Co-Relationid"] = str(co_relationid)
        if initiatingsystem is not None:
            headers["InitiatingSystem"] = str(initiatingsystem)
        if servicemode is not None:
            headers["ServiceMode"] = str(servicemode)
        if uuidseqno is not None:
            headers["UUIDSeqNo"] = str(uuidseqno)
        if entity is not None:
            headers["entity"] = str(entity)
        if languagecode is not None:
            headers["languageCode"] = str(languagecode)
        if referenceid is not None:
            headers["referenceId"] = str(referenceid)
        if userid is not None:
            headers["userId"] = str(userid)
        
        
        return await make_api_request(
            "GET", 
            path, 
            
            params=params if params else None, 
            headers=headers if headers else None
        )
    
    
    
    @mcp.tool()
    async def qzet0702_ftch_hol_using_get(
        year: int,
        fixedholiday: Optional[int] = None,
        holidayday: Optional[int] = None,
        holidaymonth: Optional[int] = None,
        holidayyear: Optional[int] = None,
        pagenum: Optional[int] = None,
        pagesize: Optional[int] = None,
        accesstoken: Optional[str] = None,
        channeltype: Optional[int] = None,
        co_relationid: Optional[int] = None,
        initiatingsystem: Optional[str] = None,
        servicemode: Optional[int] = None,
        uuidseqno: Optional[int] = None,
        entity: Optional[str] = None,
        languagecode: Optional[int] = None,
        referenceid: Optional[str] = None,
        userid: Optional[int] = None
    ) -> Dict[str, Any]:
        """
        Fetch Bank Holidays
        
        Generated from: GET /referenceData/bank/holidayList
        Source: swagger_2_0
        Operation ID: QZET0702FtchHolUsingGET
        
        
        Authentication: Not required
        
        Parameters:
        - FixedHoliday: integer
          The Fixed Holiday will denotes the Fixed Holidays or Non-Fixed/Weekend Holidays in a Calender Year. Weekend:0, Fixed Holiday:1,Non-Fixed Holiday:2
        - HolidayDay: integer
          Enter the day of holiday
        - HolidayMonth: integer
          Enter the month of holiday
        - HolidayYear: integer
          Enter the year of holiday
        - Year: integer (required)
          Enter the year of holiday
        - pageNum: integer
          pageNum
        - pageSize: integer
          pageSize
        
        
        
        Headers:
        - Accesstoken: string
          Authorization Token to validation the caller
        - ChannelType: integer
          Channel identifier from where the TXN has originated (Internet, Mobile, ATM, Branch Channel )
        - Co-Relationid: integer
          Unique ID for the service invoked, will be set by the TXN system
        - InitiatingSystem: string
          Indicating the initiated system
        - ServiceMode: integer
          Used for branch channel to indicate the type of customer
        - UUIDSeqNo: integer
          UUID Sequence Number
        - entity: string
          entity
        - languageCode: integer
          languageCode
        - referenceId: string
          Place holder for Token based authentication
        - userId: integer
          userId
        
        
        """
        
        
        # Prepare query parameters
        params = {}
        if fixedholiday is not None:
            params["FixedHoliday"] = fixedholiday
            
        if holidayday is not None:
            params["HolidayDay"] = holidayday
            
        if holidaymonth is not None:
            params["HolidayMonth"] = holidaymonth
            
        if holidayyear is not None:
            params["HolidayYear"] = holidayyear
            
        if year is not None:
            params["Year"] = year
            
        if pagenum is not None:
            params["pageNum"] = pagenum
            
        if pagesize is not None:
            params["pageSize"] = pagesize
            
        
        
        # Replace path parameters in URL
        path = "/referenceData/bank/holidayList"
        
        
        # Prepare headers
        headers = {}
        if accesstoken is not None:
            headers["Accesstoken"] = str(accesstoken)
        if channeltype is not None:
            headers["ChannelType"] = str(channeltype)
        if co_relationid is not None:
            headers["Co-Relationid"] = str(co_relationid)
        if initiatingsystem is not None:
            headers["InitiatingSystem"] = str(initiatingsystem)
        if servicemode is not None:
            headers["ServiceMode"] = str(servicemode)
        if uuidseqno is not None:
            headers["UUIDSeqNo"] = str(uuidseqno)
        if entity is not None:
            headers["entity"] = str(entity)
        if languagecode is not None:
            headers["languageCode"] = str(languagecode)
        if referenceid is not None:
            headers["referenceId"] = str(referenceid)
        if userid is not None:
            headers["userId"] = str(userid)
        
        
        return await make_api_request(
            "GET", 
            path, 
            
            params=params if params else None, 
            headers=headers if headers else None
        )
    
    
    
    @mcp.tool()
    async def cbcbt5548_crt_bsns_crspndc_dtls_postusing_post(
        request_body:Dict[str, Any] ,  # createBusinessCrspndcDetailsRequest,
        channeltype: Optional[int] = None,
        co_relationid: Optional[int] = None,
        entity: Optional[str] = None,
        initiatingsystem: Optional[str] = None,
        languagecode: Optional[int] = None,
        servicemode: Optional[int] = None,
        userid: Optional[int] = None,
        uuidseqno: Optional[int] = None
    ) -> Dict[str, Any]:
        """
        Api to create business correspondence details
        
        Generated from: POST /referenceData/createBusinessCrspndc
        Source: swagger_2_0
        Operation ID: CBCBT5548CrtBsnsCrspndcDtls_POSTUsingPOST
        
        
        Authentication: Not required
        
        Parameters:
        - request_body: any (required)
          input
        
        
        
        Headers:
        - channelType: integer
          Channel identifier from where the TXN has originated (Internet, Mobile, ATM, Branch Channel )
        - co-Relationid: integer
          Unique ID for the service invoked, will be set by the TXN system
        - entity: string
          entity
        - initiatingSystem: string
          Indicating the initiated system
        - languageCode: integer
          languageCode
        - serviceMode: integer
          Used for branch channel to indicate the type of customer
        - userId: integer
          userId
        - uuidSeqNo: integer
          UUID Sequence Number
        
        
        """
        
        
        # Prepare request data
        
        # Single body parameter - send directly
        data = request_body if request_body is not None else {}
        
        
        
        # Prepare query parameters
        params = {}
        
        
        # Replace path parameters in URL
        path = "/referenceData/createBusinessCrspndc"
        
        
        # Prepare headers
        headers = {}
        if channeltype is not None:
            headers["channelType"] = str(channeltype)
        if co_relationid is not None:
            headers["co-Relationid"] = str(co_relationid)
        if entity is not None:
            headers["entity"] = str(entity)
        if initiatingsystem is not None:
            headers["initiatingSystem"] = str(initiatingsystem)
        if languagecode is not None:
            headers["languageCode"] = str(languagecode)
        if servicemode is not None:
            headers["serviceMode"] = str(servicemode)
        if userid is not None:
            headers["userId"] = str(userid)
        if uuidseqno is not None:
            headers["uuidSeqNo"] = str(uuidseqno)
        
        
        return await make_api_request(
            "POST", 
            path, 
            data=data, 
            params=params if params else None, 
            headers=headers if headers else None
        )
    
    
    
    @mcp.tool()
    async def qzet0113_fetch_country_codes_using_get(
        countrycode: str,
        pagenum: Optional[int] = None,
        pagesize: Optional[int] = None,
        accesstoken: Optional[str] = None,
        channeltype: Optional[int] = None,
        co_relationid: Optional[int] = None,
        initiatingsystem: Optional[str] = None,
        servicemode: Optional[int] = None,
        uuidseqno: Optional[int] = None,
        entity: Optional[str] = None,
        languagecode: Optional[int] = None,
        referenceid: Optional[str] = None,
        userid: Optional[int] = None
    ) -> Dict[str, Any]:
        """
        Fetch Country Codes
        
        Generated from: GET /referenceData/directory/details/{countryCode}
        Source: swagger_2_0
        Operation ID: QZET0113FetchCountryCodesUsingGET
        
        
        Authentication: Not required
        
        Parameters:
        - countryCode: string (required)
          Enter the country code
        - pageNum: integer
          pageNum
        - pageSize: integer
          pageSize
        
        
        
        Headers:
        - Accesstoken: string
          Authorization Token to validation the caller
        - ChannelType: integer
          Channel identifier from where the TXN has originated (Internet, Mobile, ATM, Branch Channel )
        - Co-Relationid: integer
          Unique ID for the service invoked, will be set by the TXN system
        - InitiatingSystem: string
          Indicating the initiated system
        - ServiceMode: integer
          Used for branch channel to indicate the type of customer
        - UUIDSeqNo: integer
          UUID Sequence Number
        - entity: string
          entity
        - languageCode: integer
          languageCode
        - referenceId: string
          Place holder for Token based authentication
        - userId: integer
          userId
        
        
        """
        
        
        # Prepare query parameters
        params = {}
        if pagenum is not None:
            params["pageNum"] = pagenum
            
        if pagesize is not None:
            params["pageSize"] = pagesize
            
        
        
        # Replace path parameters in URL
        path = "/referenceData/directory/details/{countryCode}"
        if countrycode is not None:
            path = path.replace("{countryCode}", str(countrycode))
        
        
        # Prepare headers
        headers = {}
        if accesstoken is not None:
            headers["Accesstoken"] = str(accesstoken)
        if channeltype is not None:
            headers["ChannelType"] = str(channeltype)
        if co_relationid is not None:
            headers["Co-Relationid"] = str(co_relationid)
        if initiatingsystem is not None:
            headers["InitiatingSystem"] = str(initiatingsystem)
        if servicemode is not None:
            headers["ServiceMode"] = str(servicemode)
        if uuidseqno is not None:
            headers["UUIDSeqNo"] = str(uuidseqno)
        if entity is not None:
            headers["entity"] = str(entity)
        if languagecode is not None:
            headers["languageCode"] = str(languagecode)
        if referenceid is not None:
            headers["referenceId"] = str(referenceid)
        if userid is not None:
            headers["userId"] = str(userid)
        
        
        return await make_api_request(
            "GET", 
            path, 
            
            params=params if params else None, 
            headers=headers if headers else None
        )
    
    
    
    @mcp.tool()
    async def miet1106_list_inrtusing_get(
        pagenum: Optional[int] = None,
        pagesize: Optional[int] = None,
        accesstoken: Optional[str] = None,
        channeltype: Optional[int] = None,
        co_relationid: Optional[int] = None,
        initiatingsystem: Optional[str] = None,
        servicemode: Optional[int] = None,
        uuidseqno: Optional[int] = None,
        entity: Optional[str] = None,
        languagecode: Optional[int] = None,
        referenceid: Optional[str] = None,
        userid: Optional[int] = None
    ) -> Dict[str, Any]:
        """
        Fetch Interest Rates
        
        Generated from: GET /referenceData/directory/interestRates
        Source: swagger_2_0
        Operation ID: MIET1106ListINRTUsingGET
        
        
        Authentication: Not required
        
        Parameters:
        - pageNum: integer
          pageNum
        - pageSize: integer
          pageSize
        
        
        
        Headers:
        - Accesstoken: string
          Authorization Token to validation the caller
        - ChannelType: integer
          Channel identifier from where the TXN has originated (Internet, Mobile, ATM, Branch Channel )
        - Co-Relationid: integer
          Unique ID for the service invoked, will be set by the TXN system
        - InitiatingSystem: string
          Indicating the initiated system
        - ServiceMode: integer
          Used for branch channel to indicate the type of customer
        - UUIDSeqNo: integer
          UUID Sequence Number
        - entity: string
          entity
        - languageCode: integer
          languageCode
        - referenceId: string
          Place holder for Token based authentication
        - userId: integer
          userId
        
        
        """
        
        
        # Prepare query parameters
        params = {}
        if pagenum is not None:
            params["pageNum"] = pagenum
            
        if pagesize is not None:
            params["pageSize"] = pagesize
            
        
        
        # Replace path parameters in URL
        path = "/referenceData/directory/interestRates"
        
        
        # Prepare headers
        headers = {}
        if accesstoken is not None:
            headers["Accesstoken"] = str(accesstoken)
        if channeltype is not None:
            headers["ChannelType"] = str(channeltype)
        if co_relationid is not None:
            headers["Co-Relationid"] = str(co_relationid)
        if initiatingsystem is not None:
            headers["InitiatingSystem"] = str(initiatingsystem)
        if servicemode is not None:
            headers["ServiceMode"] = str(servicemode)
        if uuidseqno is not None:
            headers["UUIDSeqNo"] = str(uuidseqno)
        if entity is not None:
            headers["entity"] = str(entity)
        if languagecode is not None:
            headers["languageCode"] = str(languagecode)
        if referenceid is not None:
            headers["referenceId"] = str(referenceid)
        if userid is not None:
            headers["userId"] = str(userid)
        
        
        return await make_api_request(
            "GET", 
            path, 
            
            params=params if params else None, 
            headers=headers if headers else None
        )
    
    
    
    @mcp.tool()
    async def cbcet6495_pending_cash_list_postusing_get(
        accountposid: Optional[int] = None,
        accountpostype: Optional[int] = None,
        accountreference: Optional[str] = None,
        customerid: Optional[int] = None,
        pagenum: Optional[int] = None,
        pagesize: Optional[int] = None,
        transactionid: Optional[int] = None,
        accesstoken: Optional[str] = None,
        channeltype: Optional[int] = None,
        co_relationid: Optional[int] = None,
        entity: Optional[str] = None,
        initiatingsystem: Optional[str] = None,
        languagecode: Optional[int] = None,
        mu_id: Optional[str] = None,
        referenceid: Optional[str] = None,
        servicemode: Optional[int] = None,
        userid: Optional[int] = None,
        uuidseqno: Optional[int] = None
    ) -> Dict[str, Any]:
        """
        Fetch pending cash list
        
        Generated from: GET /referenceData/pendingCashList
        Source: swagger_2_0
        Operation ID: CBCET6495PendingCashList_POSTUsingGET
        
        
        Authentication: Not required
        
        Parameters:
        - accountPosId: integer
          Account Pos ID
        - accountPosType: integer
          Account Pos Type
        - accountReference: string
          Account Reference
        - customerId: integer
          Customer ID
        - pageNum: integer
          pageNum
        - pageSize: integer
          pageSize
        - transactionId: integer
          Transaction ID
        
        
        
        Headers:
        - Accesstoken: string
          Authorization Token to validation the caller
        - ChannelType: integer
          Channel identifier from where the TXN has originated (Internet, Mobile, ATM, Branch Channel )
        - co-Relationid: integer
          Unique ID for the service invoked, will be set by the TXN system
        - entity: string
          entity
        - initiatingSystem: string
          Indicating the initiated system
        - languageCode: integer
          languageCode
        - mu_Id: string
          Used to indicate the Branch Id of user
        - referenceId: string
          Place holder for Token based authentication
        - serviceMode: integer
          Used for branch channel to indicate the type of customer
        - userId: integer
          userId
        - uuidSeqNo: integer
          UUID Sequence Number
        
        
        """
        
        
        # Prepare query parameters
        params = {}
        if accountposid is not None:
            params["accountPosId"] = accountposid
            
        if accountpostype is not None:
            params["accountPosType"] = accountpostype
            
        if accountreference is not None:
            params["accountReference"] = accountreference
            
        if customerid is not None:
            params["customerId"] = customerid
            
        if pagenum is not None:
            params["pageNum"] = pagenum
            
        if pagesize is not None:
            params["pageSize"] = pagesize
            
        if transactionid is not None:
            params["transactionId"] = transactionid
            
        
        
        # Replace path parameters in URL
        path = "/referenceData/pendingCashList"
        
        
        # Prepare headers
        headers = {}
        if accesstoken is not None:
            headers["Accesstoken"] = str(accesstoken)
        if channeltype is not None:
            headers["ChannelType"] = str(channeltype)
        if co_relationid is not None:
            headers["co-Relationid"] = str(co_relationid)
        if entity is not None:
            headers["entity"] = str(entity)
        if initiatingsystem is not None:
            headers["initiatingSystem"] = str(initiatingsystem)
        if languagecode is not None:
            headers["languageCode"] = str(languagecode)
        if mu_id is not None:
            headers["mu_Id"] = str(mu_id)
        if referenceid is not None:
            headers["referenceId"] = str(referenceid)
        if servicemode is not None:
            headers["serviceMode"] = str(servicemode)
        if userid is not None:
            headers["userId"] = str(userid)
        if uuidseqno is not None:
            headers["uuidSeqNo"] = str(uuidseqno)
        
        
        return await make_api_request(
            "GET", 
            path, 
            
            params=params if params else None, 
            headers=headers if headers else None
        )
    
    
    
    @mcp.tool()
    async def fietget_product_dtls_using_get(
        customerid: Optional[int] = None,
        identifiertype: Optional[int] = None,
        identifiervalue: Optional[str] = None,
        extensibilitymap: Optional[str] = None,
        pagenum: Optional[int] = None,
        pagesize: Optional[int] = None,
        accesstoken: Optional[str] = None,
        channeltype: Optional[int] = None,
        co_relationid: Optional[int] = None,
        initiatingsystem: Optional[str] = None,
        servicemode: Optional[int] = None,
        uuidseqno: Optional[int] = None,
        entity: Optional[str] = None,
        languagecode: Optional[int] = None,
        referenceid: Optional[str] = None,
        userid: Optional[int] = None
    ) -> Dict[str, Any]:
        """
        Fetch Product Parameters
        
        Generated from: GET /referenceData/product/list
        Source: swagger_2_0
        Operation ID: FIETGetProductDtlsUsingGET
        
        
        Authentication: Not required
        
        Parameters:
        - CustomerID: integer
          Customer ID
        - IdentifierType: integer
          Identifier Type
        - IdentifierValue: string
          Identifier Value
        - extensibilityMap: string
          Custom key - value pair of attributes for extensibility enablement
        - pageNum: integer
          pageNum
        - pageSize: integer
          pageSize
        
        
        
        Headers:
        - Accesstoken: string
          Authorization Token to validation the caller
        - ChannelType: integer
          Channel identifier from where the TXN has originated (Internet, Mobile, ATM, Branch Channel )
        - Co-Relationid: integer
          Unique ID for the service invoked, will be set by the TXN system
        - InitiatingSystem: string
          Indicating the initiated system
        - ServiceMode: integer
          Used for branch channel to indicate the type of customer
        - UUIDSeqNo: integer
          UUID Sequence Number
        - entity: string
          entity
        - languageCode: integer
          languageCode
        - referenceId: string
          Place holder for Token based authentication
        - userId: integer
          userId
        
        
        """
        
        
        # Prepare query parameters
        params = {}
        if customerid is not None:
            params["CustomerID"] = customerid
            
        if identifiertype is not None:
            params["IdentifierType"] = identifiertype
            
        if identifiervalue is not None:
            params["IdentifierValue"] = identifiervalue
            
        if extensibilitymap is not None:
            params["extensibilityMap"] = extensibilitymap
            
        if pagenum is not None:
            params["pageNum"] = pagenum
            
        if pagesize is not None:
            params["pageSize"] = pagesize
            
        
        
        # Replace path parameters in URL
        path = "/referenceData/product/list"
        
        
        # Prepare headers
        headers = {}
        if accesstoken is not None:
            headers["Accesstoken"] = str(accesstoken)
        if channeltype is not None:
            headers["ChannelType"] = str(channeltype)
        if co_relationid is not None:
            headers["Co-Relationid"] = str(co_relationid)
        if initiatingsystem is not None:
            headers["InitiatingSystem"] = str(initiatingsystem)
        if servicemode is not None:
            headers["ServiceMode"] = str(servicemode)
        if uuidseqno is not None:
            headers["UUIDSeqNo"] = str(uuidseqno)
        if entity is not None:
            headers["entity"] = str(entity)
        if languagecode is not None:
            headers["languageCode"] = str(languagecode)
        if referenceid is not None:
            headers["referenceId"] = str(referenceid)
        if userid is not None:
            headers["userId"] = str(userid)
        
        
        return await make_api_request(
            "GET", 
            path, 
            
            params=params if params else None, 
            headers=headers if headers else None
        )
    
    
    
    @mcp.tool()
    async def qzbt0411_crt_sys_codes_on_hld_using_post(
        request_body:Dict[str, Any] ,  # OnHoldSystemCodesRequest,
        accesstoken: Optional[str] = None,
        channeltype: Optional[int] = None,
        co_relationid: Optional[int] = None,
        initiatingsystem: Optional[str] = None,
        servicemode: Optional[int] = None,
        uuidseqno: Optional[int] = None,
        entity: Optional[str] = None,
        languagecode: Optional[int] = None,
        referenceid: Optional[str] = None,
        requesthash: Optional[str] = None,
        userid: Optional[int] = None
    ) -> Dict[str, Any]:
        """
        Creation of system code in Onhold status
        
        Generated from: POST /referenceData/systemCodes/createDraft
        Source: swagger_2_0
        Operation ID: QZBT0411CrtSysCodesOnHldUsingPOST
        
        
        Authentication: Not required
        
        Parameters:
        - request_body: any (required)
          input
        
        
        
        Headers:
        - Accesstoken: string
          Authorization Token to validation the caller
        - ChannelType: integer
          Channel identifier from where the Transaction has originated (Internet, Mobile, ATM, Branch Channel )
        - Co-Relationid: integer
          Unique ID for the service invoked, will be set by the Transaction system
        - InitiatingSystem: string
          Indicating the initiated system
        - ServiceMode: integer
          Used for branch channel to indicate the type of customer
        - UUIDSeqNo: integer
          UUID Sequence Number
        - entity: string
          entity
        - languageCode: integer
          languageCode
        - referenceId: string
          Place holder for Token based authentication
        - requesthash: string
          Request payload for hash validation
        - userId: integer
          userId
        
        
        """
        
        
        # Prepare request data
        
        # Single body parameter - send directly
        data = request_body if request_body is not None else {}
        
        
        
        # Prepare query parameters
        params = {}
        
        
        # Replace path parameters in URL
        path = "/referenceData/systemCodes/createDraft"
        
        
        # Prepare headers
        headers = {}
        if accesstoken is not None:
            headers["Accesstoken"] = str(accesstoken)
        if channeltype is not None:
            headers["ChannelType"] = str(channeltype)
        if co_relationid is not None:
            headers["Co-Relationid"] = str(co_relationid)
        if initiatingsystem is not None:
            headers["InitiatingSystem"] = str(initiatingsystem)
        if servicemode is not None:
            headers["ServiceMode"] = str(servicemode)
        if uuidseqno is not None:
            headers["UUIDSeqNo"] = str(uuidseqno)
        if entity is not None:
            headers["entity"] = str(entity)
        if languagecode is not None:
            headers["languageCode"] = str(languagecode)
        if referenceid is not None:
            headers["referenceId"] = str(referenceid)
        if requesthash is not None:
            headers["requesthash"] = str(requesthash)
        if userid is not None:
            headers["userId"] = str(userid)
        
        
        return await make_api_request(
            "POST", 
            path, 
            data=data, 
            params=params if params else None, 
            headers=headers if headers else None
        )
    
    
    
    @mcp.tool()
    async def qzbt0413_crt_sys_codes_rel_using_post(
        request_body:Dict[str, Any] ,  # CreateSystemCodeToReleaseRequest,
        accesstoken: Optional[str] = None,
        channeltype: Optional[int] = None,
        co_relationid: Optional[int] = None,
        initiatingsystem: Optional[str] = None,
        servicemode: Optional[int] = None,
        uuidseqno: Optional[int] = None,
        entity: Optional[str] = None,
        languagecode: Optional[int] = None,
        referenceid: Optional[str] = None,
        requesthash: Optional[str] = None,
        userid: Optional[int] = None
    ) -> Dict[str, Any]:
        """
        Creation of system code in Active status
        
        Generated from: POST /referenceData/systemCodes/createSystemCodeToActive
        Source: swagger_2_0
        Operation ID: QZBT0413CrtSysCodesRelUsingPOST
        
        
        Authentication: Not required
        
        Parameters:
        - request_body: any (required)
          input
        
        
        
        Headers:
        - Accesstoken: string
          Authorization Token to validation the caller
        - ChannelType: integer
          Channel identifier from where the Transaction has originated (Internet, Mobile, ATM, Branch Channel )
        - Co-Relationid: integer
          Unique ID for the service invoked, will be set by the Transaction system
        - InitiatingSystem: string
          Indicating the initiated system
        - ServiceMode: integer
          Used for branch channel to indicate the type of customer
        - UUIDSeqNo: integer
          UUID Sequence Number
        - entity: string
          entity
        - languageCode: integer
          languageCode
        - referenceId: string
          Place holder for Token based authentication
        - requesthash: string
          Request payload for hash validation
        - userId: integer
          userId
        
        
        """
        
        
        # Prepare request data
        
        # Single body parameter - send directly
        data = request_body if request_body is not None else {}
        
        
        
        # Prepare query parameters
        params = {}
        
        
        # Replace path parameters in URL
        path = "/referenceData/systemCodes/createSystemCodeToActive"
        
        
        # Prepare headers
        headers = {}
        if accesstoken is not None:
            headers["Accesstoken"] = str(accesstoken)
        if channeltype is not None:
            headers["ChannelType"] = str(channeltype)
        if co_relationid is not None:
            headers["Co-Relationid"] = str(co_relationid)
        if initiatingsystem is not None:
            headers["InitiatingSystem"] = str(initiatingsystem)
        if servicemode is not None:
            headers["ServiceMode"] = str(servicemode)
        if uuidseqno is not None:
            headers["UUIDSeqNo"] = str(uuidseqno)
        if entity is not None:
            headers["entity"] = str(entity)
        if languagecode is not None:
            headers["languageCode"] = str(languagecode)
        if referenceid is not None:
            headers["referenceId"] = str(referenceid)
        if requesthash is not None:
            headers["requesthash"] = str(requesthash)
        if userid is not None:
            headers["userId"] = str(userid)
        
        
        return await make_api_request(
            "POST", 
            path, 
            data=data, 
            params=params if params else None, 
            headers=headers if headers else None
        )
    
    
    
    @mcp.tool()
    async def qzet0408_get_sys_codes_using_get(
        codeid: int,
        codevalue: int,
        languagecode: int,
        accesstoken: Optional[str] = None,
        channeltype: Optional[int] = None,
        co_relationid: Optional[int] = None,
        initiatingsystem: Optional[str] = None,
        servicemode: Optional[int] = None,
        uuidseqno: Optional[int] = None,
        entity: Optional[str] = None,
        referenceid: Optional[str] = None,
        userid: Optional[int] = None
    ) -> Dict[str, Any]:
        """
        Fetches details of a specific system code in the system
        
        Generated from: GET /referenceData/systemCodes/details
        Source: swagger_2_0
        Operation ID: QZET0408GetSysCodesUsingGET
        
        
        Authentication: Not required
        
        Parameters:
        - codeId: integer (required)
          Code ID field is auto generated field at the time of system code creation
        - codeValue: integer (required)
          Code Value denotes unique ID of specified system code entry
        - languageCode: integer (required)
          Language Code denotes the language of system codes with which entry is created(1-English,2-French,3-Arabic,4-Spanish)
        
        
        
        Headers:
        - Accesstoken: string
          Authorization Token to validation the caller
        - ChannelType: integer
          Channel identifier from where the  Transaction has originated (Internet, Mobile, ATM, Branch Channel )
        - Co-Relationid: integer
          Unique ID for the service invoked, will be set by the  Transaction system
        - InitiatingSystem: string
          Indicating the initiated system
        - ServiceMode: integer
          Used for branch channel to indicate the type of customer
        - UUIDSeqNo: integer
          UUID Sequence Number
        - entity: string
          entity
        - referenceId: string
          Place holder for Token based authentication
        - userId: integer
          userId
        
        
        """
        
        
        # Prepare query parameters
        params = {}
        if codeid is not None:
            params["codeId"] = codeid
            
        if codevalue is not None:
            params["codeValue"] = codevalue
            
        if languagecode is not None:
            params["languageCode"] = languagecode
            
        
        
        # Replace path parameters in URL
        path = "/referenceData/systemCodes/details"
        
        
        # Prepare headers
        headers = {}
        if accesstoken is not None:
            headers["Accesstoken"] = str(accesstoken)
        if channeltype is not None:
            headers["ChannelType"] = str(channeltype)
        if co_relationid is not None:
            headers["Co-Relationid"] = str(co_relationid)
        if initiatingsystem is not None:
            headers["InitiatingSystem"] = str(initiatingsystem)
        if servicemode is not None:
            headers["ServiceMode"] = str(servicemode)
        if uuidseqno is not None:
            headers["UUIDSeqNo"] = str(uuidseqno)
        if entity is not None:
            headers["entity"] = str(entity)
        if referenceid is not None:
            headers["referenceId"] = str(referenceid)
        if userid is not None:
            headers["userId"] = str(userid)
        
        
        return await make_api_request(
            "GET", 
            path, 
            
            params=params if params else None, 
            headers=headers if headers else None
        )
    
    
    
    @mcp.tool()
    async def qzbt0412_crt_sys_codes_on_hld_to_rel_using_put(
        request_body:Dict[str, Any] ,  # CreateSystemCodesOnHoldToReleaseRequest,
        accesstoken: Optional[str] = None,
        channeltype: Optional[int] = None,
        co_relationid: Optional[int] = None,
        initiatingsystem: Optional[str] = None,
        servicemode: Optional[int] = None,
        uuidseqno: Optional[int] = None,
        entity: Optional[str] = None,
        languagecode: Optional[int] = None,
        referenceid: Optional[str] = None,
        userid: Optional[int] = None
    ) -> Dict[str, Any]:
        """
        Creation of system code from On Hold To Released status
        
        Generated from: PUT /referenceData/systemCodes/systemCodesOnHoldToRelease
        Source: swagger_2_0
        Operation ID: QZBT0412CrtSysCodesOnHldToRelUsingPUT
        
        
        Authentication: Not required
        
        Parameters:
        - request_body: any (required)
          input
        
        
        
        Headers:
        - Accesstoken: string
          Authorization Token to validation the caller
        - ChannelType: integer
          Channel identifier from where the Transaction has originated (Internet, Mobile, ATM, Branch Channel )
        - Co-Relationid: integer
          Unique ID for the service invoked, will be set by the Transaction system
        - InitiatingSystem: string
          Indicating the initiated system
        - ServiceMode: integer
          Used for branch channel to indicate the type of customer
        - UUIDSeqNo: integer
          UUID Sequence Number
        - entity: string
          entity
        - languageCode: integer
          languageCode
        - referenceId: string
          Place holder for Token based authentication
        - userId: integer
          userId
        
        
        """
        
        
        # Prepare request data
        
        # Single body parameter - send directly
        data = request_body if request_body is not None else {}
        
        
        
        # Prepare query parameters
        params = {}
        
        
        # Replace path parameters in URL
        path = "/referenceData/systemCodes/systemCodesOnHoldToRelease"
        
        
        # Prepare headers
        headers = {}
        if accesstoken is not None:
            headers["Accesstoken"] = str(accesstoken)
        if channeltype is not None:
            headers["ChannelType"] = str(channeltype)
        if co_relationid is not None:
            headers["Co-Relationid"] = str(co_relationid)
        if initiatingsystem is not None:
            headers["InitiatingSystem"] = str(initiatingsystem)
        if servicemode is not None:
            headers["ServiceMode"] = str(servicemode)
        if uuidseqno is not None:
            headers["UUIDSeqNo"] = str(uuidseqno)
        if entity is not None:
            headers["entity"] = str(entity)
        if languagecode is not None:
            headers["languageCode"] = str(languagecode)
        if referenceid is not None:
            headers["referenceId"] = str(referenceid)
        if userid is not None:
            headers["userId"] = str(userid)
        
        
        return await make_api_request(
            "PUT", 
            path, 
            data=data, 
            params=params if params else None, 
            headers=headers if headers else None
        )
    
    
    
    @mcp.tool()
    async def qzbt8005_del_sec_ind_code_using_delete(
        request_body:Dict[str, Any] ,  # DeleteSystemCodeRequest,
        accesstoken: Optional[str] = None,
        channeltype: Optional[int] = None,
        co_relationid: Optional[int] = None,
        initiatingsystem: Optional[str] = None,
        servicemode: Optional[int] = None,
        uuidseqno: Optional[int] = None,
        entity: Optional[str] = None,
        languagecode: Optional[int] = None,
        referenceid: Optional[str] = None,
        requesthash: Optional[str] = None,
        userid: Optional[int] = None
    ) -> Dict[str, Any]:
        """
        Deletion of system code details
        
        Generated from: DELETE /referenceData/systemCodes/userDefinedSystemCode/cancel
        Source: swagger_2_0
        Operation ID: QZBT8005DelSecIndCodeUsingDELETE
        
        
        Authentication: Not required
        
        Parameters:
        - request_body: any (required)
          input
        
        
        
        Headers:
        - Accesstoken: string
          Authorization Token to validation the caller
        - ChannelType: integer
          Channel identifier from where the Transaction has originated (Internet, Mobile, ATM, Branch Channel )
        - Co-Relationid: integer
          Unique ID for the service invoked, will be set by the Transaction system
        - InitiatingSystem: string
          Indicating the initiated system
        - ServiceMode: integer
          Used for branch channel to indicate the type of customer
        - UUIDSeqNo: integer
          UUID Sequence Number
        - entity: string
          entity
        - languageCode: integer
          languageCode
        - referenceId: string
          place holder for Token based authentication
        - requesthash: string
          Request payload for hash validation
        - userId: integer
          userId
        
        
        """
        
        
        # Prepare request data
        
        # Single body parameter - send directly
        data = request_body if request_body is not None else {}
        
        
        
        # Prepare query parameters
        params = {}
        
        
        # Replace path parameters in URL
        path = "/referenceData/systemCodes/userDefinedSystemCode/cancel"
        
        
        # Prepare headers
        headers = {}
        if accesstoken is not None:
            headers["Accesstoken"] = str(accesstoken)
        if channeltype is not None:
            headers["ChannelType"] = str(channeltype)
        if co_relationid is not None:
            headers["Co-Relationid"] = str(co_relationid)
        if initiatingsystem is not None:
            headers["InitiatingSystem"] = str(initiatingsystem)
        if servicemode is not None:
            headers["ServiceMode"] = str(servicemode)
        if uuidseqno is not None:
            headers["UUIDSeqNo"] = str(uuidseqno)
        if entity is not None:
            headers["entity"] = str(entity)
        if languagecode is not None:
            headers["languageCode"] = str(languagecode)
        if referenceid is not None:
            headers["referenceId"] = str(referenceid)
        if requesthash is not None:
            headers["requesthash"] = str(requesthash)
        if userid is not None:
            headers["userId"] = str(userid)
        
        
        return await make_api_request(
            "DELETE", 
            path, 
            data=data, 
            params=params if params else None, 
            headers=headers if headers else None
        )
    
    
    
    @mcp.tool()
    async def qzbt0402_mdfy_sys_codes_using_put(
        codeid: str,
        request_body:Dict[str, Any] ,  # ModifySystemCodesRequest,
        accesstoken: Optional[str] = None,
        channeltype: Optional[int] = None,
        co_relationid: Optional[int] = None,
        initiatingsystem: Optional[str] = None,
        servicemode: Optional[int] = None,
        uuidseqno: Optional[int] = None,
        entity: Optional[str] = None,
        languagecode: Optional[int] = None,
        referenceid: Optional[str] = None,
        requesthash: Optional[str] = None,
        userid: Optional[int] = None
    ) -> Dict[str, Any]:
        """
        Modification of system code details
        
        Generated from: PUT /referenceData/systemCodes/{codeId}/update
        Source: swagger_2_0
        Operation ID: QZBT0402MdfySysCodesUsingPUT
        
        
        Authentication: Not required
        
        Parameters:
        - codeId: string (required)
          Path parameter codeId
        - request_body: any (required)
          input
        
        
        
        Headers:
        - Accesstoken: string
          Authorization Token to validation the caller
        - ChannelType: integer
          Channel identifier from where the Transaction has originated (Internet, Mobile, ATM, Branch Channel )
        - Co-Relationid: integer
          Unique ID for the service invoked, will be set by the Transaction system
        - InitiatingSystem: string
          Indicating the initiated system
        - ServiceMode: integer
          Used for branch channel to indicate the type of customer
        - UUIDSeqNo: integer
          UUID Sequence Number
        - entity: string
          entity
        - languageCode: integer
          languageCode
        - referenceId: string
          Place holder for Token based authentication
        - requesthash: string
          Request payload for hash validation
        - userId: integer
          userId
        
        
        """
        
        
        # Prepare request data
        
        # Single body parameter - send directly
        data = request_body if request_body is not None else {}
        
        
        
        # Prepare query parameters
        params = {}
        
        
        # Replace path parameters in URL
        path = "/referenceData/systemCodes/{codeId}/update"
        if codeid is not None:
            path = path.replace("{codeId}", str(codeid))
        
        
        # Prepare headers
        headers = {}
        if accesstoken is not None:
            headers["Accesstoken"] = str(accesstoken)
        if channeltype is not None:
            headers["ChannelType"] = str(channeltype)
        if co_relationid is not None:
            headers["Co-Relationid"] = str(co_relationid)
        if initiatingsystem is not None:
            headers["InitiatingSystem"] = str(initiatingsystem)
        if servicemode is not None:
            headers["ServiceMode"] = str(servicemode)
        if uuidseqno is not None:
            headers["UUIDSeqNo"] = str(uuidseqno)
        if entity is not None:
            headers["entity"] = str(entity)
        if languagecode is not None:
            headers["languageCode"] = str(languagecode)
        if referenceid is not None:
            headers["referenceId"] = str(referenceid)
        if requesthash is not None:
            headers["requesthash"] = str(requesthash)
        if userid is not None:
            headers["userId"] = str(userid)
        
        
        return await make_api_request(
            "PUT", 
            path, 
            data=data, 
            params=params if params else None, 
            headers=headers if headers else None
        )
    
    
    
    @mcp.tool()
    async def qzet0404_ftch_sys_codes_for_client_using_get(
        codename: str,
        accesstoken: Optional[str] = None,
        channeltype: Optional[int] = None,
        co_relationid: Optional[int] = None,
        initiatingsystem: Optional[str] = None,
        servicemode: Optional[int] = None,
        uuidseqno: Optional[int] = None,
        entity: Optional[str] = None,
        languagecode: Optional[int] = None,
        referenceid: Optional[str] = None,
        userid: Optional[int] = None
    ) -> Dict[str, Any]:
        """
        This service is used to fetch system code details
        
        Generated from: GET /referenceData/systemCodes/{codeName}/details
        Source: swagger_2_0
        Operation ID: QZET0404FtchSysCodesForClientUsingGET
        
        
        Authentication: Not required
        
        Parameters:
        - codeName: string (required)
          Unique reference for the user defined system code name has to be fetched
        
        
        
        Headers:
        - Accesstoken: string
          Authorization Token to validation the caller
        - ChannelType: integer
          Channel identifier from where the Transaction has originated (Internet, Mobile, ATM, Branch Channel )
        - Co-Relationid: integer
          Unique ID for the service invoked, will be set by the Transaction system
        - InitiatingSystem: string
          Indicating the initiated system
        - ServiceMode: integer
          Used for branch channel to indicate the type of customer
        - UUIDSeqNo: integer
          UUID Sequence Number
        - entity: string
          entity
        - languageCode: integer
          languageCode
        - referenceId: string
          Place holder for Token based authentication
        - userId: integer
          userId
        
        
        """
        
        
        # Prepare query parameters
        params = {}
        
        
        # Replace path parameters in URL
        path = "/referenceData/systemCodes/{codeName}/details"
        if codename is not None:
            path = path.replace("{codeName}", str(codename))
        
        
        # Prepare headers
        headers = {}
        if accesstoken is not None:
            headers["Accesstoken"] = str(accesstoken)
        if channeltype is not None:
            headers["ChannelType"] = str(channeltype)
        if co_relationid is not None:
            headers["Co-Relationid"] = str(co_relationid)
        if initiatingsystem is not None:
            headers["InitiatingSystem"] = str(initiatingsystem)
        if servicemode is not None:
            headers["ServiceMode"] = str(servicemode)
        if uuidseqno is not None:
            headers["UUIDSeqNo"] = str(uuidseqno)
        if entity is not None:
            headers["entity"] = str(entity)
        if languagecode is not None:
            headers["languageCode"] = str(languagecode)
        if referenceid is not None:
            headers["referenceId"] = str(referenceid)
        if userid is not None:
            headers["userId"] = str(userid)
        
        
        return await make_api_request(
            "GET", 
            path, 
            
            params=params if params else None, 
            headers=headers if headers else None
        )
    
    
    
    @mcp.tool()
    async def qzetget_sys_code_defn_postusing_get(
        codename: Optional[str] = None,
        codetype: Optional[int] = None,
        pagenum: Optional[int] = None,
        pagesize: Optional[int] = None,
        accesstoken: Optional[str] = None,
        channeltype: Optional[int] = None,
        co_relationid: Optional[int] = None,
        initiatingsystem: Optional[str] = None,
        servicemode: Optional[int] = None,
        uuidseqno: Optional[int] = None,
        entity: Optional[str] = None,
        languagecode: Optional[int] = None,
        referenceid: Optional[str] = None,
        userid: Optional[int] = None
    ) -> Dict[str, Any]:
        """
        Fetches all system code names
        
        Generated from: GET /referenceData/systemcodes/definitionList
        Source: swagger_2_0
        Operation ID: QZETGetSysCodeDefn_POSTUsingGET
        
        
        Authentication: Not required
        
        Parameters:
        - CodeName: string
          Code name denotes the system code name which will be fetched from system code definition
        - CodeType: integer
          Code val type denotes whether the system code defined is system or user defined(1-User Defined,2-System Defined,3-Both)
        - pageNum: integer
          pageNum
        - pageSize: integer
          pageSize
        
        
        
        Headers:
        - Accesstoken: string
          Authorization Token to validation the caller
        - ChannelType: integer
          Channel identifier from where the  Transaction has originated (Internet, Mobile, ATM, Branch Channel )
        - Co-Relationid: integer
          Unique ID for the service invoked, will be set by the  Transaction system
        - InitiatingSystem: string
          Indicating the initiated system
        - ServiceMode: integer
          Used for branch channel to indicate the type of customer
        - UUIDSeqNo: integer
          UUID Sequence Number
        - entity: string
          entity
        - languageCode: integer
          languageCode
        - referenceId: string
          Place holder for Token based authentication
        - userId: integer
          userId
        
        
        """
        
        
        # Prepare query parameters
        params = {}
        if codename is not None:
            params["CodeName"] = codename
            
        if codetype is not None:
            params["CodeType"] = codetype
            
        if pagenum is not None:
            params["pageNum"] = pagenum
            
        if pagesize is not None:
            params["pageSize"] = pagesize
            
        
        
        # Replace path parameters in URL
        path = "/referenceData/systemcodes/definitionList"
        
        
        # Prepare headers
        headers = {}
        if accesstoken is not None:
            headers["Accesstoken"] = str(accesstoken)
        if channeltype is not None:
            headers["ChannelType"] = str(channeltype)
        if co_relationid is not None:
            headers["Co-Relationid"] = str(co_relationid)
        if initiatingsystem is not None:
            headers["InitiatingSystem"] = str(initiatingsystem)
        if servicemode is not None:
            headers["ServiceMode"] = str(servicemode)
        if uuidseqno is not None:
            headers["UUIDSeqNo"] = str(uuidseqno)
        if entity is not None:
            headers["entity"] = str(entity)
        if languagecode is not None:
            headers["languageCode"] = str(languagecode)
        if referenceid is not None:
            headers["referenceId"] = str(referenceid)
        if userid is not None:
            headers["userId"] = str(userid)
        
        
        return await make_api_request(
            "GET", 
            path, 
            
            params=params if params else None, 
            headers=headers if headers else None
        )
    
    
    
    @mcp.tool()
    async def qzet0403_ftch_sys_codes_postusing_get(
        codename: Optional[str] = None,
        codevaluetype: Optional[int] = None,
        displayrequired: Optional[str] = None,
        pagenum: Optional[int] = None,
        pagesize: Optional[int] = None,
        accesstoken: Optional[str] = None,
        channeltype: Optional[int] = None,
        co_relationid: Optional[int] = None,
        initiatingsystem: Optional[str] = None,
        servicemode: Optional[int] = None,
        uuidseqno: Optional[int] = None,
        entity: Optional[str] = None,
        languagecode: Optional[int] = None,
        referenceid: Optional[str] = None,
        userid: Optional[int] = None
    ) -> Dict[str, Any]:
        """
        This service is used to fetch system codes
        
        Generated from: GET /referenceData/systemcodes/list
        Source: swagger_2_0
        Operation ID: QZET0403FtchSysCodes_POSTUsingGET
        
        
        Authentication: Not required
        
        Parameters:
        - CodeName: string
          Code name denotes  name of the system code
        - CodeValueType: integer
          Code val type denotes whether the system code is system or user defined(1-User Defined,2-System Defined,3-Both)
        - DisplayRequired: string
          This field denotes System Code is required or not(yes,no)
        - pageNum: integer
          pageNum
        - pageSize: integer
          pageSize
        
        
        
        Headers:
        - Accesstoken: string
          Authorization Token to validation the caller
        - ChannelType: integer
          Channel identifier from where the Transaction has originated (Internet, Mobile, ATM, Branch Channel )
        - Co-Relationid: integer
          Unique ID for the service invoked, will be set by the Transaction system
        - InitiatingSystem: string
          Indicating the initiated system
        - ServiceMode: integer
          Used for branch channel to indicate the type of customer
        - UUIDSeqNo: integer
          UUID Sequence Number
        - entity: string
          entity
        - languageCode: integer
          languageCode
        - referenceId: string
          Place holder for Token based authentication
        - userId: integer
          userId
        
        
        """
        
        
        # Prepare query parameters
        params = {}
        if codename is not None:
            params["CodeName"] = codename
            
        if codevaluetype is not None:
            params["CodeValueType"] = codevaluetype
            
        if displayrequired is not None:
            params["DisplayRequired"] = displayrequired
            
        if pagenum is not None:
            params["pageNum"] = pagenum
            
        if pagesize is not None:
            params["pageSize"] = pagesize
            
        
        
        # Replace path parameters in URL
        path = "/referenceData/systemcodes/list"
        
        
        # Prepare headers
        headers = {}
        if accesstoken is not None:
            headers["Accesstoken"] = str(accesstoken)
        if channeltype is not None:
            headers["ChannelType"] = str(channeltype)
        if co_relationid is not None:
            headers["Co-Relationid"] = str(co_relationid)
        if initiatingsystem is not None:
            headers["InitiatingSystem"] = str(initiatingsystem)
        if servicemode is not None:
            headers["ServiceMode"] = str(servicemode)
        if uuidseqno is not None:
            headers["UUIDSeqNo"] = str(uuidseqno)
        if entity is not None:
            headers["entity"] = str(entity)
        if languagecode is not None:
            headers["languageCode"] = str(languagecode)
        if referenceid is not None:
            headers["referenceId"] = str(referenceid)
        if userid is not None:
            headers["userId"] = str(userid)
        
        
        return await make_api_request(
            "GET", 
            path, 
            
            params=params if params else None, 
            headers=headers if headers else None
        )
    
    
    
    @mcp.tool()
    async def rpbt0803_generate_advice_postusing_post(
        request_body:Dict[str, Any] ,  # MO_RM_PARAM_RPBT0803_GenerateAdvice_Resource,
        co_relationid: Optional[int] = None,
        initiatingsystem: Optional[str] = None,
        servicemode: Optional[int] = None,
        uuidseqno: Optional[int] = None,
        entity: Optional[str] = None,
        languagecode: Optional[int] = None,
        referenceid: Optional[str] = None,
        requesthash: Optional[str] = None,
        userid: Optional[int] = None
    ) -> Dict[str, Any]:
        """
        Offline Report Generation API
        
        Generated from: POST /reports/rpbt0803_generateadvice
        Source: swagger_2_0
        Operation ID: RPBT0803_GenerateAdvice_POSTUsingPOST
        
        
        Authentication: Not required
        
        Parameters:
        - request_body: any (required)
          input
        
        
        
        Headers:
        - Co-Relationid: integer
          Unique ID for the service invoked, will be set by the TXN system
        - InitiatingSystem: string
          Indicating the initiated system
        - ServiceMode: integer
          Used for branch channel to indicate the type of customer
        - UUIDSeqNo: integer
          UUID Sequence Number
        - entity: string
          entity
        - languageCode: integer
          languageCode
        - referenceId: string
          Place holder for Token based authentication
        - requesthash: string
          Request payload for hash validation
        - userId: integer
          userId
        
        
        """
        
        
        # Prepare request data
        
        # Single body parameter - send directly
        data = request_body if request_body is not None else {}
        
        
        
        # Prepare query parameters
        params = {}
        
        
        # Replace path parameters in URL
        path = "/reports/rpbt0803_generateadvice"
        
        
        # Prepare headers
        headers = {}
        if co_relationid is not None:
            headers["Co-Relationid"] = str(co_relationid)
        if initiatingsystem is not None:
            headers["InitiatingSystem"] = str(initiatingsystem)
        if servicemode is not None:
            headers["ServiceMode"] = str(servicemode)
        if uuidseqno is not None:
            headers["UUIDSeqNo"] = str(uuidseqno)
        if entity is not None:
            headers["entity"] = str(entity)
        if languagecode is not None:
            headers["languageCode"] = str(languagecode)
        if referenceid is not None:
            headers["referenceId"] = str(referenceid)
        if requesthash is not None:
            headers["requesthash"] = str(requesthash)
        if userid is not None:
            headers["userId"] = str(userid)
        
        
        return await make_api_request(
            "POST", 
            path, 
            data=data, 
            params=params if params else None, 
            headers=headers if headers else None
        )
    
    
    
    @mcp.tool()
    async def rsbt5068_auth_cash_desk_force_clsr_postusing_post(
        request_body:Dict[str, Any] ,  # authoriseCashDeskFroceClosureRequest,
        accesstoken: Optional[str] = None,
        co_relationid: Optional[int] = None,
        entity: Optional[str] = None,
        initiatingsystem: Optional[str] = None,
        languagecode: Optional[int] = None,
        referenceid: Optional[str] = None,
        servicemode: Optional[int] = None,
        userid: Optional[int] = None,
        uuidseqno: Optional[int] = None
    ) -> Dict[str, Any]:
        """
        API to Authorise Teller Cash Desk Force Closure
        
        Generated from: POST /retailServices/cashDeskManagement/authForceClosure
        Source: swagger_2_0
        Operation ID: RSBT5068AuthCashDeskForceClsr_POSTUsingPOST
        
        
        Authentication: Not required
        
        Parameters:
        - request_body: any (required)
          input
        
        
        
        Headers:
        - Accesstoken: string
          Authorization Token to validation the caller
        - Co-Relationid: integer
          Unique ID for the service invoked, will be set by the TXN system
        - entity: string
          entity
        - initiatingSystem: string
          Indicating the initiated system
        - languageCode: integer
          languageCode
        - referenceId: string
          Place holder for Token based authentication
        - serviceMode: integer
          Used for branch channel to indicate the type of customer
        - userId: integer
          userId
        - uuiDSeqNo: integer
          UUID Sequence Number
        
        
        """
        
        
        # Prepare request data
        
        # Single body parameter - send directly
        data = request_body if request_body is not None else {}
        
        
        
        # Prepare query parameters
        params = {}
        
        
        # Replace path parameters in URL
        path = "/retailServices/cashDeskManagement/authForceClosure"
        
        
        # Prepare headers
        headers = {}
        if accesstoken is not None:
            headers["Accesstoken"] = str(accesstoken)
        if co_relationid is not None:
            headers["Co-Relationid"] = str(co_relationid)
        if entity is not None:
            headers["entity"] = str(entity)
        if initiatingsystem is not None:
            headers["initiatingSystem"] = str(initiatingsystem)
        if languagecode is not None:
            headers["languageCode"] = str(languagecode)
        if referenceid is not None:
            headers["referenceId"] = str(referenceid)
        if servicemode is not None:
            headers["serviceMode"] = str(servicemode)
        if userid is not None:
            headers["userId"] = str(userid)
        if uuidseqno is not None:
            headers["uuiDSeqNo"] = str(uuidseqno)
        
        
        return await make_api_request(
            "POST", 
            path, 
            data=data, 
            params=params if params else None, 
            headers=headers if headers else None
        )
    
    
    
    @mcp.tool()
    async def rsbt5068_init_cash_desk_force_clsr_postusing_post(
        request_body:Dict[str, Any] ,  # initiateCashDeskFroceClosureRequest,
        accesstoken: Optional[str] = None,
        channeltype: Optional[int] = None,
        co_relationid: Optional[int] = None,
        entity: Optional[str] = None,
        initiatingsystem: Optional[str] = None,
        languagecode: Optional[int] = None,
        referenceid: Optional[str] = None,
        servicemode: Optional[int] = None,
        userid: Optional[int] = None,
        uuidseqno: Optional[int] = None
    ) -> Dict[str, Any]:
        """
        API to Initiate Teller Cash Desk Force Closure
        
        Generated from: POST /retailServices/cashDeskManagement/initForceClosure
        Source: swagger_2_0
        Operation ID: RSBT5068InitCashDeskForceClsr_POSTUsingPOST
        
        
        Authentication: Not required
        
        Parameters:
        - request_body: any (required)
          input
        
        
        
        Headers:
        - Accesstoken: string
          Authorization Token to validation the caller
        - ChannelType: integer
          Channel identifier from where the TXN has originated (Internet, Mobile, ATM, Branch Channel )
        - co-Relationid: integer
          Unique ID for the service invoked, will be set by the TXN system
        - entity: string
          entity
        - initiatingSystem: string
          Indicating the initiated system
        - languageCode: integer
          languageCode
        - referenceId: string
          Place holder for Token based authentication
        - serviceMode: integer
          Used for branch channel to indicate the type of customer
        - userId: integer
          userId
        - uuidSeqNo: integer
          UUID Sequence Number
        
        
        """
        
        
        # Prepare request data
        
        # Single body parameter - send directly
        data = request_body if request_body is not None else {}
        
        
        
        # Prepare query parameters
        params = {}
        
        
        # Replace path parameters in URL
        path = "/retailServices/cashDeskManagement/initForceClosure"
        
        
        # Prepare headers
        headers = {}
        if accesstoken is not None:
            headers["Accesstoken"] = str(accesstoken)
        if channeltype is not None:
            headers["ChannelType"] = str(channeltype)
        if co_relationid is not None:
            headers["co-Relationid"] = str(co_relationid)
        if entity is not None:
            headers["entity"] = str(entity)
        if initiatingsystem is not None:
            headers["initiatingSystem"] = str(initiatingsystem)
        if languagecode is not None:
            headers["languageCode"] = str(languagecode)
        if referenceid is not None:
            headers["referenceId"] = str(referenceid)
        if servicemode is not None:
            headers["serviceMode"] = str(servicemode)
        if userid is not None:
            headers["userId"] = str(userid)
        if uuidseqno is not None:
            headers["uuidSeqNo"] = str(uuidseqno)
        
        
        return await make_api_request(
            "POST", 
            path, 
            data=data, 
            params=params if params else None, 
            headers=headers if headers else None
        )
    
    
    
    @mcp.tool()
    async def cbcet1721_rstxn_chrg_cr_using_get(
        accountid: Optional[int] = None,
        accountreference: Optional[str] = None,
        accounttype: Optional[int] = None,
        branch: Optional[str] = None,
        channeltype1: Optional[int] = None,
        chargeabletransaction: Optional[int] = None,
        chequebooktype_: Optional[int] = None,
        chequeleaves: Optional[int] = None,
        currency: Optional[str] = None,
        customerreference: Optional[int] = None,
        deliverymode_: Optional[int] = None,
        entitycode: Optional[str] = None,
        eventsubprps: Optional[int] = None,
        feeaccountcurrency: Optional[str] = None,
        feeaccountposid: Optional[int] = None,
        feeaccounttype: Optional[int] = None,
        identifier: Optional[int] = None,
        numberofchequebooks: Optional[int] = None,
        paymentmode: Optional[int] = None,
        postype: Optional[int] = None,
        servicemode1: Optional[int] = None,
        tcissuerbpflag: Optional[int] = None,
        trackid: Optional[int] = None,
        transactionamount: Optional[float] = None,
        transactionpurpose: Optional[int] = None,
        transactiontype: Optional[int] = None,
        trasactioncurrency: Optional[str] = None,
        accesstoken: Optional[str] = None,
        channeltype: Optional[int] = None,
        co_relationid: Optional[int] = None,
        initiatingsystem: Optional[str] = None,
        servicemode: Optional[int] = None,
        uuidseqno: Optional[int] = None,
        entity: Optional[str] = None,
        languagecode: Optional[int] = None,
        referenceid: Optional[str] = None,
        userid: Optional[int] = None
    ) -> Dict[str, Any]:
        """
        Fetch Transaction Charges
        
        Generated from: GET /retailServices/charges
        Source: swagger_2_0
        Operation ID: CBCET1721RSTxnChrgCrUsingGET
        
        
        Authentication: Not required
        
        Parameters:
        - accountId: integer
          Account POs Id
        - accountReference: string
          Account Reference
        - accountType: integer
          Account Pos Type
        - branch: string
          Branch Defining_MU_Id
        - channelType1: integer
          Channel Type
        - chargeableTransaction: integer
          Chargeable Transaction 296-DealPreClosure, 287-LoanOpen, 870-LoanTopUp, 244-LimitCrtFee(Domain Name: d_CTId)
        - chequeBookType : integer
          Cheque Book Type
        - chequeLeaves: integer
          No. of leaves/Cheque Book
        - currency: string
          Currency Eg : AED, MXN, EUR, USD, INR (Domain Name: d_CurrCode)
        - customerReference: integer
          Customer Reference
        - deliveryMode : integer
          Delivery Mode
        - entityCode: string
          Entity Code
        - eventSubPrps: integer
          EventSubPrps
        - feeAccountCurrency: string
          fee Account Currency Eg : AED, MXN, EUR, USD, INR (Domain Name: d_CurrCode)
        - feeAccountPosId: integer
          Fee Account Pos Id
        - feeAccountType: integer
          Fee Account Type
        - identifier: integer
          Identifier
        - numberofChequeBooks: integer
          Number of cheque books/cheques
        - paymentMode: integer
          Payment Mode
        - posType: integer
          pos Type(Domain d_PosTyp 1-Cash)
        - serviceMode1: integer
          Service Mode
        - tcIssuerBPFlag: integer
          TC Issuer BP Flag 0-NONE,1-Yes,2-No(Domain Name: d_YesNoFlg)
        - trackId: integer
          Track Id
        - transactionAmount: number
          Transaction Amount
        - transactionPurpose: integer
          transaction Purpose(Domain d_TxnPrps)
        - transactionType: integer
          Transaction Pos Type 551-DepositTxn (Domain Name: d_PosTyp)
        - trasactionCurrency: string
          trasaction Currency Eg : AED, MXN, EUR, USD, INR (Domain Name: d_CurrCode)
        
        
        
        Headers:
        - Accesstoken: string
          Authorization token for identification of the caller
        - ChannelType: integer
          Channel identifier from where the TXN has originated (Internet, Mobile, ATM, Branch Channel )
        - Co-Relationid: integer
          Unique ID for the service invoked, will be set by the TXN system
        - InitiatingSystem: string
          Indicating the initiated system
        - ServiceMode: integer
          Used for branch channel to indicate the type of customer
        - UUIDSeqNo: integer
          UUID Sequence Number
        - entity: string
          entity
        - languageCode: integer
          languageCode
        - referenceId: string
          Place holder for Token based authentication
        - userId: integer
          userId
        
        
        """
        
        
        # Prepare query parameters
        params = {}
        if accountid is not None:
            params["accountId"] = accountid
            
        if accountreference is not None:
            params["accountReference"] = accountreference
            
        if accounttype is not None:
            params["accountType"] = accounttype
            
        if branch is not None:
            params["branch"] = branch
            
        if channeltype1 is not None:
            params["channelType1"] = channeltype1
            
        if chargeabletransaction is not None:
            params["chargeableTransaction"] = chargeabletransaction
            
        if chequebooktype_ is not None:
            params["chequeBookType "] = chequebooktype_
            
        if chequeleaves is not None:
            params["chequeLeaves"] = chequeleaves
            
        if currency is not None:
            params["currency"] = currency
            
        if customerreference is not None:
            params["customerReference"] = customerreference
            
        if deliverymode_ is not None:
            params["deliveryMode "] = deliverymode_
            
        if entitycode is not None:
            params["entityCode"] = entitycode
            
        if eventsubprps is not None:
            params["eventSubPrps"] = eventsubprps
            
        if feeaccountcurrency is not None:
            params["feeAccountCurrency"] = feeaccountcurrency
            
        if feeaccountposid is not None:
            params["feeAccountPosId"] = feeaccountposid
            
        if feeaccounttype is not None:
            params["feeAccountType"] = feeaccounttype
            
        if identifier is not None:
            params["identifier"] = identifier
            
        if numberofchequebooks is not None:
            params["numberofChequeBooks"] = numberofchequebooks
            
        if paymentmode is not None:
            params["paymentMode"] = paymentmode
            
        if postype is not None:
            params["posType"] = postype
            
        if servicemode1 is not None:
            params["serviceMode1"] = servicemode1
            
        if tcissuerbpflag is not None:
            params["tcIssuerBPFlag"] = tcissuerbpflag
            
        if trackid is not None:
            params["trackId"] = trackid
            
        if transactionamount is not None:
            params["transactionAmount"] = transactionamount
            
        if transactionpurpose is not None:
            params["transactionPurpose"] = transactionpurpose
            
        if transactiontype is not None:
            params["transactionType"] = transactiontype
            
        if trasactioncurrency is not None:
            params["trasactionCurrency"] = trasactioncurrency
            
        
        
        # Replace path parameters in URL
        path = "/retailServices/charges"
        
        
        # Prepare headers
        headers = {}
        if accesstoken is not None:
            headers["Accesstoken"] = str(accesstoken)
        if channeltype is not None:
            headers["ChannelType"] = str(channeltype)
        if co_relationid is not None:
            headers["Co-Relationid"] = str(co_relationid)
        if initiatingsystem is not None:
            headers["InitiatingSystem"] = str(initiatingsystem)
        if servicemode is not None:
            headers["ServiceMode"] = str(servicemode)
        if uuidseqno is not None:
            headers["UUIDSeqNo"] = str(uuidseqno)
        if entity is not None:
            headers["entity"] = str(entity)
        if languagecode is not None:
            headers["languageCode"] = str(languagecode)
        if referenceid is not None:
            headers["referenceId"] = str(referenceid)
        if userid is not None:
            headers["userId"] = str(userid)
        
        
        return await make_api_request(
            "GET", 
            path, 
            
            params=params if params else None, 
            headers=headers if headers else None
        )
    
    
    
    @mcp.tool()
    async def rsbtcreate_chq_request_on_rlsd_postusing_post(
        request_body:Dict[str, Any] ,  # chequeBookOrderRequest,
        accesstoken: Optional[str] = None,
        channeltype: Optional[int] = None,
        co_relationid: Optional[int] = None,
        initiatingsystem: Optional[str] = None,
        servicemode: Optional[int] = None,
        uuidseqno: Optional[int] = None,
        entity: Optional[str] = None,
        languagecode: Optional[int] = None,
        mu_id: Optional[str] = None,
        referenceid: Optional[str] = None,
        requesthash: Optional[str] = None,
        userid: Optional[int] = None
    ) -> Dict[str, Any]:
        """
        Create Cheque Request
        
        Generated from: POST /retailServices/cheque/createRequest
        Source: swagger_2_0
        Operation ID: RSBTCreateChqRequestOnRlsd_POSTUsingPOST
        
        
        Authentication: Not required
        
        Parameters:
        - request_body: any (required)
          input
        
        
        
        Headers:
        - Accesstoken: string
          Authorization Token to validation the caller
        - ChannelType: integer
          Channel identifier from where the TXN has originated (Internet, Mobile, ATM, Branch Channel )
        - Co-Relationid: integer
          Unique ID for the service invoked, will be set by the TXN system
        - InitiatingSystem: string
          Indicating the initiated system
        - ServiceMode: integer
          Used for branch channel to indicate the type of customer
        - UUIDSeqNo: integer
          UUID Sequence Number
        - entity: string
          entity
        - languageCode: integer
          languageCode
        - mu_Id: string
          Used to indicate the Branch Id of user
        - referenceId: string
          Place holder for Token based authentication
        - requesthash: string
          Request payload for hash validation
        - userId: integer
          userId
        
        
        """
        
        
        # Prepare request data
        
        # Single body parameter - send directly
        data = request_body if request_body is not None else {}
        
        
        
        # Prepare query parameters
        params = {}
        
        
        # Replace path parameters in URL
        path = "/retailServices/cheque/createRequest"
        
        
        # Prepare headers
        headers = {}
        if accesstoken is not None:
            headers["Accesstoken"] = str(accesstoken)
        if channeltype is not None:
            headers["ChannelType"] = str(channeltype)
        if co_relationid is not None:
            headers["Co-Relationid"] = str(co_relationid)
        if initiatingsystem is not None:
            headers["InitiatingSystem"] = str(initiatingsystem)
        if servicemode is not None:
            headers["ServiceMode"] = str(servicemode)
        if uuidseqno is not None:
            headers["UUIDSeqNo"] = str(uuidseqno)
        if entity is not None:
            headers["entity"] = str(entity)
        if languagecode is not None:
            headers["languageCode"] = str(languagecode)
        if mu_id is not None:
            headers["mu_Id"] = str(mu_id)
        if referenceid is not None:
            headers["referenceId"] = str(referenceid)
        if requesthash is not None:
            headers["requesthash"] = str(requesthash)
        if userid is not None:
            headers["userId"] = str(userid)
        
        
        return await make_api_request(
            "POST", 
            path, 
            data=data, 
            params=params if params else None, 
            headers=headers if headers else None
        )
    
    
    
    @mcp.tool()
    async def rsbtauth_chq_request_in_progress_postusing_post(
        request_body:Dict[str, Any] ,  # chequeBookOrderAuthRequest,
        accesstoken: Optional[str] = None,
        channeltype: Optional[int] = None,
        co_relationid: Optional[int] = None,
        initiatingsystem: Optional[str] = None,
        servicemode: Optional[int] = None,
        uuidseqno: Optional[int] = None,
        entity: Optional[str] = None,
        languagecode: Optional[int] = None,
        mu_id: Optional[str] = None,
        referenceid: Optional[str] = None,
        requesthash: Optional[str] = None,
        userid: Optional[int] = None
    ) -> Dict[str, Any]:
        """
        Auth for Create Cheque request
        
        Generated from: POST /retailServices/cheque/createRequest/auth
        Source: swagger_2_0
        Operation ID: RSBTAuthChqRequestInProgress_POSTUsingPOST
        
        
        Authentication: Not required
        
        Parameters:
        - request_body: any (required)
          input
        
        
        
        Headers:
        - Accesstoken: string
          Authorization Token to validation the caller
        - ChannelType: integer
          Channel identifier from where the TXN has originated (Internet, Mobile, ATM, Branch Channel )
        - Co-Relationid: integer
          Unique ID for the service invoked, will be set by the TXN system
        - InitiatingSystem: string
          Indicating the initiated system
        - ServiceMode: integer
          Used for branch channel to indicate the type of customer
        - UUIDSeqNo: integer
          UUID Sequence Number
        - entity: string
          entity
        - languageCode: integer
          languageCode
        - mu_Id: string
          Used to indicate the Branch Id of user
        - referenceId: string
          Place holder for Token based authentication
        - requesthash: string
          Request payload for hash validation
        - userId: integer
          userId
        
        
        """
        
        
        # Prepare request data
        
        # Single body parameter - send directly
        data = request_body if request_body is not None else {}
        
        
        
        # Prepare query parameters
        params = {}
        
        
        # Replace path parameters in URL
        path = "/retailServices/cheque/createRequest/auth"
        
        
        # Prepare headers
        headers = {}
        if accesstoken is not None:
            headers["Accesstoken"] = str(accesstoken)
        if channeltype is not None:
            headers["ChannelType"] = str(channeltype)
        if co_relationid is not None:
            headers["Co-Relationid"] = str(co_relationid)
        if initiatingsystem is not None:
            headers["InitiatingSystem"] = str(initiatingsystem)
        if servicemode is not None:
            headers["ServiceMode"] = str(servicemode)
        if uuidseqno is not None:
            headers["UUIDSeqNo"] = str(uuidseqno)
        if entity is not None:
            headers["entity"] = str(entity)
        if languagecode is not None:
            headers["languageCode"] = str(languagecode)
        if mu_id is not None:
            headers["mu_Id"] = str(mu_id)
        if referenceid is not None:
            headers["referenceId"] = str(referenceid)
        if requesthash is not None:
            headers["requesthash"] = str(requesthash)
        if userid is not None:
            headers["userId"] = str(userid)
        
        
        return await make_api_request(
            "POST", 
            path, 
            data=data, 
            params=params if params else None, 
            headers=headers if headers else None
        )
    
    
    
    @mcp.tool()
    async def rsbt7114_auth_rej_chq_request_postusing_post(
        request_body:Dict[str, Any] ,  # chequeBookOrderRejectRequest,
        accesstoken: Optional[str] = None,
        channeltype: Optional[int] = None,
        co_relationid: Optional[int] = None,
        initiatingsystem: Optional[str] = None,
        servicemode: Optional[int] = None,
        uuidseqno: Optional[int] = None,
        entity: Optional[str] = None,
        languagecode: Optional[int] = None,
        mu_id: Optional[str] = None,
        referenceid: Optional[str] = None,
        requesthash: Optional[str] = None,
        userid: Optional[int] = None
    ) -> Dict[str, Any]:
        """
        Reject Service for Cheque Book order
        
        Generated from: POST /retailServices/cheque/createRequest/reject
        Source: swagger_2_0
        Operation ID: RSBT7114AuthRejChqRequest_POSTUsingPOST
        
        
        Authentication: Not required
        
        Parameters:
        - request_body: any (required)
          input
        
        
        
        Headers:
        - Accesstoken: string
          Authorization Token to validation the caller
        - ChannelType: integer
          Channel identifier from where the TXN has originated (Internet, Mobile, ATM, Branch Channel )
        - Co-Relationid: integer
          Unique ID for the service invoked, will be set by the TXN system
        - InitiatingSystem: string
          Indicating the initiated system
        - ServiceMode: integer
          Used for branch channel to indicate the type of customer
        - UUIDSeqNo: integer
          UUID Sequence Number
        - entity: string
          entity
        - languageCode: integer
          languageCode
        - mu_Id: string
          Used to indicate the Branch Id of user
        - referenceId: string
          Place holder for Token based authentication
        - requesthash: string
          Request payload for hash validation
        - userId: integer
          userId
        
        
        """
        
        
        # Prepare request data
        
        # Single body parameter - send directly
        data = request_body if request_body is not None else {}
        
        
        
        # Prepare query parameters
        params = {}
        
        
        # Replace path parameters in URL
        path = "/retailServices/cheque/createRequest/reject"
        
        
        # Prepare headers
        headers = {}
        if accesstoken is not None:
            headers["Accesstoken"] = str(accesstoken)
        if channeltype is not None:
            headers["ChannelType"] = str(channeltype)
        if co_relationid is not None:
            headers["Co-Relationid"] = str(co_relationid)
        if initiatingsystem is not None:
            headers["InitiatingSystem"] = str(initiatingsystem)
        if servicemode is not None:
            headers["ServiceMode"] = str(servicemode)
        if uuidseqno is not None:
            headers["UUIDSeqNo"] = str(uuidseqno)
        if entity is not None:
            headers["entity"] = str(entity)
        if languagecode is not None:
            headers["languageCode"] = str(languagecode)
        if mu_id is not None:
            headers["mu_Id"] = str(mu_id)
        if referenceid is not None:
            headers["referenceId"] = str(referenceid)
        if requesthash is not None:
            headers["requesthash"] = str(requesthash)
        if userid is not None:
            headers["userId"] = str(userid)
        
        
        return await make_api_request(
            "POST", 
            path, 
            data=data, 
            params=params if params else None, 
            headers=headers if headers else None
        )
    
    
    
    @mcp.tool()
    async def cbcbtcreate_cheque_book_request_using_post(
        request_body:Dict[str, Any] ,  # CreateChequeOrders_Resource,
        accesstoken: Optional[str] = None,
        channeltype: Optional[int] = None,
        co_relationid: Optional[int] = None,
        initiatingsystem: Optional[str] = None,
        servicemode: Optional[int] = None,
        uuidseqno: Optional[int] = None,
        entity: Optional[str] = None,
        languagecode: Optional[int] = None,
        mu_id: Optional[str] = None,
        referenceid: Optional[str] = None,
        requesthash: Optional[str] = None,
        userid: Optional[int] = None
    ) -> Dict[str, Any]:
        """
        Create Cheque orders
        
        Generated from: POST /retailServices/cheque/order
        Source: swagger_2_0
        Operation ID: CBCBTCreateChequeBookRequestUsingPOST
        
        
        Authentication: Not required
        
        Parameters:
        - request_body: any (required)
          input
        
        
        
        Headers:
        - Accesstoken: string
          Authorization Token to validation the caller
        - ChannelType: integer
          Channel identifier from where the TXN has originated (Internet, Mobile, ATM, Branch Channel )
        - Co-Relationid: integer
          Unique ID for the service invoked, will be set by the TXN system
        - InitiatingSystem: string
          Indicating the initiated system
        - ServiceMode: integer
          Used for branch channel to indicate the type of customer
        - UUIDSeqNo: integer
          UUID Sequence Number
        - entity: string
          entity
        - languageCode: integer
          languageCode
        - mu_Id: string
          Used to indicate the Branch Id of user
        - referenceId: string
          Place holder for Token based authentication
        - requesthash: string
          Request payload for hash validation
        - userId: integer
          userId
        
        
        """
        
        
        # Prepare request data
        
        # Single body parameter - send directly
        data = request_body if request_body is not None else {}
        
        
        
        # Prepare query parameters
        params = {}
        
        
        # Replace path parameters in URL
        path = "/retailServices/cheque/order"
        
        
        # Prepare headers
        headers = {}
        if accesstoken is not None:
            headers["Accesstoken"] = str(accesstoken)
        if channeltype is not None:
            headers["ChannelType"] = str(channeltype)
        if co_relationid is not None:
            headers["Co-Relationid"] = str(co_relationid)
        if initiatingsystem is not None:
            headers["InitiatingSystem"] = str(initiatingsystem)
        if servicemode is not None:
            headers["ServiceMode"] = str(servicemode)
        if uuidseqno is not None:
            headers["UUIDSeqNo"] = str(uuidseqno)
        if entity is not None:
            headers["entity"] = str(entity)
        if languagecode is not None:
            headers["languageCode"] = str(languagecode)
        if mu_id is not None:
            headers["mu_Id"] = str(mu_id)
        if referenceid is not None:
            headers["referenceId"] = str(referenceid)
        if requesthash is not None:
            headers["requesthash"] = str(requesthash)
        if userid is not None:
            headers["userId"] = str(userid)
        
        
        return await make_api_request(
            "POST", 
            path, 
            data=data, 
            params=params if params else None, 
            headers=headers if headers else None
        )
    
    
    
    @mcp.tool()
    async def cbcbtrevoke_stop_cheque_book_request_using_put(
        request_body:Dict[str, Any] ,  # RevokeChequeRequest_Resource,
        accesstoken: Optional[str] = None,
        channeltype: Optional[int] = None,
        co_relationid: Optional[int] = None,
        initiatingsystem: Optional[str] = None,
        servicemode: Optional[int] = None,
        uuidseqno: Optional[int] = None,
        entity: Optional[str] = None,
        languagecode: Optional[int] = None,
        mu_id: Optional[str] = None,
        referenceid: Optional[str] = None,
        requesthash: Optional[str] = None,
        userid: Optional[int] = None
    ) -> Dict[str, Any]:
        """
        Revoke Cheque Request
        
        Generated from: PUT /retailServices/cheque/revoke
        Source: swagger_2_0
        Operation ID: CBCBTRevokeStopChequeBookRequestUsingPUT
        
        
        Authentication: Not required
        
        Parameters:
        - request_body: any (required)
          input
        
        
        
        Headers:
        - Accesstoken: string
          Authorization Token to validation the caller
        - ChannelType: integer
          Channel identifier from where the TXN has originated (Internet, Mobile, ATM, Branch Channel )
        - Co-Relationid: integer
          Unique ID for the service invoked, will be set by the TXN system
        - InitiatingSystem: string
          Indicating the initiated system
        - ServiceMode: integer
          Used for branch channel to indicate the type of customer
        - UUIDSeqNo: integer
          UUID Sequence Number
        - entity: string
          entity
        - languageCode: integer
          languageCode
        - mu_Id: string
          Used to indicate the Branch Id of user
        - referenceId: string
          Place holder for Token based authentication
        - requesthash: string
          Request payload for hash validation
        - userId: integer
          userId
        
        
        """
        
        
        # Prepare request data
        
        # Single body parameter - send directly
        data = request_body if request_body is not None else {}
        
        
        
        # Prepare query parameters
        params = {}
        
        
        # Replace path parameters in URL
        path = "/retailServices/cheque/revoke"
        
        
        # Prepare headers
        headers = {}
        if accesstoken is not None:
            headers["Accesstoken"] = str(accesstoken)
        if channeltype is not None:
            headers["ChannelType"] = str(channeltype)
        if co_relationid is not None:
            headers["Co-Relationid"] = str(co_relationid)
        if initiatingsystem is not None:
            headers["InitiatingSystem"] = str(initiatingsystem)
        if servicemode is not None:
            headers["ServiceMode"] = str(servicemode)
        if uuidseqno is not None:
            headers["UUIDSeqNo"] = str(uuidseqno)
        if entity is not None:
            headers["entity"] = str(entity)
        if languagecode is not None:
            headers["languageCode"] = str(languagecode)
        if mu_id is not None:
            headers["mu_Id"] = str(mu_id)
        if referenceid is not None:
            headers["referenceId"] = str(referenceid)
        if requesthash is not None:
            headers["requesthash"] = str(requesthash)
        if userid is not None:
            headers["userId"] = str(userid)
        
        
        return await make_api_request(
            "PUT", 
            path, 
            data=data, 
            params=params if params else None, 
            headers=headers if headers else None
        )
    
    
    
    @mcp.tool()
    async def rsbtrevoke_cheque_stop_request_postusing_post(
        request_body:Dict[str, Any] ,  # revokeChequeStopRequest,
        accesstoken: Optional[str] = None,
        channeltype: Optional[int] = None,
        co_relationid: Optional[int] = None,
        initiatingsystem: Optional[str] = None,
        servicemode: Optional[int] = None,
        uuidseqno: Optional[int] = None,
        entity: Optional[str] = None,
        languagecode: Optional[int] = None,
        mu_id: Optional[str] = None,
        referenceid: Optional[str] = None,
        requesthash: Optional[str] = None,
        userid: Optional[int] = None
    ) -> Dict[str, Any]:
        """
        Revoke Cheque request
        
        Generated from: POST /retailServices/cheque/revokestopCheque
        Source: swagger_2_0
        Operation ID: RSBTRevokeChequeStopRequest_POSTUsingPOST
        
        
        Authentication: Not required
        
        Parameters:
        - request_body: any (required)
          input
        
        
        
        Headers:
        - Accesstoken: string
          Authorization Token to validation the caller
        - ChannelType: integer
          Channel identifier from where the TXN has originated (Internet, Mobile, ATM, Branch Channel )
        - Co-Relationid: integer
          Unique ID for the service invoked, will be set by the TXN system
        - InitiatingSystem: string
          Indicating the initiated system
        - ServiceMode: integer
          Used for branch channel to indicate the type of customer
        - UUIDSeqNo: integer
          UUID Sequence Number
        - entity: string
          entity
        - languageCode: integer
          languageCode
        - mu_Id: string
          Used to indicate the Branch Id of user
        - referenceId: string
          Place holder for Token based authentication
        - requesthash: string
          Request payload for hash validation
        - userId: integer
          userId
        
        
        """
        
        
        # Prepare request data
        
        # Single body parameter - send directly
        data = request_body if request_body is not None else {}
        
        
        
        # Prepare query parameters
        params = {}
        
        
        # Replace path parameters in URL
        path = "/retailServices/cheque/revokestopCheque"
        
        
        # Prepare headers
        headers = {}
        if accesstoken is not None:
            headers["Accesstoken"] = str(accesstoken)
        if channeltype is not None:
            headers["ChannelType"] = str(channeltype)
        if co_relationid is not None:
            headers["Co-Relationid"] = str(co_relationid)
        if initiatingsystem is not None:
            headers["InitiatingSystem"] = str(initiatingsystem)
        if servicemode is not None:
            headers["ServiceMode"] = str(servicemode)
        if uuidseqno is not None:
            headers["UUIDSeqNo"] = str(uuidseqno)
        if entity is not None:
            headers["entity"] = str(entity)
        if languagecode is not None:
            headers["languageCode"] = str(languagecode)
        if mu_id is not None:
            headers["mu_Id"] = str(mu_id)
        if referenceid is not None:
            headers["referenceId"] = str(referenceid)
        if requesthash is not None:
            headers["requesthash"] = str(requesthash)
        if userid is not None:
            headers["userId"] = str(userid)
        
        
        return await make_api_request(
            "POST", 
            path, 
            data=data, 
            params=params if params else None, 
            headers=headers if headers else None
        )
    
    
    
    @mcp.tool()
    async def rsbtauth_revoke_cheque_stop_request_postusing_post(
        request_body:Dict[str, Any] ,  # revokeStopChequeAuthRequest,
        accesstoken: Optional[str] = None,
        channeltype: Optional[int] = None,
        co_relationid: Optional[int] = None,
        initiatingsystem: Optional[str] = None,
        servicemode: Optional[int] = None,
        uuidseqno: Optional[int] = None,
        entity: Optional[str] = None,
        languagecode: Optional[int] = None,
        mu_id: Optional[str] = None,
        referenceid: Optional[str] = None,
        requesthash: Optional[str] = None,
        userid: Optional[int] = None
    ) -> Dict[str, Any]:
        """
        Auth for Revoked Cheque request
        
        Generated from: POST /retailServices/cheque/revokestopCheque/Auth
        Source: swagger_2_0
        Operation ID: RSBTAuthRevokeChequeStopRequest_POSTUsingPOST
        
        
        Authentication: Not required
        
        Parameters:
        - request_body: any (required)
          input
        
        
        
        Headers:
        - Accesstoken: string
          Authorization Token to validation the caller
        - ChannelType: integer
          Channel identifier from where the TXN has originated (Internet, Mobile, ATM, Branch Channel )
        - Co-Relationid: integer
          Unique ID for the service invoked, will be set by the TXN system
        - InitiatingSystem: string
          Indicating the initiated system
        - ServiceMode: integer
          Used for branch channel to indicate the type of customer
        - UUIDSeqNo: integer
          UUID Sequence Number
        - entity: string
          entity
        - languageCode: integer
          languageCode
        - mu_Id: string
          Used to indicate the Branch Id of user
        - referenceId: string
          Place holder for Token based authentication
        - requesthash: string
          Request payload for hash validation
        - userId: integer
          userId
        
        
        """
        
        
        # Prepare request data
        
        # Single body parameter - send directly
        data = request_body if request_body is not None else {}
        
        
        
        # Prepare query parameters
        params = {}
        
        
        # Replace path parameters in URL
        path = "/retailServices/cheque/revokestopCheque/Auth"
        
        
        # Prepare headers
        headers = {}
        if accesstoken is not None:
            headers["Accesstoken"] = str(accesstoken)
        if channeltype is not None:
            headers["ChannelType"] = str(channeltype)
        if co_relationid is not None:
            headers["Co-Relationid"] = str(co_relationid)
        if initiatingsystem is not None:
            headers["InitiatingSystem"] = str(initiatingsystem)
        if servicemode is not None:
            headers["ServiceMode"] = str(servicemode)
        if uuidseqno is not None:
            headers["UUIDSeqNo"] = str(uuidseqno)
        if entity is not None:
            headers["entity"] = str(entity)
        if languagecode is not None:
            headers["languageCode"] = str(languagecode)
        if mu_id is not None:
            headers["mu_Id"] = str(mu_id)
        if referenceid is not None:
            headers["referenceId"] = str(referenceid)
        if requesthash is not None:
            headers["requesthash"] = str(requesthash)
        if userid is not None:
            headers["userId"] = str(userid)
        
        
        return await make_api_request(
            "POST", 
            path, 
            data=data, 
            params=params if params else None, 
            headers=headers if headers else None
        )
    
    
    
    @mcp.tool()
    async def rsetlist_chq_leaf_for_account_postusing_get(
        accountreference: str,
        leafnumber: int,
        flagforchqdtls: str,
        pagenum: Optional[int] = None,
        pagesize: Optional[int] = None,
        accesstoken: Optional[str] = None,
        channeltype: Optional[int] = None,
        co_relationid: Optional[int] = None,
        initiatingsystem: Optional[str] = None,
        servicemode: Optional[int] = None,
        uuidseqno: Optional[int] = None,
        entity: Optional[str] = None,
        languagecode: Optional[int] = None,
        referenceid: Optional[str] = None,
        userid: Optional[int] = None
    ) -> Dict[str, Any]:
        """
        Query Check leaf for account
        
        Generated from: GET /retailServices/cheque/status/{accountReference}/{leafNumber}
        Source: swagger_2_0
        Operation ID: RSETListChqLeafForAccount_POSTUsingGET
        
        
        Authentication: Not required
        
        Parameters:
        - accountReference: string (required)
          Account Reference of the Cheque book
        - flagForChqDtls: string (required)
          Cheque Order Details Flag
        - leafNumber: integer (required)
          Cheque Leaf Number
        - pageNum: integer
          pageNum
        - pageSize: integer
          pageSize
        
        
        
        Headers:
        - Accesstoken: string
          Authorization Token to validation the caller
        - ChannelType: integer
          Channel identifier from where the TXN has originated (Internet, Mobile, ATM, Branch Channel )
        - Co-Relationid: integer
          Unique ID for the service invoked, will be set by the TXN system
        - InitiatingSystem: string
          Indicating the initiated system
        - ServiceMode: integer
          Used for branch channel to indicate the type of customer
        - UUIDSeqNo: integer
          UUID Sequence Number
        - entity: string
          entity
        - languageCode: integer
          languageCode
        - referenceId: string
          Place holder for Token based authentication
        - userId: integer
          userId
        
        
        """
        
        
        # Prepare query parameters
        params = {}
        if flagforchqdtls is not None:
            params["flagForChqDtls"] = flagforchqdtls
            
        if pagenum is not None:
            params["pageNum"] = pagenum
            
        if pagesize is not None:
            params["pageSize"] = pagesize
            
        
        
        # Replace path parameters in URL
        path = "/retailServices/cheque/status/{accountReference}/{leafNumber}"
        if accountreference is not None:
            path = path.replace("{accountReference}", str(accountreference))
        if leafnumber is not None:
            path = path.replace("{leafNumber}", str(leafnumber))
        
        
        # Prepare headers
        headers = {}
        if accesstoken is not None:
            headers["Accesstoken"] = str(accesstoken)
        if channeltype is not None:
            headers["ChannelType"] = str(channeltype)
        if co_relationid is not None:
            headers["Co-Relationid"] = str(co_relationid)
        if initiatingsystem is not None:
            headers["InitiatingSystem"] = str(initiatingsystem)
        if servicemode is not None:
            headers["ServiceMode"] = str(servicemode)
        if uuidseqno is not None:
            headers["UUIDSeqNo"] = str(uuidseqno)
        if entity is not None:
            headers["entity"] = str(entity)
        if languagecode is not None:
            headers["languageCode"] = str(languagecode)
        if referenceid is not None:
            headers["referenceId"] = str(referenceid)
        if userid is not None:
            headers["userId"] = str(userid)
        
        
        return await make_api_request(
            "GET", 
            path, 
            
            params=params if params else None, 
            headers=headers if headers else None
        )
    
    
    
    @mcp.tool()
    async def rstbt11810_stop_pymnt_chq_using_post(
        request_body:Dict[str, Any] ,  # StopPymntChqRequest,
        accesstoken: Optional[str] = None,
        channeltype: Optional[int] = None,
        co_relationid: Optional[int] = None,
        initiatingsystem: Optional[str] = None,
        servicemode: Optional[int] = None,
        uuidseqno: Optional[int] = None,
        entity: Optional[str] = None,
        languagecode: Optional[int] = None,
        mu_id: Optional[str] = None,
        referenceid: Optional[str] = None,
        requesthash: Optional[str] = None,
        userid: Optional[int] = None
    ) -> Dict[str, Any]:
        """
        RSTBT11810StopPymntChq
        
        Generated from: POST /retailServices/cheque/stopCheque
        Source: swagger_2_0
        Operation ID: RSTBT11810StopPymntChqUsingPOST
        
        
        Authentication: Not required
        
        Parameters:
        - request_body: any (required)
          input
        
        
        
        Headers:
        - Accesstoken: string
          Authorization Token to validation the caller
        - ChannelType: integer
          Channel identifier from where the TXN has originated (Internet, Mobile, ATM, Branch Channel )
        - Co-Relationid: integer
          Unique ID for the service invoked, will be set by the TXN system
        - InitiatingSystem: string
          Indicating the initiated system
        - ServiceMode: integer
          Used for branch channel to indicate the type of customer
        - UUIDSeqNo: integer
          UUID Sequence Number
        - entity: string
          entity
        - languageCode: integer
          languageCode
        - mu_Id: string
          Used to indicate the Branch Id of user
        - referenceId: string
          Place holder for Token based authentication
        - requesthash: string
          Request payload for hash validation
        - userId: integer
          userId
        
        
        """
        
        
        # Prepare request data
        
        # Single body parameter - send directly
        data = request_body if request_body is not None else {}
        
        
        
        # Prepare query parameters
        params = {}
        
        
        # Replace path parameters in URL
        path = "/retailServices/cheque/stopCheque"
        
        
        # Prepare headers
        headers = {}
        if accesstoken is not None:
            headers["Accesstoken"] = str(accesstoken)
        if channeltype is not None:
            headers["ChannelType"] = str(channeltype)
        if co_relationid is not None:
            headers["Co-Relationid"] = str(co_relationid)
        if initiatingsystem is not None:
            headers["InitiatingSystem"] = str(initiatingsystem)
        if servicemode is not None:
            headers["ServiceMode"] = str(servicemode)
        if uuidseqno is not None:
            headers["UUIDSeqNo"] = str(uuidseqno)
        if entity is not None:
            headers["entity"] = str(entity)
        if languagecode is not None:
            headers["languageCode"] = str(languagecode)
        if mu_id is not None:
            headers["mu_Id"] = str(mu_id)
        if referenceid is not None:
            headers["referenceId"] = str(referenceid)
        if requesthash is not None:
            headers["requesthash"] = str(requesthash)
        if userid is not None:
            headers["userId"] = str(userid)
        
        
        return await make_api_request(
            "POST", 
            path, 
            data=data, 
            params=params if params else None, 
            headers=headers if headers else None
        )
    
    
    
    @mcp.tool()
    async def rsbtauth_stop_cheque_request_postusing_post(
        request_body:Dict[str, Any] ,  # stopChequeAuthRequest,
        accesstoken: Optional[str] = None,
        channeltype: Optional[int] = None,
        co_relationid: Optional[int] = None,
        initiatingsystem: Optional[str] = None,
        servicemode: Optional[int] = None,
        uuidseqno: Optional[int] = None,
        entity: Optional[str] = None,
        languagecode: Optional[int] = None,
        mu_id: Optional[str] = None,
        referenceid: Optional[str] = None,
        requesthash: Optional[str] = None,
        userid: Optional[int] = None
    ) -> Dict[str, Any]:
        """
        Auth service for Stop Cheque
        
        Generated from: POST /retailServices/cheque/stopCheque/auth
        Source: swagger_2_0
        Operation ID: RSBTAuthStopChequeRequest_POSTUsingPOST
        
        
        Authentication: Not required
        
        Parameters:
        - request_body: any (required)
          input
        
        
        
        Headers:
        - Accesstoken: string
          Authorization Token to validation the caller
        - ChannelType: integer
          Channel identifier from where the TXN has originated (Internet, Mobile, ATM, Branch Channel )
        - Co-Relationid: integer
          Unique ID for the service invoked, will be set by the TXN system
        - InitiatingSystem: string
          Indicating the initiated system
        - ServiceMode: integer
          Used for branch channel to indicate the type of customer
        - UUIDSeqNo: integer
          UUID Sequence Number
        - entity: string
          entity
        - languageCode: integer
          languageCode
        - mu_Id: string
          Used to indicate the Branch Id of user
        - referenceId: string
          Place holder for Token based authentication
        - requesthash: string
          Request payload for hash validation
        - userId: integer
          userId
        
        
        """
        
        
        # Prepare request data
        
        # Single body parameter - send directly
        data = request_body if request_body is not None else {}
        
        
        
        # Prepare query parameters
        params = {}
        
        
        # Replace path parameters in URL
        path = "/retailServices/cheque/stopCheque/auth"
        
        
        # Prepare headers
        headers = {}
        if accesstoken is not None:
            headers["Accesstoken"] = str(accesstoken)
        if channeltype is not None:
            headers["ChannelType"] = str(channeltype)
        if co_relationid is not None:
            headers["Co-Relationid"] = str(co_relationid)
        if initiatingsystem is not None:
            headers["InitiatingSystem"] = str(initiatingsystem)
        if servicemode is not None:
            headers["ServiceMode"] = str(servicemode)
        if uuidseqno is not None:
            headers["UUIDSeqNo"] = str(uuidseqno)
        if entity is not None:
            headers["entity"] = str(entity)
        if languagecode is not None:
            headers["languageCode"] = str(languagecode)
        if mu_id is not None:
            headers["mu_Id"] = str(mu_id)
        if referenceid is not None:
            headers["referenceId"] = str(referenceid)
        if requesthash is not None:
            headers["requesthash"] = str(requesthash)
        if userid is not None:
            headers["userId"] = str(userid)
        
        
        return await make_api_request(
            "POST", 
            path, 
            data=data, 
            params=params if params else None, 
            headers=headers if headers else None
        )
    
    
    
    @mcp.tool()
    async def rsbtcreate_stop_cheque_request_postusing_post(
        request_body:Dict[str, Any] ,  # createStopChequeRequest,
        accesstoken: Optional[str] = None,
        channeltype: Optional[int] = None,
        co_relationid: Optional[int] = None,
        initiatingsystem: Optional[str] = None,
        servicemode: Optional[int] = None,
        uuidseqno: Optional[int] = None,
        entity: Optional[str] = None,
        languagecode: Optional[int] = None,
        mu_id: Optional[str] = None,
        referenceid: Optional[str] = None,
        requesthash: Optional[str] = None,
        userid: Optional[int] = None
    ) -> Dict[str, Any]:
        """
        createStopChequeRequest
        
        Generated from: POST /retailServices/cheque/stopChequeRequest
        Source: swagger_2_0
        Operation ID: RSBTCreateStopChequeRequest_POSTUsingPOST
        
        
        Authentication: Not required
        
        Parameters:
        - request_body: any (required)
          input
        
        
        
        Headers:
        - Accesstoken: string
          Authorization Token to validation the caller
        - ChannelType: integer
          Channel identifier from where the TXN has originated (Internet, Mobile, ATM, Branch Channel )
        - Co-Relationid: integer
          Unique ID for the service invoked, will be set by the TXN system
        - InitiatingSystem: string
          Indicating the initiated system
        - ServiceMode: integer
          Used for branch channel to indicate the type of customer
        - UUIDSeqNo: integer
          UUID Sequence Number
        - entity: string
          entity
        - languageCode: integer
          languageCode
        - mu_Id: string
          Used to indicate the Branch Id of user
        - referenceId: string
          Place holder for Token based authentication
        - requesthash: string
          Request payload for hash validation
        - userId: integer
          userId
        
        
        """
        
        
        # Prepare request data
        
        # Single body parameter - send directly
        data = request_body if request_body is not None else {}
        
        
        
        # Prepare query parameters
        params = {}
        
        
        # Replace path parameters in URL
        path = "/retailServices/cheque/stopChequeRequest"
        
        
        # Prepare headers
        headers = {}
        if accesstoken is not None:
            headers["Accesstoken"] = str(accesstoken)
        if channeltype is not None:
            headers["ChannelType"] = str(channeltype)
        if co_relationid is not None:
            headers["Co-Relationid"] = str(co_relationid)
        if initiatingsystem is not None:
            headers["InitiatingSystem"] = str(initiatingsystem)
        if servicemode is not None:
            headers["ServiceMode"] = str(servicemode)
        if uuidseqno is not None:
            headers["UUIDSeqNo"] = str(uuidseqno)
        if entity is not None:
            headers["entity"] = str(entity)
        if languagecode is not None:
            headers["languageCode"] = str(languagecode)
        if mu_id is not None:
            headers["mu_Id"] = str(mu_id)
        if referenceid is not None:
            headers["referenceId"] = str(referenceid)
        if requesthash is not None:
            headers["requesthash"] = str(requesthash)
        if userid is not None:
            headers["userId"] = str(userid)
        
        
        return await make_api_request(
            "POST", 
            path, 
            data=data, 
            params=params if params else None, 
            headers=headers if headers else None
        )
    
    
    
    @mcp.tool()
    async def rsbt5309_reject_stop_revoke_cheque_request_postusing_post(
        request_body:Dict[str, Any] ,  # rejectStopRevokeChequeRequest,
        accesstoken: Optional[str] = None,
        channeltype: Optional[int] = None,
        co_relationid: Optional[int] = None,
        initiatingsystem: Optional[str] = None,
        servicemode: Optional[int] = None,
        uuidseqno: Optional[int] = None,
        entity: Optional[str] = None,
        languagecode: Optional[int] = None,
        mu_id: Optional[str] = None,
        referenceid: Optional[str] = None,
        requesthash: Optional[str] = None,
        userid: Optional[int] = None
    ) -> Dict[str, Any]:
        """
        Reject service for Stopcheque and Revoke
        
        Generated from: POST /retailServices/cheque/stopChequeRevoke/reject
        Source: swagger_2_0
        Operation ID: RSBT5309RejectStopRevokeChequeRequest_POSTUsingPOST
        
        
        Authentication: Not required
        
        Parameters:
        - request_body: any (required)
          input
        
        
        
        Headers:
        - Accesstoken: string
          Authorization Token to validation the caller
        - ChannelType: integer
          Channel identifier from where the TXN has originated (Internet, Mobile, ATM, Branch Channel )
        - Co-Relationid: integer
          Unique ID for the service invoked, will be set by the TXN system
        - InitiatingSystem: string
          Indicating the initiated system
        - ServiceMode: integer
          Used for branch channel to indicate the type of customer
        - UUIDSeqNo: integer
          UUID Sequence Number
        - entity: string
          entity
        - languageCode: integer
          languageCode
        - mu_Id: string
          Used to indicate the Branch Id of user
        - referenceId: string
          Place holder for Token based authentication
        - requesthash: string
          Request payload for hash validation
        - userId: integer
          userId
        
        
        """
        
        
        # Prepare request data
        
        # Single body parameter - send directly
        data = request_body if request_body is not None else {}
        
        
        
        # Prepare query parameters
        params = {}
        
        
        # Replace path parameters in URL
        path = "/retailServices/cheque/stopChequeRevoke/reject"
        
        
        # Prepare headers
        headers = {}
        if accesstoken is not None:
            headers["Accesstoken"] = str(accesstoken)
        if channeltype is not None:
            headers["ChannelType"] = str(channeltype)
        if co_relationid is not None:
            headers["Co-Relationid"] = str(co_relationid)
        if initiatingsystem is not None:
            headers["InitiatingSystem"] = str(initiatingsystem)
        if servicemode is not None:
            headers["ServiceMode"] = str(servicemode)
        if uuidseqno is not None:
            headers["UUIDSeqNo"] = str(uuidseqno)
        if entity is not None:
            headers["entity"] = str(entity)
        if languagecode is not None:
            headers["languageCode"] = str(languagecode)
        if mu_id is not None:
            headers["mu_Id"] = str(mu_id)
        if referenceid is not None:
            headers["referenceId"] = str(referenceid)
        if requesthash is not None:
            headers["requesthash"] = str(requesthash)
        if userid is not None:
            headers["userId"] = str(userid)
        
        
        return await make_api_request(
            "POST", 
            path, 
            data=data, 
            params=params if params else None, 
            headers=headers if headers else None
        )
    
    
    
    @mcp.tool()
    async def rset7016_get_chq_request_lst_postusing_get(
        accountreference: str,
        channeltyp: Optional[str] = None,
        chequebookcategory: Optional[str] = None,
        chequerequestreference: Optional[str] = None,
        deliverybranch: Optional[str] = None,
        fromdate: Optional[str] = None,
        homebranch: Optional[str] = None,
        orderingbranch: Optional[str] = None,
        pagenum: Optional[int] = None,
        pagesize: Optional[int] = None,
        requeststatus: Optional[str] = None,
        reservationtype: Optional[str] = None,
        todate: Optional[str] = None,
        accesstoken: Optional[str] = None,
        channeltype: Optional[int] = None,
        co_relationid: Optional[int] = None,
        initiatingsystem: Optional[str] = None,
        servicemode: Optional[int] = None,
        uuidseqno: Optional[int] = None,
        authorization: Optional[str] = None,
        entity: Optional[str] = None,
        languagecode: Optional[int] = None,
        referenceid: Optional[str] = None,
        userid: Optional[int] = None
    ) -> Dict[str, Any]:
        """
        Cheque Request list
        
        Generated from: GET /retailServices/chequeRequestList
        Source: swagger_2_0
        Operation ID: RSET7016GetChqRequestLst_POSTUsingGET
        
        
        Authentication: Not required
        
        Parameters:
        - accountReference: string (required)
          Account Reference
        - channelTyp: string
          Channel Type
        - chequeBookCategory: string
          Cheque Book Category
        - chequeRequestReference: string
          Cheque Request Reference
        - deliveryBranch: string
          Delivery Branch
        - fromDate: string
          fromDate
        - homeBranch: string
          Home Branch
        - orderingBranch: string
          orderingBranch
        - pageNum: integer
          pageNum
        - pageSize: integer
          pageSize
        - requestStatus: string
          Request Status
        - reservationType: string
          Reservation Type
        - toDate: string
          To Date
        
        
        
        Headers:
        - Accesstoken: string
          Authorization token for identification of the caller
        - ChannelType: integer
          Channel identifier from where the TXN has originated (Internet, Mobile, ATM, Branch Channel )
        - Co-Relationid: integer
          Unique ID for the service invoked, will be set by the TXN system
        - InitiatingSystem: string
          Indicating the initiated system
        - ServiceMode: integer
          Used for branch channel to indicate the type of customer
        - UUIDSeqNo: integer
          UUID Sequence Number
        - authorization: string
          Authorization Token to validation the caller
        - entity: string
          entity
        - languageCode: integer
          languageCode
        - referenceId: string
          Place holder for Token based authentication
        - userId: integer
          userId
        
        
        """
        
        
        # Prepare query parameters
        params = {}
        if accountreference is not None:
            params["accountReference"] = accountreference
            
        if channeltyp is not None:
            params["channelTyp"] = channeltyp
            
        if chequebookcategory is not None:
            params["chequeBookCategory"] = chequebookcategory
            
        if chequerequestreference is not None:
            params["chequeRequestReference"] = chequerequestreference
            
        if deliverybranch is not None:
            params["deliveryBranch"] = deliverybranch
            
        if fromdate is not None:
            params["fromDate"] = fromdate
            
        if homebranch is not None:
            params["homeBranch"] = homebranch
            
        if orderingbranch is not None:
            params["orderingBranch"] = orderingbranch
            
        if pagenum is not None:
            params["pageNum"] = pagenum
            
        if pagesize is not None:
            params["pageSize"] = pagesize
            
        if requeststatus is not None:
            params["requestStatus"] = requeststatus
            
        if reservationtype is not None:
            params["reservationType"] = reservationtype
            
        if todate is not None:
            params["toDate"] = todate
            
        
        
        # Replace path parameters in URL
        path = "/retailServices/chequeRequestList"
        
        
        # Prepare headers
        headers = {}
        if accesstoken is not None:
            headers["Accesstoken"] = str(accesstoken)
        if channeltype is not None:
            headers["ChannelType"] = str(channeltype)
        if co_relationid is not None:
            headers["Co-Relationid"] = str(co_relationid)
        if initiatingsystem is not None:
            headers["InitiatingSystem"] = str(initiatingsystem)
        if servicemode is not None:
            headers["ServiceMode"] = str(servicemode)
        if uuidseqno is not None:
            headers["UUIDSeqNo"] = str(uuidseqno)
        if authorization is not None:
            headers["authorization"] = str(authorization)
        if entity is not None:
            headers["entity"] = str(entity)
        if languagecode is not None:
            headers["languageCode"] = str(languagecode)
        if referenceid is not None:
            headers["referenceId"] = str(referenceid)
        if userid is not None:
            headers["userId"] = str(userid)
        
        
        return await make_api_request(
            "GET", 
            path, 
            
            params=params if params else None, 
            headers=headers if headers else None
        )
    
    
    
    @mcp.tool()
    async def rsetcalculate_days_postusing_get(
        advancerentperiod: int,
        advancerentvalue: int,
        pagenum: Optional[int] = None,
        pagesize: Optional[int] = None,
        rentduedate: Optional[str] = None,
        accesstoken: Optional[str] = None,
        channeltype: Optional[int] = None,
        co_relationid: Optional[int] = None,
        entity: Optional[str] = None,
        initiatingsystem: Optional[str] = None,
        languagecode: Optional[int] = None,
        mu_id: Optional[str] = None,
        referenceid: Optional[str] = None,
        servicemode: Optional[int] = None,
        userid: Optional[int] = None,
        uuidseqno: Optional[int] = None
    ) -> Dict[str, Any]:
        """
        Service to calculate days
        
        Generated from: GET /retailServices/generic/fetchCalculateTenureDays
        Source: swagger_2_0
        Operation ID: RSETCalculateDays_POSTUsingGET
        
        
        Authentication: Not required
        
        Parameters:
        - advanceRentPeriod: integer (required)
          Advance_Rent_Period
        - advanceRentValue: integer (required)
          Advance_Rent_Value
        - pageNum: integer
          pageNum
        - pageSize: integer
          pageSize
        - rentDueDate: string
          Rent_Due_Date
        
        
        
        Headers:
        - Accesstoken: string
          Authorization Token to validation the caller
        - ChannelType: integer
          Channel identifier from where the TXN has originated (Internet, Mobile, ATM, Branch Channel )
        - co-Relationid: integer
          Unique ID for the service invoked, will be set by the TXN system
        - entity: string
          entity
        - initiatingSystem: string
          Indicating the initiated system
        - languageCode: integer
          languageCode
        - mu_Id: string
          Used to indicate the Branch Id of user
        - referenceId: string
          Place holder for Token based authentication
        - serviceMode: integer
          Used for branch channel to indicate the type of customer
        - userId: integer
          userId
        - uuidSeqNo: integer
          UUID Sequence Number
        
        
        """
        
        
        # Prepare query parameters
        params = {}
        if advancerentperiod is not None:
            params["advanceRentPeriod"] = advancerentperiod
            
        if advancerentvalue is not None:
            params["advanceRentValue"] = advancerentvalue
            
        if pagenum is not None:
            params["pageNum"] = pagenum
            
        if pagesize is not None:
            params["pageSize"] = pagesize
            
        if rentduedate is not None:
            params["rentDueDate"] = rentduedate
            
        
        
        # Replace path parameters in URL
        path = "/retailServices/generic/fetchCalculateTenureDays"
        
        
        # Prepare headers
        headers = {}
        if accesstoken is not None:
            headers["Accesstoken"] = str(accesstoken)
        if channeltype is not None:
            headers["ChannelType"] = str(channeltype)
        if co_relationid is not None:
            headers["co-Relationid"] = str(co_relationid)
        if entity is not None:
            headers["entity"] = str(entity)
        if initiatingsystem is not None:
            headers["initiatingSystem"] = str(initiatingsystem)
        if languagecode is not None:
            headers["languageCode"] = str(languagecode)
        if mu_id is not None:
            headers["mu_Id"] = str(mu_id)
        if referenceid is not None:
            headers["referenceId"] = str(referenceid)
        if servicemode is not None:
            headers["serviceMode"] = str(servicemode)
        if userid is not None:
            headers["userId"] = str(userid)
        if uuidseqno is not None:
            headers["uuidSeqNo"] = str(uuidseqno)
        
        
        return await make_api_request(
            "GET", 
            path, 
            
            params=params if params else None, 
            headers=headers if headers else None
        )
    
    
    
    @mcp.tool()
    async def rsbt6402_auth_vcoadvnce_rent_rcvry_postusing_put(
        request_body:Dict[str, Any] ,  # AuthVCOAdvnceRentRcvryRequest,
        accesstoken: Optional[str] = None,
        channeltype: Optional[int] = None,
        co_relationid: Optional[int] = None,
        initiatingsystem: Optional[str] = None,
        servicemode: Optional[int] = None,
        uuidseqno: Optional[int] = None,
        entity: Optional[str] = None,
        languagecode: Optional[int] = None,
        mu_id: Optional[str] = None,
        referenceid: Optional[str] = None,
        requesthash: Optional[str] = None,
        userid: Optional[int] = None
    ) -> Dict[str, Any]:
        """
        Locker Rent Recovery
        
        Generated from: PUT /retailServices/locker/authRentRecovery
        Source: swagger_2_0
        Operation ID: RSBT6402AuthVCOAdvnceRentRcvry_POSTUsingPUT
        
        
        Authentication: Not required
        
        Parameters:
        - request_body: any (required)
          input
        
        
        
        Headers:
        - Accesstoken: string
          Authorization Token to validation the caller
        - ChannelType: integer
          Channel identifier from where the TXN has originated (Internet, Mobile, ATM, Branch Channel )
        - Co-Relationid: integer
          Unique ID for the service invoked, will be set by the TXN system
        - InitiatingSystem: string
          Indicating the initiated system
        - ServiceMode: integer
          Used for branch channel to indicate the type of customer
        - UUIDSeqNo: integer
          UUID Sequence Number
        - entity: string
          entity
        - languageCode: integer
          languageCode
        - mu_Id: string
          Used to indicate the Branch Id of user
        - referenceId: string
          Place holder for Token based authentication
        - requesthash: string
          Request payload for hash validation
        - userId: integer
          userId
        
        
        """
        
        
        # Prepare request data
        
        # Single body parameter - send directly
        data = request_body if request_body is not None else {}
        
        
        
        # Prepare query parameters
        params = {}
        
        
        # Replace path parameters in URL
        path = "/retailServices/locker/authRentRecovery"
        
        
        # Prepare headers
        headers = {}
        if accesstoken is not None:
            headers["Accesstoken"] = str(accesstoken)
        if channeltype is not None:
            headers["ChannelType"] = str(channeltype)
        if co_relationid is not None:
            headers["Co-Relationid"] = str(co_relationid)
        if initiatingsystem is not None:
            headers["InitiatingSystem"] = str(initiatingsystem)
        if servicemode is not None:
            headers["ServiceMode"] = str(servicemode)
        if uuidseqno is not None:
            headers["UUIDSeqNo"] = str(uuidseqno)
        if entity is not None:
            headers["entity"] = str(entity)
        if languagecode is not None:
            headers["languageCode"] = str(languagecode)
        if mu_id is not None:
            headers["mu_Id"] = str(mu_id)
        if referenceid is not None:
            headers["referenceId"] = str(referenceid)
        if requesthash is not None:
            headers["requesthash"] = str(requesthash)
        if userid is not None:
            headers["userId"] = str(userid)
        
        
        return await make_api_request(
            "PUT", 
            path, 
            data=data, 
            params=params if params else None, 
            headers=headers if headers else None
        )
    
    
    
    @mcp.tool()
    async def rset6405_fetch_vlt_no_postusing_get(
        fromcustomerkeynumber: str,
        lockernumber: Optional[str] = None,
        lockertype: Optional[int] = None,
        unitnumber: Optional[int] = None,
        accesstoken: Optional[str] = None,
        channeltype: Optional[int] = None,
        co_relationid: Optional[int] = None,
        entity: Optional[str] = None,
        initiatingsystem: Optional[str] = None,
        mu_id: Optional[str] = None,
        referenceid: Optional[str] = None,
        runmode: Optional[int] = None,
        userid: Optional[int] = None,
        uuidseqno: Optional[int] = None
    ) -> Dict[str, Any]:
        """
        API to Fetch Vault Number
        
        Generated from: GET /retailServices/locker/fetchLockerNumber
        Source: swagger_2_0
        Operation ID: RSET6405FetchVltNo_POSTUsingGET
        
        
        Authentication: Not required
        
        Parameters:
        - fromCustomerKeyNumber: string (required)
          fromCustomerKeyNumber
        - lockerNumber: string
          lockerNumber
        - lockerType: integer
          lockerType
        - unitNumber: integer
          unitNumber
        
        
        
        Headers:
        - Accesstoken: string
          Authorization Token to validation the caller
        - ChannelType: integer
          Channel identifier from where the TXN has originated (Internet, Mobile, ATM, Branch Channel )
        - co-Relationid: integer
          Unique ID for the service invoked, will be set by the TXN system
        - entity: string
          entity
        - initiatingSystem: string
          Indicating the initiated system
        - mu_Id: string
          Used to indicate the Branch Id of user
        - referenceId: string
          Place holder for Token based authentication
        - runMode: integer
          runMode
        - userId: integer
          userId
        - uuidSeqNo: integer
          UUID Sequence Number
        
        
        """
        
        
        # Prepare query parameters
        params = {}
        if fromcustomerkeynumber is not None:
            params["fromCustomerKeyNumber"] = fromcustomerkeynumber
            
        if lockernumber is not None:
            params["lockerNumber"] = lockernumber
            
        if lockertype is not None:
            params["lockerType"] = lockertype
            
        if unitnumber is not None:
            params["unitNumber"] = unitnumber
            
        
        
        # Replace path parameters in URL
        path = "/retailServices/locker/fetchLockerNumber"
        
        
        # Prepare headers
        headers = {}
        if accesstoken is not None:
            headers["Accesstoken"] = str(accesstoken)
        if channeltype is not None:
            headers["ChannelType"] = str(channeltype)
        if co_relationid is not None:
            headers["co-Relationid"] = str(co_relationid)
        if entity is not None:
            headers["entity"] = str(entity)
        if initiatingsystem is not None:
            headers["initiatingSystem"] = str(initiatingsystem)
        if mu_id is not None:
            headers["mu_Id"] = str(mu_id)
        if referenceid is not None:
            headers["referenceId"] = str(referenceid)
        if runmode is not None:
            headers["runMode"] = str(runmode)
        if userid is not None:
            headers["userId"] = str(userid)
        if uuidseqno is not None:
            headers["uuidSeqNo"] = str(uuidseqno)
        
        
        return await make_api_request(
            "GET", 
            path, 
            
            params=params if params else None, 
            headers=headers if headers else None
        )
    
    
    
    @mcp.tool()
    async def rsbt6402_init_vcoadvnce_rent_rcvry_postusing_post(
        request_body:Dict[str, Any] ,  # InitVCOAdvnceRentRcvryRequest,
        accesstoken: Optional[str] = None,
        channeltype: Optional[int] = None,
        co_relationid: Optional[int] = None,
        initiatingsystem: Optional[str] = None,
        servicemode: Optional[int] = None,
        uuidseqno: Optional[int] = None,
        entity: Optional[str] = None,
        languagecode: Optional[int] = None,
        mu_id: Optional[str] = None,
        referenceid: Optional[str] = None,
        requesthash: Optional[str] = None,
        userid: Optional[int] = None
    ) -> Dict[str, Any]:
        """
        Create Locker Rent Recovery
        
        Generated from: POST /retailServices/locker/initRentRecovery
        Source: swagger_2_0
        Operation ID: RSBT6402InitVCOAdvnceRentRcvry_POSTUsingPOST
        
        
        Authentication: Not required
        
        Parameters:
        - request_body: any (required)
          input
        
        
        
        Headers:
        - Accesstoken: string
          Authorization Token to validation the caller
        - ChannelType: integer
          Channel identifier from where the TXN has originated (Internet, Mobile, ATM, Branch Channel )
        - Co-Relationid: integer
          Unique ID for the service invoked, will be set by the TXN system
        - InitiatingSystem: string
          Indicating the initiated system
        - ServiceMode: integer
          Used for branch channel to indicate the type of customer
        - UUIDSeqNo: integer
          UUID Sequence Number
        - entity: string
          entity
        - languageCode: integer
          languageCode
        - mu_Id: string
          Used to indicate the Branch Id of user
        - referenceId: string
          Place holder for Token based authentication
        - requesthash: string
          Request payload for hash validation
        - userId: integer
          userId
        
        
        """
        
        
        # Prepare request data
        
        # Single body parameter - send directly
        data = request_body if request_body is not None else {}
        
        
        
        # Prepare query parameters
        params = {}
        
        
        # Replace path parameters in URL
        path = "/retailServices/locker/initRentRecovery"
        
        
        # Prepare headers
        headers = {}
        if accesstoken is not None:
            headers["Accesstoken"] = str(accesstoken)
        if channeltype is not None:
            headers["ChannelType"] = str(channeltype)
        if co_relationid is not None:
            headers["Co-Relationid"] = str(co_relationid)
        if initiatingsystem is not None:
            headers["InitiatingSystem"] = str(initiatingsystem)
        if servicemode is not None:
            headers["ServiceMode"] = str(servicemode)
        if uuidseqno is not None:
            headers["UUIDSeqNo"] = str(uuidseqno)
        if entity is not None:
            headers["entity"] = str(entity)
        if languagecode is not None:
            headers["languageCode"] = str(languagecode)
        if mu_id is not None:
            headers["mu_Id"] = str(mu_id)
        if referenceid is not None:
            headers["referenceId"] = str(referenceid)
        if requesthash is not None:
            headers["requesthash"] = str(requesthash)
        if userid is not None:
            headers["userId"] = str(userid)
        
        
        return await make_api_request(
            "POST", 
            path, 
            data=data, 
            params=params if params else None, 
            headers=headers if headers else None
        )
    
    
    
    @mcp.tool()
    async def rsbt6405_auth_vlt_key_swp_postusing_put(
        request_body:Dict[str, Any] ,  # lockerKeySwapAuthRequest,
        accesstoken: Optional[str] = None,
        channeltype: Optional[int] = None,
        co_relationid: Optional[int] = None,
        entity: Optional[str] = None,
        initiatingsystem: Optional[str] = None,
        mu_id: Optional[str] = None,
        referenceid: Optional[str] = None,
        userid: Optional[int] = None,
        uuidseqno: Optional[int] = None
    ) -> Dict[str, Any]:
        """
        API for key Swapping of Locker
        
        Generated from: PUT /retailServices/locker/lockerKeySwapAuth
        Source: swagger_2_0
        Operation ID: RSBT6405AuthVltKeySwp_POSTUsingPUT
        
        
        Authentication: Not required
        
        Parameters:
        - request_body: any (required)
          input
        
        
        
        Headers:
        - Accesstoken: string
          Authorization Token to validation the caller
        - ChannelType: integer
          Channel identifier from where the TXN has originated (Internet, Mobile, ATM, Branch Channel )
        - co-Relationid: integer
          Unique ID for the service invoked, will be set by the TXN system
        - entity: string
          entity
        - initiatingSystem: string
          Indicating the initiated system
        - mu_Id: string
          Used to indicate the Branch Id of user
        - referenceId: string
          Place holder for Token based authentication
        - userId: integer
          userId
        - uuidSeqNo: integer
          UUID Sequence Number
        
        
        """
        
        
        # Prepare request data
        
        # Single body parameter - send directly
        data = request_body if request_body is not None else {}
        
        
        
        # Prepare query parameters
        params = {}
        
        
        # Replace path parameters in URL
        path = "/retailServices/locker/lockerKeySwapAuth"
        
        
        # Prepare headers
        headers = {}
        if accesstoken is not None:
            headers["Accesstoken"] = str(accesstoken)
        if channeltype is not None:
            headers["ChannelType"] = str(channeltype)
        if co_relationid is not None:
            headers["co-Relationid"] = str(co_relationid)
        if entity is not None:
            headers["entity"] = str(entity)
        if initiatingsystem is not None:
            headers["initiatingSystem"] = str(initiatingsystem)
        if mu_id is not None:
            headers["mu_Id"] = str(mu_id)
        if referenceid is not None:
            headers["referenceId"] = str(referenceid)
        if userid is not None:
            headers["userId"] = str(userid)
        if uuidseqno is not None:
            headers["uuidSeqNo"] = str(uuidseqno)
        
        
        return await make_api_request(
            "PUT", 
            path, 
            data=data, 
            params=params if params else None, 
            headers=headers if headers else None
        )
    
    
    
    @mcp.tool()
    async def rsbt6405_crt_vlt_key_swp_postusing_post(
        request_body:Dict[str, Any] ,  # lockerKeySwapInitRequest,
        accesstoken: Optional[str] = None,
        channeltype: Optional[int] = None,
        co_relationid: Optional[int] = None,
        entity: Optional[str] = None,
        initiatingsystem: Optional[str] = None,
        languagecode: Optional[int] = None,
        mu_id: Optional[str] = None,
        referenceid: Optional[str] = None,
        userid: Optional[int] = None,
        uuidseqno: Optional[int] = None
    ) -> Dict[str, Any]:
        """
        API for key Swapping of Locker
        
        Generated from: POST /retailServices/locker/lockerKeySwapInit
        Source: swagger_2_0
        Operation ID: RSBT6405CrtVltKeySwp_POSTUsingPOST
        
        
        Authentication: Not required
        
        Parameters:
        - request_body: any (required)
          input
        
        
        
        Headers:
        - Accesstoken: string
          Authorization Token to validation the caller
        - ChannelType: integer
          Channel identifier from where the TXN has originated (Internet, Mobile, ATM, Branch Channel )
        - co-Relationid: integer
          Unique ID for the service invoked, will be set by the TXN system
        - entity: string
          entity
        - initiatingSystem: string
          Indicating the initiated system
        - languageCode: integer
          languageCode
        - mu_Id: string
          Used to indicate the Branch Id of user
        - referenceId: string
          Place holder for Token based authentication
        - userId: integer
          userId
        - uuidSeqNo: integer
          UUID Sequence Number
        
        
        """
        
        
        # Prepare request data
        
        # Single body parameter - send directly
        data = request_body if request_body is not None else {}
        
        
        
        # Prepare query parameters
        params = {}
        
        
        # Replace path parameters in URL
        path = "/retailServices/locker/lockerKeySwapInit"
        
        
        # Prepare headers
        headers = {}
        if accesstoken is not None:
            headers["Accesstoken"] = str(accesstoken)
        if channeltype is not None:
            headers["ChannelType"] = str(channeltype)
        if co_relationid is not None:
            headers["co-Relationid"] = str(co_relationid)
        if entity is not None:
            headers["entity"] = str(entity)
        if initiatingsystem is not None:
            headers["initiatingSystem"] = str(initiatingsystem)
        if languagecode is not None:
            headers["languageCode"] = str(languagecode)
        if mu_id is not None:
            headers["mu_Id"] = str(mu_id)
        if referenceid is not None:
            headers["referenceId"] = str(referenceid)
        if userid is not None:
            headers["userId"] = str(userid)
        if uuidseqno is not None:
            headers["uuidSeqNo"] = str(uuidseqno)
        
        
        return await make_api_request(
            "POST", 
            path, 
            data=data, 
            params=params if params else None, 
            headers=headers if headers else None
        )
    
    
    
    @mcp.tool()
    async def rset6405_swap_list_postusing_get(
        lockernumber: Optional[str] = None,
        lockertype: Optional[int] = None,
        pagenum: Optional[int] = None,
        pagesize: Optional[int] = None,
        swapstatus: Optional[int] = None,
        transactionreference: Optional[int] = None,
        unitnumber: Optional[int] = None,
        accesstoken: Optional[str] = None,
        channeltype: Optional[int] = None,
        co_relationid: Optional[int] = None,
        entity: Optional[str] = None,
        initiatingsystem: Optional[str] = None,
        mu_id: Optional[str] = None,
        referenceid: Optional[str] = None,
        uuidseqno: Optional[int] = None
    ) -> Dict[str, Any]:
        """
        Api to list the Locker Swap List
        
        Generated from: GET /retailServices/locker/lockerKeySwapList
        Source: swagger_2_0
        Operation ID: RSET6405SwapList_POSTUsingGET
        
        
        Authentication: Not required
        
        Parameters:
        - lockerNumber: string
          lockerNumber
        - lockerType: integer
          lockerType
        - pageNum: integer
          pageNum
        - pageSize: integer
          pageSize
        - swapStatus: integer
          swapStatus
        - transactionReference: integer
          transactionReference
        - unitNumber: integer
          unitNumber
        
        
        
        Headers:
        - Accesstoken: string
          Authorization Token to validation the caller
        - ChannelType: integer
          Channel identifier from where the TXN has originated (Internet, Mobile, ATM, Branch Channel )
        - co-Relationid: integer
          Unique ID for the service invoked, will be set by the TXN system
        - entity: string
          entity
        - initiatingSystem: string
          Indicating the initiated system
        - mu_Id: string
          Used to indicate the Branch Id of user
        - referenceId: string
          Place holder for Token based authentication
        - uuidSeqNo: integer
          UUID Sequence Number
        
        
        """
        
        
        # Prepare query parameters
        params = {}
        if lockernumber is not None:
            params["lockerNumber"] = lockernumber
            
        if lockertype is not None:
            params["lockerType"] = lockertype
            
        if pagenum is not None:
            params["pageNum"] = pagenum
            
        if pagesize is not None:
            params["pageSize"] = pagesize
            
        if swapstatus is not None:
            params["swapStatus"] = swapstatus
            
        if transactionreference is not None:
            params["transactionReference"] = transactionreference
            
        if unitnumber is not None:
            params["unitNumber"] = unitnumber
            
        
        
        # Replace path parameters in URL
        path = "/retailServices/locker/lockerKeySwapList"
        
        
        # Prepare headers
        headers = {}
        if accesstoken is not None:
            headers["Accesstoken"] = str(accesstoken)
        if channeltype is not None:
            headers["ChannelType"] = str(channeltype)
        if co_relationid is not None:
            headers["co-Relationid"] = str(co_relationid)
        if entity is not None:
            headers["entity"] = str(entity)
        if initiatingsystem is not None:
            headers["initiatingSystem"] = str(initiatingsystem)
        if mu_id is not None:
            headers["mu_Id"] = str(mu_id)
        if referenceid is not None:
            headers["referenceId"] = str(referenceid)
        if uuidseqno is not None:
            headers["uuidSeqNo"] = str(uuidseqno)
        
        
        return await make_api_request(
            "GET", 
            path, 
            
            params=params if params else None, 
            headers=headers if headers else None
        )
    
    
    
    @mcp.tool()
    async def rset6405_get_swap_view_getusing_get(
        transactionreference: int,
        accesstoken: Optional[str] = None,
        channeltype: Optional[int] = None,
        co_relationid: Optional[int] = None,
        entity: Optional[str] = None,
        initiatingsystem: Optional[str] = None,
        mu_id: Optional[str] = None,
        referenceid: Optional[str] = None,
        uuidseqno: Optional[int] = None
    ) -> Dict[str, Any]:
        """
        API for key Swapping of Locker
        
        Generated from: GET /retailServices/locker/lockerKeySwapView
        Source: swagger_2_0
        Operation ID: RSET6405GetSwapView_GETUsingGET
        
        
        Authentication: Not required
        
        Parameters:
        - transactionReference: integer (required)
          transactionReference
        
        
        
        Headers:
        - Accesstoken: string
          Authorization Token to validation the caller
        - ChannelType: integer
          Channel identifier from where the TXN has originated (Internet, Mobile, ATM, Branch Channel )
        - co-Relationid: integer
          Unique ID for the service invoked, will be set by the TXN system
        - entity: string
          entity
        - initiatingSystem: string
          Indicating the initiated system
        - mu_Id: string
          Used to indicate the Branch Id of user
        - referenceId: string
          Place holder for Token based authentication
        - uuidSeqNo: integer
          UUID Sequence Number
        
        
        """
        
        
        # Prepare query parameters
        params = {}
        if transactionreference is not None:
            params["transactionReference"] = transactionreference
            
        
        
        # Replace path parameters in URL
        path = "/retailServices/locker/lockerKeySwapView"
        
        
        # Prepare headers
        headers = {}
        if accesstoken is not None:
            headers["Accesstoken"] = str(accesstoken)
        if channeltype is not None:
            headers["ChannelType"] = str(channeltype)
        if co_relationid is not None:
            headers["co-Relationid"] = str(co_relationid)
        if entity is not None:
            headers["entity"] = str(entity)
        if initiatingsystem is not None:
            headers["initiatingSystem"] = str(initiatingsystem)
        if mu_id is not None:
            headers["mu_Id"] = str(mu_id)
        if referenceid is not None:
            headers["referenceId"] = str(referenceid)
        if uuidseqno is not None:
            headers["uuidSeqNo"] = str(uuidseqno)
        
        
        return await make_api_request(
            "GET", 
            path, 
            
            params=params if params else None, 
            headers=headers if headers else None
        )
    
    
    
    @mcp.tool()
    async def rsetview_vault_access_details_postusing_get(
        transactionid: int,
        transactiontype: int,
        accessid: Optional[int] = None,
        batchid: Optional[int] = None,
        accesstoken: Optional[str] = None,
        channeltype: Optional[int] = None,
        co_relationid: Optional[int] = None,
        entity: Optional[str] = None,
        initiatingsystem: Optional[str] = None,
        languagecode: Optional[int] = None,
        mu_id: Optional[str] = None,
        referenceid: Optional[str] = None,
        userid: Optional[int] = None,
        uuidseqno: Optional[int] = None
    ) -> Dict[str, Any]:
        """
        Service to return Locker access details
        
        Generated from: GET /retailServices/locker/viewVaultAccessDetails
        Source: swagger_2_0
        Operation ID: RSETViewVaultAccessDetails_POSTUsingGET
        
        
        Authentication: Not required
        
        Parameters:
        - accessId: integer
          Access Id
        - batchId: integer
          Batch ID
        - transactionId: integer (required)
          Transaction Id
        - transactionType: integer (required)
          Transaction Type
        
        
        
        Headers:
        - Accesstoken: string
          Authorization Token to validation the caller
        - ChannelType: integer
          Channel identifier from where the TXN has originated (Internet, Mobile, ATM, Branch Channel )
        - co-Relationid: integer
          Unique ID for the service invoked, will be set by the TXN system
        - entity: string
          entity
        - initiatingSystem: string
          Header description
        - languageCode: integer
          languageCode
        - mu_Id: string
          Used to indicate the Branch Id of user
        - referenceId: string
          Place holder for Token based authentication
        - userId: integer
          userId
        - uuidSeqNo: integer
          UUID Sequence Number
        
        
        """
        
        
        # Prepare query parameters
        params = {}
        if accessid is not None:
            params["accessId"] = accessid
            
        if batchid is not None:
            params["batchId"] = batchid
            
        if transactionid is not None:
            params["transactionId"] = transactionid
            
        if transactiontype is not None:
            params["transactionType"] = transactiontype
            
        
        
        # Replace path parameters in URL
        path = "/retailServices/locker/viewVaultAccessDetails"
        
        
        # Prepare headers
        headers = {}
        if accesstoken is not None:
            headers["Accesstoken"] = str(accesstoken)
        if channeltype is not None:
            headers["ChannelType"] = str(channeltype)
        if co_relationid is not None:
            headers["co-Relationid"] = str(co_relationid)
        if entity is not None:
            headers["entity"] = str(entity)
        if initiatingsystem is not None:
            headers["initiatingSystem"] = str(initiatingsystem)
        if languagecode is not None:
            headers["languageCode"] = str(languagecode)
        if mu_id is not None:
            headers["mu_Id"] = str(mu_id)
        if referenceid is not None:
            headers["referenceId"] = str(referenceid)
        if userid is not None:
            headers["userId"] = str(userid)
        if uuidseqno is not None:
            headers["uuidSeqNo"] = str(uuidseqno)
        
        
        return await make_api_request(
            "GET", 
            path, 
            
            params=params if params else None, 
            headers=headers if headers else None
        )
    
    
    
    @mcp.tool()
    async def rsbt1002_partial_chq_active_postusing_post(
        request_body:Dict[str, Any] ,  # AuthpartialChequeRequest,
        accesstoken: Optional[str] = None,
        channeltype: Optional[int] = None,
        co_relationid: Optional[int] = None,
        initiatingsystem: Optional[str] = None,
        servicemode: Optional[int] = None,
        uuidseqno: Optional[int] = None,
        entity: Optional[str] = None,
        languagecode: Optional[int] = None,
        userid: Optional[int] = None
    ) -> Dict[str, Any]:
        """
        Auth Partial Cheque
        
        Generated from: POST /retailServices/partialcheque/auth
        Source: swagger_2_0
        Operation ID: RSBT1002PartialChqActive_POSTUsingPOST
        
        
        Authentication: Not required
        
        Parameters:
        - request_body: any (required)
          input
        
        
        
        Headers:
        - Accesstoken: string
          Authorization token for identification of the caller
        - ChannelType: integer
          Channel identifier from where the TXN has originated (Internet, Mobile, ATM or Branch Channel )
        - Co-Relationid: integer
          Unique ID for the service invoked, will be set by the TXN system
        - InitiatingSystem: string
          Indicating the initiated system
        - ServiceMode: integer
          Used for branch channel to indicate the type of customer
        - UUIDSeqNo: integer
          UUID Sequence Number
        - entity: string
          entity
        - languageCode: integer
          languageCode
        - userId: integer
          userId
        
        
        """
        
        
        # Prepare request data
        
        # Single body parameter - send directly
        data = request_body if request_body is not None else {}
        
        
        
        # Prepare query parameters
        params = {}
        
        
        # Replace path parameters in URL
        path = "/retailServices/partialcheque/auth"
        
        
        # Prepare headers
        headers = {}
        if accesstoken is not None:
            headers["Accesstoken"] = str(accesstoken)
        if channeltype is not None:
            headers["ChannelType"] = str(channeltype)
        if co_relationid is not None:
            headers["Co-Relationid"] = str(co_relationid)
        if initiatingsystem is not None:
            headers["InitiatingSystem"] = str(initiatingsystem)
        if servicemode is not None:
            headers["ServiceMode"] = str(servicemode)
        if uuidseqno is not None:
            headers["UUIDSeqNo"] = str(uuidseqno)
        if entity is not None:
            headers["entity"] = str(entity)
        if languagecode is not None:
            headers["languageCode"] = str(languagecode)
        if userid is not None:
            headers["userId"] = str(userid)
        
        
        return await make_api_request(
            "POST", 
            path, 
            data=data, 
            params=params if params else None, 
            headers=headers if headers else None
        )
    
    
    
    @mcp.tool()
    async def rsbt1001_partial_chq_onhold_postusing_post(
        request_body:Dict[str, Any] ,  # PartialChqOnholdRequest,
        accesstoken: Optional[str] = None,
        channeltype: Optional[int] = None,
        co_relationid: Optional[int] = None,
        initiatingsystem: Optional[str] = None,
        servicemode: Optional[int] = None,
        uuidseqno: Optional[int] = None,
        entity: Optional[str] = None,
        languagecode: Optional[int] = None,
        runmode: Optional[int] = None,
        userid: Optional[int] = None
    ) -> Dict[str, Any]:
        """
        Create Partial Cheque
        
        Generated from: POST /retailServices/partialcheque/creation
        Source: swagger_2_0
        Operation ID: RSBT1001PartialChqOnhold_POSTUsingPOST
        
        
        Authentication: Not required
        
        Parameters:
        - request_body: any (required)
          input
        
        
        
        Headers:
        - Accesstoken: string
          Authorization token for identification of the caller
        - ChannelType: integer
          Channel identifier from where the TXN has originated (Internet, Mobile, ATM or Branch Channel )
        - Co-Relationid: integer
          Unique ID for the service invoked, will be set by the TXN system
        - InitiatingSystem: string
          Indicating the initiated system
        - ServiceMode: integer
          Used for branch channel to indicate the type of customer
        - UUIDSeqNo: integer
          UUID Sequence Number
        - entity: string
          entity
        - languageCode: integer
          languageCode
        - runMode: integer
          runMode
        - userId: integer
          userId
        
        
        """
        
        
        # Prepare request data
        
        # Single body parameter - send directly
        data = request_body if request_body is not None else {}
        
        
        
        # Prepare query parameters
        params = {}
        
        
        # Replace path parameters in URL
        path = "/retailServices/partialcheque/creation"
        
        
        # Prepare headers
        headers = {}
        if accesstoken is not None:
            headers["Accesstoken"] = str(accesstoken)
        if channeltype is not None:
            headers["ChannelType"] = str(channeltype)
        if co_relationid is not None:
            headers["Co-Relationid"] = str(co_relationid)
        if initiatingsystem is not None:
            headers["InitiatingSystem"] = str(initiatingsystem)
        if servicemode is not None:
            headers["ServiceMode"] = str(servicemode)
        if uuidseqno is not None:
            headers["UUIDSeqNo"] = str(uuidseqno)
        if entity is not None:
            headers["entity"] = str(entity)
        if languagecode is not None:
            headers["languageCode"] = str(languagecode)
        if runmode is not None:
            headers["runMode"] = str(runmode)
        if userid is not None:
            headers["userId"] = str(userid)
        
        
        return await make_api_request(
            "POST", 
            path, 
            data=data, 
            params=params if params else None, 
            headers=headers if headers else None
        )
    
    
    
    @mcp.tool()
    async def rset1003_fetch_partial_chq_blc_getusing_get(
        accountreference: str,
        chequenumber: str,
        accesstoken: Optional[str] = None,
        channeltype: Optional[int] = None,
        co_relationid: Optional[int] = None,
        initiatingsystem: Optional[str] = None,
        servicemode: Optional[int] = None,
        uuidseqno: Optional[int] = None,
        entity: Optional[str] = None,
        languagecode: Optional[int] = None,
        userid: Optional[int] = None
    ) -> Dict[str, Any]:
        """
        Fetch Cheque Detail
        
        Generated from: GET /retailServices/partialcheque/fetchchequedetail
        Source: swagger_2_0
        Operation ID: RSET1003FetchPartialChqBlc_GETUsingGET
        
        
        Authentication: Not required
        
        Parameters:
        - accountReference: string (required)
          account reference
        - chequeNumber: string (required)
          cheque Number
        
        
        
        Headers:
        - Accesstoken: string
          Authorization token for identification of the caller
        - ChannelType: integer
          Channel identifier from where the TXN has originated (Internet, Mobile, ATM or Branch Channel )
        - Co-Relationid: integer
          Unique ID for the service invoked, will be set by the TXN system
        - InitiatingSystem: string
          Indicating the initiated system
        - ServiceMode: integer
          Used for branch channel to indicate the type of customer
        - UUIDSeqNo: integer
          UUID Sequence Number
        - entity: string
          entity
        - languageCode: integer
          languageCode
        - userId: integer
          userId
        
        
        """
        
        
        # Prepare query parameters
        params = {}
        if accountreference is not None:
            params["accountReference"] = accountreference
            
        if chequenumber is not None:
            params["chequeNumber"] = chequenumber
            
        
        
        # Replace path parameters in URL
        path = "/retailServices/partialcheque/fetchchequedetail"
        
        
        # Prepare headers
        headers = {}
        if accesstoken is not None:
            headers["Accesstoken"] = str(accesstoken)
        if channeltype is not None:
            headers["ChannelType"] = str(channeltype)
        if co_relationid is not None:
            headers["Co-Relationid"] = str(co_relationid)
        if initiatingsystem is not None:
            headers["InitiatingSystem"] = str(initiatingsystem)
        if servicemode is not None:
            headers["ServiceMode"] = str(servicemode)
        if uuidseqno is not None:
            headers["UUIDSeqNo"] = str(uuidseqno)
        if entity is not None:
            headers["entity"] = str(entity)
        if languagecode is not None:
            headers["languageCode"] = str(languagecode)
        if userid is not None:
            headers["userId"] = str(userid)
        
        
        return await make_api_request(
            "GET", 
            path, 
            
            params=params if params else None, 
            headers=headers if headers else None
        )
    
    
    
    @mcp.tool()
    async def rset1004_fetch_partial_chq_txn_getusing_get(
        chequenumber: str,
        seqid: str,
        accesstoken: Optional[str] = None,
        channeltype: Optional[int] = None,
        co_relationid: Optional[int] = None,
        initiatingsystem: Optional[str] = None,
        servicemode: Optional[int] = None,
        uuidseqno: Optional[int] = None,
        entity: Optional[str] = None,
        languagecode: Optional[int] = None,
        userid: Optional[int] = None
    ) -> Dict[str, Any]:
        """
        Fetch Cheque Detail Txn View
        
        Generated from: GET /retailServices/partialcheque/fetchchequedetailtxn
        Source: swagger_2_0
        Operation ID: RSET1004FetchPartialChqTxn_GETUsingGET
        
        
        Authentication: Not required
        
        Parameters:
        - chequeNumber: string (required)
          cheque Number
        - seqId: string (required)
          SEQ_ID
        
        
        
        Headers:
        - Accesstoken: string
          Authorization token for identification of the caller
        - ChannelType: integer
          Channel identifier from where the TXN has originated (Internet, Mobile, ATM or Branch Channel )
        - Co-Relationid: integer
          Unique ID for the service invoked, will be set by the TXN system
        - InitiatingSystem: string
          Indicating the initiated system
        - ServiceMode: integer
          Used for branch channel to indicate the type of customer
        - UUIDSeqNo: integer
          UUID Sequence Number
        - entity: string
          entity
        - languageCode: integer
          languageCode
        - userId: integer
          userId
        
        
        """
        
        
        # Prepare query parameters
        params = {}
        if chequenumber is not None:
            params["chequeNumber"] = chequenumber
            
        if seqid is not None:
            params["seqId"] = seqid
            
        
        
        # Replace path parameters in URL
        path = "/retailServices/partialcheque/fetchchequedetailtxn"
        
        
        # Prepare headers
        headers = {}
        if accesstoken is not None:
            headers["Accesstoken"] = str(accesstoken)
        if channeltype is not None:
            headers["ChannelType"] = str(channeltype)
        if co_relationid is not None:
            headers["Co-Relationid"] = str(co_relationid)
        if initiatingsystem is not None:
            headers["InitiatingSystem"] = str(initiatingsystem)
        if servicemode is not None:
            headers["ServiceMode"] = str(servicemode)
        if uuidseqno is not None:
            headers["UUIDSeqNo"] = str(uuidseqno)
        if entity is not None:
            headers["entity"] = str(entity)
        if languagecode is not None:
            headers["languageCode"] = str(languagecode)
        if userid is not None:
            headers["userId"] = str(userid)
        
        
        return await make_api_request(
            "GET", 
            path, 
            
            params=params if params else None, 
            headers=headers if headers else None
        )
    
    
    
    @mcp.tool()
    async def rsbt6228_auth_claim_bc_postusing_put(
        request_body:Dict[str, Any] ,  # authBCClaimRequest,
        channeltype: Optional[int] = None,
        co_relationid: Optional[int] = None,
        entity: Optional[str] = None,
        initiatingsystem: Optional[str] = None,
        languagecode: Optional[int] = None,
        servicemode: Optional[int] = None,
        userid: Optional[int] = None,
        uuidseqno: Optional[int] = None
    ) -> Dict[str, Any]:
        """
        BC Claim Authorization
        
        Generated from: PUT /retailServices/remitIssue/authBCClaim
        Source: swagger_2_0
        Operation ID: RSBT6228AuthClaimBC_POSTUsingPUT
        
        
        Authentication: Not required
        
        Parameters:
        - request_body: any (required)
          input
        
        
        
        Headers:
        - ChannelType: integer
          Channel identifier from where the TXN has originated (Internet, Mobile, ATM, Branch Channel )
        - co-Relationid: integer
          Unique ID for the service invoked, will be set by the TXN system
        - entity: string
          entity
        - initiatingSystem: string
          Indicating the initiated system
        - languageCode: integer
          languageCode
        - serviceMode: integer
          Used for branch channel to indicate the type of customer
        - userId: integer
          userId
        - uuidSeqNo: integer
          UUID Sequence Number
        
        
        """
        
        
        # Prepare request data
        
        # Single body parameter - send directly
        data = request_body if request_body is not None else {}
        
        
        
        # Prepare query parameters
        params = {}
        
        
        # Replace path parameters in URL
        path = "/retailServices/remitIssue/authBCClaim"
        
        
        # Prepare headers
        headers = {}
        if channeltype is not None:
            headers["ChannelType"] = str(channeltype)
        if co_relationid is not None:
            headers["co-Relationid"] = str(co_relationid)
        if entity is not None:
            headers["entity"] = str(entity)
        if initiatingsystem is not None:
            headers["initiatingSystem"] = str(initiatingsystem)
        if languagecode is not None:
            headers["languageCode"] = str(languagecode)
        if servicemode is not None:
            headers["serviceMode"] = str(servicemode)
        if userid is not None:
            headers["userId"] = str(userid)
        if uuidseqno is not None:
            headers["uuidSeqNo"] = str(uuidseqno)
        
        
        return await make_api_request(
            "PUT", 
            path, 
            data=data, 
            params=params if params else None, 
            headers=headers if headers else None
        )
    
    
    
    @mcp.tool()
    async def rsbt4020_auth_remit_issue_postusing_post(
        request_body:Dict[str, Any] ,  # RSBT4020AuthRemitIssue_Resource,
        accesstoken: Optional[str] = None,
        channeltype: Optional[int] = None,
        co_relationid: Optional[int] = None,
        entity: Optional[str] = None,
        initiatingsystem: Optional[str] = None,
        languagecode: Optional[int] = None,
        mu_id: Optional[str] = None,
        referenceid: Optional[str] = None,
        servicemode: Optional[int] = None,
        userid: Optional[int] = None,
        uuidseqno: Optional[int] = None
    ) -> Dict[str, Any]:
        """
        API to Authorize Issue Pay Order
        
        Generated from: POST /retailServices/remitIssue/authRemitIssue
        Source: swagger_2_0
        Operation ID: RSBT4020AuthRemitIssue_POSTUsingPOST
        
        
        Authentication: Not required
        
        Parameters:
        - request_body: any (required)
          input
        
        
        
        Headers:
        - Accesstoken: string
          Authorization Token to validation the caller
        - ChannelType: integer
          Channel identifier from where the TXN has originated (Internet, Mobile, ATM, Branch Channel )
        - co-Relationid: integer
          Unique ID for the service invoked, will be set by the TXN system
        - entity: string
          entity
        - initiatingSystem: string
          Indicating the initiated system
        - languageCode: integer
          languageCode
        - mu_Id: string
          Used to indicate the Branch Id of user
        - referenceId: string
          Place holder for Token based authentication
        - serviceMode: integer
          Used for branch channel to indicate the type of customer
        - userId: integer
          userId
        - uuidSeqNo: integer
          UUID Sequence Number
        
        
        """
        
        
        # Prepare request data
        
        # Single body parameter - send directly
        data = request_body if request_body is not None else {}
        
        
        
        # Prepare query parameters
        params = {}
        
        
        # Replace path parameters in URL
        path = "/retailServices/remitIssue/authRemitIssue"
        
        
        # Prepare headers
        headers = {}
        if accesstoken is not None:
            headers["Accesstoken"] = str(accesstoken)
        if channeltype is not None:
            headers["ChannelType"] = str(channeltype)
        if co_relationid is not None:
            headers["co-Relationid"] = str(co_relationid)
        if entity is not None:
            headers["entity"] = str(entity)
        if initiatingsystem is not None:
            headers["initiatingSystem"] = str(initiatingsystem)
        if languagecode is not None:
            headers["languageCode"] = str(languagecode)
        if mu_id is not None:
            headers["mu_Id"] = str(mu_id)
        if referenceid is not None:
            headers["referenceId"] = str(referenceid)
        if servicemode is not None:
            headers["serviceMode"] = str(servicemode)
        if userid is not None:
            headers["userId"] = str(userid)
        if uuidseqno is not None:
            headers["uuidSeqNo"] = str(uuidseqno)
        
        
        return await make_api_request(
            "POST", 
            path, 
            data=data, 
            params=params if params else None, 
            headers=headers if headers else None
        )
    
    
    
    @mcp.tool()
    async def rsbt5328_auth_revoke_stop_payment_postusing_post(
        request_body:Dict[str, Any] ,  # remitAuthorizeRevokeStopPaymentRequest,
        accesstoken: Optional[str] = None,
        channeltype: Optional[int] = None,
        co_relationid: Optional[int] = None,
        entity: Optional[str] = None,
        initiatingsystem: Optional[str] = None,
        languagecode: Optional[int] = None,
        referenceid: Optional[str] = None,
        servicemode: Optional[int] = None,
        userid: Optional[int] = None,
        uuidseqno: Optional[int] = None
    ) -> Dict[str, Any]:
        """
        API to Authorize Remit Revoke Stop Payment
        
        Generated from: POST /retailServices/remitIssue/authRevokeStopPayment
        Source: swagger_2_0
        Operation ID: RSBT5328AuthRevokeStopPayment_POSTUsingPOST
        
        
        Authentication: Not required
        
        Parameters:
        - request_body: any (required)
          input
        
        
        
        Headers:
        - Accesstoken: string
          Authorization Token to validation the caller
        - ChannelType: integer
          Channel identifier from where the TXN has originated (Internet, Mobile, ATM, Branch Channel )
        - co-Relationid: integer
          Unique ID for the service invoked, will be set by the TXN system
        - entity: string
          entity
        - initiatingSystem: string
          Indicating the initiated system
        - languageCode: integer
          languageCode
        - referenceId: string
          Place holder for Token based authentication
        - serviceMode: integer
          Used for branch channel to indicate the type of customer
        - userId: integer
          userId
        - uuidSeqNo: integer
          UUID Sequence Number
        
        
        """
        
        
        # Prepare request data
        
        # Single body parameter - send directly
        data = request_body if request_body is not None else {}
        
        
        
        # Prepare query parameters
        params = {}
        
        
        # Replace path parameters in URL
        path = "/retailServices/remitIssue/authRevokeStopPayment"
        
        
        # Prepare headers
        headers = {}
        if accesstoken is not None:
            headers["Accesstoken"] = str(accesstoken)
        if channeltype is not None:
            headers["ChannelType"] = str(channeltype)
        if co_relationid is not None:
            headers["co-Relationid"] = str(co_relationid)
        if entity is not None:
            headers["entity"] = str(entity)
        if initiatingsystem is not None:
            headers["initiatingSystem"] = str(initiatingsystem)
        if languagecode is not None:
            headers["languageCode"] = str(languagecode)
        if referenceid is not None:
            headers["referenceId"] = str(referenceid)
        if servicemode is not None:
            headers["serviceMode"] = str(servicemode)
        if userid is not None:
            headers["userId"] = str(userid)
        if uuidseqno is not None:
            headers["uuidSeqNo"] = str(uuidseqno)
        
        
        return await make_api_request(
            "POST", 
            path, 
            data=data, 
            params=params if params else None, 
            headers=headers if headers else None
        )
    
    
    
    @mcp.tool()
    async def rsbt5328_auth_stop_payment_postusing_post(
        request_body:Dict[str, Any] ,  # remitAuthorizeStopPaymentRequest,
        accesstoken: Optional[str] = None,
        channeltype: Optional[int] = None,
        co_relationid: Optional[int] = None,
        entity: Optional[str] = None,
        initiatingsystem: Optional[str] = None,
        languagecode: Optional[int] = None,
        referenceid: Optional[str] = None,
        servicemode: Optional[int] = None,
        userid: Optional[int] = None,
        uuidseqno: Optional[int] = None
    ) -> Dict[str, Any]:
        """
        API to Authorize Remit Stop Payment
        
        Generated from: POST /retailServices/remitIssue/authStopPayment
        Source: swagger_2_0
        Operation ID: RSBT5328AuthStopPayment_POSTUsingPOST
        
        
        Authentication: Not required
        
        Parameters:
        - request_body: any (required)
          input
        
        
        
        Headers:
        - Accesstoken: string
          Authorization Token to validation the caller
        - ChannelType: integer
          Channel identifier from where the TXN has originated (Internet, Mobile, ATM, Branch Channel )
        - co-Relationid: integer
          Unique ID for the service invoked, will be set by the TXN system
        - entity: string
          entity
        - initiatingSystem: string
          Indicating the initiated system
        - languageCode: integer
          languageCode
        - referenceId: string
          Place holder for Token based authentication
        - serviceMode: integer
          Used for branch channel to indicate the type of customer
        - userId: integer
          userId
        - uuidSeqNo: integer
          UUID Sequence Number
        
        
        """
        
        
        # Prepare request data
        
        # Single body parameter - send directly
        data = request_body if request_body is not None else {}
        
        
        
        # Prepare query parameters
        params = {}
        
        
        # Replace path parameters in URL
        path = "/retailServices/remitIssue/authStopPayment"
        
        
        # Prepare headers
        headers = {}
        if accesstoken is not None:
            headers["Accesstoken"] = str(accesstoken)
        if channeltype is not None:
            headers["ChannelType"] = str(channeltype)
        if co_relationid is not None:
            headers["co-Relationid"] = str(co_relationid)
        if entity is not None:
            headers["entity"] = str(entity)
        if initiatingsystem is not None:
            headers["initiatingSystem"] = str(initiatingsystem)
        if languagecode is not None:
            headers["languageCode"] = str(languagecode)
        if referenceid is not None:
            headers["referenceId"] = str(referenceid)
        if servicemode is not None:
            headers["serviceMode"] = str(servicemode)
        if userid is not None:
            headers["userId"] = str(userid)
        if uuidseqno is not None:
            headers["uuidSeqNo"] = str(uuidseqno)
        
        
        return await make_api_request(
            "POST", 
            path, 
            data=data, 
            params=params if params else None, 
            headers=headers if headers else None
        )
    
    
    
    @mcp.tool()
    async def rsbt4018_crt_remit_issue_postusing_post(
        request_body:Dict[str, Any] ,  # RSBT4018CrtRemitIssue_Resource,
        accesstoken: Optional[str] = None,
        channeltype: Optional[int] = None,
        co_relationid: Optional[int] = None,
        initiatingsystem: Optional[str] = None,
        servicemode: Optional[int] = None,
        uuidseqno: Optional[int] = None,
        entity: Optional[str] = None,
        languagecode: Optional[int] = None,
        mu_id: Optional[str] = None,
        referenceid: Optional[str] = None,
        requesthash: Optional[str] = None,
        userid: Optional[int] = None
    ) -> Dict[str, Any]:
        """
        This API services are used to create Issue pay Order
        
        Generated from: POST /retailServices/remitIssue/createRemitIssue
        Source: swagger_2_0
        Operation ID: RSBT4018CrtRemitIssue_POSTUsingPOST
        
        
        Authentication: Not required
        
        Parameters:
        - request_body: any (required)
          input
        
        
        
        Headers:
        - Accesstoken: string
          Authorization token for identification of the caller
        - ChannelType: integer
          Channel identifier from where the TXN has originated (Internet, Mobile, ATM, Branch Channel )
        - Co-Relationid: integer
          Unique ID for the service invoked, will be set by the TXN system
        - InitiatingSystem: string
          Indicating the initiated system
        - ServiceMode: integer
          Used for branch channel to indicate the type of customer
        - UUIDSeqNo: integer
          UUID Sequence Number
        - entity: string
          entity
        - languageCode: integer
          languageCode
        - mu_Id: string
          Used to indicate the Branch Id of user
        - referenceId: string
          Place holder for Token based authentication
        - requesthash: string
          Request payload for hash validation
        - userId: integer
          userId
        
        
        """
        
        
        # Prepare request data
        
        # Single body parameter - send directly
        data = request_body if request_body is not None else {}
        
        
        
        # Prepare query parameters
        params = {}
        
        
        # Replace path parameters in URL
        path = "/retailServices/remitIssue/createRemitIssue"
        
        
        # Prepare headers
        headers = {}
        if accesstoken is not None:
            headers["Accesstoken"] = str(accesstoken)
        if channeltype is not None:
            headers["ChannelType"] = str(channeltype)
        if co_relationid is not None:
            headers["Co-Relationid"] = str(co_relationid)
        if initiatingsystem is not None:
            headers["InitiatingSystem"] = str(initiatingsystem)
        if servicemode is not None:
            headers["ServiceMode"] = str(servicemode)
        if uuidseqno is not None:
            headers["UUIDSeqNo"] = str(uuidseqno)
        if entity is not None:
            headers["entity"] = str(entity)
        if languagecode is not None:
            headers["languageCode"] = str(languagecode)
        if mu_id is not None:
            headers["mu_Id"] = str(mu_id)
        if referenceid is not None:
            headers["referenceId"] = str(referenceid)
        if requesthash is not None:
            headers["requesthash"] = str(requesthash)
        if userid is not None:
            headers["userId"] = str(userid)
        
        
        return await make_api_request(
            "POST", 
            path, 
            data=data, 
            params=params if params else None, 
            headers=headers if headers else None
        )
    
    
    
    @mcp.tool()
    async def rsbt6228_init_claim_bc_postusing_post(
        request_body:Dict[str, Any] ,  # initBCClaimRequest,
        accesstoken: Optional[str] = None,
        channeltype: Optional[int] = None,
        co_relationid: Optional[int] = None,
        entity: Optional[str] = None,
        initiatingsystem: Optional[str] = None,
        languagecode: Optional[int] = None,
        referenceid: Optional[str] = None,
        servicemode: Optional[int] = None,
        userid: Optional[int] = None,
        uuidseqno: Optional[int] = None
    ) -> Dict[str, Any]:
        """
        BC Claim Initiation
        
        Generated from: POST /retailServices/remitIssue/initBCClaim
        Source: swagger_2_0
        Operation ID: RSBT6228InitClaimBC_POSTUsingPOST
        
        
        Authentication: Not required
        
        Parameters:
        - request_body: any (required)
          input
        
        
        
        Headers:
        - accesstoken: string
          Authorization Token to validation the caller
        - channelType: integer
          Channel identifier from where the TXN has originated (Internet, Mobile, ATM, Branch Channel )
        - co-Relationid: integer
          Unique ID for the service invoked, will be set by the TXN system
        - entity: string
          entity
        - initiatingSystem: string
          Indicating the initiated system
        - languageCode: integer
          languageCode
        - referenceId: string
          Place holder for Token based authentication
        - serviceMode: integer
          Used for branch channel to indicate the type of customer
        - userId: integer
          userId
        - uuidSeqNo: integer
          UUID Sequence Number
        
        
        """
        
        
        # Prepare request data
        
        # Single body parameter - send directly
        data = request_body if request_body is not None else {}
        
        
        
        # Prepare query parameters
        params = {}
        
        
        # Replace path parameters in URL
        path = "/retailServices/remitIssue/initBCClaim"
        
        
        # Prepare headers
        headers = {}
        if accesstoken is not None:
            headers["accesstoken"] = str(accesstoken)
        if channeltype is not None:
            headers["channelType"] = str(channeltype)
        if co_relationid is not None:
            headers["co-Relationid"] = str(co_relationid)
        if entity is not None:
            headers["entity"] = str(entity)
        if initiatingsystem is not None:
            headers["initiatingSystem"] = str(initiatingsystem)
        if languagecode is not None:
            headers["languageCode"] = str(languagecode)
        if referenceid is not None:
            headers["referenceId"] = str(referenceid)
        if servicemode is not None:
            headers["serviceMode"] = str(servicemode)
        if userid is not None:
            headers["userId"] = str(userid)
        if uuidseqno is not None:
            headers["uuidSeqNo"] = str(uuidseqno)
        
        
        return await make_api_request(
            "POST", 
            path, 
            data=data, 
            params=params if params else None, 
            headers=headers if headers else None
        )
    
    
    
    @mcp.tool()
    async def rsbt5328_init_revoke_stop_payment_postusing_post(
        request_body:Dict[str, Any] ,  # remitInitiateRevokeStopPaymentRequest,
        accesstoken: Optional[str] = None,
        channeltype: Optional[int] = None,
        co_relationid: Optional[int] = None,
        entity: Optional[str] = None,
        initiatingsystem: Optional[str] = None,
        languagecode: Optional[int] = None,
        referenceid: Optional[str] = None,
        servicemode: Optional[int] = None,
        userid: Optional[int] = None,
        uuidseqno: Optional[int] = None
    ) -> Dict[str, Any]:
        """
        API to Initiate Remit Revoke Stop Payment
        
        Generated from: POST /retailServices/remitIssue/initRevokeStopPayment
        Source: swagger_2_0
        Operation ID: RSBT5328InitRevokeStopPayment_POSTUsingPOST
        
        
        Authentication: Not required
        
        Parameters:
        - request_body: any (required)
          input
        
        
        
        Headers:
        - Accesstoken: string
          Authorization Token to validation the caller
        - channelType: integer
          Channel identifier from where the TXN has originated (Internet, Mobile, ATM, Branch Channel )
        - co-Relationid: integer
          Unique ID for the service invoked, will be set by the TXN system
        - entity: string
          entity
        - initiatingSystem: string
          Indicating the initiated system
        - languageCode: integer
          languageCode
        - referenceId: string
          Place holder for Token based authentication
        - serviceMode: integer
          Used for branch channel to indicate the type of customer
        - userId: integer
          userId
        - uuidSeqNo: integer
          UUID Sequence Number
        
        
        """
        
        
        # Prepare request data
        
        # Single body parameter - send directly
        data = request_body if request_body is not None else {}
        
        
        
        # Prepare query parameters
        params = {}
        
        
        # Replace path parameters in URL
        path = "/retailServices/remitIssue/initRevokeStopPayment"
        
        
        # Prepare headers
        headers = {}
        if accesstoken is not None:
            headers["Accesstoken"] = str(accesstoken)
        if channeltype is not None:
            headers["channelType"] = str(channeltype)
        if co_relationid is not None:
            headers["co-Relationid"] = str(co_relationid)
        if entity is not None:
            headers["entity"] = str(entity)
        if initiatingsystem is not None:
            headers["initiatingSystem"] = str(initiatingsystem)
        if languagecode is not None:
            headers["languageCode"] = str(languagecode)
        if referenceid is not None:
            headers["referenceId"] = str(referenceid)
        if servicemode is not None:
            headers["serviceMode"] = str(servicemode)
        if userid is not None:
            headers["userId"] = str(userid)
        if uuidseqno is not None:
            headers["uuidSeqNo"] = str(uuidseqno)
        
        
        return await make_api_request(
            "POST", 
            path, 
            data=data, 
            params=params if params else None, 
            headers=headers if headers else None
        )
    
    
    
    @mcp.tool()
    async def rsbt5328_init_stop_payment_postusing_post(
        request_body:Dict[str, Any] ,  # remitInitiateStopPaymentRequest,
        accesstoken: Optional[str] = None,
        channeltype: Optional[int] = None,
        co_relationid: Optional[int] = None,
        entity: Optional[str] = None,
        initiatingsystem: Optional[str] = None,
        languagecode: Optional[int] = None,
        referenceid: Optional[str] = None,
        servicemode: Optional[int] = None,
        userid: Optional[int] = None,
        uuidseqno: Optional[int] = None
    ) -> Dict[str, Any]:
        """
        API to Initiate Remit Stop Payment
        
        Generated from: POST /retailServices/remitIssue/initStopPayment
        Source: swagger_2_0
        Operation ID: RSBT5328InitStopPayment_POSTUsingPOST
        
        
        Authentication: Not required
        
        Parameters:
        - request_body: any (required)
          input
        
        
        
        Headers:
        - Accesstoken: string
          Authorization Token to validation the caller
        - ChannelType: integer
          Channel identifier from where the TXN has originated (Internet, Mobile, ATM, Branch Channel )
        - co-Relationid: integer
          Unique ID for the service invoked, will be set by the TXN system
        - entity: string
          entity
        - initiatingSystem: string
          Indicating the initiated system
        - languageCode: integer
          languageCode
        - referenceId: string
          Place holder for Token based authentication
        - serviceMode: integer
          Used for branch channel to indicate the type of customer
        - userId: integer
          userId
        - uuidSeqNo: integer
          UUID Sequence Number
        
        
        """
        
        
        # Prepare request data
        
        # Single body parameter - send directly
        data = request_body if request_body is not None else {}
        
        
        
        # Prepare query parameters
        params = {}
        
        
        # Replace path parameters in URL
        path = "/retailServices/remitIssue/initStopPayment"
        
        
        # Prepare headers
        headers = {}
        if accesstoken is not None:
            headers["Accesstoken"] = str(accesstoken)
        if channeltype is not None:
            headers["ChannelType"] = str(channeltype)
        if co_relationid is not None:
            headers["co-Relationid"] = str(co_relationid)
        if entity is not None:
            headers["entity"] = str(entity)
        if initiatingsystem is not None:
            headers["initiatingSystem"] = str(initiatingsystem)
        if languagecode is not None:
            headers["languageCode"] = str(languagecode)
        if referenceid is not None:
            headers["referenceId"] = str(referenceid)
        if servicemode is not None:
            headers["serviceMode"] = str(servicemode)
        if userid is not None:
            headers["userId"] = str(userid)
        if uuidseqno is not None:
            headers["uuidSeqNo"] = str(uuidseqno)
        
        
        return await make_api_request(
            "POST", 
            path, 
            data=data, 
            params=params if params else None, 
            headers=headers if headers else None
        )
    
    
    
    @mcp.tool()
    async def rsbt5883_auth_bcrvrsl_using_put(
        request_body:Dict[str, Any] ,  # paymentReversalAuthRequest,
        channeltype: Optional[int] = None,
        co_relationid: Optional[int] = None,
        entity: Optional[str] = None,
        initiatingsystem: Optional[str] = None,
        languagecode: Optional[int] = None,
        servicemode: Optional[int] = None,
        userid: Optional[int] = None,
        uuidseqno: Optional[int] = None
    ) -> Dict[str, Any]:
        """
        API for MC payment reversal Auth
        
        Generated from: PUT /retailServices/remitIssue/paymentReversalAuth
        Source: swagger_2_0
        Operation ID: RSBT5883AuthBCRvrslUsingPUT
        
        
        Authentication: Not required
        
        Parameters:
        - request_body: any (required)
          input
        
        
        
        Headers:
        - ChannelType: integer
          Channel identifier from where the TXN has originated (Internet, Mobile, ATM, Branch Channel )
        - co-Relationid: integer
          Unique ID for the service invoked, will be set by the TXN system
        - entity: string
          entity
        - initiatingSystem: string
          Indicating the initiated system
        - languageCode: integer
          languageCode
        - serviceMode: integer
          Used for branch channel to indicate the type of customer
        - userId: integer
          userId
        - uuidSeqNo: integer
          UUID Sequence Number
        
        
        """
        
        
        # Prepare request data
        
        # Single body parameter - send directly
        data = request_body if request_body is not None else {}
        
        
        
        # Prepare query parameters
        params = {}
        
        
        # Replace path parameters in URL
        path = "/retailServices/remitIssue/paymentReversalAuth"
        
        
        # Prepare headers
        headers = {}
        if channeltype is not None:
            headers["ChannelType"] = str(channeltype)
        if co_relationid is not None:
            headers["co-Relationid"] = str(co_relationid)
        if entity is not None:
            headers["entity"] = str(entity)
        if initiatingsystem is not None:
            headers["initiatingSystem"] = str(initiatingsystem)
        if languagecode is not None:
            headers["languageCode"] = str(languagecode)
        if servicemode is not None:
            headers["serviceMode"] = str(servicemode)
        if userid is not None:
            headers["userId"] = str(userid)
        if uuidseqno is not None:
            headers["uuidSeqNo"] = str(uuidseqno)
        
        
        return await make_api_request(
            "PUT", 
            path, 
            data=data, 
            params=params if params else None, 
            headers=headers if headers else None
        )
    
    
    
    @mcp.tool()
    async def rsbt5883_init_bcrvrsl_postusing_post(
        request_body:Dict[str, Any] ,  # paymentReversalInitRequest,
        accesstoken: Optional[str] = None,
        channeltype: Optional[int] = None,
        co_relationid: Optional[int] = None,
        entity: Optional[str] = None,
        initiatingsystem: Optional[str] = None,
        languagecode: Optional[int] = None,
        referenceid: Optional[str] = None,
        servicemode: Optional[int] = None,
        userid: Optional[int] = None,
        uuidseqno: Optional[int] = None
    ) -> Dict[str, Any]:
        """
        API for MC payment reversal Init
        
        Generated from: POST /retailServices/remitIssue/paymentReversalInit
        Source: swagger_2_0
        Operation ID: RSBT5883InitBCRvrsl_POSTUsingPOST
        
        
        Authentication: Not required
        
        Parameters:
        - request_body: any (required)
          input
        
        
        
        Headers:
        - accesstoken: string
          Authorization Token to validation the caller
        - channelType: integer
          Channel identifier from where the TXN has originated (Internet, Mobile, ATM, Branch Channel )
        - co-Relationid: integer
          Unique ID for the service invoked, will be set by the TXN system
        - entity: string
          entity
        - initiatingSystem: string
          Indicating the initiated system
        - languageCode: integer
          languageCode
        - referenceId: string
          Place holder for Token based authentication
        - serviceMode: integer
          Used for branch channel to indicate the type of customer
        - userId: integer
          userId
        - uuidSeqNo: integer
          UUID Sequence Number
        
        
        """
        
        
        # Prepare request data
        
        # Single body parameter - send directly
        data = request_body if request_body is not None else {}
        
        
        
        # Prepare query parameters
        params = {}
        
        
        # Replace path parameters in URL
        path = "/retailServices/remitIssue/paymentReversalInit"
        
        
        # Prepare headers
        headers = {}
        if accesstoken is not None:
            headers["accesstoken"] = str(accesstoken)
        if channeltype is not None:
            headers["channelType"] = str(channeltype)
        if co_relationid is not None:
            headers["co-Relationid"] = str(co_relationid)
        if entity is not None:
            headers["entity"] = str(entity)
        if initiatingsystem is not None:
            headers["initiatingSystem"] = str(initiatingsystem)
        if languagecode is not None:
            headers["languageCode"] = str(languagecode)
        if referenceid is not None:
            headers["referenceId"] = str(referenceid)
        if servicemode is not None:
            headers["serviceMode"] = str(servicemode)
        if userid is not None:
            headers["userId"] = str(userid)
        if uuidseqno is not None:
            headers["uuidSeqNo"] = str(uuidseqno)
        
        
        return await make_api_request(
            "POST", 
            path, 
            data=data, 
            params=params if params else None, 
            headers=headers if headers else None
        )
    
    
    
    @mcp.tool()
    async def rset5302_list_stop_chq_txns_postusing_get(
        accountreference: str,
        transactionstatus_: int,
        chequecancellationtype: Optional[int] = None,
        initiatedviainternet: Optional[int] = None,
        pagenum: Optional[int] = None,
        pagesize: Optional[int] = None,
        transactionreference: Optional[int] = None,
        accesstoken: Optional[str] = None,
        channeltype: Optional[int] = None,
        co_relationid: Optional[int] = None,
        initiatingsystem: Optional[str] = None,
        servicemode: Optional[int] = None,
        uuidseqno: Optional[int] = None,
        authorization: Optional[str] = None,
        entity: Optional[str] = None,
        languagecode: Optional[int] = None,
        referenceid: Optional[str] = None,
        userid: Optional[int] = None
    ) -> Dict[str, Any]:
        """
        List Stop Cheque
        
        Generated from: GET /retailServices/stopcheque
        Source: swagger_2_0
        Operation ID: RSET5302ListStopChqTxns_POSTUsingGET
        
        
        Authentication: Not required
        
        Parameters:
        - accountReference: string (required)
          Account Reference
        - chequeCancellationType: integer
          Cheque Cancellation Type 
        - initiatedViaInternet: integer
          Initiated Via Internet
        - pageNum: integer
          pageNum
        - pageSize: integer
          pageSize
        - transactionReference: integer
          Transaction Reference
        - transactionStatus : integer (required)
          Transaction Status( Stopped - 4 , Revoked - 9)
        
        
        
        Headers:
        - Accesstoken: string
          Authorization token for identification of the caller
        - ChannelType: integer
          Channel identifier from where the TXN has originated (Internet, Mobile, ATM, Branch Channel )
        - Co-Relationid: integer
          Unique ID for the service invoked, will be set by the TXN system
        - InitiatingSystem: string
          Indicating the initiated system
        - ServiceMode: integer
          Used for branch channel to indicate the type of customer
        - UUIDSeqNo: integer
          UUID Sequence Number
        - authorization: string
          Authorization Token to validation the caller
        - entity: string
          entity
        - languageCode: integer
          languageCode
        - referenceId: string
          Place holder for Token based authentication
        - userId: integer
          userId
        
        
        """
        
        
        # Prepare query parameters
        params = {}
        if accountreference is not None:
            params["accountReference"] = accountreference
            
        if chequecancellationtype is not None:
            params["chequeCancellationType"] = chequecancellationtype
            
        if initiatedviainternet is not None:
            params["initiatedViaInternet"] = initiatedviainternet
            
        if pagenum is not None:
            params["pageNum"] = pagenum
            
        if pagesize is not None:
            params["pageSize"] = pagesize
            
        if transactionreference is not None:
            params["transactionReference"] = transactionreference
            
        if transactionstatus_ is not None:
            params["transactionStatus "] = transactionstatus_
            
        
        
        # Replace path parameters in URL
        path = "/retailServices/stopcheque"
        
        
        # Prepare headers
        headers = {}
        if accesstoken is not None:
            headers["Accesstoken"] = str(accesstoken)
        if channeltype is not None:
            headers["ChannelType"] = str(channeltype)
        if co_relationid is not None:
            headers["Co-Relationid"] = str(co_relationid)
        if initiatingsystem is not None:
            headers["InitiatingSystem"] = str(initiatingsystem)
        if servicemode is not None:
            headers["ServiceMode"] = str(servicemode)
        if uuidseqno is not None:
            headers["UUIDSeqNo"] = str(uuidseqno)
        if authorization is not None:
            headers["authorization"] = str(authorization)
        if entity is not None:
            headers["entity"] = str(entity)
        if languagecode is not None:
            headers["languageCode"] = str(languagecode)
        if referenceid is not None:
            headers["referenceId"] = str(referenceid)
        if userid is not None:
            headers["userId"] = str(userid)
        
        
        return await make_api_request(
            "GET", 
            path, 
            
            params=params if params else None, 
            headers=headers if headers else None
        )
    
    
    
    @mcp.tool()
    async def rsbt4720_auth_link_tcrto_tlrusing_post(
        request_body:Dict[str, Any] ,  # authTcrLinkageRequest,
        accesstoken: Optional[str] = None,
        channeltype: Optional[int] = None,
        co_relationid: Optional[int] = None,
        entity: Optional[str] = None,
        initiatingsystem: Optional[str] = None,
        languagecode: Optional[int] = None,
        referenceid: Optional[str] = None,
        servicemode: Optional[int] = None,
        userid: Optional[int] = None,
        uuidseqno: Optional[int] = None
    ) -> Dict[str, Any]:
        """
        API to Authorize craeted TCR Linkage
        
        Generated from: POST /retailServices/tellerTcrManagement/authTcrLinkage
        Source: swagger_2_0
        Operation ID: RSBT4720AuthLinkTCRtoTLRUsingPOST
        
        
        Authentication: Not required
        
        Parameters:
        - request_body: any (required)
          input
        
        
        
        Headers:
        - Accesstoken: string
          Authorization Token to validation the caller
        - ChannelType: integer
          Channel identifier from where the TXN has originated (Internet, Mobile, ATM, Branch Channel )
        - co-Relationid: integer
          Unique ID for the service invoked, will be set by the TXN system
        - entity: string
          entity
        - initiatingSystem: string
          Indicating the initiated system
        - languageCode: integer
          languageCode
        - referenceId: string
          Place holder for Token based authentication
        - serviceMode: integer
          Used for branch channel to indicate the type of customer
        - userId: integer
          userId
        - uuidSeqNo: integer
          UUID Sequence Number
        
        
        """
        
        
        # Prepare request data
        
        # Single body parameter - send directly
        data = request_body if request_body is not None else {}
        
        
        
        # Prepare query parameters
        params = {}
        
        
        # Replace path parameters in URL
        path = "/retailServices/tellerTcrManagement/authTcrLinkage"
        
        
        # Prepare headers
        headers = {}
        if accesstoken is not None:
            headers["Accesstoken"] = str(accesstoken)
        if channeltype is not None:
            headers["ChannelType"] = str(channeltype)
        if co_relationid is not None:
            headers["co-Relationid"] = str(co_relationid)
        if entity is not None:
            headers["entity"] = str(entity)
        if initiatingsystem is not None:
            headers["initiatingSystem"] = str(initiatingsystem)
        if languagecode is not None:
            headers["languageCode"] = str(languagecode)
        if referenceid is not None:
            headers["referenceId"] = str(referenceid)
        if servicemode is not None:
            headers["serviceMode"] = str(servicemode)
        if userid is not None:
            headers["userId"] = str(userid)
        if uuidseqno is not None:
            headers["uuidSeqNo"] = str(uuidseqno)
        
        
        return await make_api_request(
            "POST", 
            path, 
            data=data, 
            params=params if params else None, 
            headers=headers if headers else None
        )
    
    
    
    @mcp.tool()
    async def rsbt4720_link_tcrto_tlrusing_post(
        request_body:Dict[str, Any] ,  # createTcrLinkageRequest,
        accesstoken: Optional[str] = None,
        channeltype: Optional[int] = None,
        co_relationid: Optional[int] = None,
        entity: Optional[str] = None,
        initiatingsystem: Optional[str] = None,
        languagecode: Optional[int] = None,
        referenceid: Optional[str] = None,
        servicemode: Optional[int] = None,
        userid: Optional[int] = None,
        uuidseqno: Optional[int] = None
    ) -> Dict[str, Any]:
        """
        API to create Teller TCR Linkage
        
        Generated from: POST /retailServices/tellerTcrManagement/createTcrLinkage
        Source: swagger_2_0
        Operation ID: RSBT4720LinkTCRtoTLRUsingPOST
        
        
        Authentication: Not required
        
        Parameters:
        - request_body: any (required)
          input
        
        
        
        Headers:
        - Accesstoken: string
          Authorization Token to validation the caller
        - ChannelType: integer
          Channel identifier from where the TXN has originated (Internet, Mobile, ATM, Branch Channel )
        - co-Relationid: integer
          Unique ID for the service invoked, will be set by the TXN system
        - entity: string
          entity
        - initiatingSystem: string
          Indicating the initiated system
        - languageCode: integer
          languageCode
        - referenceId: string
          Place holder for Token based authentication
        - serviceMode: integer
          Used for branch channel to indicate the type of customer
        - userId: integer
          userId
        - uuidSeqNo: integer
          UUID Sequence Number
        
        
        """
        
        
        # Prepare request data
        
        # Single body parameter - send directly
        data = request_body if request_body is not None else {}
        
        
        
        # Prepare query parameters
        params = {}
        
        
        # Replace path parameters in URL
        path = "/retailServices/tellerTcrManagement/createTcrLinkage"
        
        
        # Prepare headers
        headers = {}
        if accesstoken is not None:
            headers["Accesstoken"] = str(accesstoken)
        if channeltype is not None:
            headers["ChannelType"] = str(channeltype)
        if co_relationid is not None:
            headers["co-Relationid"] = str(co_relationid)
        if entity is not None:
            headers["entity"] = str(entity)
        if initiatingsystem is not None:
            headers["initiatingSystem"] = str(initiatingsystem)
        if languagecode is not None:
            headers["languageCode"] = str(languagecode)
        if referenceid is not None:
            headers["referenceId"] = str(referenceid)
        if servicemode is not None:
            headers["serviceMode"] = str(servicemode)
        if userid is not None:
            headers["userId"] = str(userid)
        if uuidseqno is not None:
            headers["uuidSeqNo"] = str(uuidseqno)
        
        
        return await make_api_request(
            "POST", 
            path, 
            data=data, 
            params=params if params else None, 
            headers=headers if headers else None
        )
    
    
    
    @mcp.tool()
    async def rsbt4720_de_link_tcrlinkage_using_post(
        request_body:Dict[str, Any] ,  # deLinkTcrLinkageRequest,
        accesstoken: Optional[str] = None,
        channeltype: Optional[int] = None,
        co_relationid: Optional[int] = None,
        entity: Optional[str] = None,
        initiatingsystem: Optional[str] = None,
        languagecode: Optional[int] = None,
        referenceid: Optional[str] = None,
        servicemode: Optional[int] = None,
        userid: Optional[int] = None,
        uuidseqno: Optional[int] = None
    ) -> Dict[str, Any]:
        """
        API to De-Link TCR Linkage
        
        Generated from: POST /retailServices/tellerTcrManagement/deLinkTcrLinkage
        Source: swagger_2_0
        Operation ID: RSBT4720DeLinkTCRLinkageUsingPOST
        
        
        Authentication: Not required
        
        Parameters:
        - request_body: any (required)
          input
        
        
        
        Headers:
        - Accesstoken: string
          Authorization Token to validation the caller
        - ChannelType: integer
          Channel identifier from where the TXN has originated (Internet, Mobile, ATM, Branch Channel )
        - co-Relationid: integer
          Unique ID for the service invoked, will be set by the TXN system
        - entity: string
          entity
        - initiatingSystem: string
          Indicating the initiated system
        - languageCode: integer
          languageCode
        - referenceId: string
          Place holder for Token based authentication
        - serviceMode: integer
          Used for branch channel to indicate the type of customer
        - userId: integer
          userId
        - uuidSeqNo: integer
          UUID Sequence Number
        
        
        """
        
        
        # Prepare request data
        
        # Single body parameter - send directly
        data = request_body if request_body is not None else {}
        
        
        
        # Prepare query parameters
        params = {}
        
        
        # Replace path parameters in URL
        path = "/retailServices/tellerTcrManagement/deLinkTcrLinkage"
        
        
        # Prepare headers
        headers = {}
        if accesstoken is not None:
            headers["Accesstoken"] = str(accesstoken)
        if channeltype is not None:
            headers["ChannelType"] = str(channeltype)
        if co_relationid is not None:
            headers["co-Relationid"] = str(co_relationid)
        if entity is not None:
            headers["entity"] = str(entity)
        if initiatingsystem is not None:
            headers["initiatingSystem"] = str(initiatingsystem)
        if languagecode is not None:
            headers["languageCode"] = str(languagecode)
        if referenceid is not None:
            headers["referenceId"] = str(referenceid)
        if servicemode is not None:
            headers["serviceMode"] = str(servicemode)
        if userid is not None:
            headers["userId"] = str(userid)
        if uuidseqno is not None:
            headers["uuidSeqNo"] = str(uuidseqno)
        
        
        return await make_api_request(
            "POST", 
            path, 
            data=data, 
            params=params if params else None, 
            headers=headers if headers else None
        )
    
    
    
    @mcp.tool()
    async def rset4720_list_tcrlinkage_using_get(
        entityid: Optional[str] = None,
        couid: Optional[int] = None,
        pagenum: Optional[int] = None,
        pagesize: Optional[int] = None,
        status: Optional[int] = None,
        tcrid: Optional[int] = None,
        tellerid: Optional[int] = None,
        accesstoken: Optional[str] = None,
        channeltype: Optional[int] = None,
        co_relationid: Optional[int] = None,
        entity: Optional[str] = None,
        initiatingsystem: Optional[str] = None,
        languagecode: Optional[int] = None,
        referenceid: Optional[str] = None,
        servicemode: Optional[int] = None,
        userid: Optional[int] = None,
        uuidseqno: Optional[int] = None
    ) -> Dict[str, Any]:
        """
        API to Fetch all Teller-TCR linkage
        
        Generated from: GET /retailServices/tellerTcrManagement/fetchTcrLinkageList
        Source: swagger_2_0
        Operation ID: RSET4720ListTCRLinkageUsingGET
        
        
        Authentication: Not required
        
        Parameters:
        - EntityId: string
          Entity
        - couId: integer
          COU Id
        - pageNum: integer
          pageNum
        - pageSize: integer
          pageSize
        - status: integer
          Status of TCR linkage
        - tcrId: integer
          TCR ID
        - tellerId: integer
          Teller Id
        
        
        
        Headers:
        - Accesstoken: string
          Authorization Token to validation the caller
        - ChannelType: integer
          Channel identifier from where the TXN has originated (Internet, Mobile, ATM, Branch Channel )
        - co-Relationid: integer
          Unique ID for the service invoked, will be set by the TXN system
        - entity: string
          entity
        - initiatingSystem: string
          Indicating the initiated system
        - languageCode: integer
          languageCode
        - referenceId: string
          Place holder for Token based authentication
        - serviceMode: integer
          Used for branch channel to indicate the type of customer
        - userId: integer
          userId
        - uuidSeqNo: integer
          UUID Sequence Number
        
        
        """
        
        
        # Prepare query parameters
        params = {}
        if entityid is not None:
            params["EntityId"] = entityid
            
        if couid is not None:
            params["couId"] = couid
            
        if pagenum is not None:
            params["pageNum"] = pagenum
            
        if pagesize is not None:
            params["pageSize"] = pagesize
            
        if status is not None:
            params["status"] = status
            
        if tcrid is not None:
            params["tcrId"] = tcrid
            
        if tellerid is not None:
            params["tellerId"] = tellerid
            
        
        
        # Replace path parameters in URL
        path = "/retailServices/tellerTcrManagement/fetchTcrLinkageList"
        
        
        # Prepare headers
        headers = {}
        if accesstoken is not None:
            headers["Accesstoken"] = str(accesstoken)
        if channeltype is not None:
            headers["ChannelType"] = str(channeltype)
        if co_relationid is not None:
            headers["co-Relationid"] = str(co_relationid)
        if entity is not None:
            headers["entity"] = str(entity)
        if initiatingsystem is not None:
            headers["initiatingSystem"] = str(initiatingsystem)
        if languagecode is not None:
            headers["languageCode"] = str(languagecode)
        if referenceid is not None:
            headers["referenceId"] = str(referenceid)
        if servicemode is not None:
            headers["serviceMode"] = str(servicemode)
        if userid is not None:
            headers["userId"] = str(userid)
        if uuidseqno is not None:
            headers["uuidSeqNo"] = str(uuidseqno)
        
        
        return await make_api_request(
            "GET", 
            path, 
            
            params=params if params else None, 
            headers=headers if headers else None
        )
    
    
    
    @mcp.tool()
    async def rsbt5884_forex_buy_sell_rvrsl_postusing_post(
        request_body:Dict[str, Any] ,  # forexBuySellReversalRequest,
        channeltype: Optional[int] = None,
        accesstoken: Optional[str] = None,
        co_relationid: Optional[int] = None,
        entity: Optional[str] = None,
        initiatingsystem: Optional[str] = None,
        languagecode: Optional[int] = None,
        referenceid: Optional[str] = None,
        servicemode: Optional[int] = None,
        userid: Optional[int] = None,
        uuidseqno: Optional[int] = None
    ) -> Dict[str, Any]:
        """
        API for forex buy sell reversal
        
        Generated from: POST /retailServices/travellerChequesTxn/ForexBuySellReversalInit
        Source: swagger_2_0
        Operation ID: RSBT5884ForexBuySellRvrsl_POSTUsingPOST
        
        
        Authentication: Not required
        
        Parameters:
        - request_body: any (required)
          input
        
        
        
        Headers:
        - ChannelType: integer
          Channel identifier from where the TXN has originated (Internet, Mobile, ATM, Branch Channel )
        - accesstoken: string
          Authorization Token to validation the caller
        - co-Relationid: integer
          Unique ID for the service invoked, will be set by the TXN system
        - entity: string
          entity
        - initiatingSystem: string
          Indicating the initiated system
        - languageCode: integer
          languageCode
        - referenceId: string
          Place holder for Token based authentication
        - serviceMode: integer
          Used for branch channel to indicate the type of customer
        - userId: integer
          userId
        - uuidSeqNo: integer
          UUID Sequence Number
        
        
        """
        
        
        # Prepare request data
        
        # Single body parameter - send directly
        data = request_body if request_body is not None else {}
        
        
        
        # Prepare query parameters
        params = {}
        
        
        # Replace path parameters in URL
        path = "/retailServices/travellerChequesTxn/ForexBuySellReversalInit"
        
        
        # Prepare headers
        headers = {}
        if channeltype is not None:
            headers["ChannelType"] = str(channeltype)
        if accesstoken is not None:
            headers["accesstoken"] = str(accesstoken)
        if co_relationid is not None:
            headers["co-Relationid"] = str(co_relationid)
        if entity is not None:
            headers["entity"] = str(entity)
        if initiatingsystem is not None:
            headers["initiatingSystem"] = str(initiatingsystem)
        if languagecode is not None:
            headers["languageCode"] = str(languagecode)
        if referenceid is not None:
            headers["referenceId"] = str(referenceid)
        if servicemode is not None:
            headers["serviceMode"] = str(servicemode)
        if userid is not None:
            headers["userId"] = str(userid)
        if uuidseqno is not None:
            headers["uuidSeqNo"] = str(uuidseqno)
        
        
        return await make_api_request(
            "POST", 
            path, 
            data=data, 
            params=params if params else None, 
            headers=headers if headers else None
        )
    
    
    
    @mcp.tool()
    async def rsbt5884_auth_forex_buy_sell_rvrsl_using_put(
        request_body:Dict[str, Any] ,  # authorizeForexBuySellReversalRequest,
        channeltype: Optional[int] = None,
        co_relationid: Optional[int] = None,
        entity: Optional[str] = None,
        initiatingsystem: Optional[str] = None,
        languagecode: Optional[int] = None,
        servicemode: Optional[int] = None,
        userid: Optional[int] = None,
        uuidseqno: Optional[int] = None
    ) -> Dict[str, Any]:
        """
        API for Forex buy/sell reversal authorization
        
        Generated from: PUT /retailServices/travellerChequesTxn/authorizeForexBuySellReversal
        Source: swagger_2_0
        Operation ID: RSBT5884AuthForexBuySellRvrslUsingPUT
        
        
        Authentication: Not required
        
        Parameters:
        - request_body: any (required)
          input
        
        
        
        Headers:
        - ChannelType: integer
          Channel identifier from where the TXN has originated (Internet, Mobile, ATM, Branch Channel )
        - co-Relationid: integer
          Unique ID for the service invoked, will be set by the TXN system
        - entity: string
          entity
        - initiatingSystem: string
          Indicating the initiated system
        - languageCode: integer
          languageCode
        - serviceMode: integer
          Used for branch channel to indicate the type of customer
        - userId: integer
          userId
        - uuidSeqNo: integer
          UUID Sequence Number
        
        
        """
        
        
        # Prepare request data
        
        # Single body parameter - send directly
        data = request_body if request_body is not None else {}
        
        
        
        # Prepare query parameters
        params = {}
        
        
        # Replace path parameters in URL
        path = "/retailServices/travellerChequesTxn/authorizeForexBuySellReversal"
        
        
        # Prepare headers
        headers = {}
        if channeltype is not None:
            headers["ChannelType"] = str(channeltype)
        if co_relationid is not None:
            headers["co-Relationid"] = str(co_relationid)
        if entity is not None:
            headers["entity"] = str(entity)
        if initiatingsystem is not None:
            headers["initiatingSystem"] = str(initiatingsystem)
        if languagecode is not None:
            headers["languageCode"] = str(languagecode)
        if servicemode is not None:
            headers["serviceMode"] = str(servicemode)
        if userid is not None:
            headers["userId"] = str(userid)
        if uuidseqno is not None:
            headers["uuidSeqNo"] = str(uuidseqno)
        
        
        return await make_api_request(
            "PUT", 
            path, 
            data=data, 
            params=params if params else None, 
            headers=headers if headers else None
        )
    
    
    
    @mcp.tool()
    async def intbt0118_crt_csh_blck_intf_postusing_post_1(
        request_body:Dict[str, Any] ,  # RiskCheckRequest,
        accesstoken: Optional[str] = None,
        channeltype: Optional[int] = None,
        co_relationid: Optional[int] = None,
        initiatingsystem: Optional[str] = None,
        servicemode: Optional[int] = None,
        uuidseqno: Optional[int] = None,
        entity: Optional[str] = None,
        languagecode: Optional[int] = None,
        referenceid: Optional[str] = None,
        userid: Optional[int] = None
    ) -> Dict[str, Any]:
        """
        Risk Check
        
        Generated from: POST /riskManagement/core/marketInformation/cashBlock
        Source: swagger_2_0
        Operation ID: INTBT0118CrtCshBlckIntf_POSTUsingPOST_1
        
        
        Authentication: Not required
        
        Parameters:
        - request_body: any (required)
          input
        
        
        
        Headers:
        - Accesstoken: string
          Authorization token for identification of the caller
        - ChannelType: integer
          Channel identifier from where the TXN has originated (Internet, Mobile, ATM, Branch Channel )
        - Co-Relationid: integer
          Unique ID for the service invoked, will be set by the TXN system
        - InitiatingSystem: string
          Indicating the initiated system
        - ServiceMode: integer
          Used for branch channel to indicate the type of customer
        - UUIDSeqNo: integer
          UUID Sequence Number
        - entity: string
          entity
        - languageCode: integer
          languageCode
        - referenceId: string
          Place holder for Token based authentication
        - userId: integer
          userId
        
        
        """
        
        
        # Prepare request data
        
        # Single body parameter - send directly
        data = request_body if request_body is not None else {}
        
        
        
        # Prepare query parameters
        params = {}
        
        
        # Replace path parameters in URL
        path = "/riskManagement/core/marketInformation/cashBlock"
        
        
        # Prepare headers
        headers = {}
        if accesstoken is not None:
            headers["Accesstoken"] = str(accesstoken)
        if channeltype is not None:
            headers["ChannelType"] = str(channeltype)
        if co_relationid is not None:
            headers["Co-Relationid"] = str(co_relationid)
        if initiatingsystem is not None:
            headers["InitiatingSystem"] = str(initiatingsystem)
        if servicemode is not None:
            headers["ServiceMode"] = str(servicemode)
        if uuidseqno is not None:
            headers["UUIDSeqNo"] = str(uuidseqno)
        if entity is not None:
            headers["entity"] = str(entity)
        if languagecode is not None:
            headers["languageCode"] = str(languagecode)
        if referenceid is not None:
            headers["referenceId"] = str(referenceid)
        if userid is not None:
            headers["userId"] = str(userid)
        
        
        return await make_api_request(
            "POST", 
            path, 
            data=data, 
            params=params if params else None, 
            headers=headers if headers else None
        )
    
    
    
    @mcp.tool()
    async def rmbt2022_create_hierarchy_postusing_post(
        request_body:Dict[str, Any] ,  # groupsRequest,
        entity: Optional[str] = None
    ) -> Dict[str, Any]:
        """
        Create group and group structure.
        
        Generated from: POST /riskManagement/createHierarchy
        Source: swagger_2_0
        Operation ID: RMBT2022CreateHierarchy_POSTUsingPOST
        
        
        Authentication: Not required
        
        Parameters:
        - request_body: any (required)
          input
        
        
        
        Headers:
        - entity: string
          entity
        
        
        """
        
        
        # Prepare request data
        
        # Single body parameter - send directly
        data = request_body if request_body is not None else {}
        
        
        
        # Prepare query parameters
        params = {}
        
        
        # Replace path parameters in URL
        path = "/riskManagement/createHierarchy"
        
        
        # Prepare headers
        headers = {}
        if entity is not None:
            headers["entity"] = str(entity)
        
        
        return await make_api_request(
            "POST", 
            path, 
            data=data, 
            params=params if params else None, 
            headers=headers if headers else None
        )
    
    
    
    @mcp.tool()
    async def rmet0201_ftch_grp_stru_dtls_postusing_get(
        customerreference: Optional[int] = None,
        groupname: Optional[str] = None,
        pagenum: Optional[int] = None,
        pagesize: Optional[int] = None,
        entity: Optional[str] = None,
        userid: Optional[int] = None
    ) -> Dict[str, Any]:
        """
        Fetch Group Structure Details.
        
        Generated from: GET /riskManagement/fetchGroupStructureDetails
        Source: swagger_2_0
        Operation ID: RMET0201FtchGrpStruDtls_POSTUsingGET
        
        
        Authentication: Not required
        
        Parameters:
        - customerReference: integer
          This field denotes the Customer associated with group.
        - groupName: string
          This field denotes Name of the Hierarchy.
        - pageNum: integer
          pageNum
        - pageSize: integer
          pageSize
        
        
        
        Headers:
        - entity: string
          entity
        - userId: integer
          userId
        
        
        """
        
        
        # Prepare query parameters
        params = {}
        if customerreference is not None:
            params["customerReference"] = customerreference
            
        if groupname is not None:
            params["groupName"] = groupname
            
        if pagenum is not None:
            params["pageNum"] = pagenum
            
        if pagesize is not None:
            params["pageSize"] = pagesize
            
        
        
        # Replace path parameters in URL
        path = "/riskManagement/fetchGroupStructureDetails"
        
        
        # Prepare headers
        headers = {}
        if entity is not None:
            headers["entity"] = str(entity)
        if userid is not None:
            headers["userId"] = str(userid)
        
        
        return await make_api_request(
            "GET", 
            path, 
            
            params=params if params else None, 
            headers=headers if headers else None
        )
    
    
    
    @mcp.tool()
    async def rmbt2020_limit_crtn_rest_apiusing_post(
        request_body:Dict[str, Any] ,  # LIMIT_RMBT2020LimitCrtnRestAPI_Resource,
        accesstoken: Optional[str] = None,
        channeltype: Optional[int] = None,
        co_relationid: Optional[int] = None,
        initiatingsystem: Optional[str] = None,
        servicemode: Optional[int] = None,
        uuidseqno: Optional[int] = None,
        entity: Optional[str] = None,
        languagecode: Optional[int] = None,
        referenceid: Optional[str] = None,
        requesthash: Optional[str] = None,
        userid: Optional[int] = None
    ) -> Dict[str, Any]:
        """
        Create Limit
        
        Generated from: POST /riskManagement/limit
        Source: swagger_2_0
        Operation ID: RMBT2020LimitCrtnRestAPIUsingPOST
        
        
        Authentication: Not required
        
        Parameters:
        - request_body: any (required)
          input
        
        
        
        Headers:
        - Accesstoken: string
          Authorization Token to validation the caller
        - ChannelType: integer
          Channel identifier from where the transaction has originated (Internet, Mobile, ATM, Branch Channel )
        - Co-Relationid: integer
          Unique ID for the service invoked, will be set by the transaction system
        - InitiatingSystem: string
          Indicating the initiated system
        - ServiceMode: integer
          Used for branch channel to indicate the type of customer
        - UUIDSeqNo: integer
          UUID Sequence Number
        - entity: string
          entity
        - languageCode: integer
          languageCode
        - referenceId: string
          Place holder for Token based authentication
        - requesthash: string
          Request payload for hash validation
        - userId: integer
          userId
        
        
        """
        
        
        # Prepare request data
        
        # Single body parameter - send directly
        data = request_body if request_body is not None else {}
        
        
        
        # Prepare query parameters
        params = {}
        
        
        # Replace path parameters in URL
        path = "/riskManagement/limit"
        
        
        # Prepare headers
        headers = {}
        if accesstoken is not None:
            headers["Accesstoken"] = str(accesstoken)
        if channeltype is not None:
            headers["ChannelType"] = str(channeltype)
        if co_relationid is not None:
            headers["Co-Relationid"] = str(co_relationid)
        if initiatingsystem is not None:
            headers["InitiatingSystem"] = str(initiatingsystem)
        if servicemode is not None:
            headers["ServiceMode"] = str(servicemode)
        if uuidseqno is not None:
            headers["UUIDSeqNo"] = str(uuidseqno)
        if entity is not None:
            headers["entity"] = str(entity)
        if languagecode is not None:
            headers["languageCode"] = str(languagecode)
        if referenceid is not None:
            headers["referenceId"] = str(referenceid)
        if requesthash is not None:
            headers["requesthash"] = str(requesthash)
        if userid is not None:
            headers["userId"] = str(userid)
        
        
        return await make_api_request(
            "POST", 
            path, 
            data=data, 
            params=params if params else None, 
            headers=headers if headers else None
        )
    
    
    
    @mcp.tool()
    async def rmbt0026_crt_limit_sche_int_postusing_post(
        request_body:Dict[str, Any] ,  # crtLimitScheIntResource,
        channeltype: Optional[int] = None,
        co_relationid: Optional[int] = None,
        initiatingsystem: Optional[str] = None,
        servicemode: Optional[int] = None,
        uuidseqno: Optional[int] = None,
        accesstoken: Optional[str] = None,
        entity: Optional[str] = None,
        languagecode: Optional[int] = None,
        referenceid: Optional[str] = None,
        requesthash: Optional[str] = None,
        userid: Optional[int] = None
    ) -> Dict[str, Any]:
        """
        Create Limit Schedules
        
        Generated from: POST /riskManagement/limit/createLimitChangeSchedules
        Source: swagger_2_0
        Operation ID: RMBT0026CrtLimitScheInt_POSTUsingPOST
        
        
        Authentication: Not required
        
        Parameters:
        - request_body: any (required)
          input
        
        
        
        Headers:
        - ChannelType: integer
          Channel identifier from where the transaction has originated (Internet, Mobile, ATM, Branch Channel )
        - Co-Relationid: integer
          Unique ID for the service invoked, will be set by the transaction system
        - InitiatingSystem: string
          Indicating the initiated system
        - ServiceMode: integer
          Used for branch channel to indicate the type of customer
        - UUIDSeqNo: integer
          UUID Sequence Number
        - accessToken: string
          Authorization Token to validation the caller
        - entity: string
          entity
        - languageCode: integer
          languageCode
        - referenceId: string
          Place holder for Token based authentication
        - requestHash: string
          Request payload for hash validation
        - userId: integer
          userId
        
        
        """
        
        
        # Prepare request data
        
        # Single body parameter - send directly
        data = request_body if request_body is not None else {}
        
        
        
        # Prepare query parameters
        params = {}
        
        
        # Replace path parameters in URL
        path = "/riskManagement/limit/createLimitChangeSchedules"
        
        
        # Prepare headers
        headers = {}
        if channeltype is not None:
            headers["ChannelType"] = str(channeltype)
        if co_relationid is not None:
            headers["Co-Relationid"] = str(co_relationid)
        if initiatingsystem is not None:
            headers["InitiatingSystem"] = str(initiatingsystem)
        if servicemode is not None:
            headers["ServiceMode"] = str(servicemode)
        if uuidseqno is not None:
            headers["UUIDSeqNo"] = str(uuidseqno)
        if accesstoken is not None:
            headers["accessToken"] = str(accesstoken)
        if entity is not None:
            headers["entity"] = str(entity)
        if languagecode is not None:
            headers["languageCode"] = str(languagecode)
        if referenceid is not None:
            headers["referenceId"] = str(referenceid)
        if requesthash is not None:
            headers["requestHash"] = str(requesthash)
        if userid is not None:
            headers["userId"] = str(userid)
        
        
        return await make_api_request(
            "POST", 
            path, 
            data=data, 
            params=params if params else None, 
            headers=headers if headers else None
        )
    
    
    
    @mcp.tool()
    async def rmet2020_ftch_lmt_dtls_rest_apiusing_get(
        limitontyp: Optional[int] = None,
        limitonno: Optional[str] = None,
        limitref: Optional[str] = None,
        limitstatus: Optional[str] = None,
        limittyp: Optional[str] = None,
        pagenum: Optional[int] = None,
        pagesize: Optional[int] = None,
        accesstoken: Optional[str] = None,
        channeltype: Optional[int] = None,
        co_relationid: Optional[int] = None,
        initiatingsystem: Optional[str] = None,
        servicemode: Optional[int] = None,
        uuidseqno: Optional[int] = None,
        entity: Optional[str] = None,
        languagecode: Optional[int] = None,
        referenceid: Optional[str] = None,
        userid: Optional[int] = None
    ) -> Dict[str, Any]:
        """
        Fetch Limit
        
        Generated from: GET /riskManagement/limit/details
        Source: swagger_2_0
        Operation ID: RMET2020FtchLmtDtlsRestAPIUsingGET
        
        
        Authentication: Not required
        
        Parameters:
        - LimitOnTyp: integer
          Enter the Limit on Type
        - Limitonno: string
          This indicated different values for different dimension on which limit can be defined as for Account Limit, Account Group and Customer Limit, Customer Refence will be display. and for BP Group and Miscellaneous Group, Group Name will be displayed.
        - Limitref: string
          Unique Reference to identify the limit
        - Limitstatus: string
          Status of the Limit
        - Limittyp: string
          The limit type for which you want to define the limit ( 1. Credit Limit, 9.Overdraft Limit)
        - pageNum: integer
          pageNum
        - pageSize: integer
          pageSize
        
        
        
        Headers:
        - Accesstoken: string
          Authorization Token to validation the caller
        - ChannelType: integer
          Channel identifier from where the transaction has originated (Internet, Mobile, ATM, Branch Channel )
        - Co-Relationid: integer
          Unique ID for the service invoked, will be set by the transaction system
        - InitiatingSystem: string
          Indicating the initiated system
        - ServiceMode: integer
          Used for branch channel to indicate the type of customer
        - UUIDSeqNo: integer
          UUID Sequence Number
        - entity: string
          entity
        - languageCode: integer
          languageCode
        - referenceId: string
          Place holder for Token based authentication
        - userId: integer
          userId
        
        
        """
        
        
        # Prepare query parameters
        params = {}
        if limitontyp is not None:
            params["LimitOnTyp"] = limitontyp
            
        if limitonno is not None:
            params["Limitonno"] = limitonno
            
        if limitref is not None:
            params["Limitref"] = limitref
            
        if limitstatus is not None:
            params["Limitstatus"] = limitstatus
            
        if limittyp is not None:
            params["Limittyp"] = limittyp
            
        if pagenum is not None:
            params["pageNum"] = pagenum
            
        if pagesize is not None:
            params["pageSize"] = pagesize
            
        
        
        # Replace path parameters in URL
        path = "/riskManagement/limit/details"
        
        
        # Prepare headers
        headers = {}
        if accesstoken is not None:
            headers["Accesstoken"] = str(accesstoken)
        if channeltype is not None:
            headers["ChannelType"] = str(channeltype)
        if co_relationid is not None:
            headers["Co-Relationid"] = str(co_relationid)
        if initiatingsystem is not None:
            headers["InitiatingSystem"] = str(initiatingsystem)
        if servicemode is not None:
            headers["ServiceMode"] = str(servicemode)
        if uuidseqno is not None:
            headers["UUIDSeqNo"] = str(uuidseqno)
        if entity is not None:
            headers["entity"] = str(entity)
        if languagecode is not None:
            headers["languageCode"] = str(languagecode)
        if referenceid is not None:
            headers["referenceId"] = str(referenceid)
        if userid is not None:
            headers["userId"] = str(userid)
        
        
        return await make_api_request(
            "GET", 
            path, 
            
            params=params if params else None, 
            headers=headers if headers else None
        )
    
    
    
    @mcp.tool()
    async def rmet1234_get_lmt_dtls_using_get(
        limitid: int,
        accesstoken: Optional[str] = None,
        channeltype: Optional[int] = None,
        co_relationid: Optional[int] = None,
        initiatingsystem: Optional[str] = None,
        servicemode: Optional[int] = None,
        uuidseqno: Optional[int] = None,
        entity: Optional[str] = None,
        languagecode: Optional[int] = None,
        referenceid: Optional[str] = None,
        userid: Optional[int] = None
    ) -> Dict[str, Any]:
        """
        View Limit
        
        Generated from: GET /riskManagement/limit/details/{limitId}
        Source: swagger_2_0
        Operation ID: RMET1234GetLmtDtlsUsingGET
        
        
        Authentication: Not required
        
        Parameters:
        - limitId: integer (required)
          Enter the Limit Reference
        
        
        
        Headers:
        - Accesstoken: string
          Authorization Token to validation the caller
        - ChannelType: integer
          Channel identifier from where the transaction has originated (Internet, Mobile, ATM, Branch Channel )
        - Co-Relationid: integer
          Unique ID for the service invoked, will be set by the transaction system
        - InitiatingSystem: string
          Indicating the initiated system
        - ServiceMode: integer
          Used for branch channel to indicate the type of customer
        - UUIDSeqNo: integer
          UUID Sequence Number
        - entity: string
          entity
        - languageCode: integer
          languageCode
        - referenceId: string
          Place holder for Token based authentication
        - userId: integer
          userId
        
        
        """
        
        
        # Prepare query parameters
        params = {}
        
        
        # Replace path parameters in URL
        path = "/riskManagement/limit/details/{limitId}"
        if limitid is not None:
            path = path.replace("{limitId}", str(limitid))
        
        
        # Prepare headers
        headers = {}
        if accesstoken is not None:
            headers["Accesstoken"] = str(accesstoken)
        if channeltype is not None:
            headers["ChannelType"] = str(channeltype)
        if co_relationid is not None:
            headers["Co-Relationid"] = str(co_relationid)
        if initiatingsystem is not None:
            headers["InitiatingSystem"] = str(initiatingsystem)
        if servicemode is not None:
            headers["ServiceMode"] = str(servicemode)
        if uuidseqno is not None:
            headers["UUIDSeqNo"] = str(uuidseqno)
        if entity is not None:
            headers["entity"] = str(entity)
        if languagecode is not None:
            headers["languageCode"] = str(languagecode)
        if referenceid is not None:
            headers["referenceId"] = str(referenceid)
        if userid is not None:
            headers["userId"] = str(userid)
        
        
        return await make_api_request(
            "GET", 
            path, 
            
            params=params if params else None, 
            headers=headers if headers else None
        )
    
    
    
    @mcp.tool()
    async def rmet026_fetch_lmt_sch_list_using_get(
        accountrefence: Optional[str] = None,
        limitstartdate: Optional[str] = None,
        pagenum: Optional[int] = None,
        pagesize: Optional[int] = None,
        status: Optional[str] = None,
        accesstoken: Optional[str] = None,
        channeltype: Optional[int] = None,
        co_relationid: Optional[int] = None,
        initiatingsystem: Optional[str] = None,
        servicemode: Optional[int] = None,
        uuidseqno: Optional[int] = None,
        entity: Optional[str] = None,
        languagecode: Optional[int] = None,
        referenceid: Optional[str] = None,
        userid: Optional[int] = None
    ) -> Dict[str, Any]:
        """
        Fetch Limit Change Schedules
        
        Generated from: GET /riskManagement/limit/fetchLimitChangeSchedules
        Source: swagger_2_0
        Operation ID: RMET026FetchLmtSchListUsingGET
        
        
        Authentication: Not required
        
        Parameters:
        - accountRefence: string
          IBAN of Account
        - limitStartDate: string
          Start date of Limit(Format:YYYYMMDD)
        - pageNum: integer
          pageNum
        - pageSize: integer
          pageSize
        - status: string
          Status of the Limit Change Schedules( 2-Onhold,4-ExeAwaited,6-Executed,CodeName:d_DDStat)
        
        
        
        Headers:
        - Accesstoken: string
          Authorization token for identification of the caller
        - ChannelType: integer
          Channel identifier from where the TXN has originated (Internet, Mobile, ATM, Branch Channel )
        - Co-Relationid: integer
          Unique ID for the service invoked, will be set by the TXN system
        - InitiatingSystem: string
          Indicating the initiated system
        - ServiceMode: integer
          Used for branch channel to indicate the type of customer
        - UUIDSeqNo: integer
          UUID Sequence Number
        - entity: string
          entity
        - languageCode: integer
          languageCode
        - referenceId: string
          Place holder for Token based authentication
        - userId: integer
          userId
        
        
        """
        
        
        # Prepare query parameters
        params = {}
        if accountrefence is not None:
            params["accountRefence"] = accountrefence
            
        if limitstartdate is not None:
            params["limitStartDate"] = limitstartdate
            
        if pagenum is not None:
            params["pageNum"] = pagenum
            
        if pagesize is not None:
            params["pageSize"] = pagesize
            
        if status is not None:
            params["status"] = status
            
        
        
        # Replace path parameters in URL
        path = "/riskManagement/limit/fetchLimitChangeSchedules"
        
        
        # Prepare headers
        headers = {}
        if accesstoken is not None:
            headers["Accesstoken"] = str(accesstoken)
        if channeltype is not None:
            headers["ChannelType"] = str(channeltype)
        if co_relationid is not None:
            headers["Co-Relationid"] = str(co_relationid)
        if initiatingsystem is not None:
            headers["InitiatingSystem"] = str(initiatingsystem)
        if servicemode is not None:
            headers["ServiceMode"] = str(servicemode)
        if uuidseqno is not None:
            headers["UUIDSeqNo"] = str(uuidseqno)
        if entity is not None:
            headers["entity"] = str(entity)
        if languagecode is not None:
            headers["languageCode"] = str(languagecode)
        if referenceid is not None:
            headers["referenceId"] = str(referenceid)
        if userid is not None:
            headers["userId"] = str(userid)
        
        
        return await make_api_request(
            "GET", 
            path, 
            
            params=params if params else None, 
            headers=headers if headers else None
        )
    
    
    
    @mcp.tool()
    async def cbcbt1504_prnt_utlsd_amt_updtn_postusing_put(
        request_body:Dict[str, Any] ,  # UtilizationAmountUpdateRequest,
        accesstoken: Optional[str] = None,
        channeltype: Optional[int] = None,
        co_relationid: Optional[int] = None,
        initiatingsystem: Optional[str] = None,
        servicemode: Optional[int] = None,
        uuidseqno: Optional[int] = None,
        entity: Optional[str] = None,
        languagecode: Optional[int] = None,
        referenceid: Optional[str] = None,
        userid: Optional[int] = None
    ) -> Dict[str, Any]:
        """
        Update Utilization Amount
        
        Generated from: PUT /riskManagement/limit/utilization
        Source: swagger_2_0
        Operation ID: CBCBT1504PrntUtlsdAmtUpdtn_POSTUsingPUT
        
        
        Authentication: Not required
        
        Parameters:
        - request_body: any (required)
          input
        
        
        
        Headers:
        - Accesstoken: string
          Authorization Token to validation the caller
        - ChannelType: integer
          Channel identifier from where the Transaction has originated (Internet, Mobile, ATM, Branch Channel )
        - Co-Relationid: integer
          Unique ID for the service invoked, will be set by the Transaction system
        - InitiatingSystem: string
          Indicating the initiated system
        - ServiceMode: integer
          Used for branch channel to indicate the type of customer
        - UUIDSeqNo: integer
          UUID Sequence Number
        - entity: string
          entity
        - languageCode: integer
          languageCode
        - referenceId: string
          Place holder for Token based authentication
        - userId: integer
          userId
        
        
        """
        
        
        # Prepare request data
        
        # Single body parameter - send directly
        data = request_body if request_body is not None else {}
        
        
        
        # Prepare query parameters
        params = {}
        
        
        # Replace path parameters in URL
        path = "/riskManagement/limit/utilization"
        
        
        # Prepare headers
        headers = {}
        if accesstoken is not None:
            headers["Accesstoken"] = str(accesstoken)
        if channeltype is not None:
            headers["ChannelType"] = str(channeltype)
        if co_relationid is not None:
            headers["Co-Relationid"] = str(co_relationid)
        if initiatingsystem is not None:
            headers["InitiatingSystem"] = str(initiatingsystem)
        if servicemode is not None:
            headers["ServiceMode"] = str(servicemode)
        if uuidseqno is not None:
            headers["UUIDSeqNo"] = str(uuidseqno)
        if entity is not None:
            headers["entity"] = str(entity)
        if languagecode is not None:
            headers["languageCode"] = str(languagecode)
        if referenceid is not None:
            headers["referenceId"] = str(referenceid)
        if userid is not None:
            headers["userId"] = str(userid)
        
        
        return await make_api_request(
            "PUT", 
            path, 
            data=data, 
            params=params if params else None, 
            headers=headers if headers else None
        )
    
    
    
    @mcp.tool()
    async def rmet2020_fetch_alert_lmt_dtls_using_get(
        customerreference: int,
        pagenum: Optional[int] = None,
        pagesize: Optional[int] = None,
        authorization: Optional[str] = None,
        entity: Optional[str] = None,
        userid: Optional[int] = None
    ) -> Dict[str, Any]:
        """
        This service is used for limit alert
        
        Generated from: GET /riskManagement/limitAlert/{CustomerReference}
        Source: swagger_2_0
        Operation ID: RMET2020FetchAlertLmtDtlsUsingGET
        
        
        Authentication: Not required
        
        Parameters:
        - CustomerReference: integer (required)
          Customer Reference for which limit percentages need to check
        - pageNum: integer
          pageNum
        - pageSize: integer
          pageSize
        
        
        
        Headers:
        - authorization: string
          Authorization Token to validation the caller
        - entity: string
          entity
        - userId: integer
          userId
        
        
        """
        
        
        # Prepare query parameters
        params = {}
        if pagenum is not None:
            params["pageNum"] = pagenum
            
        if pagesize is not None:
            params["pageSize"] = pagesize
            
        
        
        # Replace path parameters in URL
        path = "/riskManagement/limitAlert/{CustomerReference}"
        if customerreference is not None:
            path = path.replace("{CustomerReference}", str(customerreference))
        
        
        # Prepare headers
        headers = {}
        if authorization is not None:
            headers["authorization"] = str(authorization)
        if entity is not None:
            headers["entity"] = str(entity)
        if userid is not None:
            headers["userId"] = str(userid)
        
        
        return await make_api_request(
            "GET", 
            path, 
            
            params=params if params else None, 
            headers=headers if headers else None
        )
    
    
    
    @mcp.tool()
    async def rmbt2025_amendt_lmt_hierarchy_postusing_post(
        request_body:Dict[str, Any] ,  # limitHierarchyMaintainRequest,
        accesstoken: Optional[str] = None,
        channeltype: Optional[int] = None,
        co_relationid: Optional[int] = None,
        initiatingsystem: Optional[str] = None,
        servicemode: Optional[int] = None,
        uuidseqno: Optional[int] = None,
        entity: Optional[str] = None,
        languagecode: Optional[int] = None,
        referenceid: Optional[str] = None,
        userid: Optional[int] = None
    ) -> Dict[str, Any]:
        """
        Amend Hierarchy
        
        Generated from: POST /riskManagement/limitHierarchy/Amend
        Source: swagger_2_0
        Operation ID: RMBT2025AmendtLmtHierarchy_POSTUsingPOST
        
        
        Authentication: Not required
        
        Parameters:
        - request_body: any (required)
          input
        
        
        
        Headers:
        - Accesstoken: string
          Authorization Token to validation the caller
        - ChannelType: integer
          Channel identifier from where the Transaction has originated (Internet, Mobile, ATM, Branch Channel )
        - Co-Relationid: integer
          Unique ID for the service invoked, will be set by the Transaction system
        - InitiatingSystem: string
          Indicating the initiated system
        - ServiceMode: integer
          Used for branch channel to indicate the type of customer
        - UUIDSeqNo: integer
          UUID Sequence Number
        - entity: string
          entity
        - languageCode: integer
          languageCode
        - referenceId: string
          Place holder for Token based authentication
        - userId: integer
          userId
        
        
        """
        
        
        # Prepare request data
        
        # Single body parameter - send directly
        data = request_body if request_body is not None else {}
        
        
        
        # Prepare query parameters
        params = {}
        
        
        # Replace path parameters in URL
        path = "/riskManagement/limitHierarchy/Amend"
        
        
        # Prepare headers
        headers = {}
        if accesstoken is not None:
            headers["Accesstoken"] = str(accesstoken)
        if channeltype is not None:
            headers["ChannelType"] = str(channeltype)
        if co_relationid is not None:
            headers["Co-Relationid"] = str(co_relationid)
        if initiatingsystem is not None:
            headers["InitiatingSystem"] = str(initiatingsystem)
        if servicemode is not None:
            headers["ServiceMode"] = str(servicemode)
        if uuidseqno is not None:
            headers["UUIDSeqNo"] = str(uuidseqno)
        if entity is not None:
            headers["entity"] = str(entity)
        if languagecode is not None:
            headers["languageCode"] = str(languagecode)
        if referenceid is not None:
            headers["referenceId"] = str(referenceid)
        if userid is not None:
            headers["userId"] = str(userid)
        
        
        return await make_api_request(
            "POST", 
            path, 
            data=data, 
            params=params if params else None, 
            headers=headers if headers else None
        )
    
    
    
    @mcp.tool()
    async def rmbt2023_create_limit_hierarchy_postusing_post(
        request_body:Dict[str, Any] ,  # limitHierarchyRequest,
        accesstoken: Optional[str] = None,
        channeltype: Optional[int] = None,
        co_relationid: Optional[int] = None,
        initiatingsystem: Optional[str] = None,
        servicemode: Optional[int] = None,
        uuidseqno: Optional[int] = None,
        entity: Optional[str] = None,
        languagecode: Optional[int] = None,
        referenceid: Optional[str] = None,
        requesthash: Optional[str] = None,
        userid: Optional[int] = None
    ) -> Dict[str, Any]:
        """
        Create Limit Hierarchy
        
        Generated from: POST /riskManagement/limitHierarchy/Create
        Source: swagger_2_0
        Operation ID: RMBT2023CreateLimitHierarchy_POSTUsingPOST
        
        
        Authentication: Not required
        
        Parameters:
        - request_body: any (required)
          input
        
        
        
        Headers:
        - Accesstoken: string
          Authorization Token to validation the caller
        - ChannelType: integer
          Channel identifier from where the Transaction has originated (Internet, Mobile, ATM, Branch Channel )
        - Co-Relationid: integer
          Unique ID for the service invoked, will be set by the Transaction system
        - InitiatingSystem: string
          Indicating the initiated system
        - ServiceMode: integer
          Used for branch channel to indicate the type of customer
        - UUIDSeqNo: integer
          UUID Sequence Number
        - entity: string
          entity
        - languageCode: integer
          languageCode
        - referenceId: string
          Place holder for Token based authentication
        - requesthash: string
          Request payload for hash validation
        - userId: integer
          userId
        
        
        """
        
        
        # Prepare request data
        
        # Single body parameter - send directly
        data = request_body if request_body is not None else {}
        
        
        
        # Prepare query parameters
        params = {}
        
        
        # Replace path parameters in URL
        path = "/riskManagement/limitHierarchy/Create"
        
        
        # Prepare headers
        headers = {}
        if accesstoken is not None:
            headers["Accesstoken"] = str(accesstoken)
        if channeltype is not None:
            headers["ChannelType"] = str(channeltype)
        if co_relationid is not None:
            headers["Co-Relationid"] = str(co_relationid)
        if initiatingsystem is not None:
            headers["InitiatingSystem"] = str(initiatingsystem)
        if servicemode is not None:
            headers["ServiceMode"] = str(servicemode)
        if uuidseqno is not None:
            headers["UUIDSeqNo"] = str(uuidseqno)
        if entity is not None:
            headers["entity"] = str(entity)
        if languagecode is not None:
            headers["languageCode"] = str(languagecode)
        if referenceid is not None:
            headers["referenceId"] = str(referenceid)
        if requesthash is not None:
            headers["requesthash"] = str(requesthash)
        if userid is not None:
            headers["userId"] = str(userid)
        
        
        return await make_api_request(
            "POST", 
            path, 
            data=data, 
            params=params if params else None, 
            headers=headers if headers else None
        )
    
    
    
    @mcp.tool()
    async def rmet2024_fetch_limit_hierarchy_postusing_get(
        externalrootlimitreference: Optional[int] = None,
        limitonreference: Optional[str] = None,
        limitontype: Optional[int] = None,
        rootlimitreference: Optional[int] = None,
        accesstoken: Optional[str] = None,
        channeltype: Optional[int] = None,
        co_relationid: Optional[int] = None,
        initiatingsystem: Optional[str] = None,
        servicemode: Optional[int] = None,
        uuidseqno: Optional[int] = None,
        entity: Optional[str] = None,
        languagecode: Optional[int] = None,
        referenceid: Optional[str] = None,
        userid: Optional[int] = None
    ) -> Dict[str, Any]:
        """
        Fetch Limit Hierarchy
        
        Generated from: GET /riskManagement/limitHierarchy/Fetch
        Source: swagger_2_0
        Operation ID: RMET2024FetchLimitHierarchy_POSTUsingGET
        
        
        Authentication: Not required
        
        Parameters:
        - externalRootLimitReference: integer
          External system root limit reference
        - limitOnReference: string
          Value of the limit. e.g. BBAN for the Account limit, BpId for the Customer limit, Group Name for the account group and Customer Group.
        - limitOnType: integer
          Indicates whether you want to define limits on a single entity or on a group(1-Customer/Member Limit,2-Customer Group Limit,3-Misc Group limit,4-Account Limit,5-Account Group Limit) 
        - rootLimitReference: integer
          External system limit reference
        
        
        
        Headers:
        - Accesstoken: string
          Authorization Token to validation the caller
        - ChannelType: integer
          Channel identifier from where the Transaction has originated (Internet, Mobile, ATM, Branch Channel )
        - Co-Relationid: integer
          Unique ID for the service invoked, will be set by the Transaction system
        - InitiatingSystem: string
          Indicating the initiated system
        - ServiceMode: integer
          Used for branch channel to indicate the type of customer
        - UUIDSeqNo: integer
          UUID Sequence Number
        - entity: string
          entity
        - languageCode: integer
          languageCode
        - referenceId: string
          Place holder for Token based authentication
        - userId: integer
          userId
        
        
        """
        
        
        # Prepare query parameters
        params = {}
        if externalrootlimitreference is not None:
            params["externalRootLimitReference"] = externalrootlimitreference
            
        if limitonreference is not None:
            params["limitOnReference"] = limitonreference
            
        if limitontype is not None:
            params["limitOnType"] = limitontype
            
        if rootlimitreference is not None:
            params["rootLimitReference"] = rootlimitreference
            
        
        
        # Replace path parameters in URL
        path = "/riskManagement/limitHierarchy/Fetch"
        
        
        # Prepare headers
        headers = {}
        if accesstoken is not None:
            headers["Accesstoken"] = str(accesstoken)
        if channeltype is not None:
            headers["ChannelType"] = str(channeltype)
        if co_relationid is not None:
            headers["Co-Relationid"] = str(co_relationid)
        if initiatingsystem is not None:
            headers["InitiatingSystem"] = str(initiatingsystem)
        if servicemode is not None:
            headers["ServiceMode"] = str(servicemode)
        if uuidseqno is not None:
            headers["UUIDSeqNo"] = str(uuidseqno)
        if entity is not None:
            headers["entity"] = str(entity)
        if languagecode is not None:
            headers["languageCode"] = str(languagecode)
        if referenceid is not None:
            headers["referenceId"] = str(referenceid)
        if userid is not None:
            headers["userId"] = str(userid)
        
        
        return await make_api_request(
            "GET", 
            path, 
            
            params=params if params else None, 
            headers=headers if headers else None
        )
    
    
    
    @mcp.tool()
    async def rmetget_multiple_acnt_bal_postusing_post(
        request_body:Dict[str, Any] ,  # RM_Performance_RMETGetMultipleAcntBal_Resource,
        entity: Optional[str] = None
    ) -> Dict[str, Any]:
        """
        RMETGetMultipleAcntBal
        
        Generated from: POST /riskManagement/rmetgetmultipleacntbal
        Source: swagger_2_0
        Operation ID: RMETGetMultipleAcntBal_POSTUsingPOST
        
        
        Authentication: Not required
        
        Parameters:
        - request_body: any (required)
          input
        
        
        
        Headers:
        - entity: string
          entity
        
        
        """
        
        
        # Prepare request data
        
        # Single body parameter - send directly
        data = request_body if request_body is not None else {}
        
        
        
        # Prepare query parameters
        params = {}
        
        
        # Replace path parameters in URL
        path = "/riskManagement/rmetgetmultipleacntbal"
        
        
        # Prepare headers
        headers = {}
        if entity is not None:
            headers["entity"] = str(entity)
        
        
        return await make_api_request(
            "POST", 
            path, 
            data=data, 
            params=params if params else None, 
            headers=headers if headers else None
        )
    
    
    
    @mcp.tool()
    async def rmet6388_ftch_adhoc_limit_hstry_postusing_get(
        limitid: Optional[int] = None,
        accesstoken: Optional[str] = None,
        channeltype: Optional[int] = None,
        co_relationid: Optional[int] = None,
        initiatingsystem: Optional[str] = None,
        servicemode: Optional[int] = None,
        uuidseqno: Optional[int] = None,
        entity: Optional[str] = None,
        languagecode: Optional[int] = None,
        referenceid: Optional[str] = None,
        userid: Optional[int] = None
    ) -> Dict[str, Any]:
        """
        This API is to fetch the modification of seasonal limit details
        
        Generated from: GET /riskManagement/seasonalLimit/history/view
        Source: swagger_2_0
        Operation ID: RMET6388FtchAdhocLimitHstry_POSTUsingGET
        
        
        Authentication: Not required
        
        Parameters:
        - limitId: integer
          Limit Id of the modified limit
        
        
        
        Headers:
        - Accesstoken: string
          Authorization token for identification of the caller
        - ChannelType: integer
          Channel identifier from where the TXN has originated (Internet, Mobile, ATM, Branch Channel )
        - Co-Relationid: integer
          Unique ID for the service invoked, will be set by the TXN system
        - InitiatingSystem: string
          Indicating the initiated system
        - ServiceMode: integer
          Used for branch channel to indicate the type of customer
        - UUIDSeqNo: integer
          UUID Sequence Number
        - entity: string
          entity
        - languageCode: integer
          languageCode
        - referenceId: string
          Place holder for Token based authentication
        - userId: integer
          userId
        
        
        """
        
        
        # Prepare query parameters
        params = {}
        if limitid is not None:
            params["limitId"] = limitid
            
        
        
        # Replace path parameters in URL
        path = "/riskManagement/seasonalLimit/history/view"
        
        
        # Prepare headers
        headers = {}
        if accesstoken is not None:
            headers["Accesstoken"] = str(accesstoken)
        if channeltype is not None:
            headers["ChannelType"] = str(channeltype)
        if co_relationid is not None:
            headers["Co-Relationid"] = str(co_relationid)
        if initiatingsystem is not None:
            headers["InitiatingSystem"] = str(initiatingsystem)
        if servicemode is not None:
            headers["ServiceMode"] = str(servicemode)
        if uuidseqno is not None:
            headers["UUIDSeqNo"] = str(uuidseqno)
        if entity is not None:
            headers["entity"] = str(entity)
        if languagecode is not None:
            headers["languageCode"] = str(languagecode)
        if referenceid is not None:
            headers["referenceId"] = str(referenceid)
        if userid is not None:
            headers["userId"] = str(userid)
        
        
        return await make_api_request(
            "GET", 
            path, 
            
            params=params if params else None, 
            headers=headers if headers else None
        )
    
    
    
    @mcp.tool()
    async def msbt6478_bulk_share_printing_postusing_post(
        request_body:Dict[str, Any] ,  # bulkSharePrintingResource,
        accesstoken: Optional[str] = None,
        channeltype: Optional[int] = None,
        co_relationid: Optional[int] = None,
        initiatingsystem: Optional[str] = None,
        servicemode: Optional[int] = None,
        uuidseqno: Optional[int] = None,
        entity: Optional[str] = None,
        languagecode: Optional[int] = None,
        referenceid: Optional[str] = None,
        requesthash: Optional[str] = None,
        userid: Optional[int] = None
    ) -> Dict[str, Any]:
        """
        Bluk printing of shares
        
        Generated from: POST /shareManagement/bulkshareprint
        Source: swagger_2_0
        Operation ID: MSBT6478BulkSharePrinting_POSTUsingPOST
        
        
        Authentication: Not required
        
        Parameters:
        - request_body: any (required)
          input
        
        
        
        Headers:
        - Accesstoken: string
          Authorization token for identification of the caller
        - ChannelType: integer
          Channel identifier from where the TXN has originated (Internet, Mobile, ATM, Branch Channel )
        - Co-Relationid: integer
          Unique ID for the service invoked, will be set by the TXN system
        - InitiatingSystem: string
          Indicating the initiated system
        - ServiceMode: integer
          Used for branch channel to indicate the type of customer
        - UUIDSeqNo: integer
          UUID Sequence Number
        - entity: string
          entity
        - languageCode: integer
          languageCode
        - referenceId: string
          Place holder for Token based authentication
        - requesthash: string
          Request payload for hash validation
        - userId: integer
          userId
        
        
        """
        
        
        # Prepare request data
        
        # Single body parameter - send directly
        data = request_body if request_body is not None else {}
        
        
        
        # Prepare query parameters
        params = {}
        
        
        # Replace path parameters in URL
        path = "/shareManagement/bulkshareprint"
        
        
        # Prepare headers
        headers = {}
        if accesstoken is not None:
            headers["Accesstoken"] = str(accesstoken)
        if channeltype is not None:
            headers["ChannelType"] = str(channeltype)
        if co_relationid is not None:
            headers["Co-Relationid"] = str(co_relationid)
        if initiatingsystem is not None:
            headers["InitiatingSystem"] = str(initiatingsystem)
        if servicemode is not None:
            headers["ServiceMode"] = str(servicemode)
        if uuidseqno is not None:
            headers["UUIDSeqNo"] = str(uuidseqno)
        if entity is not None:
            headers["entity"] = str(entity)
        if languagecode is not None:
            headers["languageCode"] = str(languagecode)
        if referenceid is not None:
            headers["referenceId"] = str(referenceid)
        if requesthash is not None:
            headers["requesthash"] = str(requesthash)
        if userid is not None:
            headers["userId"] = str(userid)
        
        
        return await make_api_request(
            "POST", 
            path, 
            data=data, 
            params=params if params else None, 
            headers=headers if headers else None
        )
    
    
    
    @mcp.tool()
    async def elcbt5993_incmng_swft_postusing_post(
        request_body:Dict[str, Any] ,  # ELC_BILL_LODGEMENT_ELCBT5993IncmngSwft_Resource
    ) -> Dict[str, Any]:
        """
        ELCBT5993IncmngSwft
        
        Generated from: POST /shareManagement/elcbt5993incmngswft
        Source: swagger_2_0
        Operation ID: ELCBT5993IncmngSwft_POSTUsingPOST
        
        
        Authentication: Not required
        
        Parameters:
        - request_body: any (required)
          input
        
        
        
        """
        
        
        # Prepare request data
        
        # Single body parameter - send directly
        data = request_body if request_body is not None else {}
        
        
        
        # Prepare query parameters
        params = {}
        
        
        # Replace path parameters in URL
        path = "/shareManagement/elcbt5993incmngswft"
        
        
        # Prepare headers
        headers = {}
        
        
        return await make_api_request(
            "POST", 
            path, 
            data=data, 
            params=params if params else None, 
            headers=headers if headers else None
        )
    
    
    
    @mcp.tool()
    async def mset6372_fetch_share_bglcdetails_postusing_get(
        customerref: Optional[int] = None,
        accesstoken: Optional[str] = None,
        channeltype: Optional[int] = None,
        co_relationid: Optional[int] = None,
        initiatingsystem: Optional[str] = None,
        servicemode: Optional[int] = None,
        uuidseqno: Optional[int] = None,
        entity: Optional[str] = None,
        languagecode: Optional[int] = None,
        referenceid: Optional[str] = None,
        userid: Optional[int] = None
    ) -> Dict[str, Any]:
        """
        fetchShareBglc
        
        Generated from: GET /shareManagement/fetch/bglcDetails
        Source: swagger_2_0
        Operation ID: MSET6372FetchShareBGLCDetails_POSTUsingGET
        
        
        Authentication: Not required
        
        Parameters:
        - customerRef: integer
          Customer Reference
        
        
        
        Headers:
        - Accesstoken: string
          Authorization token for identification of the caller
        - ChannelType: integer
          Channel identifier from where the TXN has originated (Internet, Mobile, ATM, Branch Channel )
        - Co-Relationid: integer
          Unique ID for the service invoked, will be set by the TXN system
        - InitiatingSystem: string
          Indicating the initiated system
        - ServiceMode: integer
          Used for branch channel to indicate the type of customer
        - UUIDSeqNo: integer
          UUID Sequence Number
        - entity: string
          entity
        - languageCode: integer
          languageCode
        - referenceId: string
          Place holder for Token based authentication
        - userId: integer
          userId
        
        
        """
        
        
        # Prepare query parameters
        params = {}
        if customerref is not None:
            params["customerRef"] = customerref
            
        
        
        # Replace path parameters in URL
        path = "/shareManagement/fetch/bglcDetails"
        
        
        # Prepare headers
        headers = {}
        if accesstoken is not None:
            headers["Accesstoken"] = str(accesstoken)
        if channeltype is not None:
            headers["ChannelType"] = str(channeltype)
        if co_relationid is not None:
            headers["Co-Relationid"] = str(co_relationid)
        if initiatingsystem is not None:
            headers["InitiatingSystem"] = str(initiatingsystem)
        if servicemode is not None:
            headers["ServiceMode"] = str(servicemode)
        if uuidseqno is not None:
            headers["UUIDSeqNo"] = str(uuidseqno)
        if entity is not None:
            headers["entity"] = str(entity)
        if languagecode is not None:
            headers["languageCode"] = str(languagecode)
        if referenceid is not None:
            headers["referenceId"] = str(referenceid)
        if userid is not None:
            headers["userId"] = str(userid)
        
        
        return await make_api_request(
            "GET", 
            path, 
            
            params=params if params else None, 
            headers=headers if headers else None
        )
    
    
    
    @mcp.tool()
    async def mset6372_fetch_share_liability_postusing_get(
        accountrefernce: Optional[int] = None,
        accesstoken: Optional[str] = None,
        channeltype: Optional[int] = None,
        co_relationid: Optional[int] = None,
        initiatingsystem: Optional[str] = None,
        servicemode: Optional[int] = None,
        uuidseqno: Optional[int] = None,
        entity: Optional[str] = None,
        languagecode: Optional[int] = None,
        referenceid: Optional[str] = None,
        userid: Optional[int] = None
    ) -> Dict[str, Any]:
        """
        fetchShareLiability
        
        Generated from: GET /shareManagement/fetch/liability
        Source: swagger_2_0
        Operation ID: MSET6372FetchShareLiability_POSTUsingGET
        
        
        Authentication: Not required
        
        Parameters:
        - accountRefernce: integer
          BP_ID
        
        
        
        Headers:
        - Accesstoken: string
          Authorization token for identification of the caller
        - ChannelType: integer
          Channel identifier from where the TXN has originated (Internet, Mobile, ATM, Branch Channel )
        - Co-Relationid: integer
          Unique ID for the service invoked, will be set by the TXN system
        - InitiatingSystem: string
          Indicating the initiated system
        - ServiceMode: integer
          Used for branch channel to indicate the type of customer
        - UUIDSeqNo: integer
          UUID Sequence Number
        - entity: string
          entity
        - languageCode: integer
          languageCode
        - referenceId: string
          Place holder for Token based authentication
        - userId: integer
          userId
        
        
        """
        
        
        # Prepare query parameters
        params = {}
        if accountrefernce is not None:
            params["accountRefernce"] = accountrefernce
            
        
        
        # Replace path parameters in URL
        path = "/shareManagement/fetch/liability"
        
        
        # Prepare headers
        headers = {}
        if accesstoken is not None:
            headers["Accesstoken"] = str(accesstoken)
        if channeltype is not None:
            headers["ChannelType"] = str(channeltype)
        if co_relationid is not None:
            headers["Co-Relationid"] = str(co_relationid)
        if initiatingsystem is not None:
            headers["InitiatingSystem"] = str(initiatingsystem)
        if servicemode is not None:
            headers["ServiceMode"] = str(servicemode)
        if uuidseqno is not None:
            headers["UUIDSeqNo"] = str(uuidseqno)
        if entity is not None:
            headers["entity"] = str(entity)
        if languagecode is not None:
            headers["languageCode"] = str(languagecode)
        if referenceid is not None:
            headers["referenceId"] = str(referenceid)
        if userid is not None:
            headers["userId"] = str(userid)
        
        
        return await make_api_request(
            "GET", 
            path, 
            
            params=params if params else None, 
            headers=headers if headers else None
        )
    
    
    
    @mcp.tool()
    async def mset2023_dividend_history_postusing_get(
        bpid: Optional[int] = None,
        accesstoken: Optional[str] = None,
        channeltype: Optional[int] = None,
        co_relationid: Optional[int] = None,
        initiatingsystem: Optional[str] = None,
        servicemode: Optional[int] = None,
        uuidseqno: Optional[int] = None,
        entity: Optional[str] = None,
        languagecode: Optional[int] = None,
        referenceid: Optional[str] = None,
        userid: Optional[int] = None
    ) -> Dict[str, Any]:
        """
        Dividend History
        
        Generated from: GET /shareManagement/member/list
        Source: swagger_2_0
        Operation ID: MSET2023DividendHistory_POSTUsingGET
        
        
        Authentication: Not required
        
        Parameters:
        - bpId: integer
          BP_ID
        
        
        
        Headers:
        - Accesstoken: string
          Authorization token for identification of the caller
        - ChannelType: integer
          Channel identifier from where the TXN has originated (Internet, Mobile, ATM, Branch Channel )
        - Co-Relationid: integer
          Unique ID for the service invoked, will be set by the TXN system
        - InitiatingSystem: string
          Indicating the initiated system
        - ServiceMode: integer
          Used for branch channel to indicate the type of customer
        - UUIDSeqNo: integer
          UUID Sequence Number
        - entity: string
          entity
        - languageCode: integer
          languageCode
        - referenceId: string
          Place holder for Token based authentication
        - userId: integer
          userId
        
        
        """
        
        
        # Prepare query parameters
        params = {}
        if bpid is not None:
            params["bpId"] = bpid
            
        
        
        # Replace path parameters in URL
        path = "/shareManagement/member/list"
        
        
        # Prepare headers
        headers = {}
        if accesstoken is not None:
            headers["Accesstoken"] = str(accesstoken)
        if channeltype is not None:
            headers["ChannelType"] = str(channeltype)
        if co_relationid is not None:
            headers["Co-Relationid"] = str(co_relationid)
        if initiatingsystem is not None:
            headers["InitiatingSystem"] = str(initiatingsystem)
        if servicemode is not None:
            headers["ServiceMode"] = str(servicemode)
        if uuidseqno is not None:
            headers["UUIDSeqNo"] = str(uuidseqno)
        if entity is not None:
            headers["entity"] = str(entity)
        if languagecode is not None:
            headers["languageCode"] = str(languagecode)
        if referenceid is not None:
            headers["referenceId"] = str(referenceid)
        if userid is not None:
            headers["userId"] = str(userid)
        
        
        return await make_api_request(
            "GET", 
            path, 
            
            params=params if params else None, 
            headers=headers if headers else None
        )
    
    
    
    @mcp.tool()
    async def msbt2022_mmbr_bulk_appr_bsd_on_srch_postusing_post(
        request_body:Dict[str, Any] ,  # mmbrBulkApprBsdOnSrchResource,
        branchid: Optional[int] = None,
        accesstoken: Optional[str] = None,
        channeltype: Optional[int] = None,
        co_relationid: Optional[int] = None,
        initiatingsystem: Optional[str] = None,
        servicemode: Optional[int] = None,
        uuidseqno: Optional[int] = None,
        entity: Optional[str] = None,
        languagecode: Optional[int] = None,
        referenceid: Optional[str] = None,
        requesthash: Optional[str] = None,
        userid: Optional[int] = None
    ) -> Dict[str, Any]:
        """
        Member Application Bulk Approval Process
        
        Generated from: POST /shareManagement/memberApplication/blukApproval/approvalProcess
        Source: swagger_2_0
        Operation ID: MSBT2022MmbrBulkApprBsdOnSrch_POSTUsingPOST
        
        
        Authentication: Not required
        
        Parameters:
        - branchId: integer
          Branch ID
        - request_body: any (required)
          input
        
        
        
        Headers:
        - Accesstoken: string
          Authorization token for identification of the caller
        - ChannelType: integer
          Channel identifier from where the TXN has originated (Internet, Mobile, ATM, Branch Channel )
        - Co-Relationid: integer
          Unique ID for the service invoked, will be set by the TXN system
        - InitiatingSystem: string
          Indicating the initiated system
        - ServiceMode: integer
          Used for branch channel to indicate the type of customer
        - UUIDSeqNo: integer
          UUID Sequence Number
        - entity: string
          entity
        - languageCode: integer
          languageCode
        - referenceId: string
          Place holder for Token based authentication
        - requesthash: string
          Request payload for hash validation
        - userId: integer
          userId
        
        
        """
        
        
        # Prepare request data
        
        # Single body parameter - send directly
        data = request_body if request_body is not None else {}
        
        
        
        # Prepare query parameters
        params = {}
        if branchid is not None:
            params["branchId"] = branchid
            
        
        
        # Replace path parameters in URL
        path = "/shareManagement/memberApplication/blukApproval/approvalProcess"
        
        
        # Prepare headers
        headers = {}
        if accesstoken is not None:
            headers["Accesstoken"] = str(accesstoken)
        if channeltype is not None:
            headers["ChannelType"] = str(channeltype)
        if co_relationid is not None:
            headers["Co-Relationid"] = str(co_relationid)
        if initiatingsystem is not None:
            headers["InitiatingSystem"] = str(initiatingsystem)
        if servicemode is not None:
            headers["ServiceMode"] = str(servicemode)
        if uuidseqno is not None:
            headers["UUIDSeqNo"] = str(uuidseqno)
        if entity is not None:
            headers["entity"] = str(entity)
        if languagecode is not None:
            headers["languageCode"] = str(languagecode)
        if referenceid is not None:
            headers["referenceId"] = str(referenceid)
        if requesthash is not None:
            headers["requesthash"] = str(requesthash)
        if userid is not None:
            headers["userId"] = str(userid)
        
        
        return await make_api_request(
            "POST", 
            path, 
            data=data, 
            params=params if params else None, 
            headers=headers if headers else None
        )
    
    
    
    @mcp.tool()
    async def mset2022_mmbr_bulkcount_postusing_get(
        applicationfromdate: Optional[str] = None,
        applicationtodate: Optional[str] = None,
        applicationtype: Optional[int] = None,
        approvaltype: Optional[int] = None,
        branchid: Optional[int] = None,
        closuretype: Optional[int] = None,
        count: Optional[int] = None,
        meetingdate: Optional[str] = None,
        meetingid: Optional[int] = None,
        membertype: Optional[int] = None,
        status: Optional[int] = None,
        accesstoken: Optional[str] = None,
        channeltype: Optional[int] = None,
        co_relationid: Optional[int] = None,
        initiatingsystem: Optional[str] = None,
        servicemode: Optional[int] = None,
        uuidseqno: Optional[int] = None,
        entity: Optional[str] = None,
        languagecode: Optional[int] = None,
        referenceid: Optional[str] = None,
        userid: Optional[int] = None
    ) -> Dict[str, Any]:
        """
        Member Bulk Count
        
        Generated from: GET /shareManagement/memberApplication/blukApproval/count
        Source: swagger_2_0
        Operation ID: MSET2022MmbrBulkcount_POSTUsingGET
        
        
        Authentication: Not required
        
        Parameters:
        - applicationFromDate: string
          Application From Date
        - applicationToDate: string
          Application To Date
        - applicationType: integer
          Application Type
        - approvalType: integer
          Approval Type
        - branchID: integer
          BRANCH ID
        - closureType: integer
          Closure Type
        - count: integer
          Count
        - meetingDate: string
          Meeting Date
        - meetingId: integer
          Meeting ID
        - memberType: integer
          Member Type
        - status: integer
          Status
        
        
        
        Headers:
        - Accesstoken: string
          Authorization token for identification of the caller
        - ChannelType: integer
          Channel identifier from where the TXN has originated (Internet, Mobile, ATM, Branch Channel )
        - Co-Relationid: integer
          Unique ID for the service invoked, will be set by the TXN system
        - InitiatingSystem: string
          Indicating the initiated system
        - ServiceMode: integer
          Used for branch channel to indicate the type of customer
        - UUIDSeqNo: integer
          UUID Sequence Number
        - entity: string
          entity
        - languageCode: integer
          languageCode
        - referenceId: string
          Place holder for Token based authentication
        - userId: integer
          userId
        
        
        """
        
        
        # Prepare query parameters
        params = {}
        if applicationfromdate is not None:
            params["applicationFromDate"] = applicationfromdate
            
        if applicationtodate is not None:
            params["applicationToDate"] = applicationtodate
            
        if applicationtype is not None:
            params["applicationType"] = applicationtype
            
        if approvaltype is not None:
            params["approvalType"] = approvaltype
            
        if branchid is not None:
            params["branchID"] = branchid
            
        if closuretype is not None:
            params["closureType"] = closuretype
            
        if count is not None:
            params["count"] = count
            
        if meetingdate is not None:
            params["meetingDate"] = meetingdate
            
        if meetingid is not None:
            params["meetingId"] = meetingid
            
        if membertype is not None:
            params["memberType"] = membertype
            
        if status is not None:
            params["status"] = status
            
        
        
        # Replace path parameters in URL
        path = "/shareManagement/memberApplication/blukApproval/count"
        
        
        # Prepare headers
        headers = {}
        if accesstoken is not None:
            headers["Accesstoken"] = str(accesstoken)
        if channeltype is not None:
            headers["ChannelType"] = str(channeltype)
        if co_relationid is not None:
            headers["Co-Relationid"] = str(co_relationid)
        if initiatingsystem is not None:
            headers["InitiatingSystem"] = str(initiatingsystem)
        if servicemode is not None:
            headers["ServiceMode"] = str(servicemode)
        if uuidseqno is not None:
            headers["UUIDSeqNo"] = str(uuidseqno)
        if entity is not None:
            headers["entity"] = str(entity)
        if languagecode is not None:
            headers["languageCode"] = str(languagecode)
        if referenceid is not None:
            headers["referenceId"] = str(referenceid)
        if userid is not None:
            headers["userId"] = str(userid)
        
        
        return await make_api_request(
            "GET", 
            path, 
            
            params=params if params else None, 
            headers=headers if headers else None
        )
    
    
    
    @mcp.tool()
    async def msbt2022_member_app_bulk_appr_postusing_post(
        request_body:Dict[str, Any] ,  # approveBulkMemberApplicationResource,
        accesstoken: Optional[str] = None,
        channeltype: Optional[int] = None,
        co_relationid: Optional[int] = None,
        initiatingsystem: Optional[str] = None,
        servicemode: Optional[int] = None,
        uuidseqno: Optional[int] = None,
        entity: Optional[str] = None,
        languagecode: Optional[int] = None,
        referenceid: Optional[str] = None,
        requesthash: Optional[str] = None,
        userid: Optional[int] = None
    ) -> Dict[str, Any]:
        """
        Approve Bulk Member Application
        
        Generated from: POST /shareManagement/memberApplication/bulkApproval
        Source: swagger_2_0
        Operation ID: MSBT2022MemberAppBulkAppr_POSTUsingPOST
        
        
        Authentication: Not required
        
        Parameters:
        - request_body: any (required)
          input
        
        
        
        Headers:
        - Accesstoken: string
          Authorization token for identification of the caller
        - ChannelType: integer
          Channel identifier from where the TXN has originated (Internet, Mobile, ATM, Branch Channel )
        - Co-Relationid: integer
          Unique ID for the service invoked, will be set by the TXN system
        - InitiatingSystem: string
          Indicating the initiated system
        - ServiceMode: integer
          Used for branch channel to indicate the type of customer
        - UUIDSeqNo: integer
          UUID Sequence Number
        - entity: string
          entity
        - languageCode: integer
          languageCode
        - referenceId: string
          Place holder for Token based authentication
        - requesthash: string
          Request payload for hash validation
        - userId: integer
          userId
        
        
        """
        
        
        # Prepare request data
        
        # Single body parameter - send directly
        data = request_body if request_body is not None else {}
        
        
        
        # Prepare query parameters
        params = {}
        
        
        # Replace path parameters in URL
        path = "/shareManagement/memberApplication/bulkApproval"
        
        
        # Prepare headers
        headers = {}
        if accesstoken is not None:
            headers["Accesstoken"] = str(accesstoken)
        if channeltype is not None:
            headers["ChannelType"] = str(channeltype)
        if co_relationid is not None:
            headers["Co-Relationid"] = str(co_relationid)
        if initiatingsystem is not None:
            headers["InitiatingSystem"] = str(initiatingsystem)
        if servicemode is not None:
            headers["ServiceMode"] = str(servicemode)
        if uuidseqno is not None:
            headers["UUIDSeqNo"] = str(uuidseqno)
        if entity is not None:
            headers["entity"] = str(entity)
        if languagecode is not None:
            headers["languageCode"] = str(languagecode)
        if referenceid is not None:
            headers["referenceId"] = str(referenceid)
        if requesthash is not None:
            headers["requesthash"] = str(requesthash)
        if userid is not None:
            headers["userId"] = str(userid)
        
        
        return await make_api_request(
            "POST", 
            path, 
            data=data, 
            params=params if params else None, 
            headers=headers if headers else None
        )
    
    
    
    @mcp.tool()
    async def msbt6225_surren_req_crtn_postusing_post(
        request_body:Dict[str, Any] ,  # surrenReqCrtnResource,
        accesstoken: Optional[str] = None,
        channeltype: Optional[int] = None,
        co_relationid: Optional[int] = None,
        initiatingsystem: Optional[str] = None,
        servicemode: Optional[int] = None,
        uuidseqno: Optional[int] = None,
        entity: Optional[str] = None,
        languagecode: Optional[int] = None,
        referenceid: Optional[str] = None,
        requesthash: Optional[str] = None,
        userid: Optional[int] = None
    ) -> Dict[str, Any]:
        """
        Surrender Request
        
        Generated from: POST /shareManagement/memberApplication/surrenderRequest
        Source: swagger_2_0
        Operation ID: MSBT6225SurrenReqCrtn_POSTUsingPOST
        
        
        Authentication: Not required
        
        Parameters:
        - request_body: any (required)
          input
        
        
        
        Headers:
        - Accesstoken: string
          Authorization token for identification of the caller
        - ChannelType: integer
          Channel identifier from where the TXN has originated (Internet, Mobile, ATM, Branch Channel )
        - Co-Relationid: integer
          Unique ID for the service invoked, will be set by the TXN system
        - InitiatingSystem: string
          Indicating the initiated system
        - ServiceMode: integer
          Used for branch channel to indicate the type of customer
        - UUIDSeqNo: integer
          UUID Sequence Number
        - entity: string
          entity
        - languageCode: integer
          languageCode
        - referenceId: string
          Place holder for Token based authentication
        - requesthash: string
          Request payload for hash validation
        - userId: integer
          userId
        
        
        """
        
        
        # Prepare request data
        
        # Single body parameter - send directly
        data = request_body if request_body is not None else {}
        
        
        
        # Prepare query parameters
        params = {}
        
        
        # Replace path parameters in URL
        path = "/shareManagement/memberApplication/surrenderRequest"
        
        
        # Prepare headers
        headers = {}
        if accesstoken is not None:
            headers["Accesstoken"] = str(accesstoken)
        if channeltype is not None:
            headers["ChannelType"] = str(channeltype)
        if co_relationid is not None:
            headers["Co-Relationid"] = str(co_relationid)
        if initiatingsystem is not None:
            headers["InitiatingSystem"] = str(initiatingsystem)
        if servicemode is not None:
            headers["ServiceMode"] = str(servicemode)
        if uuidseqno is not None:
            headers["UUIDSeqNo"] = str(uuidseqno)
        if entity is not None:
            headers["entity"] = str(entity)
        if languagecode is not None:
            headers["languageCode"] = str(languagecode)
        if referenceid is not None:
            headers["referenceId"] = str(referenceid)
        if requesthash is not None:
            headers["requesthash"] = str(requesthash)
        if userid is not None:
            headers["userId"] = str(userid)
        
        
        return await make_api_request(
            "POST", 
            path, 
            data=data, 
            params=params if params else None, 
            headers=headers if headers else None
        )
    
    
    
    @mcp.tool()
    async def mset6461_get_surrndr_dtls_postusing_get(
        bpid: Optional[int] = None,
        memberid: Optional[int] = None,
        accesstoken: Optional[str] = None,
        channeltype: Optional[int] = None,
        co_relationid: Optional[int] = None,
        initiatingsystem: Optional[str] = None,
        servicemode: Optional[int] = None,
        uuidseqno: Optional[int] = None,
        entity: Optional[str] = None,
        languagecode: Optional[int] = None,
        referenceid: Optional[str] = None,
        requesthash: Optional[str] = None,
        userid: Optional[int] = None
    ) -> Dict[str, Any]:
        """
        Surrender view
        
        Generated from: GET /shareManagement/memberApplication/surrenderView
        Source: swagger_2_0
        Operation ID: MSET6461GetSurrndrDtls_POSTUsingGET
        
        
        Authentication: Not required
        
        Parameters:
        - bpId: integer
          BP ID
        - memberId: integer
          Member ID
        
        
        
        Headers:
        - Accesstoken: string
          Authorization token for identification of the caller
        - ChannelType: integer
          Channel identifier from where the TXN has originated (Internet, Mobile, ATM, Branch Channel )
        - Co-Relationid: integer
          Unique ID for the service invoked, will be set by the TXN system
        - InitiatingSystem: string
          Indicating the initiated system
        - ServiceMode: integer
          Used for branch channel to indicate the type of customer
        - UUIDSeqNo: integer
          UUID Sequence Number
        - entity: string
          entity
        - languageCode: integer
          languageCode
        - referenceId: string
          Place holder for Token based authentication
        - requesthash: string
          Request payload for hash validation
        - userId: integer
          userId
        
        
        """
        
        
        # Prepare query parameters
        params = {}
        if bpid is not None:
            params["bpId"] = bpid
            
        if memberid is not None:
            params["memberId"] = memberid
            
        
        
        # Replace path parameters in URL
        path = "/shareManagement/memberApplication/surrenderView"
        
        
        # Prepare headers
        headers = {}
        if accesstoken is not None:
            headers["Accesstoken"] = str(accesstoken)
        if channeltype is not None:
            headers["ChannelType"] = str(channeltype)
        if co_relationid is not None:
            headers["Co-Relationid"] = str(co_relationid)
        if initiatingsystem is not None:
            headers["InitiatingSystem"] = str(initiatingsystem)
        if servicemode is not None:
            headers["ServiceMode"] = str(servicemode)
        if uuidseqno is not None:
            headers["UUIDSeqNo"] = str(uuidseqno)
        if entity is not None:
            headers["entity"] = str(entity)
        if languagecode is not None:
            headers["languageCode"] = str(languagecode)
        if referenceid is not None:
            headers["referenceId"] = str(referenceid)
        if requesthash is not None:
            headers["requesthash"] = str(requesthash)
        if userid is not None:
            headers["userId"] = str(userid)
        
        
        return await make_api_request(
            "GET", 
            path, 
            
            params=params if params else None, 
            headers=headers if headers else None
        )
    
    
    
    @mcp.tool()
    async def msbt8290_create_membr_appln_postusing_post(
        request_body:Dict[str, Any] ,  # CreateMembrApplnResource,
        accesstoken: Optional[str] = None,
        channeltype: Optional[int] = None,
        co_relationid: Optional[int] = None,
        initiatingsystem: Optional[str] = None,
        servicemode: Optional[int] = None,
        uuidseqno: Optional[int] = None,
        entity: Optional[str] = None,
        languagecode: Optional[int] = None,
        referenceid: Optional[str] = None,
        requesthash: Optional[str] = None,
        userid: Optional[int] = None
    ) -> Dict[str, Any]:
        """
        This service is used to create share application
        
        Generated from: POST /shareManagement/share/create
        Source: swagger_2_0
        Operation ID: MSBT8290CreateMembrAppln_POSTUsingPOST
        
        
        Authentication: Not required
        
        Parameters:
        - request_body: any (required)
          input
        
        
        
        Headers:
        - Accesstoken: string
          Authorization token for identification of the caller
        - ChannelType: integer
          Channel identifier from where the TXN has originated (Internet, Mobile, ATM, Branch Channel )
        - Co-Relationid: integer
          Unique ID for the service invoked, will be set by the TXN system
        - InitiatingSystem: string
          Indicating the initiated system
        - ServiceMode: integer
          Used for branch channel to indicate the type of customer
        - UUIDSeqNo: integer
          UUID Sequence Number
        - entity: string
          entity
        - languageCode: integer
          languageCode
        - referenceId: string
          Place holder for Token based authentication
        - requesthash: string
          Request payload for hash validation
        - userId: integer
          userId
        
        
        """
        
        
        # Prepare request data
        
        # Single body parameter - send directly
        data = request_body if request_body is not None else {}
        
        
        
        # Prepare query parameters
        params = {}
        
        
        # Replace path parameters in URL
        path = "/shareManagement/share/create"
        
        
        # Prepare headers
        headers = {}
        if accesstoken is not None:
            headers["Accesstoken"] = str(accesstoken)
        if channeltype is not None:
            headers["ChannelType"] = str(channeltype)
        if co_relationid is not None:
            headers["Co-Relationid"] = str(co_relationid)
        if initiatingsystem is not None:
            headers["InitiatingSystem"] = str(initiatingsystem)
        if servicemode is not None:
            headers["ServiceMode"] = str(servicemode)
        if uuidseqno is not None:
            headers["UUIDSeqNo"] = str(uuidseqno)
        if entity is not None:
            headers["entity"] = str(entity)
        if languagecode is not None:
            headers["languageCode"] = str(languagecode)
        if referenceid is not None:
            headers["referenceId"] = str(referenceid)
        if requesthash is not None:
            headers["requesthash"] = str(requesthash)
        if userid is not None:
            headers["userId"] = str(userid)
        
        
        return await make_api_request(
            "POST", 
            path, 
            data=data, 
            params=params if params else None, 
            headers=headers if headers else None
        )
    
    
    
    @mcp.tool()
    async def slbt5801_create_synd_non_fund_postusing_post(
        request_body:Dict[str, Any] ,  # CONTINGENT_TXN_SLBT5801CreateSyndNonFund_Resource,
        entity: Optional[str] = None,
        userid: Optional[int] = None
    ) -> Dict[str, Any]:
        """
        Create Syndicate Non Fund
        
        Generated from: POST /syndication/CreateSyndNonFund
        Source: swagger_2_0
        Operation ID: SLBT5801CreateSyndNonFund_POSTUsingPOST
        
        
        Authentication: Not required
        
        Parameters:
        - request_body: any (required)
          input
        
        
        
        Headers:
        - entity: string
          entity
        - userId: integer
          userId
        
        
        """
        
        
        # Prepare request data
        
        # Single body parameter - send directly
        data = request_body if request_body is not None else {}
        
        
        
        # Prepare query parameters
        params = {}
        
        
        # Replace path parameters in URL
        path = "/syndication/CreateSyndNonFund"
        
        
        # Prepare headers
        headers = {}
        if entity is not None:
            headers["entity"] = str(entity)
        if userid is not None:
            headers["userId"] = str(userid)
        
        
        return await make_api_request(
            "POST", 
            path, 
            data=data, 
            params=params if params else None, 
            headers=headers if headers else None
        )
    
    
    
    @mcp.tool()
    async def slbt5786_create_syndicate_facility_agency_postusing_post(
        request_body:Dict[str, Any] ,  # SL_CONTRACT_SLBT5786CreateSyndicateFacilityAgency_Resource,
        entity: Optional[str] = None,
        languagecode: Optional[int] = None,
        userid: Optional[int] = None
    ) -> Dict[str, Any]:
        """
        Create Syndicate Facility Agency
        
        Generated from: POST /syndication/CreateSyndicateFacilityAgency
        Source: swagger_2_0
        Operation ID: SLBT5786CreateSyndicateFacilityAgency_POSTUsingPOST
        
        
        Authentication: Not required
        
        Parameters:
        - request_body: any (required)
          input
        
        
        
        Headers:
        - entity: string
          entity
        - languageCode: integer
          languageCode
        - userId: integer
          userId
        
        
        """
        
        
        # Prepare request data
        
        # Single body parameter - send directly
        data = request_body if request_body is not None else {}
        
        
        
        # Prepare query parameters
        params = {}
        
        
        # Replace path parameters in URL
        path = "/syndication/CreateSyndicateFacilityAgency"
        
        
        # Prepare headers
        headers = {}
        if entity is not None:
            headers["entity"] = str(entity)
        if languagecode is not None:
            headers["languageCode"] = str(languagecode)
        if userid is not None:
            headers["userId"] = str(userid)
        
        
        return await make_api_request(
            "POST", 
            path, 
            data=data, 
            params=params if params else None, 
            headers=headers if headers else None
        )
    
    
    
    @mcp.tool()
    async def slet5786_view_syndicate_facility_agency_postusing_get(
        agencyrole: Optional[int] = None,
        pagenum: Optional[int] = None,
        pagesize: Optional[int] = None,
        posnum: Optional[int] = None,
        postype: Optional[int] = None,
        templateid: Optional[int] = None,
        accesstoken: Optional[str] = None,
        channeltype: Optional[int] = None,
        co_relationid: Optional[int] = None,
        initiatingsystem: Optional[str] = None,
        servicemode: Optional[int] = None,
        uuidseqno: Optional[int] = None,
        entity: Optional[str] = None,
        languagecode: Optional[int] = None,
        referenceid: Optional[str] = None,
        requesthash: Optional[str] = None,
        userid: Optional[int] = None
    ) -> Dict[str, Any]:
        """
        View Syndication Facility Agency
        
        Generated from: GET /syndication/ViewSyndicateFacilityAgency
        Source: swagger_2_0
        Operation ID: SLET5786ViewSyndicateFacilityAgency_POSTUsingGET
        
        
        Authentication: Not required
        
        Parameters:
        - agencyRole: integer
          agencyRole
        - pageNum: integer
          pageNum
        - pageSize: integer
          pageSize
        - posNum: integer
          posNum
        - posType: integer
          posType
        - templateId: integer
          templateId
        
        
        
        Headers:
        - Accesstoken: string
          Authorization Token to validation the caller
        - ChannelType: integer
          Channel identifier from where the TXN has originated (Internet, Mobile, ATM, Branch Channel )
        - Co-Relationid: integer
          Unique ID for the service invoked, will be set by the TXN system
        - InitiatingSystem: string
          Indicating the initiated system
        - ServiceMode: integer
          Used for branch channel to indicate the type of customer
        - UUIDSeqNo: integer
          UUID Sequence Number
        - entity: string
          entity
        - languageCode: integer
          languageCode
        - referenceId: string
          Place holder for Token based authentication
        - requesthash: string
          Request payload for hash validation
        - userId: integer
          userId
        
        
        """
        
        
        # Prepare query parameters
        params = {}
        if agencyrole is not None:
            params["agencyRole"] = agencyrole
            
        if pagenum is not None:
            params["pageNum"] = pagenum
            
        if pagesize is not None:
            params["pageSize"] = pagesize
            
        if posnum is not None:
            params["posNum"] = posnum
            
        if postype is not None:
            params["posType"] = postype
            
        if templateid is not None:
            params["templateId"] = templateid
            
        
        
        # Replace path parameters in URL
        path = "/syndication/ViewSyndicateFacilityAgency"
        
        
        # Prepare headers
        headers = {}
        if accesstoken is not None:
            headers["Accesstoken"] = str(accesstoken)
        if channeltype is not None:
            headers["ChannelType"] = str(channeltype)
        if co_relationid is not None:
            headers["Co-Relationid"] = str(co_relationid)
        if initiatingsystem is not None:
            headers["InitiatingSystem"] = str(initiatingsystem)
        if servicemode is not None:
            headers["ServiceMode"] = str(servicemode)
        if uuidseqno is not None:
            headers["UUIDSeqNo"] = str(uuidseqno)
        if entity is not None:
            headers["entity"] = str(entity)
        if languagecode is not None:
            headers["languageCode"] = str(languagecode)
        if referenceid is not None:
            headers["referenceId"] = str(referenceid)
        if requesthash is not None:
            headers["requesthash"] = str(requesthash)
        if userid is not None:
            headers["userId"] = str(userid)
        
        
        return await make_api_request(
            "GET", 
            path, 
            
            params=params if params else None, 
            headers=headers if headers else None
        )
    
    
    
    @mcp.tool()
    async def slbt0001_auth_syndication_cntrct_using_post(
        request_body:Dict[str, Any] ,  # AuthSyndicationRequest,
        accesstoken: Optional[str] = None,
        channeltype: Optional[int] = None,
        co_relationid: Optional[int] = None,
        initiatingsystem: Optional[str] = None,
        servicemode: Optional[int] = None,
        uuidseqno: Optional[int] = None,
        entity: Optional[str] = None,
        languagecode: Optional[int] = None,
        referenceid: Optional[str] = None,
        requesthash: Optional[str] = None,
        userid: Optional[int] = None
    ) -> Dict[str, Any]:
        """
        AuthSyndication
        
        Generated from: POST /syndication/authSyndication
        Source: swagger_2_0
        Operation ID: SLBT0001AuthSyndicationCntrctUsingPOST
        
        
        Authentication: Not required
        
        Parameters:
        - request_body: any (required)
          input
        
        
        
        Headers:
        - Accesstoken: string
          Authorization Token to validation the caller
        - ChannelType: integer
          Channel identifier from where the TXN has originated (Internet, Mobile, ATM, Branch Channel )
        - Co-Relationid: integer
          Unique ID for the service invoked, will be set by the TXN system
        - InitiatingSystem: string
          Indicating the initiated system
        - ServiceMode: integer
          Used for branch channel to indicate the type of customer
        - UUIDSeqNo: integer
          UUID Sequence Number
        - entity: string
          entity
        - languageCode: integer
          languageCode
        - referenceId: string
          Place holder for Token based authentication
        - requesthash: string
          Request payload for hash validation
        - userId: integer
          userId
        
        
        """
        
        
        # Prepare request data
        
        # Single body parameter - send directly
        data = request_body if request_body is not None else {}
        
        
        
        # Prepare query parameters
        params = {}
        
        
        # Replace path parameters in URL
        path = "/syndication/authSyndication"
        
        
        # Prepare headers
        headers = {}
        if accesstoken is not None:
            headers["Accesstoken"] = str(accesstoken)
        if channeltype is not None:
            headers["ChannelType"] = str(channeltype)
        if co_relationid is not None:
            headers["Co-Relationid"] = str(co_relationid)
        if initiatingsystem is not None:
            headers["InitiatingSystem"] = str(initiatingsystem)
        if servicemode is not None:
            headers["ServiceMode"] = str(servicemode)
        if uuidseqno is not None:
            headers["UUIDSeqNo"] = str(uuidseqno)
        if entity is not None:
            headers["entity"] = str(entity)
        if languagecode is not None:
            headers["languageCode"] = str(languagecode)
        if referenceid is not None:
            headers["referenceId"] = str(referenceid)
        if requesthash is not None:
            headers["requesthash"] = str(requesthash)
        if userid is not None:
            headers["userId"] = str(userid)
        
        
        return await make_api_request(
            "POST", 
            path, 
            data=data, 
            params=params if params else None, 
            headers=headers if headers else None
        )
    
    
    
    @mcp.tool()
    async def slbt5801_auth_synd_non_fund_postusing_post(
        request_body:Dict[str, Any] ,  # CONTINGENT_TXN_SLBT5801AuthSyndNonFund_Resource,
        accesstoken: Optional[str] = None,
        channeltype: Optional[int] = None,
        co_relationid: Optional[int] = None,
        initiatingsystem: Optional[str] = None,
        servicemode: Optional[int] = None,
        uuidseqno: Optional[int] = None,
        entity: Optional[str] = None,
        languagecode: Optional[int] = None,
        referenceid: Optional[str] = None,
        requesthash: Optional[str] = None,
        userid: Optional[int] = None
    ) -> Dict[str, Any]:
        """
        AuthSyndicationNonFund 
        
        Generated from: POST /syndication/authsyndnonfund
        Source: swagger_2_0
        Operation ID: SLBT5801AuthSyndNonFund_POSTUsingPOST
        
        
        Authentication: Not required
        
        Parameters:
        - request_body: any (required)
          input
        
        
        
        Headers:
        - Accesstoken: string
          Authorization Token to validation the caller
        - ChannelType: integer
          Channel identifier from where the TXN has originated (Internet, Mobile, ATM, Branch Channel )
        - Co-Relationid: integer
          Unique ID for the service invoked, will be set by the TXN system
        - InitiatingSystem: string
          Indicating the initiated system
        - ServiceMode: integer
          Used for branch channel to indicate the type of customer
        - UUIDSeqNo: integer
          UUID Sequence Number
        - entity: string
          entity
        - languageCode: integer
          languageCode
        - referenceId: string
          Place holder for Token based authentication
        - requesthash: string
          Request payload for hash validation
        - userId: integer
          userId
        
        
        """
        
        
        # Prepare request data
        
        # Single body parameter - send directly
        data = request_body if request_body is not None else {}
        
        
        
        # Prepare query parameters
        params = {}
        
        
        # Replace path parameters in URL
        path = "/syndication/authsyndnonfund"
        
        
        # Prepare headers
        headers = {}
        if accesstoken is not None:
            headers["Accesstoken"] = str(accesstoken)
        if channeltype is not None:
            headers["ChannelType"] = str(channeltype)
        if co_relationid is not None:
            headers["Co-Relationid"] = str(co_relationid)
        if initiatingsystem is not None:
            headers["InitiatingSystem"] = str(initiatingsystem)
        if servicemode is not None:
            headers["ServiceMode"] = str(servicemode)
        if uuidseqno is not None:
            headers["UUIDSeqNo"] = str(uuidseqno)
        if entity is not None:
            headers["entity"] = str(entity)
        if languagecode is not None:
            headers["languageCode"] = str(languagecode)
        if referenceid is not None:
            headers["referenceId"] = str(referenceid)
        if requesthash is not None:
            headers["requesthash"] = str(requesthash)
        if userid is not None:
            headers["userId"] = str(userid)
        
        
        return await make_api_request(
            "POST", 
            path, 
            data=data, 
            params=params if params else None, 
            headers=headers if headers else None
        )
    
    
    
    @mcp.tool()
    async def slbt0007_create_agency_role_postusing_post(
        request_body:Dict[str, Any] ,  # SL_OTHER_AGENCY_ROLES_SLBT0007CreateAgencyRole_Resource,
        channeltype: Optional[int] = None,
        co_relationid: Optional[int] = None,
        initiatingsystem: Optional[str] = None,
        servicemode: Optional[int] = None,
        uuidseqno: Optional[int] = None,
        entity: Optional[str] = None,
        userid: Optional[int] = None
    ) -> Dict[str, Any]:
        """
        Agency Role Creation
        
        Generated from: POST /syndication/createAgencyRole
        Source: swagger_2_0
        Operation ID: SLBT0007CreateAgencyRole_POSTUsingPOST
        
        
        Authentication: Not required
        
        Parameters:
        - request_body: any (required)
          input
        
        
        
        Headers:
        - ChannelType: integer
          Channel identifier from where the TXN has originated (Internet, Mobile, ATM, Branch Channel )
        - Co-Relationid: integer
          Unique ID for the service invoked, will be set by the TXN system
        - InitiatingSystem: string
          Indicating the initiated system
        - ServiceMode: integer
          Used for branch channel to indicate the type of customer
        - UUIDSeqNo: integer
          UUID Sequence Number
        - entity: string
          entity
        - userId: integer
          userId
        
        
        """
        
        
        # Prepare request data
        
        # Single body parameter - send directly
        data = request_body if request_body is not None else {}
        
        
        
        # Prepare query parameters
        params = {}
        
        
        # Replace path parameters in URL
        path = "/syndication/createAgencyRole"
        
        
        # Prepare headers
        headers = {}
        if channeltype is not None:
            headers["ChannelType"] = str(channeltype)
        if co_relationid is not None:
            headers["Co-Relationid"] = str(co_relationid)
        if initiatingsystem is not None:
            headers["InitiatingSystem"] = str(initiatingsystem)
        if servicemode is not None:
            headers["ServiceMode"] = str(servicemode)
        if uuidseqno is not None:
            headers["UUIDSeqNo"] = str(uuidseqno)
        if entity is not None:
            headers["entity"] = str(entity)
        if userid is not None:
            headers["userId"] = str(userid)
        
        
        return await make_api_request(
            "POST", 
            path, 
            data=data, 
            params=params if params else None, 
            headers=headers if headers else None
        )
    
    
    
    @mcp.tool()
    async def slbt0005_create_participant_limit_using_post(
        request_body:Dict[str, Any] ,  # SL_PARTICIPANT_LIMIT_SLBT0005CreateParticipantLimit_Resource,
        accesstoken: Optional[str] = None,
        channeltype: Optional[int] = None,
        co_relationid: Optional[int] = None,
        initiatingsystem: Optional[str] = None,
        servicemode: Optional[int] = None,
        uuidseqno: Optional[int] = None,
        entity: Optional[str] = None,
        languagecode: Optional[int] = None,
        referenceid: Optional[str] = None,
        requesthash: Optional[str] = None,
        userid: Optional[int] = None
    ) -> Dict[str, Any]:
        """
        This is Syndication Participant Limit Creation service
        
        Generated from: POST /syndication/createParticipantLimit
        Source: swagger_2_0
        Operation ID: SLBT0005CreateParticipantLimitUsingPOST
        
        
        Authentication: Not required
        
        Parameters:
        - request_body: any (required)
          input
        
        
        
        Headers:
        - Accesstoken: string
          Authorization Token to validation the caller
        - ChannelType: integer
          Channel identifier from where the TXN has originated (Internet, Mobile, ATM, Branch Channel )
        - Co-Relationid: integer
          Unique ID for the service invoked, will be set by the TXN system
        - InitiatingSystem: string
          Indicating the initiated system
        - ServiceMode: integer
          Used for branch channel to indicate the type of customer
        - UUIDSeqNo: integer
          UUID Sequence Number
        - entity: string
          entity
        - languageCode: integer
          languageCode
        - referenceId: string
          Place holder for Token based authentication
        - requesthash: string
          Request payload for hash validation
        - userId: integer
          userId
        
        
        """
        
        
        # Prepare request data
        
        # Single body parameter - send directly
        data = request_body if request_body is not None else {}
        
        
        
        # Prepare query parameters
        params = {}
        
        
        # Replace path parameters in URL
        path = "/syndication/createParticipantLimit"
        
        
        # Prepare headers
        headers = {}
        if accesstoken is not None:
            headers["Accesstoken"] = str(accesstoken)
        if channeltype is not None:
            headers["ChannelType"] = str(channeltype)
        if co_relationid is not None:
            headers["Co-Relationid"] = str(co_relationid)
        if initiatingsystem is not None:
            headers["InitiatingSystem"] = str(initiatingsystem)
        if servicemode is not None:
            headers["ServiceMode"] = str(servicemode)
        if uuidseqno is not None:
            headers["UUIDSeqNo"] = str(uuidseqno)
        if entity is not None:
            headers["entity"] = str(entity)
        if languagecode is not None:
            headers["languageCode"] = str(languagecode)
        if referenceid is not None:
            headers["referenceId"] = str(referenceid)
        if requesthash is not None:
            headers["requesthash"] = str(requesthash)
        if userid is not None:
            headers["userId"] = str(userid)
        
        
        return await make_api_request(
            "POST", 
            path, 
            data=data, 
            params=params if params else None, 
            headers=headers if headers else None
        )
    
    
    
    @mcp.tool()
    async def slbt0001_create_syndication_cntrct_using_post(
        request_body:Dict[str, Any] ,  # SL_CONTRACT_SLBT0001CreateSyndicationCntrct_Resource,
        accesstoken: Optional[str] = None,
        channeltype: Optional[int] = None,
        co_relationid: Optional[int] = None,
        initiatingsystem: Optional[str] = None,
        servicemode: Optional[int] = None,
        uuidseqno: Optional[int] = None,
        entity: Optional[str] = None,
        languagecode: Optional[int] = None,
        referenceid: Optional[str] = None,
        requesthash: Optional[str] = None,
        userid: Optional[int] = None
    ) -> Dict[str, Any]:
        """
        This is Syndication Creation Service
        
        Generated from: POST /syndication/createSyndication
        Source: swagger_2_0
        Operation ID: SLBT0001CreateSyndicationCntrctUsingPOST
        
        
        Authentication: Not required
        
        Parameters:
        - request_body: any (required)
          input
        
        
        
        Headers:
        - Accesstoken: string
          Authorization Token to validation the caller
        - ChannelType: integer
          Channel identifier from where the TXN has originated (Internet, Mobile, ATM, Branch Channel )
        - Co-Relationid: integer
          Unique ID for the service invoked, will be set by the TXN system
        - InitiatingSystem: string
          Indicating the initiated system
        - ServiceMode: integer
          Used for branch channel to indicate the type of customer
        - UUIDSeqNo: integer
          UUID Sequence Number
        - entity: string
          entity
        - languageCode: integer
          languageCode
        - referenceId: string
          Place holder for Token based authentication
        - requesthash: string
          Request payload for hash validation
        - userId: integer
          userId
        
        
        """
        
        
        # Prepare request data
        
        # Single body parameter - send directly
        data = request_body if request_body is not None else {}
        
        
        
        # Prepare query parameters
        params = {}
        
        
        # Replace path parameters in URL
        path = "/syndication/createSyndication"
        
        
        # Prepare headers
        headers = {}
        if accesstoken is not None:
            headers["Accesstoken"] = str(accesstoken)
        if channeltype is not None:
            headers["ChannelType"] = str(channeltype)
        if co_relationid is not None:
            headers["Co-Relationid"] = str(co_relationid)
        if initiatingsystem is not None:
            headers["InitiatingSystem"] = str(initiatingsystem)
        if servicemode is not None:
            headers["ServiceMode"] = str(servicemode)
        if uuidseqno is not None:
            headers["UUIDSeqNo"] = str(uuidseqno)
        if entity is not None:
            headers["entity"] = str(entity)
        if languagecode is not None:
            headers["languageCode"] = str(languagecode)
        if referenceid is not None:
            headers["referenceId"] = str(referenceid)
        if requesthash is not None:
            headers["requesthash"] = str(requesthash)
        if userid is not None:
            headers["userId"] = str(userid)
        
        
        return await make_api_request(
            "POST", 
            path, 
            data=data, 
            params=params if params else None, 
            headers=headers if headers else None
        )
    
    
    
    @mcp.tool()
    async def slbt5789_create_participant_details_postusing_post(
        request_body:Dict[str, Any] ,  # SL_PARTICIPANT_DETAILS_SLBT5789CreateParticipantDetails_Resource,
        entity: Optional[str] = None,
        languagecode: Optional[int] = None,
        userid: Optional[int] = None
    ) -> Dict[str, Any]:
        """
        SLBT5789CreateParticipantDetails
        
        Generated from: POST /syndication/createparticipantdetails
        Source: swagger_2_0
        Operation ID: SLBT5789CreateParticipantDetails_POSTUsingPOST
        
        
        Authentication: Not required
        
        Parameters:
        - request_body: any (required)
          input
        
        
        
        Headers:
        - entity: string
          entity
        - languageCode: integer
          languageCode
        - userId: integer
          userId
        
        
        """
        
        
        # Prepare request data
        
        # Single body parameter - send directly
        data = request_body if request_body is not None else {}
        
        
        
        # Prepare query parameters
        params = {}
        
        
        # Replace path parameters in URL
        path = "/syndication/createparticipantdetails"
        
        
        # Prepare headers
        headers = {}
        if entity is not None:
            headers["entity"] = str(entity)
        if languagecode is not None:
            headers["languageCode"] = str(languagecode)
        if userid is not None:
            headers["userId"] = str(userid)
        
        
        return await make_api_request(
            "POST", 
            path, 
            data=data, 
            params=params if params else None, 
            headers=headers if headers else None
        )
    
    
    
    @mcp.tool()
    async def slbt5790_create_syndication_event_postusing_post(
        request_body:Dict[str, Any] ,  # SL_EVENTS_SLBT5790CreateSyndicationEvent_Resource,
        entity: Optional[str] = None,
        languagecode: Optional[int] = None,
        userid: Optional[int] = None
    ) -> Dict[str, Any]:
        """
        Create Syndication Events
        
        Generated from: POST /syndication/createsyndicationevent
        Source: swagger_2_0
        Operation ID: SLBT5790CreateSyndicationEvent_POSTUsingPOST
        
        
        Authentication: Not required
        
        Parameters:
        - request_body: any (required)
          input
        
        
        
        Headers:
        - entity: string
          entity
        - languageCode: integer
          languageCode
        - userId: integer
          userId
        
        
        """
        
        
        # Prepare request data
        
        # Single body parameter - send directly
        data = request_body if request_body is not None else {}
        
        
        
        # Prepare query parameters
        params = {}
        
        
        # Replace path parameters in URL
        path = "/syndication/createsyndicationevent"
        
        
        # Prepare headers
        headers = {}
        if entity is not None:
            headers["entity"] = str(entity)
        if languagecode is not None:
            headers["languageCode"] = str(languagecode)
        if userid is not None:
            headers["userId"] = str(userid)
        
        
        return await make_api_request(
            "POST", 
            path, 
            data=data, 
            params=params if params else None, 
            headers=headers if headers else None
        )
    
    
    
    @mcp.tool()
    async def slet5794_fetch_syndication_contract_dtls_postusing_get(
        limit_ref: int,
        pagenum: Optional[int] = None,
        pagesize: Optional[int] = None,
        entity: Optional[str] = None,
        languagecode: Optional[int] = None,
        userid: Optional[int] = None
    ) -> Dict[str, Any]:
        """
        Fetch Syndication Contract details fetch on LIMIT_REF
        
        Generated from: GET /syndication/fetchSyndContractDtls
        Source: swagger_2_0
        Operation ID: SLET5794FetchSyndicationContractDtls_POSTUsingGET
        
        
        Authentication: Not required
        
        Parameters:
        - LIMIT_REF: integer (required)
          Limit Ref
        - pageNum: integer
          pageNum
        - pageSize: integer
          pageSize
        
        
        
        Headers:
        - entity: string
          entity
        - languageCode: integer
          languageCode
        - userId: integer
          userId
        
        
        """
        
        
        # Prepare query parameters
        params = {}
        if limit_ref is not None:
            params["LIMIT_REF"] = limit_ref
            
        if pagenum is not None:
            params["pageNum"] = pagenum
            
        if pagesize is not None:
            params["pageSize"] = pagesize
            
        
        
        # Replace path parameters in URL
        path = "/syndication/fetchSyndContractDtls"
        
        
        # Prepare headers
        headers = {}
        if entity is not None:
            headers["entity"] = str(entity)
        if languagecode is not None:
            headers["languageCode"] = str(languagecode)
        if userid is not None:
            headers["userId"] = str(userid)
        
        
        return await make_api_request(
            "GET", 
            path, 
            
            params=params if params else None, 
            headers=headers if headers else None
        )
    
    
    
    @mcp.tool()
    async def slet5801_list_con_accounting_postusing_get(
        lnkdref: Optional[str] = None,
        pagenum: Optional[int] = None,
        pagesize: Optional[int] = None,
        posnum: Optional[int] = None,
        postype: Optional[int] = None,
        subtxnposid: Optional[int] = None,
        subtxnpostyp: Optional[int] = None,
        txnposid: Optional[int] = None,
        txnpostyp: Optional[int] = None,
        entity: Optional[str] = None,
        languagecode: Optional[int] = None,
        userid: Optional[int] = None
    ) -> Dict[str, Any]:
        """
        Fetch  Contingent Accounting Details
        
        Generated from: GET /syndication/listContingentAccounting
        Source: swagger_2_0
        Operation ID: SLET5801ListConAccounting_POSTUsingGET
        
        
        Authentication: Not required
        
        Parameters:
        - lnkdRef: string
          Linked Reference of Contingent Transaction
        - pageNum: integer
          pageNum
        - pageSize: integer
          pageSize
        - posNum: integer
          Pos Num of sl contract
        - posType: integer
          Pos Type of sl contract
        - subTxnPosId: integer
          Sub Transaction Pos Id of Contingent Transaction
        - subTxnPosTyp: integer
          Sub Transaction Pos Type of Contingent Transaction
        - txnPosId: integer
          Transaction Pos Id of contingent transaction
        - txnPosTyp: integer
          Transaction Pos Type of contingent transaction
        
        
        
        Headers:
        - entity: string
          entity
        - languageCode: integer
          languageCode
        - userId: integer
          userId
        
        
        """
        
        
        # Prepare query parameters
        params = {}
        if lnkdref is not None:
            params["lnkdRef"] = lnkdref
            
        if pagenum is not None:
            params["pageNum"] = pagenum
            
        if pagesize is not None:
            params["pageSize"] = pagesize
            
        if posnum is not None:
            params["posNum"] = posnum
            
        if postype is not None:
            params["posType"] = postype
            
        if subtxnposid is not None:
            params["subTxnPosId"] = subtxnposid
            
        if subtxnpostyp is not None:
            params["subTxnPosTyp"] = subtxnpostyp
            
        if txnposid is not None:
            params["txnPosId"] = txnposid
            
        if txnpostyp is not None:
            params["txnPosTyp"] = txnpostyp
            
        
        
        # Replace path parameters in URL
        path = "/syndication/listContingentAccounting"
        
        
        # Prepare headers
        headers = {}
        if entity is not None:
            headers["entity"] = str(entity)
        if languagecode is not None:
            headers["languageCode"] = str(languagecode)
        if userid is not None:
            headers["userId"] = str(userid)
        
        
        return await make_api_request(
            "GET", 
            path, 
            
            params=params if params else None, 
            headers=headers if headers else None
        )
    
    
    
    @mcp.tool()
    async def slet5801_list_con_txn_postusing_get(
        posnum: int,
        postype: int,
        pagenum: Optional[int] = None,
        pagesize: Optional[int] = None,
        entity: Optional[str] = None,
        languagecode: Optional[int] = None,
        userid: Optional[int] = None
    ) -> Dict[str, Any]:
        """
        Fetch  Contingent Transaction Details
        
        Generated from: GET /syndication/listContingentTransaction
        Source: swagger_2_0
        Operation ID: SLET5801ListConTxn_POSTUsingGET
        
        
        Authentication: Not required
        
        Parameters:
        - pageNum: integer
          pageNum
        - pageSize: integer
          pageSize
        - posNum: integer (required)
          Pos Num of sl contract
        - posType: integer (required)
          Pos Type of sl contract
        
        
        
        Headers:
        - entity: string
          entity
        - languageCode: integer
          languageCode
        - userId: integer
          userId
        
        
        """
        
        
        # Prepare query parameters
        params = {}
        if pagenum is not None:
            params["pageNum"] = pagenum
            
        if pagesize is not None:
            params["pageSize"] = pagesize
            
        if posnum is not None:
            params["posNum"] = posnum
            
        if postype is not None:
            params["posType"] = postype
            
        
        
        # Replace path parameters in URL
        path = "/syndication/listContingentTransaction"
        
        
        # Prepare headers
        headers = {}
        if entity is not None:
            headers["entity"] = str(entity)
        if languagecode is not None:
            headers["languageCode"] = str(languagecode)
        if userid is not None:
            headers["userId"] = str(userid)
        
        
        return await make_api_request(
            "GET", 
            path, 
            
            params=params if params else None, 
            headers=headers if headers else None
        )
    
    
    
    @mcp.tool()
    async def slet0001_list_syndication_cntrct_using_get(
        contractref: str,
        contractexpirydate: Optional[str] = None,
        contractidtyp: Optional[int] = None,
        contractname: Optional[str] = None,
        contractstartdate: Optional[str] = None,
        contractstatus: Optional[int] = None,
        customerref: Optional[str] = None,
        pagenum: Optional[int] = None,
        pagesize: Optional[int] = None,
        accesstoken: Optional[str] = None,
        channeltype: Optional[int] = None,
        co_relationid: Optional[int] = None,
        initiatingsystem: Optional[str] = None,
        servicemode: Optional[int] = None,
        uuidseqno: Optional[int] = None,
        entity: Optional[str] = None,
        languagecode: Optional[int] = None,
        referenceid: Optional[str] = None,
        requesthash: Optional[str] = None,
        userid: Optional[int] = None
    ) -> Dict[str, Any]:
        """
        List Syndication Contract Details
        
        Generated from: GET /syndication/listSyndication/{contractRef}
        Source: swagger_2_0
        Operation ID: SLET0001ListSyndicationCntrctUsingGET
        
        
        Authentication: Not required
        
        Parameters:
        - contractExpiryDate: string
          End date of the Syndication Contract
        - contractIDTyp: integer
          Contract account pos type in BaNCS
        - contractName: string
          Contract Name for Syndication
        - contractRef: string (required)
          Reference Contract account Number
        - contractStartDate: string
          Start Date of the Syndication Contract
        - contractStatus: integer
          Syndication contract status
        - customerRef: string
          Technical Reference of Customer created in BaNCS
        - pageNum: integer
          pageNum
        - pageSize: integer
          pageSize
        
        
        
        Headers:
        - Accesstoken: string
          Authorization Token to validation the caller
        - ChannelType: integer
          Channel identifier from where the TXN has originated (Internet, Mobile, ATM, Branch Channel )
        - Co-Relationid: integer
          Unique ID for the service invoked, will be set by the TXN system
        - InitiatingSystem: string
          Indicating the initiated system
        - ServiceMode: integer
          Used for branch channel to indicate the type of customer
        - UUIDSeqNo: integer
          UUID Sequence Number
        - entity: string
          entity
        - languageCode: integer
          languageCode
        - referenceId: string
          Place holder for Token based authentication
        - requesthash: string
          Request payload for hash validation
        - userId: integer
          userId
        
        
        """
        
        
        # Prepare query parameters
        params = {}
        if contractexpirydate is not None:
            params["contractExpiryDate"] = contractexpirydate
            
        if contractidtyp is not None:
            params["contractIDTyp"] = contractidtyp
            
        if contractname is not None:
            params["contractName"] = contractname
            
        if contractstartdate is not None:
            params["contractStartDate"] = contractstartdate
            
        if contractstatus is not None:
            params["contractStatus"] = contractstatus
            
        if customerref is not None:
            params["customerRef"] = customerref
            
        if pagenum is not None:
            params["pageNum"] = pagenum
            
        if pagesize is not None:
            params["pageSize"] = pagesize
            
        
        
        # Replace path parameters in URL
        path = "/syndication/listSyndication/{contractRef}"
        if contractref is not None:
            path = path.replace("{contractRef}", str(contractref))
        
        
        # Prepare headers
        headers = {}
        if accesstoken is not None:
            headers["Accesstoken"] = str(accesstoken)
        if channeltype is not None:
            headers["ChannelType"] = str(channeltype)
        if co_relationid is not None:
            headers["Co-Relationid"] = str(co_relationid)
        if initiatingsystem is not None:
            headers["InitiatingSystem"] = str(initiatingsystem)
        if servicemode is not None:
            headers["ServiceMode"] = str(servicemode)
        if uuidseqno is not None:
            headers["UUIDSeqNo"] = str(uuidseqno)
        if entity is not None:
            headers["entity"] = str(entity)
        if languagecode is not None:
            headers["languageCode"] = str(languagecode)
        if referenceid is not None:
            headers["referenceId"] = str(referenceid)
        if requesthash is not None:
            headers["requesthash"] = str(requesthash)
        if userid is not None:
            headers["userId"] = str(userid)
        
        
        return await make_api_request(
            "GET", 
            path, 
            
            params=params if params else None, 
            headers=headers if headers else None
        )
    
    
    
    @mcp.tool()
    async def slet5790_list_syndication_event_postusing_get(
        arrangementidposnum: Optional[int] = None,
        arrangementidpostype: Optional[int] = None,
        pagenum: Optional[int] = None,
        pagesize: Optional[int] = None,
        accesstoken: Optional[str] = None,
        channeltype: Optional[int] = None,
        co_relationid: Optional[int] = None,
        initiatingsystem: Optional[str] = None,
        servicemode: Optional[int] = None,
        uuidseqno: Optional[int] = None,
        entity: Optional[str] = None,
        languagecode: Optional[int] = None,
        referenceid: Optional[str] = None,
        requesthash: Optional[str] = None,
        userid: Optional[int] = None
    ) -> Dict[str, Any]:
        """
        List Syndication Events
        
        Generated from: GET /syndication/listsyndicationevent
        Source: swagger_2_0
        Operation ID: SLET5790ListSyndicationEvent_POSTUsingGET
        
        
        Authentication: Not required
        
        Parameters:
        - arrangementIdPosNum: integer
          arrangementIdPosNum
        - arrangementIdPosType: integer
          arrangementIdPosType
        - pageNum: integer
          pageNum
        - pageSize: integer
          pageSize
        
        
        
        Headers:
        - Accesstoken: string
          Authorization Token to validation the caller
        - ChannelType: integer
          Channel identifier from where the TXN has originated (Internet, Mobile, ATM, Branch Channel )
        - Co-Relationid: integer
          Unique ID for the service invoked, will be set by the TXN system
        - InitiatingSystem: string
          Indicating the initiated system
        - ServiceMode: integer
          Used for branch channel to indicate the type of customer
        - UUIDSeqNo: integer
          UUID Sequence Number
        - entity: string
          entity
        - languageCode: integer
          languageCode
        - referenceId: string
          Place holder for Token based authentication
        - requesthash: string
          Request payload for hash validation
        - userId: integer
          userId
        
        
        """
        
        
        # Prepare query parameters
        params = {}
        if arrangementidposnum is not None:
            params["arrangementIdPosNum"] = arrangementidposnum
            
        if arrangementidpostype is not None:
            params["arrangementIdPosType"] = arrangementidpostype
            
        if pagenum is not None:
            params["pageNum"] = pagenum
            
        if pagesize is not None:
            params["pageSize"] = pagesize
            
        
        
        # Replace path parameters in URL
        path = "/syndication/listsyndicationevent"
        
        
        # Prepare headers
        headers = {}
        if accesstoken is not None:
            headers["Accesstoken"] = str(accesstoken)
        if channeltype is not None:
            headers["ChannelType"] = str(channeltype)
        if co_relationid is not None:
            headers["Co-Relationid"] = str(co_relationid)
        if initiatingsystem is not None:
            headers["InitiatingSystem"] = str(initiatingsystem)
        if servicemode is not None:
            headers["ServiceMode"] = str(servicemode)
        if uuidseqno is not None:
            headers["UUIDSeqNo"] = str(uuidseqno)
        if entity is not None:
            headers["entity"] = str(entity)
        if languagecode is not None:
            headers["languageCode"] = str(languagecode)
        if referenceid is not None:
            headers["referenceId"] = str(referenceid)
        if requesthash is not None:
            headers["requesthash"] = str(requesthash)
        if userid is not None:
            headers["userId"] = str(userid)
        
        
        return await make_api_request(
            "GET", 
            path, 
            
            params=params if params else None, 
            headers=headers if headers else None
        )
    
    
    
    @mcp.tool()
    async def slbt5803_auth_synd_part_sale_postusing_post(
        request_body:Dict[str, Any] ,  # SL_SALE_PURCHASE_SLBT5803AuthSyndPartSale_Resource,
        applicationid: Optional[str] = None,
        entity: Optional[str] = None,
        languagecode: Optional[int] = None,
        userid: Optional[int] = None
    ) -> Dict[str, Any]:
        """
        Sale/Purchase authorization
        
        Generated from: POST /syndication/slbt5803authsyndpartsale
        Source: swagger_2_0
        Operation ID: SLBT5803AuthSyndPartSale_POSTUsingPOST
        
        
        Authentication: Not required
        
        Parameters:
        - request_body: any (required)
          input
        
        
        
        Headers:
        - applicationId: string
          applicationId
        - entity: string
          entity
        - languageCode: integer
          languageCode
        - userId: integer
          userId
        
        
        """
        
        
        # Prepare request data
        
        # Single body parameter - send directly
        data = request_body if request_body is not None else {}
        
        
        
        # Prepare query parameters
        params = {}
        
        
        # Replace path parameters in URL
        path = "/syndication/slbt5803authsyndpartsale"
        
        
        # Prepare headers
        headers = {}
        if applicationid is not None:
            headers["applicationId"] = str(applicationid)
        if entity is not None:
            headers["entity"] = str(entity)
        if languagecode is not None:
            headers["languageCode"] = str(languagecode)
        if userid is not None:
            headers["userId"] = str(userid)
        
        
        return await make_api_request(
            "POST", 
            path, 
            data=data, 
            params=params if params else None, 
            headers=headers if headers else None
        )
    
    
    
    @mcp.tool()
    async def slbt5803_create_synd_part_sale_postusing_post(
        request_body:Dict[str, Any] ,  # SL_SALE_PURCHASE_SLBT5803CreateSyndPartSale_Resource,
        entity: Optional[str] = None,
        languagecode: Optional[int] = None,
        userid: Optional[int] = None
    ) -> Dict[str, Any]:
        """
        SLBT5803CreateSyndPartSale
        
        Generated from: POST /syndication/slbt5803createsyndpartsale
        Source: swagger_2_0
        Operation ID: SLBT5803CreateSyndPartSale_POSTUsingPOST
        
        
        Authentication: Not required
        
        Parameters:
        - request_body: any (required)
          input
        
        
        
        Headers:
        - entity: string
          entity
        - languageCode: integer
          languageCode
        - userId: integer
          userId
        
        
        """
        
        
        # Prepare request data
        
        # Single body parameter - send directly
        data = request_body if request_body is not None else {}
        
        
        
        # Prepare query parameters
        params = {}
        
        
        # Replace path parameters in URL
        path = "/syndication/slbt5803createsyndpartsale"
        
        
        # Prepare headers
        headers = {}
        if entity is not None:
            headers["entity"] = str(entity)
        if languagecode is not None:
            headers["languageCode"] = str(languagecode)
        if userid is not None:
            headers["userId"] = str(userid)
        
        
        return await make_api_request(
            "POST", 
            path, 
            data=data, 
            params=params if params else None, 
            headers=headers if headers else None
        )
    
    
    
    @mcp.tool()
    async def slet5803_list_synd_part_sale_postusing_get(
        slposnum: int,
        slpostype: int,
        applicationid: Optional[str] = None,
        entity: Optional[str] = None,
        languagecode: Optional[int] = None,
        userid: Optional[int] = None
    ) -> Dict[str, Any]:
        """
        Fetch Sale/Purchase List via Syndication Contract
        
        Generated from: GET /syndication/slet5803listsyndpartsale
        Source: swagger_2_0
        Operation ID: SLET5803ListSyndPartSale_POSTUsingGET
        
        
        Authentication: Not required
        
        Parameters:
        - slPosNum: integer (required)
          Pos Num of Syndication Contract
        - slPosType: integer (required)
          Pos Type of Syndication Contract
        
        
        
        Headers:
        - applicationId: string
          applicationId
        - entity: string
          entity
        - languageCode: integer
          languageCode
        - userId: integer
          userId
        
        
        """
        
        
        # Prepare query parameters
        params = {}
        if slposnum is not None:
            params["slPosNum"] = slposnum
            
        if slpostype is not None:
            params["slPosType"] = slpostype
            
        
        
        # Replace path parameters in URL
        path = "/syndication/slet5803listsyndpartsale"
        
        
        # Prepare headers
        headers = {}
        if applicationid is not None:
            headers["applicationId"] = str(applicationid)
        if entity is not None:
            headers["entity"] = str(entity)
        if languagecode is not None:
            headers["languageCode"] = str(languagecode)
        if userid is not None:
            headers["userId"] = str(userid)
        
        
        return await make_api_request(
            "GET", 
            path, 
            
            params=params if params else None, 
            headers=headers if headers else None
        )
    
    
    
    @mcp.tool()
    async def slet5803_view_synd_part_sale_postusing_get(
        txnposnum: int,
        txnpostype: int,
        pagenum: Optional[int] = None,
        pagesize: Optional[int] = None,
        applicationid: Optional[str] = None,
        entity: Optional[str] = None,
        languagecode: Optional[int] = None,
        userid: Optional[int] = None
    ) -> Dict[str, Any]:
        """
        SLET5803ViewSyndPartSale
        
        Generated from: GET /syndication/slet5803viewsyndpartsale
        Source: swagger_2_0
        Operation ID: SLET5803ViewSyndPartSale_POSTUsingGET
        
        
        Authentication: Not required
        
        Parameters:
        - pageNum: integer
          pageNum
        - pageSize: integer
          pageSize
        - txnPosNum: integer (required)
          txnPosNum
        - txnPosType: integer (required)
          txnPosType
        
        
        
        Headers:
        - applicationId: string
          applicationId
        - entity: string
          entity
        - languageCode: integer
          languageCode
        - userId: integer
          userId
        
        
        """
        
        
        # Prepare query parameters
        params = {}
        if pagenum is not None:
            params["pageNum"] = pagenum
            
        if pagesize is not None:
            params["pageSize"] = pagesize
            
        if txnposnum is not None:
            params["txnPosNum"] = txnposnum
            
        if txnpostype is not None:
            params["txnPosType"] = txnpostype
            
        
        
        # Replace path parameters in URL
        path = "/syndication/slet5803viewsyndpartsale"
        
        
        # Prepare headers
        headers = {}
        if applicationid is not None:
            headers["applicationId"] = str(applicationid)
        if entity is not None:
            headers["entity"] = str(entity)
        if languagecode is not None:
            headers["languageCode"] = str(languagecode)
        if userid is not None:
            headers["userId"] = str(userid)
        
        
        return await make_api_request(
            "GET", 
            path, 
            
            params=params if params else None, 
            headers=headers if headers else None
        )
    
    
    
    @mcp.tool()
    async def slet0005_view_participant_limit_using_get(
        loanreference: str,
        loanid: Optional[int] = None,
        loanidtyp: Optional[int] = None,
        pagenum: Optional[int] = None,
        pagesize: Optional[int] = None,
        accesstoken: Optional[str] = None,
        channeltype: Optional[int] = None,
        co_relationid: Optional[int] = None,
        initiatingsystem: Optional[str] = None,
        servicemode: Optional[int] = None,
        uuidseqno: Optional[int] = None,
        entity: Optional[str] = None,
        languagecode: Optional[int] = None,
        referenceid: Optional[str] = None,
        requesthash: Optional[str] = None,
        userid: Optional[int] = None
    ) -> Dict[str, Any]:
        """
        This is Syndication Participant Limit View service
        
        Generated from: GET /syndication/viewParticipantLimit/{loanReference}
        Source: swagger_2_0
        Operation ID: SLET0005ViewParticipantLimitUsingGET
        
        
        Authentication: Not required
        
        Parameters:
        - loanId: integer
          System Generated technical Identifier for the loan account (pos_num or pos_id)
        - loanIdTyp: integer
          Loan account pos type in BaNCS 900  Syndication
        - loanReference: string (required)
          Reference Loan account Number
        - pageNum: integer
          pageNum
        - pageSize: integer
          pageSize
        
        
        
        Headers:
        - Accesstoken: string
          Authorization Token to validation the caller
        - ChannelType: integer
          Channel identifier from where the TXN has originated (Internet, Mobile, ATM, Branch Channel )
        - Co-Relationid: integer
          Unique ID for the service invoked, will be set by the TXN system
        - InitiatingSystem: string
          Indicating the initiated system
        - ServiceMode: integer
          Used for branch channel to indicate the type of customer
        - UUIDSeqNo: integer
          UUID Sequence Number
        - entity: string
          entity
        - languageCode: integer
          languageCode
        - referenceId: string
          Place holder for Token based authentication
        - requesthash: string
          Request payload for hash validation
        - userId: integer
          userId
        
        
        """
        
        
        # Prepare query parameters
        params = {}
        if loanid is not None:
            params["loanId"] = loanid
            
        if loanidtyp is not None:
            params["loanIdTyp"] = loanidtyp
            
        if pagenum is not None:
            params["pageNum"] = pagenum
            
        if pagesize is not None:
            params["pageSize"] = pagesize
            
        
        
        # Replace path parameters in URL
        path = "/syndication/viewParticipantLimit/{loanReference}"
        if loanreference is not None:
            path = path.replace("{loanReference}", str(loanreference))
        
        
        # Prepare headers
        headers = {}
        if accesstoken is not None:
            headers["Accesstoken"] = str(accesstoken)
        if channeltype is not None:
            headers["ChannelType"] = str(channeltype)
        if co_relationid is not None:
            headers["Co-Relationid"] = str(co_relationid)
        if initiatingsystem is not None:
            headers["InitiatingSystem"] = str(initiatingsystem)
        if servicemode is not None:
            headers["ServiceMode"] = str(servicemode)
        if uuidseqno is not None:
            headers["UUIDSeqNo"] = str(uuidseqno)
        if entity is not None:
            headers["entity"] = str(entity)
        if languagecode is not None:
            headers["languageCode"] = str(languagecode)
        if referenceid is not None:
            headers["referenceId"] = str(referenceid)
        if requesthash is not None:
            headers["requesthash"] = str(requesthash)
        if userid is not None:
            headers["userId"] = str(userid)
        
        
        return await make_api_request(
            "GET", 
            path, 
            
            params=params if params else None, 
            headers=headers if headers else None
        )
    
    
    
    @mcp.tool()
    async def slet0001_view_syndication_cntrct_using_get(
        contractref: str,
        contractid: int,
        contractidtyp: int,
        accesstoken: Optional[str] = None,
        channeltype: Optional[int] = None,
        co_relationid: Optional[int] = None,
        initiatingsystem: Optional[str] = None,
        servicemode: Optional[int] = None,
        uuidseqno: Optional[int] = None,
        entity: Optional[str] = None,
        languagecode: Optional[int] = None,
        referenceid: Optional[str] = None,
        requesthash: Optional[str] = None,
        userid: Optional[int] = None
    ) -> Dict[str, Any]:
        """
        View Syndication
        
        Generated from: GET /syndication/viewSyndication/{contractRef}
        Source: swagger_2_0
        Operation ID: SLET0001ViewSyndicationCntrctUsingGET
        
        
        Authentication: Not required
        
        Parameters:
        - contractID: integer (required)
          System Generated Unique Identifier for the contract account
        - contractIDTyp: integer (required)
          Contract account pos type in BaNCS 900  Syndication
        - contractRef: string (required)
          Reference Contract account Number
        
        
        
        Headers:
        - Accesstoken: string
          Authorization Token to validation the caller
        - ChannelType: integer
          Channel identifier from where the TXN has originated (Internet, Mobile, ATM, Branch Channel )
        - Co-Relationid: integer
          Unique ID for the service invoked, will be set by the TXN system
        - InitiatingSystem: string
          Indicating the initiated system
        - ServiceMode: integer
          Used for branch channel to indicate the type of customer
        - UUIDSeqNo: integer
          UUID Sequence Number
        - entity: string
          entity
        - languageCode: integer
          languageCode
        - referenceId: string
          Place holder for Token based authentication
        - requesthash: string
          Request payload for hash validation
        - userId: integer
          userId
        
        
        """
        
        
        # Prepare query parameters
        params = {}
        if contractid is not None:
            params["contractID"] = contractid
            
        if contractidtyp is not None:
            params["contractIDTyp"] = contractidtyp
            
        
        
        # Replace path parameters in URL
        path = "/syndication/viewSyndication/{contractRef}"
        if contractref is not None:
            path = path.replace("{contractRef}", str(contractref))
        
        
        # Prepare headers
        headers = {}
        if accesstoken is not None:
            headers["Accesstoken"] = str(accesstoken)
        if channeltype is not None:
            headers["ChannelType"] = str(channeltype)
        if co_relationid is not None:
            headers["Co-Relationid"] = str(co_relationid)
        if initiatingsystem is not None:
            headers["InitiatingSystem"] = str(initiatingsystem)
        if servicemode is not None:
            headers["ServiceMode"] = str(servicemode)
        if uuidseqno is not None:
            headers["UUIDSeqNo"] = str(uuidseqno)
        if entity is not None:
            headers["entity"] = str(entity)
        if languagecode is not None:
            headers["languageCode"] = str(languagecode)
        if referenceid is not None:
            headers["referenceId"] = str(referenceid)
        if requesthash is not None:
            headers["requesthash"] = str(requesthash)
        if userid is not None:
            headers["userId"] = str(userid)
        
        
        return await make_api_request(
            "GET", 
            path, 
            
            params=params if params else None, 
            headers=headers if headers else None
        )
    
    
    
    @mcp.tool()
    async def slet5801_view_synd_non_fund_postusing_get(
        posnum: int,
        postype: int,
        subtxnposid: int,
        subtxnpostyp: int,
        txnposid: int,
        txnpostyp: int,
        pagenum: Optional[int] = None,
        pagesize: Optional[int] = None,
        entity: Optional[str] = None,
        languagecode: Optional[int] = None,
        userid: Optional[int] = None
    ) -> Dict[str, Any]:
        """
        View Contingent Transaction Details
        
        Generated from: GET /syndication/viewSyndicationNonFund
        Source: swagger_2_0
        Operation ID: SLET5801ViewSyndNonFund_POSTUsingGET
        
        
        Authentication: Not required
        
        Parameters:
        - pageNum: integer
          pageNum
        - pageSize: integer
          pageSize
        - posNum: integer (required)
          Pos Num of sl contract
        - posType: integer (required)
          Pos Type of sl contract
        - subTxnPosId: integer (required)
          Sub Transaction Pos Id of Contingent Transaction
        - subTxnPosTyp: integer (required)
          Sub Transaction Pos Type of Contingent Transaction
        - txnPosId: integer (required)
          Transaction Pos Id of contingent transaction
        - txnPosTyp: integer (required)
          Transaction Pos Type of contingent transaction
        
        
        
        Headers:
        - entity: string
          entity
        - languageCode: integer
          languageCode
        - userId: integer
          userId
        
        
        """
        
        
        # Prepare query parameters
        params = {}
        if pagenum is not None:
            params["pageNum"] = pagenum
            
        if pagesize is not None:
            params["pageSize"] = pagesize
            
        if posnum is not None:
            params["posNum"] = posnum
            
        if postype is not None:
            params["posType"] = postype
            
        if subtxnposid is not None:
            params["subTxnPosId"] = subtxnposid
            
        if subtxnpostyp is not None:
            params["subTxnPosTyp"] = subtxnpostyp
            
        if txnposid is not None:
            params["txnPosId"] = txnposid
            
        if txnpostyp is not None:
            params["txnPosTyp"] = txnpostyp
            
        
        
        # Replace path parameters in URL
        path = "/syndication/viewSyndicationNonFund"
        
        
        # Prepare headers
        headers = {}
        if entity is not None:
            headers["entity"] = str(entity)
        if languagecode is not None:
            headers["languageCode"] = str(languagecode)
        if userid is not None:
            headers["userId"] = str(userid)
        
        
        return await make_api_request(
            "GET", 
            path, 
            
            params=params if params else None, 
            headers=headers if headers else None
        )
    
    
    
    @mcp.tool()
    async def slet0007_view_agency_role_getusing_get(
        posnum: int,
        postype: int,
        pagenum: Optional[int] = None,
        pagesize: Optional[int] = None,
        accesstoken: Optional[str] = None,
        channeltype: Optional[int] = None,
        co_relationid: Optional[int] = None,
        initiatingsystem: Optional[str] = None,
        servicemode: Optional[int] = None,
        uuidseqno: Optional[int] = None,
        entity: Optional[str] = None,
        languagecode: Optional[int] = None,
        referenceid: Optional[str] = None,
        requesthash: Optional[str] = None,
        userid: Optional[int] = None
    ) -> Dict[str, Any]:
        """
        View Agency Role
        
        Generated from: GET /syndication/viewagencyRole
        Source: swagger_2_0
        Operation ID: SLET0007ViewAgencyRole_GETUsingGET
        
        
        Authentication: Not required
        
        Parameters:
        - pageNum: integer
          pageNum
        - pageSize: integer
          pageSize
        - posNum: integer (required)
          posNum
        - posType: integer (required)
          posType
        
        
        
        Headers:
        - Accesstoken: string
          Authorization Token to validation the caller
        - ChannelType: integer
          Channel identifier from where the TXN has originated (Internet, Mobile, ATM, Branch Channel )
        - Co-Relationid: integer
          Unique ID for the service invoked, will be set by the TXN system
        - InitiatingSystem: string
          Indicating the initiated system
        - ServiceMode: integer
          Used for branch channel to indicate the type of customer
        - UUIDSeqNo: integer
          UUID Sequence Number
        - entity: string
          entity
        - languageCode: integer
          languageCode
        - referenceId: string
          Place holder for Token based authentication
        - requesthash: string
          Request payload for hash validation
        - userId: integer
          userId
        
        
        """
        
        
        # Prepare query parameters
        params = {}
        if pagenum is not None:
            params["pageNum"] = pagenum
            
        if pagesize is not None:
            params["pageSize"] = pagesize
            
        if posnum is not None:
            params["posNum"] = posnum
            
        if postype is not None:
            params["posType"] = postype
            
        
        
        # Replace path parameters in URL
        path = "/syndication/viewagencyRole"
        
        
        # Prepare headers
        headers = {}
        if accesstoken is not None:
            headers["Accesstoken"] = str(accesstoken)
        if channeltype is not None:
            headers["ChannelType"] = str(channeltype)
        if co_relationid is not None:
            headers["Co-Relationid"] = str(co_relationid)
        if initiatingsystem is not None:
            headers["InitiatingSystem"] = str(initiatingsystem)
        if servicemode is not None:
            headers["ServiceMode"] = str(servicemode)
        if uuidseqno is not None:
            headers["UUIDSeqNo"] = str(uuidseqno)
        if entity is not None:
            headers["entity"] = str(entity)
        if languagecode is not None:
            headers["languageCode"] = str(languagecode)
        if referenceid is not None:
            headers["referenceId"] = str(referenceid)
        if requesthash is not None:
            headers["requesthash"] = str(requesthash)
        if userid is not None:
            headers["userId"] = str(userid)
        
        
        return await make_api_request(
            "GET", 
            path, 
            
            params=params if params else None, 
            headers=headers if headers else None
        )
    
    
    
    @mcp.tool()
    async def slet5789_view_participant_details_postusing_get(
        arrangementrole: Optional[int] = None,
        pagenum: Optional[int] = None,
        pagesize: Optional[int] = None,
        posnum: Optional[int] = None,
        postype: Optional[int] = None,
        prcptid: Optional[int] = None,
        prcptseqnum: Optional[int] = None,
        salprchseflg: Optional[int] = None,
        syndicationtype: Optional[int] = None,
        accesstoken: Optional[str] = None,
        channeltype: Optional[int] = None,
        co_relationid: Optional[int] = None,
        initiatingsystem: Optional[str] = None,
        servicemode: Optional[int] = None,
        uuidseqno: Optional[int] = None,
        entity: Optional[str] = None,
        languagecode: Optional[int] = None,
        referenceid: Optional[str] = None,
        requesthash: Optional[str] = None,
        userid: Optional[int] = None
    ) -> Dict[str, Any]:
        """
        SLET5789ViewParticipantDetails
        
        Generated from: GET /syndication/viewparticipantdetails
        Source: swagger_2_0
        Operation ID: SLET5789ViewParticipantDetails_POSTUsingGET
        
        
        Authentication: Not required
        
        Parameters:
        - arrangementRole: integer
          arrangementRole
        - pageNum: integer
          pageNum
        - pageSize: integer
          pageSize
        - posNum: integer
          posNum
        - posType: integer
          posType
        - prcptId: integer
          prcptId
        - prcptSeqNum: integer
          prcptSeqNum
        - salPrchseFlg: integer
          salPrchseFlg
        - syndicationType: integer
          syndicationType
        
        
        
        Headers:
        - Accesstoken: string
          Authorization Token to validation the caller
        - ChannelType: integer
          Channel identifier from where the TXN has originated (Internet, Mobile, ATM, Branch Channel )
        - Co-Relationid: integer
          Unique ID for the service invoked, will be set by the TXN system
        - InitiatingSystem: string
          Indicating the initiated system
        - ServiceMode: integer
          Used for branch channel to indicate the type of customer
        - UUIDSeqNo: integer
          UUID Sequence Number
        - entity: string
          entity
        - languageCode: integer
          languageCode
        - referenceId: string
          Place holder for Token based authentication
        - requesthash: string
          Request payload for hash validation
        - userId: integer
          userId
        
        
        """
        
        
        # Prepare query parameters
        params = {}
        if arrangementrole is not None:
            params["arrangementRole"] = arrangementrole
            
        if pagenum is not None:
            params["pageNum"] = pagenum
            
        if pagesize is not None:
            params["pageSize"] = pagesize
            
        if posnum is not None:
            params["posNum"] = posnum
            
        if postype is not None:
            params["posType"] = postype
            
        if prcptid is not None:
            params["prcptId"] = prcptid
            
        if prcptseqnum is not None:
            params["prcptSeqNum"] = prcptseqnum
            
        if salprchseflg is not None:
            params["salPrchseFlg"] = salprchseflg
            
        if syndicationtype is not None:
            params["syndicationType"] = syndicationtype
            
        
        
        # Replace path parameters in URL
        path = "/syndication/viewparticipantdetails"
        
        
        # Prepare headers
        headers = {}
        if accesstoken is not None:
            headers["Accesstoken"] = str(accesstoken)
        if channeltype is not None:
            headers["ChannelType"] = str(channeltype)
        if co_relationid is not None:
            headers["Co-Relationid"] = str(co_relationid)
        if initiatingsystem is not None:
            headers["InitiatingSystem"] = str(initiatingsystem)
        if servicemode is not None:
            headers["ServiceMode"] = str(servicemode)
        if uuidseqno is not None:
            headers["UUIDSeqNo"] = str(uuidseqno)
        if entity is not None:
            headers["entity"] = str(entity)
        if languagecode is not None:
            headers["languageCode"] = str(languagecode)
        if referenceid is not None:
            headers["referenceId"] = str(referenceid)
        if requesthash is not None:
            headers["requesthash"] = str(requesthash)
        if userid is not None:
            headers["userId"] = str(userid)
        
        
        return await make_api_request(
            "GET", 
            path, 
            
            params=params if params else None, 
            headers=headers if headers else None
        )
    
    
    
    @mcp.tool()
    async def slet5789_view_participant_list_postusing_get(
        pagenum: Optional[int] = None,
        pagesize: Optional[int] = None,
        posnum: Optional[int] = None,
        postype: Optional[int] = None,
        salprchseflg: Optional[int] = None,
        accesstoken: Optional[str] = None,
        channeltype: Optional[int] = None,
        co_relationid: Optional[int] = None,
        initiatingsystem: Optional[str] = None,
        servicemode: Optional[int] = None,
        uuidseqno: Optional[int] = None,
        entity: Optional[str] = None,
        languagecode: Optional[int] = None,
        referenceid: Optional[str] = None,
        requesthash: Optional[str] = None,
        userid: Optional[int] = None
    ) -> Dict[str, Any]:
        """
        SLET5789ViewParticipantList
        
        Generated from: GET /syndication/viewparticipantlist
        Source: swagger_2_0
        Operation ID: SLET5789ViewParticipantList_POSTUsingGET
        
        
        Authentication: Not required
        
        Parameters:
        - pageNum: integer
          pageNum
        - pageSize: integer
          pageSize
        - posNum: integer
          posNum
        - posType: integer
          posType
        - salPrchseFlg: integer
          salPrchseFlg
        
        
        
        Headers:
        - Accesstoken: string
          Authorization Token to validation the caller
        - ChannelType: integer
          Channel identifier from where the TXN has originated (Internet, Mobile, ATM, Branch Channel )
        - Co-Relationid: integer
          Unique ID for the service invoked, will be set by the TXN system
        - InitiatingSystem: string
          Indicating the initiated system
        - ServiceMode: integer
          Used for branch channel to indicate the type of customer
        - UUIDSeqNo: integer
          UUID Sequence Number
        - entity: string
          entity
        - languageCode: integer
          languageCode
        - referenceId: string
          Place holder for Token based authentication
        - requesthash: string
          Request payload for hash validation
        - userId: integer
          userId
        
        
        """
        
        
        # Prepare query parameters
        params = {}
        if pagenum is not None:
            params["pageNum"] = pagenum
            
        if pagesize is not None:
            params["pageSize"] = pagesize
            
        if posnum is not None:
            params["posNum"] = posnum
            
        if postype is not None:
            params["posType"] = postype
            
        if salprchseflg is not None:
            params["salPrchseFlg"] = salprchseflg
            
        
        
        # Replace path parameters in URL
        path = "/syndication/viewparticipantlist"
        
        
        # Prepare headers
        headers = {}
        if accesstoken is not None:
            headers["Accesstoken"] = str(accesstoken)
        if channeltype is not None:
            headers["ChannelType"] = str(channeltype)
        if co_relationid is not None:
            headers["Co-Relationid"] = str(co_relationid)
        if initiatingsystem is not None:
            headers["InitiatingSystem"] = str(initiatingsystem)
        if servicemode is not None:
            headers["ServiceMode"] = str(servicemode)
        if uuidseqno is not None:
            headers["UUIDSeqNo"] = str(uuidseqno)
        if entity is not None:
            headers["entity"] = str(entity)
        if languagecode is not None:
            headers["languageCode"] = str(languagecode)
        if referenceid is not None:
            headers["referenceId"] = str(referenceid)
        if requesthash is not None:
            headers["requesthash"] = str(requesthash)
        if userid is not None:
            headers["userId"] = str(userid)
        
        
        return await make_api_request(
            "GET", 
            path, 
            
            params=params if params else None, 
            headers=headers if headers else None
        )
    
    
    
    @mcp.tool()
    async def slet5790_view_syndication_event_postusing_get(
        arrangementidposnum: Optional[int] = None,
        arrangementidpostype: Optional[int] = None,
        eventid: Optional[int] = None,
        eventposnum: Optional[int] = None,
        eventpostype: Optional[int] = None,
        pagenum: Optional[int] = None,
        pagesize: Optional[int] = None,
        accesstoken: Optional[str] = None,
        channeltype: Optional[int] = None,
        co_relationid: Optional[int] = None,
        initiatingsystem: Optional[str] = None,
        servicemode: Optional[int] = None,
        uuidseqno: Optional[int] = None,
        entity: Optional[str] = None,
        languagecode: Optional[int] = None,
        referenceid: Optional[str] = None,
        requesthash: Optional[str] = None,
        userid: Optional[int] = None
    ) -> Dict[str, Any]:
        """
        View Syndication Events
        
        Generated from: GET /syndication/viewsyndicationevent
        Source: swagger_2_0
        Operation ID: SLET5790ViewSyndicationEvent_POSTUsingGET
        
        
        Authentication: Not required
        
        Parameters:
        - arrangementIdPosNum: integer
          arrangementIdPosNum
        - arrangementIdPosType: integer
          arrangementIdPosType
        - eventId: integer
          eventId
        - eventPosNum: integer
          eventPosNum
        - eventPosType: integer
          eventPosType
        - pageNum: integer
          pageNum
        - pageSize: integer
          pageSize
        
        
        
        Headers:
        - Accesstoken: string
          Authorization Token to validation the caller
        - ChannelType: integer
          Channel identifier from where the TXN has originated (Internet, Mobile, ATM, Branch Channel )
        - Co-Relationid: integer
          Unique ID for the service invoked, will be set by the TXN system
        - InitiatingSystem: string
          Indicating the initiated system
        - ServiceMode: integer
          Used for branch channel to indicate the type of customer
        - UUIDSeqNo: integer
          UUID Sequence Number
        - entity: string
          entity
        - languageCode: integer
          languageCode
        - referenceId: string
          Place holder for Token based authentication
        - requesthash: string
          Request payload for hash validation
        - userId: integer
          userId
        
        
        """
        
        
        # Prepare query parameters
        params = {}
        if arrangementidposnum is not None:
            params["arrangementIdPosNum"] = arrangementidposnum
            
        if arrangementidpostype is not None:
            params["arrangementIdPosType"] = arrangementidpostype
            
        if eventid is not None:
            params["eventId"] = eventid
            
        if eventposnum is not None:
            params["eventPosNum"] = eventposnum
            
        if eventpostype is not None:
            params["eventPosType"] = eventpostype
            
        if pagenum is not None:
            params["pageNum"] = pagenum
            
        if pagesize is not None:
            params["pageSize"] = pagesize
            
        
        
        # Replace path parameters in URL
        path = "/syndication/viewsyndicationevent"
        
        
        # Prepare headers
        headers = {}
        if accesstoken is not None:
            headers["Accesstoken"] = str(accesstoken)
        if channeltype is not None:
            headers["ChannelType"] = str(channeltype)
        if co_relationid is not None:
            headers["Co-Relationid"] = str(co_relationid)
        if initiatingsystem is not None:
            headers["InitiatingSystem"] = str(initiatingsystem)
        if servicemode is not None:
            headers["ServiceMode"] = str(servicemode)
        if uuidseqno is not None:
            headers["UUIDSeqNo"] = str(uuidseqno)
        if entity is not None:
            headers["entity"] = str(entity)
        if languagecode is not None:
            headers["languageCode"] = str(languagecode)
        if referenceid is not None:
            headers["referenceId"] = str(referenceid)
        if requesthash is not None:
            headers["requesthash"] = str(requesthash)
        if userid is not None:
            headers["userId"] = str(userid)
        
        
        return await make_api_request(
            "GET", 
            path, 
            
            params=params if params else None, 
            headers=headers if headers else None
        )
    
    
    
    @mcp.tool()
    async def elcbt4001_blamnd_on_holdto_on_hold_postusing_post(
        request_body:Dict[str, Any] ,  # ElcCollectionsBillsModifyAmendmentRequest,
        accesstoken: Optional[str] = None,
        channeltype: Optional[int] = None,
        co_relationid: Optional[int] = None,
        entity: Optional[str] = None,
        initiatingsystem: Optional[str] = None,
        languagecode: Optional[int] = None,
        referenceid: Optional[str] = None,
        servicemode: Optional[int] = None,
        userid: Optional[int] = None,
        uuidseqno: Optional[int] = None
    ) -> Dict[str, Any]:
        """
        Modify Amend Export LC Bill Onhold
        
        Generated from: POST /tradeFinance/ExportLetterOfCredit/bills/amendment/modify
        Source: swagger_2_0
        Operation ID: ELCBT4001BLAmndOnHoldtoOnHold_POSTUsingPOST
        
        
        Authentication: Not required
        
        Parameters:
        - request_body: any (required)
          input
        
        
        
        Headers:
        - Accesstoken: string
          Authorization Token to validation the caller
        - ChannelType: integer
          Channel identifier from where the TXN has originated (Internet, Mobile, ATM, Branch Channel )
        - co-Relationid: integer
          Unique ID for the service invoked, will be set by the TXN system
        - entity: string
          entity
        - initiatingSystem: string
          Indicating the initiated system
        - languageCode: integer
          languageCode
        - referenceId: string
          Place holder for Token based authentication
        - serviceMode: integer
          Used for branch channel to indicate the type of customer
        - userId: integer
          userId
        - uuidSeqNo: integer
          UUID Sequence Number
        
        
        """
        
        
        # Prepare request data
        
        # Single body parameter - send directly
        data = request_body if request_body is not None else {}
        
        
        
        # Prepare query parameters
        params = {}
        
        
        # Replace path parameters in URL
        path = "/tradeFinance/ExportLetterOfCredit/bills/amendment/modify"
        
        
        # Prepare headers
        headers = {}
        if accesstoken is not None:
            headers["Accesstoken"] = str(accesstoken)
        if channeltype is not None:
            headers["ChannelType"] = str(channeltype)
        if co_relationid is not None:
            headers["co-Relationid"] = str(co_relationid)
        if entity is not None:
            headers["entity"] = str(entity)
        if initiatingsystem is not None:
            headers["initiatingSystem"] = str(initiatingsystem)
        if languagecode is not None:
            headers["languageCode"] = str(languagecode)
        if referenceid is not None:
            headers["referenceId"] = str(referenceid)
        if servicemode is not None:
            headers["serviceMode"] = str(servicemode)
        if userid is not None:
            headers["userId"] = str(userid)
        if uuidseqno is not None:
            headers["uuidSeqNo"] = str(uuidseqno)
        
        
        return await make_api_request(
            "POST", 
            path, 
            data=data, 
            params=params if params else None, 
            headers=headers if headers else None
        )
    
    
    
    @mcp.tool()
    async def tfcet0101_fetch_amldetails_postusing_get(
        eventlegid: Optional[int] = None,
        transactionid: Optional[int] = None,
        transactiontyp: Optional[int] = None,
        pagenum: Optional[int] = None,
        pagesize: Optional[int] = None,
        channeltype: Optional[int] = None,
        accesstoken: Optional[str] = None,
        co_relationid: Optional[int] = None,
        initiatingsystem: Optional[str] = None,
        referenceid: Optional[str] = None,
        servicemode: Optional[int] = None,
        uuidseqno: Optional[int] = None
    ) -> Dict[str, Any]:
        """
        AML Name Check List
        
        Generated from: GET /tradeFinance/amkNameCheckList
        Source: swagger_2_0
        Operation ID: TFCET0101FetchAMLDetails_POSTUsingGET
        
        
        Authentication: Not required
        
        Parameters:
        - EventlegId: integer
          EventlegId
        - TransactionId: integer
          Transaction Id
        - TransactionTyp: integer
          Transaction Type
        - pageNum: integer
          pageNum
        - pageSize: integer
          pageSize
        
        
        
        Headers:
        - ChannelType: integer
          Channel identifier from where the TXN has originated (Internet, Mobile, ATM, Branch Channel )
        - accesstoken: string
          Authorization Token to validation the caller
        - co-Relationid: integer
          Unique ID for the service invoked, will be set by the TXN system
        - initiatingSystem: string
          Indicating the initiated system
        - referenceId: string
          Place holder for Token based authentication
        - serviceMode: integer
          Used for branch channel to indicate the type of customer
        - uuidSeqNo: integer
          UUID Sequence Number
        
        
        """
        
        
        # Prepare query parameters
        params = {}
        if eventlegid is not None:
            params["EventlegId"] = eventlegid
            
        if transactionid is not None:
            params["TransactionId"] = transactionid
            
        if transactiontyp is not None:
            params["TransactionTyp"] = transactiontyp
            
        if pagenum is not None:
            params["pageNum"] = pagenum
            
        if pagesize is not None:
            params["pageSize"] = pagesize
            
        
        
        # Replace path parameters in URL
        path = "/tradeFinance/amkNameCheckList"
        
        
        # Prepare headers
        headers = {}
        if channeltype is not None:
            headers["ChannelType"] = str(channeltype)
        if accesstoken is not None:
            headers["accesstoken"] = str(accesstoken)
        if co_relationid is not None:
            headers["co-Relationid"] = str(co_relationid)
        if initiatingsystem is not None:
            headers["initiatingSystem"] = str(initiatingsystem)
        if referenceid is not None:
            headers["referenceId"] = str(referenceid)
        if servicemode is not None:
            headers["serviceMode"] = str(servicemode)
        if uuidseqno is not None:
            headers["uuidSeqNo"] = str(uuidseqno)
        
        
        return await make_api_request(
            "GET", 
            path, 
            
            params=params if params else None, 
            headers=headers if headers else None
        )
    
    
    
    @mcp.tool()
    async def tfpbt0834_amlcheck_rsp_postusing_post(
        request_body:Dict[str, Any] ,  # amlCheckRequest,
        accesstoken: Optional[str] = None,
        channeltype: Optional[int] = None,
        co_relationid: Optional[int] = None,
        entity: Optional[str] = None,
        initiatingsystem: Optional[str] = None,
        languagecode: Optional[int] = None,
        referenceid: Optional[str] = None,
        servicemode: Optional[int] = None,
        userid: Optional[int] = None,
        uuidseqno: Optional[int] = None
    ) -> Dict[str, Any]:
        """
        Aml Check Response
        
        Generated from: POST /tradeFinance/amlCheckResponse
        Source: swagger_2_0
        Operation ID: TFPBT0834AMLCheckRsp_POSTUsingPOST
        
        
        Authentication: Not required
        
        Parameters:
        - request_body: any (required)
          input
        
        
        
        Headers:
        - Accesstoken: string
          Authorization Token to validation the caller
        - channelType: integer
          Channel identifier from where the TXN has originated (Internet, Mobile, ATM, Branch Channel )
        - co-Relationid: integer
          Unique ID for the service invoked, will be set by the TXN system
        - entity: string
          entity
        - initiatingSystem: string
          Indicating the initiated system
        - languageCode: integer
          languageCode
        - referenceId: string
          Place holder for Token based authentication
        - serviceMode: integer
          Used for branch channel to indicate the type of customer
        - userId: integer
          userId
        - uuidSeqNo: integer
          UUID Sequence Number
        
        
        """
        
        
        # Prepare request data
        
        # Single body parameter - send directly
        data = request_body if request_body is not None else {}
        
        
        
        # Prepare query parameters
        params = {}
        
        
        # Replace path parameters in URL
        path = "/tradeFinance/amlCheckResponse"
        
        
        # Prepare headers
        headers = {}
        if accesstoken is not None:
            headers["Accesstoken"] = str(accesstoken)
        if channeltype is not None:
            headers["channelType"] = str(channeltype)
        if co_relationid is not None:
            headers["co-Relationid"] = str(co_relationid)
        if entity is not None:
            headers["entity"] = str(entity)
        if initiatingsystem is not None:
            headers["initiatingSystem"] = str(initiatingsystem)
        if languagecode is not None:
            headers["languageCode"] = str(languagecode)
        if referenceid is not None:
            headers["referenceId"] = str(referenceid)
        if servicemode is not None:
            headers["serviceMode"] = str(servicemode)
        if userid is not None:
            headers["userId"] = str(userid)
        if uuidseqno is not None:
            headers["uuidSeqNo"] = str(uuidseqno)
        
        
        return await make_api_request(
            "POST", 
            path, 
            data=data, 
            params=params if params else None, 
            headers=headers if headers else None
        )
    
    
    
    @mcp.tool()
    async def tfbt6901_crt_bgamnd_on_hold_wrapper_postusing_post(
        request_body:Dict[str, Any] ,  # RegisterBankGuaranteeAmendRequest,
        accesstoken: Optional[str] = None,
        channeltype: Optional[int] = None,
        co_relationid: Optional[int] = None,
        entity: Optional[str] = None,
        initiatingsystem: Optional[str] = None,
        languagecode: Optional[int] = None,
        referenceid: Optional[str] = None,
        servicemode: Optional[int] = None,
        userid: Optional[int] = None,
        uuidseqno: Optional[int] = None
    ) -> Dict[str, Any]:
        """
        Bank Guarantee Amend
        
        Generated from: POST /tradeFinance/bankGuarantee/amend
        Source: swagger_2_0
        Operation ID: TFBT6901CrtBGAmndOnHold_wrapper_POSTUsingPOST
        
        
        Authentication: Not required
        
        Parameters:
        - request_body: any (required)
          input
        
        
        
        Headers:
        - Accesstoken: string
          Authorization Token to validation the caller
        - ChannelType: integer
          Channel identifier from where the TXN has originated (Internet, Mobile, ATM, Branch Channel )
        - co-Relationid: integer
          Unique ID for the service invoked, will be set by the TXN system
        - entity: string
          entity
        - initiatingSystem: string
          Indicating the initiated system
        - languageCode: integer
          languageCode
        - referenceId: string
          Place holder for Token based authentication
        - serviceMode: integer
          Used for branch channel to indicate the type of customer
        - userId: integer
          userId
        - uuidSeqNo: integer
          UUID Sequence Number
        
        
        """
        
        
        # Prepare request data
        
        # Single body parameter - send directly
        data = request_body if request_body is not None else {}
        
        
        
        # Prepare query parameters
        params = {}
        
        
        # Replace path parameters in URL
        path = "/tradeFinance/bankGuarantee/amend"
        
        
        # Prepare headers
        headers = {}
        if accesstoken is not None:
            headers["Accesstoken"] = str(accesstoken)
        if channeltype is not None:
            headers["ChannelType"] = str(channeltype)
        if co_relationid is not None:
            headers["co-Relationid"] = str(co_relationid)
        if entity is not None:
            headers["entity"] = str(entity)
        if initiatingsystem is not None:
            headers["initiatingSystem"] = str(initiatingsystem)
        if languagecode is not None:
            headers["languageCode"] = str(languagecode)
        if referenceid is not None:
            headers["referenceId"] = str(referenceid)
        if servicemode is not None:
            headers["serviceMode"] = str(servicemode)
        if userid is not None:
            headers["userId"] = str(userid)
        if uuidseqno is not None:
            headers["uuidSeqNo"] = str(uuidseqno)
        
        
        return await make_api_request(
            "POST", 
            path, 
            data=data, 
            params=params if params else None, 
            headers=headers if headers else None
        )
    
    
    
    @mcp.tool()
    async def tfbt6910_bgamnd_verified_to_on_hold_postusing_put(
        amendreferenceexternal: str,
        amendreferenceinternal: Optional[str] = None,
        bgtransactionid: Optional[int] = None,
        channeltransactionid: Optional[int] = None,
        eventlegid: Optional[int] = None,
        channeltype: Optional[int] = None,
        accesstoken: Optional[str] = None,
        co_relationid: Optional[int] = None,
        entity: Optional[str] = None,
        initiatingsystem: Optional[str] = None,
        languagecode: Optional[int] = None,
        referenceid: Optional[str] = None,
        requesthash: Optional[str] = None,
        servicemode: Optional[int] = None,
        userid: Optional[int] = None,
        uuidseqno: Optional[int] = None
    ) -> Dict[str, Any]:
        """
        BG Amend Sendback
        
        Generated from: PUT /tradeFinance/bankGuarantee/amend/{amendReferenceExternal}/sendback
        Source: swagger_2_0
        Operation ID: TFBT6910BGAmndVerifiedToOnHold_POSTUsingPUT
        
        
        Authentication: Not required
        
        Parameters:
        - amendReferenceExternal: string (required)
          Amend Reference external
        - amendReferenceInternal: string
          Amend Reference Internal
        - bgTransactionID: integer
          BG Transaction ID
        - channelTransactionId: integer
          Channel Transaction Id For Send Back
        - eventLegID: integer
          Event Leg ID
        
        
        
        Headers:
        - ChannelType: integer
          Channel identifier from where the TXN has originated (Internet, Mobile, ATM, Branch Channel )
        - accesstoken: string
          Authorization Token to validation the caller
        - co-Relationid: integer
          Unique ID for the service invoked, will be set by the TXN system
        - entity: string
          entity
        - initiatingSystem: string
          Indicating the initiated system
        - languageCode: integer
          languageCode
        - referenceId: string
          Place holder for Token based authentication
        - requesthash: string
          Request payload for hash validation
        - serviceMode: integer
          Used for branch channel to indicate the type of customer
        - userId: integer
          userId
        - uuidSeqNo: integer
          UUID Sequence Number
        
        
        """
        
        
        # Prepare query parameters
        params = {}
        if amendreferenceinternal is not None:
            params["amendReferenceInternal"] = amendreferenceinternal
            
        if bgtransactionid is not None:
            params["bgTransactionID"] = bgtransactionid
            
        if channeltransactionid is not None:
            params["channelTransactionId"] = channeltransactionid
            
        if eventlegid is not None:
            params["eventLegID"] = eventlegid
            
        
        
        # Replace path parameters in URL
        path = "/tradeFinance/bankGuarantee/amend/{amendReferenceExternal}/sendback"
        if amendreferenceexternal is not None:
            path = path.replace("{amendReferenceExternal}", str(amendreferenceexternal))
        
        
        # Prepare headers
        headers = {}
        if channeltype is not None:
            headers["ChannelType"] = str(channeltype)
        if accesstoken is not None:
            headers["accesstoken"] = str(accesstoken)
        if co_relationid is not None:
            headers["co-Relationid"] = str(co_relationid)
        if entity is not None:
            headers["entity"] = str(entity)
        if initiatingsystem is not None:
            headers["initiatingSystem"] = str(initiatingsystem)
        if languagecode is not None:
            headers["languageCode"] = str(languagecode)
        if referenceid is not None:
            headers["referenceId"] = str(referenceid)
        if requesthash is not None:
            headers["requesthash"] = str(requesthash)
        if servicemode is not None:
            headers["serviceMode"] = str(servicemode)
        if userid is not None:
            headers["userId"] = str(userid)
        if uuidseqno is not None:
            headers["uuidSeqNo"] = str(uuidseqno)
        
        
        return await make_api_request(
            "PUT", 
            path, 
            
            params=params if params else None, 
            headers=headers if headers else None
        )
    
    
    
    @mcp.tool()
    async def tfbt6020_bgamend_acpt_refusal_postusing_put(
        amendrefinternal: str,
        request_body:Dict[str, Any] ,  # bgAmendAcceptRefusalReq,
        accesstoken: Optional[str] = None,
        channeltype: Optional[int] = None,
        co_relationid: Optional[int] = None,
        entity: Optional[str] = None,
        initiatingsystem: Optional[str] = None,
        languagecode: Optional[int] = None,
        referenceid: Optional[str] = None,
        servicemode: Optional[int] = None,
        userid: Optional[int] = None,
        uuidseqno: Optional[int] = None
    ) -> Dict[str, Any]:
        """
        Bank Guarantee Amendment Acceptance Refusal
        
        Generated from: PUT /tradeFinance/bankGuarantee/amendment/{amendRefInternal}/acceptrefusal
        Source: swagger_2_0
        Operation ID: TFBT6020BGAmendAcptRefusal_POSTUsingPUT
        
        
        Authentication: Not required
        
        Parameters:
        - amendRefInternal: string (required)
          Amendment Reference Internal
        - request_body: any (required)
          input
        
        
        
        Headers:
        - Accesstoken: string
          Authorization Token to validation the caller
        - ChannelType: integer
          Channel identifier from where the TXN has originated (Internet, Mobile, ATM, Branch Channel )
        - co-Relationid: integer
          Unique ID for the service invoked, will be set by the TXN system
        - entity: string
          entity
        - initiatingSystem: string
          Indicating the initiated system
        - languageCode: integer
          languageCode
        - referenceId: string
          Place holder for Token based authentication
        - serviceMode: integer
          Used for branch channel to indicate the type of customer
        - userId: integer
          userId
        - uuidSeqNo: integer
          UUID Sequence Number
        
        
        """
        
        
        # Prepare request data
        
        # Single body parameter - send directly
        data = request_body if request_body is not None else {}
        
        
        
        # Prepare query parameters
        params = {}
        
        
        # Replace path parameters in URL
        path = "/tradeFinance/bankGuarantee/amendment/{amendRefInternal}/acceptrefusal"
        if amendrefinternal is not None:
            path = path.replace("{amendRefInternal}", str(amendrefinternal))
        
        
        # Prepare headers
        headers = {}
        if accesstoken is not None:
            headers["Accesstoken"] = str(accesstoken)
        if channeltype is not None:
            headers["ChannelType"] = str(channeltype)
        if co_relationid is not None:
            headers["co-Relationid"] = str(co_relationid)
        if entity is not None:
            headers["entity"] = str(entity)
        if initiatingsystem is not None:
            headers["initiatingSystem"] = str(initiatingsystem)
        if languagecode is not None:
            headers["languageCode"] = str(languagecode)
        if referenceid is not None:
            headers["referenceId"] = str(referenceid)
        if servicemode is not None:
            headers["serviceMode"] = str(servicemode)
        if userid is not None:
            headers["userId"] = str(userid)
        if uuidseqno is not None:
            headers["uuidSeqNo"] = str(uuidseqno)
        
        
        return await make_api_request(
            "PUT", 
            path, 
            data=data, 
            params=params if params else None, 
            headers=headers if headers else None
        )
    
    
    
    @mcp.tool()
    async def tfbt6019_bgamend_acknowledge_postusing_put(
        amendrefinternal: str,
        acknowledgedate: Optional[str] = None,
        accesstoken: Optional[str] = None,
        channeltype: Optional[int] = None,
        co_relationid: Optional[int] = None,
        entity: Optional[str] = None,
        initiatingsystem: Optional[str] = None,
        languagecode: Optional[int] = None,
        referenceid: Optional[str] = None,
        servicemode: Optional[int] = None,
        userid: Optional[int] = None,
        uuidseqno: Optional[int] = None
    ) -> Dict[str, Any]:
        """
        Bank Guarantee Amendment Acknowledgement
        
        Generated from: PUT /tradeFinance/bankGuarantee/amendment/{amendRefInternal}/acknowledge
        Source: swagger_2_0
        Operation ID: TFBT6019BGAmendAcknowledge_POSTUsingPUT
        
        
        Authentication: Not required
        
        Parameters:
        - acknowledgeDate: string
          Acknowledge Date [yyyyMMdd]
        - amendRefInternal: string (required)
          Amendment Reference Internal
        
        
        
        Headers:
        - Accesstoken: string
          Authorization Token to validation the caller
        - ChannelType: integer
          Channel identifier from where the TXN has originated (Internet, Mobile, ATM, Branch Channel )
        - co-Relationid: integer
          Unique ID for the service invoked, will be set by the TXN system
        - entity: string
          entity
        - initiatingSystem: string
          Indicating the initiated system
        - languageCode: integer
          languageCode
        - referenceId: string
          Place holder for Token based authentication
        - serviceMode: integer
          Used for branch channel to indicate the type of customer
        - userId: integer
          userId
        - uuidSeqNo: integer
          UUID Sequence Number
        
        
        """
        
        
        # Prepare query parameters
        params = {}
        if acknowledgedate is not None:
            params["acknowledgeDate"] = acknowledgedate
            
        
        
        # Replace path parameters in URL
        path = "/tradeFinance/bankGuarantee/amendment/{amendRefInternal}/acknowledge"
        if amendrefinternal is not None:
            path = path.replace("{amendRefInternal}", str(amendrefinternal))
        
        
        # Prepare headers
        headers = {}
        if accesstoken is not None:
            headers["Accesstoken"] = str(accesstoken)
        if channeltype is not None:
            headers["ChannelType"] = str(channeltype)
        if co_relationid is not None:
            headers["co-Relationid"] = str(co_relationid)
        if entity is not None:
            headers["entity"] = str(entity)
        if initiatingsystem is not None:
            headers["initiatingSystem"] = str(initiatingsystem)
        if languagecode is not None:
            headers["languageCode"] = str(languagecode)
        if referenceid is not None:
            headers["referenceId"] = str(referenceid)
        if servicemode is not None:
            headers["serviceMode"] = str(servicemode)
        if userid is not None:
            headers["userId"] = str(userid)
        if uuidseqno is not None:
            headers["uuidSeqNo"] = str(uuidseqno)
        
        
        return await make_api_request(
            "PUT", 
            path, 
            
            params=params if params else None, 
            headers=headers if headers else None
        )
    
    
    
    @mcp.tool()
    async def tfbt7004_unblck_auth_postusing_post(
        request_body:Dict[str, Any] ,  # TF_BANK_GUARANTEE_TFBT7004UnblckAuth_Resource
    ) -> Dict[str, Any]:
        """
        Manual Auto Release Of Margin
        
        Generated from: POST /tradeFinance/bankGuarantee/autoRelease/unblock
        Source: swagger_2_0
        Operation ID: TFBT7004UnblckAuth_POSTUsingPOST
        
        
        Authentication: Not required
        
        Parameters:
        - request_body: any (required)
          input
        
        
        
        """
        
        
        # Prepare request data
        
        # Single body parameter - send directly
        data = request_body if request_body is not None else {}
        
        
        
        # Prepare query parameters
        params = {}
        
        
        # Replace path parameters in URL
        path = "/tradeFinance/bankGuarantee/autoRelease/unblock"
        
        
        # Prepare headers
        headers = {}
        
        
        return await make_api_request(
            "POST", 
            path, 
            data=data, 
            params=params if params else None, 
            headers=headers if headers else None
        )
    
    
    
    @mcp.tool()
    async def tfbt6028_bgcncl_cls_wrapper_postusing_post(
        request_body:Dict[str, Any] ,  # RegisterBankGuaranteeCancelRequest,
        accesstoken: Optional[str] = None,
        channeltype: Optional[int] = None,
        co_relationid: Optional[int] = None,
        entity: Optional[str] = None,
        initiatingsystem: Optional[str] = None,
        languagecode: Optional[int] = None,
        referenceid: Optional[str] = None,
        servicemode: Optional[int] = None,
        userid: Optional[int] = None,
        uuidseqno: Optional[int] = None
    ) -> Dict[str, Any]:
        """
        Bank Guarantee Cancel
        
        Generated from: POST /tradeFinance/bankGuarantee/cancel
        Source: swagger_2_0
        Operation ID: TFBT6028BGCnclCls_wrapper_POSTUsingPOST
        
        
        Authentication: Not required
        
        Parameters:
        - request_body: any (required)
          input
        
        
        
        Headers:
        - Accesstoken: string
          Authorization Token to validation the caller
        - ChannelType: integer
          Channel identifier from where the TXN has originated (Internet, Mobile, ATM, Branch Channel )
        - co-Relationid: integer
          Unique ID for the service invoked, will be set by the TXN system
        - entity: string
          entity
        - initiatingSystem: string
          Indicating the initiated system
        - languageCode: integer
          languageCode
        - referenceId: string
          Place holder for Token based authentication
        - serviceMode: integer
          Used for branch channel to indicate the type of customer
        - userId: integer
          userId
        - uuidSeqNo: integer
          UUID Sequence Number
        
        
        """
        
        
        # Prepare request data
        
        # Single body parameter - send directly
        data = request_body if request_body is not None else {}
        
        
        
        # Prepare query parameters
        params = {}
        
        
        # Replace path parameters in URL
        path = "/tradeFinance/bankGuarantee/cancel"
        
        
        # Prepare headers
        headers = {}
        if accesstoken is not None:
            headers["Accesstoken"] = str(accesstoken)
        if channeltype is not None:
            headers["ChannelType"] = str(channeltype)
        if co_relationid is not None:
            headers["co-Relationid"] = str(co_relationid)
        if entity is not None:
            headers["entity"] = str(entity)
        if initiatingsystem is not None:
            headers["initiatingSystem"] = str(initiatingsystem)
        if languagecode is not None:
            headers["languageCode"] = str(languagecode)
        if referenceid is not None:
            headers["referenceId"] = str(referenceid)
        if servicemode is not None:
            headers["serviceMode"] = str(servicemode)
        if userid is not None:
            headers["userId"] = str(userid)
        if uuidseqno is not None:
            headers["uuidSeqNo"] = str(uuidseqno)
        
        
        return await make_api_request(
            "POST", 
            path, 
            data=data, 
            params=params if params else None, 
            headers=headers if headers else None
        )
    
    
    
    @mcp.tool()
    async def tfbt6001_crt_bgon_hold_wrapper_postusing_post(
        request_body:Dict[str, Any] ,  # RegisterBankGuaranteeCreateRequest,
        accesstoken: Optional[str] = None,
        channeltype: Optional[int] = None,
        co_relationid: Optional[int] = None,
        entity: Optional[str] = None,
        initiatingsystem: Optional[str] = None,
        languagecode: Optional[int] = None,
        referenceid: Optional[str] = None,
        servicemode: Optional[int] = None,
        userid: Optional[int] = None,
        uuidseqno: Optional[int] = None
    ) -> Dict[str, Any]:
        """
        Bank Guarantee Create
        
        Generated from: POST /tradeFinance/bankGuarantee/create
        Source: swagger_2_0
        Operation ID: TFBT6001CrtBGOnHold_wrapper_POSTUsingPOST
        
        
        Authentication: Not required
        
        Parameters:
        - request_body: any (required)
          input
        
        
        
        Headers:
        - Accesstoken: string
          Authorization Token to validation the caller
        - ChannelType: integer
          Channel identifier from where the TXN has originated (Internet, Mobile, ATM, Branch Channel )
        - co-Relationid: integer
          Unique ID for the service invoked, will be set by the TXN system
        - entity: string
          entity
        - initiatingSystem: string
          Indicating the initiated system
        - languageCode: integer
          languageCode
        - referenceId: string
          Place holder for Token based authentication
        - serviceMode: integer
          Used for branch channel to indicate the type of customer
        - userId: integer
          userId
        - uuidSeqNo: integer
          UUID Sequence Number
        
        
        """
        
        
        # Prepare request data
        
        # Single body parameter - send directly
        data = request_body if request_body is not None else {}
        
        
        
        # Prepare query parameters
        params = {}
        
        
        # Replace path parameters in URL
        path = "/tradeFinance/bankGuarantee/create"
        
        
        # Prepare headers
        headers = {}
        if accesstoken is not None:
            headers["Accesstoken"] = str(accesstoken)
        if channeltype is not None:
            headers["ChannelType"] = str(channeltype)
        if co_relationid is not None:
            headers["co-Relationid"] = str(co_relationid)
        if entity is not None:
            headers["entity"] = str(entity)
        if initiatingsystem is not None:
            headers["initiatingSystem"] = str(initiatingsystem)
        if languagecode is not None:
            headers["languageCode"] = str(languagecode)
        if referenceid is not None:
            headers["referenceId"] = str(referenceid)
        if servicemode is not None:
            headers["serviceMode"] = str(servicemode)
        if userid is not None:
            headers["userId"] = str(userid)
        if uuidseqno is not None:
            headers["uuidSeqNo"] = str(uuidseqno)
        
        
        return await make_api_request(
            "POST", 
            path, 
            data=data, 
            params=params if params else None, 
            headers=headers if headers else None
        )
    
    
    
    @mcp.tool()
    async def tfet6015_fetch_bglist_postusing_get(
        approximateexpirydate: Optional[str] = None,
        beneficiaryname: Optional[str] = None,
        bgamount: Optional[float] = None,
        bginstrumentid: Optional[int] = None,
        bginternalreference: Optional[str] = None,
        bgtransactionid: Optional[int] = None,
        bgtype: Optional[int] = None,
        customername: Optional[str] = None,
        customerreference: Optional[int] = None,
        expirydate: Optional[str] = None,
        pagenum: Optional[int] = None,
        pagesize: Optional[int] = None,
        startdate: Optional[str] = None,
        status: Optional[int] = None,
        channeltype: Optional[int] = None,
        co_relationid: Optional[int] = None,
        entity: Optional[str] = None,
        initiatingsystem: Optional[str] = None,
        languagecode: Optional[int] = None,
        servicemode: Optional[int] = None,
        userid: Optional[int] = None,
        uuidseqno: Optional[int] = None
    ) -> Dict[str, Any]:
        """
        Bank Guarantee Issue List
        
        Generated from: GET /tradeFinance/bankGuarantee/issue/list
        Source: swagger_2_0
        Operation ID: TFET6015FetchBGList_POSTUsingGET
        
        
        Authentication: Not required
        
        Parameters:
        - approximateExpiryDate: string
          Approximate Expiry Date. Date Format [dd/MM/yyyy]
        - beneficiaryName: string
          Beneficiary Name
        - bgAmount: number
          BG Amount
        - bgInstrumentId: integer
          BG Instrument ID
        - bgInternalReference: string
          BG Internal Reference
        - bgTransactionId: integer
          BG Transaction ID
        - bgType: integer
          Bank Guarantee Type  .Possible Values : 2 : Advance Payment Guarantee,3 : Performance Guarantee,6 : Payment Guarantee,12 : Any,13 : Financial Guarantee,14 : Formal Guarantee,15 : Bid Bond/EMD,Guarantee,19 : Retention Money Release Guarantee,20 : Shipping Guarantee.Domain: d_TFBGType
        - customerName: string
          Customer Name
        - customerReference: integer
          Customer Reference
        - expiryDate: string
          Expiry Date. Date Format : [dd/MM/yyyy]
        - pageNum: integer
          pageNum
        - pageSize: integer
          pageSize
        - startDate: string
          Start Date. Date Format : [dd/MM/yyyy]
        - status: integer
          BG Status.Possible Values: 1 - OnHold, 2 - Released, 3 - Verified, 4 - PendingClosure, 5 - Closed, 6 - Executed, 7 - Expired, 8 - Rejected, 9 - WaitingForRate, 10 - AmndmntInit, 11 - AcptRefPndng, 13 - Refused, 12 - Final1, 14 - SuspWdrwPndng, 15 - CnclClosePndng, 16 - RevivalPndng, 17 - Cancelled Domain  - d_TFBGStatus 
        
        
        
        Headers:
        - ChannelType: integer
          Channel identifier from where the TXN has originated (Internet, Mobile, ATM, Branch Channel )
        - co-Relationid: integer
          Unique ID for the service invoked, will be set by the TXN system
        - entity: string
          entity
        - initiatingSystem: string
          Indicating the initiated system
        - languageCode: integer
          languageCode
        - serviceMode: integer
          Used for branch channel to indicate the type of customer
        - userId: integer
          userId
        - uuidSeqNo: integer
          UUID Sequence Number
        
        
        """
        
        
        # Prepare query parameters
        params = {}
        if approximateexpirydate is not None:
            params["approximateExpiryDate"] = approximateexpirydate
            
        if beneficiaryname is not None:
            params["beneficiaryName"] = beneficiaryname
            
        if bgamount is not None:
            params["bgAmount"] = bgamount
            
        if bginstrumentid is not None:
            params["bgInstrumentId"] = bginstrumentid
            
        if bginternalreference is not None:
            params["bgInternalReference"] = bginternalreference
            
        if bgtransactionid is not None:
            params["bgTransactionId"] = bgtransactionid
            
        if bgtype is not None:
            params["bgType"] = bgtype
            
        if customername is not None:
            params["customerName"] = customername
            
        if customerreference is not None:
            params["customerReference"] = customerreference
            
        if expirydate is not None:
            params["expiryDate"] = expirydate
            
        if pagenum is not None:
            params["pageNum"] = pagenum
            
        if pagesize is not None:
            params["pageSize"] = pagesize
            
        if startdate is not None:
            params["startDate"] = startdate
            
        if status is not None:
            params["status"] = status
            
        
        
        # Replace path parameters in URL
        path = "/tradeFinance/bankGuarantee/issue/list"
        
        
        # Prepare headers
        headers = {}
        if channeltype is not None:
            headers["ChannelType"] = str(channeltype)
        if co_relationid is not None:
            headers["co-Relationid"] = str(co_relationid)
        if entity is not None:
            headers["entity"] = str(entity)
        if initiatingsystem is not None:
            headers["initiatingSystem"] = str(initiatingsystem)
        if languagecode is not None:
            headers["languageCode"] = str(languagecode)
        if servicemode is not None:
            headers["serviceMode"] = str(servicemode)
        if userid is not None:
            headers["userId"] = str(userid)
        if uuidseqno is not None:
            headers["uuidSeqNo"] = str(uuidseqno)
        
        
        return await make_api_request(
            "GET", 
            path, 
            
            params=params if params else None, 
            headers=headers if headers else None
        )
    
    
    
    @mcp.tool()
    async def tfbt6009_auth_bgwrapper_postusing_put(
        bgreferenceexternal: str,
        request_body:Dict[str, Any] ,  # AuthBgResource,
        authoriseflag: Optional[int] = None,
        authoriseremarks: Optional[str] = None,
        modeflag: Optional[int] = None,
        channeltype: Optional[int] = None,
        co_relationid: Optional[int] = None,
        entity: Optional[str] = None,
        initiatingsystem: Optional[str] = None,
        languagecode: Optional[int] = None,
        servicemode: Optional[int] = None,
        userid: Optional[int] = None,
        uuidseqno: Optional[int] = None
    ) -> Dict[str, Any]:
        """
        AuthBG
        
        Generated from: PUT /tradeFinance/bankGuarantee/issue/{bgReferenceExternal}/authorise
        Source: swagger_2_0
        Operation ID: TFBT6009AuthBGWrapper_POSTUsingPUT
        
        
        Authentication: Not required
        
        Parameters:
        - AuthoriseFlag: integer
          Authorise Flag. Possible values : 1 - Authorise, 2 - Reject, 3 - Sent Back Domain name : d_VerAuthFlg
        - AuthoriseRemarks: string
          Authorise Remarks
        - bgReferenceExternal: string (required)
          BG Reference External
        - modeFlag: integer
          Mode Flag. Possible values : 9 - Release , Default empty for Authorise service. Domain name : d_ModeFlg
        - request_body: any (required)
          input
        
        
        
        Headers:
        - ChannelType: integer
          Channel identifier from where the TXN has originated (Internet, Mobile, ATM, Branch Channel )
        - co-Relationid: integer
          Unique ID for the service invoked, will be set by the TXN system
        - entity: string
          entity
        - initiatingSystem: string
          Indicating the initiated system
        - languageCode: integer
          languageCode
        - serviceMode: integer
          Used for branch channel to indicate the type of customer
        - userId: integer
          userId
        - uuidSeqNo: integer
          UUID Sequence Number
        
        
        """
        
        
        # Prepare request data
        
        # Single body parameter - send directly
        data = request_body if request_body is not None else {}
        
        
        
        # Prepare query parameters
        params = {}
        if authoriseflag is not None:
            params["AuthoriseFlag"] = authoriseflag
            
        if authoriseremarks is not None:
            params["AuthoriseRemarks"] = authoriseremarks
            
        if modeflag is not None:
            params["modeFlag"] = modeflag
            
        
        
        # Replace path parameters in URL
        path = "/tradeFinance/bankGuarantee/issue/{bgReferenceExternal}/authorise"
        if bgreferenceexternal is not None:
            path = path.replace("{bgReferenceExternal}", str(bgreferenceexternal))
        
        
        # Prepare headers
        headers = {}
        if channeltype is not None:
            headers["ChannelType"] = str(channeltype)
        if co_relationid is not None:
            headers["co-Relationid"] = str(co_relationid)
        if entity is not None:
            headers["entity"] = str(entity)
        if initiatingsystem is not None:
            headers["initiatingSystem"] = str(initiatingsystem)
        if languagecode is not None:
            headers["languageCode"] = str(languagecode)
        if servicemode is not None:
            headers["serviceMode"] = str(servicemode)
        if userid is not None:
            headers["userId"] = str(userid)
        if uuidseqno is not None:
            headers["uuidSeqNo"] = str(uuidseqno)
        
        
        return await make_api_request(
            "PUT", 
            path, 
            data=data, 
            params=params if params else None, 
            headers=headers if headers else None
        )
    
    
    
    @mcp.tool()
    async def tfbt6004_bgon_hold_to_rjct_postusing_put(
        bgreferenceexternal: str,
        request_body:Dict[str, Any] ,  # BankGuaranteeIssueCancelOnHoldRequest,
        channeltype: Optional[int] = None,
        co_relationid: Optional[int] = None,
        entity: Optional[str] = None,
        initiatingsystem: Optional[str] = None,
        languagecode: Optional[int] = None,
        servicemode: Optional[int] = None,
        userid: Optional[int] = None,
        uuidseqno: Optional[int] = None
    ) -> Dict[str, Any]:
        """
        Bank Guarantee Issue Cancel On Hold
        
        Generated from: PUT /tradeFinance/bankGuarantee/issue/{bgReferenceExternal}/cancelOnHold
        Source: swagger_2_0
        Operation ID: TFBT6004BGOnHoldToRjct_POSTUsingPUT
        
        
        Authentication: Not required
        
        Parameters:
        - bgReferenceExternal: string (required)
          BG External Reference
        - request_body: any (required)
          input
        
        
        
        Headers:
        - ChannelType: integer
          Channel identifier from where the TXN has originated (Internet, Mobile, ATM, Branch Channel )
        - co-Relationid: integer
          Unique ID for the service invoked, will be set by the TXN system
        - entity: string
          entity
        - initiatingSystem: string
          Indicating the initiated system
        - languageCode: integer
          languageCode
        - serviceMode: integer
          Used for branch channel to indicate the type of customer
        - userId: integer
          userId
        - uuidSeqNo: integer
          UUID Sequence Number
        
        
        """
        
        
        # Prepare request data
        
        # Single body parameter - send directly
        data = request_body if request_body is not None else {}
        
        
        
        # Prepare query parameters
        params = {}
        
        
        # Replace path parameters in URL
        path = "/tradeFinance/bankGuarantee/issue/{bgReferenceExternal}/cancelOnHold"
        if bgreferenceexternal is not None:
            path = path.replace("{bgReferenceExternal}", str(bgreferenceexternal))
        
        
        # Prepare headers
        headers = {}
        if channeltype is not None:
            headers["ChannelType"] = str(channeltype)
        if co_relationid is not None:
            headers["co-Relationid"] = str(co_relationid)
        if entity is not None:
            headers["entity"] = str(entity)
        if initiatingsystem is not None:
            headers["initiatingSystem"] = str(initiatingsystem)
        if languagecode is not None:
            headers["languageCode"] = str(languagecode)
        if servicemode is not None:
            headers["serviceMode"] = str(servicemode)
        if userid is not None:
            headers["userId"] = str(userid)
        if uuidseqno is not None:
            headers["uuidSeqNo"] = str(uuidseqno)
        
        
        return await make_api_request(
            "PUT", 
            path, 
            data=data, 
            params=params if params else None, 
            headers=headers if headers else None
        )
    
    
    
    @mcp.tool()
    async def tfet6043_fetch_bgmrgn_dtls_postusing_get(
        bgreferenceexternal: str,
        channeltype: Optional[int] = None,
        co_relationid: Optional[int] = None,
        entity: Optional[str] = None,
        initiatingsystem: Optional[str] = None,
        languagecode: Optional[int] = None,
        servicemode: Optional[int] = None,
        userid: Optional[int] = None,
        uuidseqno: Optional[int] = None
    ) -> Dict[str, Any]:
        """
        Fetch Bank Guarantee Margin Details
        
        Generated from: GET /tradeFinance/bankGuarantee/issue/{bgReferenceExternal}/marginDetails
        Source: swagger_2_0
        Operation ID: TFET6043FetchBGMrgnDtls_POSTUsingGET
        
        
        Authentication: Not required
        
        Parameters:
        - bgReferenceExternal: string (required)
          BG External Reference
        
        
        
        Headers:
        - ChannelType: integer
          Channel identifier from where the TXN has originated (Internet, Mobile, ATM, Branch Channel )
        - co-Relationid: integer
          Unique ID for the service invoked, will be set by the TXN system
        - entity: string
          entity
        - initiatingSystem: string
          Indicating the initiated system
        - languageCode: integer
          languageCode
        - serviceMode: integer
          Used for branch channel to indicate the type of customer
        - userId: integer
          userId
        - uuidSeqNo: integer
          UUID Sequence Number
        
        
        """
        
        
        # Prepare query parameters
        params = {}
        
        
        # Replace path parameters in URL
        path = "/tradeFinance/bankGuarantee/issue/{bgReferenceExternal}/marginDetails"
        if bgreferenceexternal is not None:
            path = path.replace("{bgReferenceExternal}", str(bgreferenceexternal))
        
        
        # Prepare headers
        headers = {}
        if channeltype is not None:
            headers["ChannelType"] = str(channeltype)
        if co_relationid is not None:
            headers["co-Relationid"] = str(co_relationid)
        if entity is not None:
            headers["entity"] = str(entity)
        if initiatingsystem is not None:
            headers["initiatingSystem"] = str(initiatingsystem)
        if languagecode is not None:
            headers["languageCode"] = str(languagecode)
        if servicemode is not None:
            headers["serviceMode"] = str(servicemode)
        if userid is not None:
            headers["userId"] = str(userid)
        if uuidseqno is not None:
            headers["uuidSeqNo"] = str(uuidseqno)
        
        
        return await make_api_request(
            "GET", 
            path, 
            
            params=params if params else None, 
            headers=headers if headers else None
        )
    
    
    
    @mcp.tool()
    async def tfbt6040_set_up_bgmrgn_dtls_putusing_put(
        bgreferenceexternal: str,
        request_body:Dict[str, Any] ,  # BankGuaranteeMarginDetailsRequest,
        channeltype: Optional[int] = None,
        co_relationid: Optional[int] = None,
        entity: Optional[str] = None,
        initiatingsystem: Optional[str] = None,
        languagecode: Optional[int] = None,
        servicemode: Optional[int] = None,
        userid: Optional[int] = None,
        uuidseqno: Optional[int] = None
    ) -> Dict[str, Any]:
        """
        Bank Guarantee Margin Details
        
        Generated from: PUT /tradeFinance/bankGuarantee/issue/{bgReferenceExternal}/marginDetails
        Source: swagger_2_0
        Operation ID: TFBT6040SetUpBGMrgnDtls_PUTUsingPUT
        
        
        Authentication: Not required
        
        Parameters:
        - bgReferenceExternal: string (required)
          BG External Reference
        - request_body: any (required)
          input
        
        
        
        Headers:
        - ChannelType: integer
          Channel identifier from where the TXN has originated (Internet, Mobile, ATM, Branch Channel )
        - co-Relationid: integer
          Unique ID for the service invoked, will be set by the TXN system
        - entity: string
          entity
        - initiatingSystem: string
          Indicating the initiated system
        - languageCode: integer
          languageCode
        - serviceMode: integer
          Used for branch channel to indicate the type of customer
        - userId: integer
          userId
        - uuidSeqNo: integer
          UUID Sequence Number
        
        
        """
        
        
        # Prepare request data
        
        # Single body parameter - send directly
        data = request_body if request_body is not None else {}
        
        
        
        # Prepare query parameters
        params = {}
        
        
        # Replace path parameters in URL
        path = "/tradeFinance/bankGuarantee/issue/{bgReferenceExternal}/marginDetails"
        if bgreferenceexternal is not None:
            path = path.replace("{bgReferenceExternal}", str(bgreferenceexternal))
        
        
        # Prepare headers
        headers = {}
        if channeltype is not None:
            headers["ChannelType"] = str(channeltype)
        if co_relationid is not None:
            headers["co-Relationid"] = str(co_relationid)
        if entity is not None:
            headers["entity"] = str(entity)
        if initiatingsystem is not None:
            headers["initiatingSystem"] = str(initiatingsystem)
        if languagecode is not None:
            headers["languageCode"] = str(languagecode)
        if servicemode is not None:
            headers["serviceMode"] = str(servicemode)
        if userid is not None:
            headers["userId"] = str(userid)
        if uuidseqno is not None:
            headers["uuidSeqNo"] = str(uuidseqno)
        
        
        return await make_api_request(
            "PUT", 
            path, 
            data=data, 
            params=params if params else None, 
            headers=headers if headers else None
        )
    
    
    
    @mcp.tool()
    async def tfbt6010_bgverified_to_on_hold_postusing_put(
        bgreferenceexternal: str,
        bgreferenceinternal: Optional[str] = None,
        bgtransactionid: Optional[int] = None,
        channeltransactionid: Optional[int] = None,
        channeltype: Optional[int] = None,
        accesstoken: Optional[str] = None,
        co_relationid: Optional[int] = None,
        entity: Optional[str] = None,
        initiatingsystem: Optional[str] = None,
        languagecode: Optional[int] = None,
        referenceid: Optional[str] = None,
        requesthash: Optional[str] = None,
        servicemode: Optional[int] = None,
        userid: Optional[int] = None,
        uuidseqno: Optional[int] = None
    ) -> Dict[str, Any]:
        """
        BG Issue Sendback
        
        Generated from: PUT /tradeFinance/bankGuarantee/issue/{bgReferenceExternal}/sendback
        Source: swagger_2_0
        Operation ID: TFBT6010BGVerifiedToOnHold_POSTUsingPUT
        
        
        Authentication: Not required
        
        Parameters:
        - bgReferenceExternal: string (required)
          BG Reference External
        - bgReferenceInternal: string
          BG Reference Internal
        - bgTransactionID: integer
          BG Transaction ID
        - channelTransactionId: integer
          Channel Transaction Id For Send Back
        
        
        
        Headers:
        - ChannelType: integer
          Channel identifier from where the TXN has originated (Internet, Mobile, ATM, Branch Channel )
        - accesstoken: string
          Authorization Token to validation the caller
        - co-Relationid: integer
          Unique ID for the service invoked, will be set by the TXN system
        - entity: string
          entity
        - initiatingSystem: string
          Indicating the initiated system
        - languageCode: integer
          languageCode
        - referenceId: string
          Place holder for Token based authentication
        - requesthash: string
          Request payload for hash validation
        - serviceMode: integer
          Used for branch channel to indicate the type of customer
        - userId: integer
          userId
        - uuidSeqNo: integer
          UUID Sequence Number
        
        
        """
        
        
        # Prepare query parameters
        params = {}
        if bgreferenceinternal is not None:
            params["bgReferenceInternal"] = bgreferenceinternal
            
        if bgtransactionid is not None:
            params["bgTransactionID"] = bgtransactionid
            
        if channeltransactionid is not None:
            params["channelTransactionId"] = channeltransactionid
            
        
        
        # Replace path parameters in URL
        path = "/tradeFinance/bankGuarantee/issue/{bgReferenceExternal}/sendback"
        if bgreferenceexternal is not None:
            path = path.replace("{bgReferenceExternal}", str(bgreferenceexternal))
        
        
        # Prepare headers
        headers = {}
        if channeltype is not None:
            headers["ChannelType"] = str(channeltype)
        if accesstoken is not None:
            headers["accesstoken"] = str(accesstoken)
        if co_relationid is not None:
            headers["co-Relationid"] = str(co_relationid)
        if entity is not None:
            headers["entity"] = str(entity)
        if initiatingsystem is not None:
            headers["initiatingSystem"] = str(initiatingsystem)
        if languagecode is not None:
            headers["languageCode"] = str(languagecode)
        if referenceid is not None:
            headers["referenceId"] = str(referenceid)
        if requesthash is not None:
            headers["requesthash"] = str(requesthash)
        if servicemode is not None:
            headers["serviceMode"] = str(servicemode)
        if userid is not None:
            headers["userId"] = str(userid)
        if uuidseqno is not None:
            headers["uuidSeqNo"] = str(uuidseqno)
        
        
        return await make_api_request(
            "PUT", 
            path, 
            
            params=params if params else None, 
            headers=headers if headers else None
        )
    
    
    
    @mcp.tool()
    async def tfbt5472_modify_bgwrapper_postusing_put(
        bgreferenceexternal: str,
        authoriseflag: Optional[int] = None,
        authoriseremarks: Optional[str] = None,
        modeflag: Optional[int] = None,
        channeltype: Optional[int] = None,
        co_relationid: Optional[int] = None,
        entity: Optional[str] = None,
        initiatingsystem: Optional[str] = None,
        languagecode: Optional[int] = None,
        servicemode: Optional[int] = None,
        userid: Optional[int] = None,
        uuidseqno: Optional[int] = None
    ) -> Dict[str, Any]:
        """
        ModifiedBankGuaranteeBasicDetailsAuthWrapper
        
        Generated from: PUT /tradeFinance/bankGuarantee/modify/{bgReferenceExternal}/authorization
        Source: swagger_2_0
        Operation ID: TFBT5472ModifyBGWrapper_POSTUsingPUT
        
        
        Authentication: Not required
        
        Parameters:
        - authoriseFlag: integer
          Authorise Flag. Possible values : 1 - Authorise, 2 - Reject, 3 - Sent Back Domain name : d_VerAuthFlg
        - authoriseRemarks: string
          Authorise Remarks
        - bgReferenceExternal: string (required)
          Bank Guarantee Reference External
        - modeFlag: integer
          Mode Flag. Possible values : 9 - Release , Default empty for Authorise service. Domain name : d_ModeFlg
        
        
        
        Headers:
        - ChannelType: integer
          Channel identifier from where the TXN has originated (Internet, Mobile, ATM, Branch Channel )
        - co-Relationid: integer
          Unique ID for the service invoked, will be set by the TXN system
        - entity: string
          entity
        - initiatingSystem: string
          Indicating the initiated system
        - languageCode: integer
          languageCode
        - serviceMode: integer
          Used for branch channel to indicate the type of customer
        - userId: integer
          userId
        - uuidSeqNo: integer
          UUID Sequence Number
        
        
        """
        
        
        # Prepare query parameters
        params = {}
        if authoriseflag is not None:
            params["authoriseFlag"] = authoriseflag
            
        if authoriseremarks is not None:
            params["authoriseRemarks"] = authoriseremarks
            
        if modeflag is not None:
            params["modeFlag"] = modeflag
            
        
        
        # Replace path parameters in URL
        path = "/tradeFinance/bankGuarantee/modify/{bgReferenceExternal}/authorization"
        if bgreferenceexternal is not None:
            path = path.replace("{bgReferenceExternal}", str(bgreferenceexternal))
        
        
        # Prepare headers
        headers = {}
        if channeltype is not None:
            headers["ChannelType"] = str(channeltype)
        if co_relationid is not None:
            headers["co-Relationid"] = str(co_relationid)
        if entity is not None:
            headers["entity"] = str(entity)
        if initiatingsystem is not None:
            headers["initiatingSystem"] = str(initiatingsystem)
        if languagecode is not None:
            headers["languageCode"] = str(languagecode)
        if servicemode is not None:
            headers["serviceMode"] = str(servicemode)
        if userid is not None:
            headers["userId"] = str(userid)
        if uuidseqno is not None:
            headers["uuidSeqNo"] = str(uuidseqno)
        
        
        return await make_api_request(
            "PUT", 
            path, 
            
            params=params if params else None, 
            headers=headers if headers else None
        )
    
    
    
    @mcp.tool()
    async def tfet5472_get_modified_bgbasic_dtls_postusing_get(
        bgreferenceexternal: str,
        channeltype: Optional[int] = None,
        co_relationid: Optional[int] = None,
        entity: Optional[str] = None,
        initiatingsystem: Optional[str] = None,
        languagecode: Optional[int] = None,
        servicemode: Optional[int] = None,
        userid: Optional[int] = None,
        uuidseqno: Optional[int] = None
    ) -> Dict[str, Any]:
        """
        ModifiedBankGuaranteeBasicDetails
        
        Generated from: GET /tradeFinance/bankGuarantee/modify/{bgReferenceExternal}/bgBasicDetails
        Source: swagger_2_0
        Operation ID: TFET5472GetModifiedBGBasicDtls_POSTUsingGET
        
        
        Authentication: Not required
        
        Parameters:
        - bgReferenceExternal: string (required)
          Bank Guarantee Reference External
        
        
        
        Headers:
        - ChannelType: integer
          Channel identifier from where the TXN has originated (Internet, Mobile, ATM, Branch Channel )
        - co-Relationid: integer
          Unique ID for the service invoked, will be set by the TXN system
        - entity: string
          entity
        - initiatingSystem: string
          Indicating the initiated system
        - languageCode: integer
          languageCode
        - serviceMode: integer
          Used for branch channel to indicate the type of customer
        - userId: integer
          userId
        - uuidSeqNo: integer
          UUID Sequence Number
        
        
        """
        
        
        # Prepare query parameters
        params = {}
        
        
        # Replace path parameters in URL
        path = "/tradeFinance/bankGuarantee/modify/{bgReferenceExternal}/bgBasicDetails"
        if bgreferenceexternal is not None:
            path = path.replace("{bgReferenceExternal}", str(bgreferenceexternal))
        
        
        # Prepare headers
        headers = {}
        if channeltype is not None:
            headers["ChannelType"] = str(channeltype)
        if co_relationid is not None:
            headers["co-Relationid"] = str(co_relationid)
        if entity is not None:
            headers["entity"] = str(entity)
        if initiatingsystem is not None:
            headers["initiatingSystem"] = str(initiatingsystem)
        if languagecode is not None:
            headers["languageCode"] = str(languagecode)
        if servicemode is not None:
            headers["serviceMode"] = str(servicemode)
        if userid is not None:
            headers["userId"] = str(userid)
        if uuidseqno is not None:
            headers["uuidSeqNo"] = str(uuidseqno)
        
        
        return await make_api_request(
            "GET", 
            path, 
            
            params=params if params else None, 
            headers=headers if headers else None
        )
    
    
    
    @mcp.tool()
    async def tfbt5472_modify_bgdetails_postusing_put(
        bgreferenceexternal: str,
        purposeofguarantee: str,
        channeltype: Optional[int] = None,
        co_relationid: Optional[int] = None,
        entity: Optional[str] = None,
        initiatingsystem: Optional[str] = None,
        languagecode: Optional[int] = None,
        servicemode: Optional[int] = None,
        userid: Optional[int] = None,
        uuidseqno: Optional[int] = None
    ) -> Dict[str, Any]:
        """
        ModificationOfBankGuaranteeBasicDetails
        
        Generated from: PUT /tradeFinance/bankGuarantee/modify/{bgReferenceExternal}/bgBasicDetails
        Source: swagger_2_0
        Operation ID: TFBT5472ModifyBGDetails_POSTUsingPUT
        
        
        Authentication: Not required
        
        Parameters:
        - bgReferenceExternal: string (required)
          Bank Guarantee Reference External
        - purposeofGuarantee: string (required)
          Purpose of Guarantee
        
        
        
        Headers:
        - ChannelType: integer
          Channel identifier from where the TXN has originated (Internet, Mobile, ATM, Branch Channel )
        - co-Relationid: integer
          Unique ID for the service invoked, will be set by the TXN system
        - entity: string
          entity
        - initiatingSystem: string
          Indicating the initiated system
        - languageCode: integer
          languageCode
        - serviceMode: integer
          Used for branch channel to indicate the type of customer
        - userId: integer
          userId
        - uuidSeqNo: integer
          UUID Sequence Number
        
        
        """
        
        
        # Prepare query parameters
        params = {}
        if purposeofguarantee is not None:
            params["purposeofGuarantee"] = purposeofguarantee
            
        
        
        # Replace path parameters in URL
        path = "/tradeFinance/bankGuarantee/modify/{bgReferenceExternal}/bgBasicDetails"
        if bgreferenceexternal is not None:
            path = path.replace("{bgReferenceExternal}", str(bgreferenceexternal))
        
        
        # Prepare headers
        headers = {}
        if channeltype is not None:
            headers["ChannelType"] = str(channeltype)
        if co_relationid is not None:
            headers["co-Relationid"] = str(co_relationid)
        if entity is not None:
            headers["entity"] = str(entity)
        if initiatingsystem is not None:
            headers["initiatingSystem"] = str(initiatingsystem)
        if languagecode is not None:
            headers["languageCode"] = str(languagecode)
        if servicemode is not None:
            headers["serviceMode"] = str(servicemode)
        if userid is not None:
            headers["userId"] = str(userid)
        if uuidseqno is not None:
            headers["uuidSeqNo"] = str(uuidseqno)
        
        
        return await make_api_request(
            "PUT", 
            path, 
            
            params=params if params else None, 
            headers=headers if headers else None
        )
    
    
    
    @mcp.tool()
    async def tfet5472_get_modified_bgmargin_dtls_postusing_get(
        bgreferenceexternal: str,
        channeltype: Optional[int] = None,
        co_relationid: Optional[int] = None,
        entity: Optional[str] = None,
        initiatingsystem: Optional[str] = None,
        languagecode: Optional[int] = None,
        servicemode: Optional[int] = None,
        userid: Optional[int] = None,
        uuidseqno: Optional[int] = None
    ) -> Dict[str, Any]:
        """
        ModifiedBankGuaranteeMarginDetails
        
        Generated from: GET /tradeFinance/bankGuarantee/modify/{bgReferenceExternal}/bgMarginDetails
        Source: swagger_2_0
        Operation ID: TFET5472GetModifiedBGMarginDtls_POSTUsingGET
        
        
        Authentication: Not required
        
        Parameters:
        - bgReferenceExternal: string (required)
          Bank Guarantee Reference External
        
        
        
        Headers:
        - ChannelType: integer
          Channel identifier from where the TXN has originated (Internet, Mobile, ATM, Branch Channel )
        - co-Relationid: integer
          Unique ID for the service invoked, will be set by the TXN system
        - entity: string
          entity
        - initiatingSystem: string
          Indicating the initiated system
        - languageCode: integer
          languageCode
        - serviceMode: integer
          Used for branch channel to indicate the type of customer
        - userId: integer
          userId
        - uuidSeqNo: integer
          UUID Sequence Number
        
        
        """
        
        
        # Prepare query parameters
        params = {}
        
        
        # Replace path parameters in URL
        path = "/tradeFinance/bankGuarantee/modify/{bgReferenceExternal}/bgMarginDetails"
        if bgreferenceexternal is not None:
            path = path.replace("{bgReferenceExternal}", str(bgreferenceexternal))
        
        
        # Prepare headers
        headers = {}
        if channeltype is not None:
            headers["ChannelType"] = str(channeltype)
        if co_relationid is not None:
            headers["co-Relationid"] = str(co_relationid)
        if entity is not None:
            headers["entity"] = str(entity)
        if initiatingsystem is not None:
            headers["initiatingSystem"] = str(initiatingsystem)
        if languagecode is not None:
            headers["languageCode"] = str(languagecode)
        if servicemode is not None:
            headers["serviceMode"] = str(servicemode)
        if userid is not None:
            headers["userId"] = str(userid)
        if uuidseqno is not None:
            headers["uuidSeqNo"] = str(uuidseqno)
        
        
        return await make_api_request(
            "GET", 
            path, 
            
            params=params if params else None, 
            headers=headers if headers else None
        )
    
    
    
    @mcp.tool()
    async def tfbt547_modify_bgmargin_dtls_postusing_put(
        bgreferenceexternal: str,
        request_body:Dict[str, Any] ,  # ModifyBGMarginDetailsResource,
        channeltype: Optional[int] = None,
        co_relationid: Optional[int] = None,
        entity: Optional[str] = None,
        initiatingsystem: Optional[str] = None,
        languagecode: Optional[int] = None,
        servicemode: Optional[int] = None,
        userid: Optional[int] = None,
        uuidseqno: Optional[int] = None
    ) -> Dict[str, Any]:
        """
        ModificationOfBankGuaranteeMarginDetails
        
        Generated from: PUT /tradeFinance/bankGuarantee/modify/{bgReferenceExternal}/bgMarginDetails
        Source: swagger_2_0
        Operation ID: TFBT547ModifyBGMarginDtls_POSTUsingPUT
        
        
        Authentication: Not required
        
        Parameters:
        - bgReferenceExternal: string (required)
          Bank Guarantee Reference External
        - request_body: any (required)
          input
        
        
        
        Headers:
        - ChannelType: integer
          Channel identifier from where the TXN has originated (Internet, Mobile, ATM, Branch Channel )
        - co-Relationid: integer
          Unique ID for the service invoked, will be set by the TXN system
        - entity: string
          entity
        - initiatingSystem: string
          Indicating the initiated system
        - languageCode: integer
          languageCode
        - serviceMode: integer
          Used for branch channel to indicate the type of customer
        - userId: integer
          userId
        - uuidSeqNo: integer
          UUID Sequence Number
        
        
        """
        
        
        # Prepare request data
        
        # Single body parameter - send directly
        data = request_body if request_body is not None else {}
        
        
        
        # Prepare query parameters
        params = {}
        
        
        # Replace path parameters in URL
        path = "/tradeFinance/bankGuarantee/modify/{bgReferenceExternal}/bgMarginDetails"
        if bgreferenceexternal is not None:
            path = path.replace("{bgReferenceExternal}", str(bgreferenceexternal))
        
        
        # Prepare headers
        headers = {}
        if channeltype is not None:
            headers["ChannelType"] = str(channeltype)
        if co_relationid is not None:
            headers["co-Relationid"] = str(co_relationid)
        if entity is not None:
            headers["entity"] = str(entity)
        if initiatingsystem is not None:
            headers["initiatingSystem"] = str(initiatingsystem)
        if languagecode is not None:
            headers["languageCode"] = str(languagecode)
        if servicemode is not None:
            headers["serviceMode"] = str(servicemode)
        if userid is not None:
            headers["userId"] = str(userid)
        if uuidseqno is not None:
            headers["uuidSeqNo"] = str(uuidseqno)
        
        
        return await make_api_request(
            "PUT", 
            path, 
            data=data, 
            params=params if params else None, 
            headers=headers if headers else None
        )
    
    
    
    @mcp.tool()
    async def tfet4874_fetch_all_bgevents_postusing_get(
        bgreferenceexternal: str,
        pagenum: Optional[int] = None,
        pagesize: Optional[int] = None,
        channeltype: Optional[int] = None,
        accesstoken: Optional[str] = None,
        co_relationid: Optional[int] = None,
        entity: Optional[str] = None,
        initiatingsystem: Optional[str] = None,
        languagecode: Optional[int] = None,
        referenceid: Optional[str] = None,
        servicemode: Optional[int] = None,
        userid: Optional[int] = None,
        uuidseqno: Optional[int] = None
    ) -> Dict[str, Any]:
        """
        Service to fetch all bank guarantee events
        
        Generated from: GET /tradeFinance/bankGuarantee/{bgReferenceExternal}/bgEventsList
        Source: swagger_2_0
        Operation ID: TFET4874FetchAllBGEvents_POSTUsingGET
        
        
        Authentication: Not required
        
        Parameters:
        - bgReferenceExternal: string (required)
          Bg Reference External
        - pageNum: integer
          pageNum
        - pageSize: integer
          pageSize
        
        
        
        Headers:
        - ChannelType: integer
          Channel identifier from where the TXN has originated (Internet, Mobile, ATM, Branch Channel )
        - accesstoken: string
          Authorization Token to validation the caller
        - co-Relationid: integer
          Unique ID for the service invoked, will be set by the TXN system
        - entity: string
          entity
        - initiatingSystem: string
          Indicating the initiated system
        - languageCode: integer
          languageCode
        - referenceId: string
          Place holder for Token based authentication
        - serviceMode: integer
          Used for branch channel to indicate the type of customer
        - userId: integer
          userId
        - uuidSeqNo: integer
          UUID Sequence Number
        
        
        """
        
        
        # Prepare query parameters
        params = {}
        if pagenum is not None:
            params["pageNum"] = pagenum
            
        if pagesize is not None:
            params["pageSize"] = pagesize
            
        
        
        # Replace path parameters in URL
        path = "/tradeFinance/bankGuarantee/{bgReferenceExternal}/bgEventsList"
        if bgreferenceexternal is not None:
            path = path.replace("{bgReferenceExternal}", str(bgreferenceexternal))
        
        
        # Prepare headers
        headers = {}
        if channeltype is not None:
            headers["ChannelType"] = str(channeltype)
        if accesstoken is not None:
            headers["accesstoken"] = str(accesstoken)
        if co_relationid is not None:
            headers["co-Relationid"] = str(co_relationid)
        if entity is not None:
            headers["entity"] = str(entity)
        if initiatingsystem is not None:
            headers["initiatingSystem"] = str(initiatingsystem)
        if languagecode is not None:
            headers["languageCode"] = str(languagecode)
        if referenceid is not None:
            headers["referenceId"] = str(referenceid)
        if servicemode is not None:
            headers["serviceMode"] = str(servicemode)
        if userid is not None:
            headers["userId"] = str(userid)
        if uuidseqno is not None:
            headers["uuidSeqNo"] = str(uuidseqno)
        
        
        return await make_api_request(
            "GET", 
            path, 
            
            params=params if params else None, 
            headers=headers if headers else None
        )
    
    
    
    @mcp.tool()
    async def tfbt5073_bgdraft_postusing_put(
        bgreferenceexternal: str,
        request_body:Dict[str, Any] ,  # bgDraftResource,
        channeltype: Optional[int] = None,
        co_relationid: Optional[int] = None,
        entity: Optional[str] = None,
        initiatingsystem: Optional[str] = None,
        languagecode: Optional[int] = None,
        servicemode: Optional[int] = None,
        userid: Optional[int] = None,
        uuidseqno: Optional[int] = None
    ) -> Dict[str, Any]:
        """
        save draft
        
        Generated from: PUT /tradeFinance/bankGuarantee/{bgReferenceExternal}/draft
        Source: swagger_2_0
        Operation ID: TFBT5073BGDraft_POSTUsingPUT
        
        
        Authentication: Not required
        
        Parameters:
        - bgReferenceExternal: string (required)
          bg Reference External
        - request_body: any (required)
          input
        
        
        
        Headers:
        - ChannelType: integer
          Channel identifier from where the TXN has originated (Internet, Mobile, ATM, Branch Channel )
        - co-Relationid: integer
          Unique ID for the service invoked, will be set by the TXN system
        - entity: string
          entity
        - initiatingSystem: string
          Indicating the initiated system
        - languageCode: integer
          languageCode
        - serviceMode: integer
          Used for branch channel to indicate the type of customer
        - userId: integer
          userId
        - uuidSeqNo: integer
          UUID Sequence Number
        
        
        """
        
        
        # Prepare request data
        
        # Single body parameter - send directly
        data = request_body if request_body is not None else {}
        
        
        
        # Prepare query parameters
        params = {}
        
        
        # Replace path parameters in URL
        path = "/tradeFinance/bankGuarantee/{bgReferenceExternal}/draft"
        if bgreferenceexternal is not None:
            path = path.replace("{bgReferenceExternal}", str(bgreferenceexternal))
        
        
        # Prepare headers
        headers = {}
        if channeltype is not None:
            headers["ChannelType"] = str(channeltype)
        if co_relationid is not None:
            headers["co-Relationid"] = str(co_relationid)
        if entity is not None:
            headers["entity"] = str(entity)
        if initiatingsystem is not None:
            headers["initiatingSystem"] = str(initiatingsystem)
        if languagecode is not None:
            headers["languageCode"] = str(languagecode)
        if servicemode is not None:
            headers["serviceMode"] = str(servicemode)
        if userid is not None:
            headers["userId"] = str(userid)
        if uuidseqno is not None:
            headers["uuidSeqNo"] = str(uuidseqno)
        
        
        return await make_api_request(
            "PUT", 
            path, 
            data=data, 
            params=params if params else None, 
            headers=headers if headers else None
        )
    
    
    
    @mcp.tool()
    async def tfet5472_fetch_margin_history_postusing_get(
        bgreferenceexternal: str,
        channeltype: Optional[int] = None,
        co_relationid: Optional[int] = None,
        entity: Optional[str] = None,
        initiatingsystem: Optional[str] = None,
        languagecode: Optional[int] = None,
        servicemode: Optional[int] = None,
        userid: Optional[int] = None,
        uuidseqno: Optional[int] = None
    ) -> Dict[str, Any]:
        """
        FetchMarginHistory
        
        Generated from: GET /tradeFinance/bankGuarantee/{bgReferenceExternal}/marginHistory
        Source: swagger_2_0
        Operation ID: TFET5472FetchMarginHistory_POSTUsingGET
        
        
        Authentication: Not required
        
        Parameters:
        - bgReferenceExternal: string (required)
          Bank Guarantee Reference External
        
        
        
        Headers:
        - ChannelType: integer
          Channel identifier from where the TXN has originated (Internet, Mobile, ATM, Branch Channel )
        - co-Relationid: integer
          Unique ID for the service invoked, will be set by the TXN system
        - entity: string
          entity
        - initiatingSystem: string
          Indicating the initiated system
        - languageCode: integer
          languageCode
        - serviceMode: integer
          Used for branch channel to indicate the type of customer
        - userId: integer
          userId
        - uuidSeqNo: integer
          UUID Sequence Number
        
        
        """
        
        
        # Prepare query parameters
        params = {}
        
        
        # Replace path parameters in URL
        path = "/tradeFinance/bankGuarantee/{bgReferenceExternal}/marginHistory"
        if bgreferenceexternal is not None:
            path = path.replace("{bgReferenceExternal}", str(bgreferenceexternal))
        
        
        # Prepare headers
        headers = {}
        if channeltype is not None:
            headers["ChannelType"] = str(channeltype)
        if co_relationid is not None:
            headers["co-Relationid"] = str(co_relationid)
        if entity is not None:
            headers["entity"] = str(entity)
        if initiatingsystem is not None:
            headers["initiatingSystem"] = str(initiatingsystem)
        if languagecode is not None:
            headers["languageCode"] = str(languagecode)
        if servicemode is not None:
            headers["serviceMode"] = str(servicemode)
        if userid is not None:
            headers["userId"] = str(userid)
        if uuidseqno is not None:
            headers["uuidSeqNo"] = str(uuidseqno)
        
        
        return await make_api_request(
            "GET", 
            path, 
            
            params=params if params else None, 
            headers=headers if headers else None
        )
    
    
    
    @mcp.tool()
    async def tfbt5590_save_sim_chrges_postusing_put(
        request_body:Dict[str, Any] ,  # SaveSimulationChargesResource,
        channeltype: Optional[int] = None,
        co_relationid: Optional[int] = None,
        entity: Optional[str] = None,
        initiatingsystem: Optional[str] = None,
        languagecode: Optional[int] = None,
        servicemode: Optional[int] = None,
        userid: Optional[int] = None,
        uuidseqno: Optional[int] = None
    ) -> Dict[str, Any]:
        """
        SaveSimulationCharges
        
        Generated from: PUT /tradeFinance/charges/simulation/save
        Source: swagger_2_0
        Operation ID: TFBT5590SaveSimChrges_POSTUsingPUT
        
        
        Authentication: Not required
        
        Parameters:
        - request_body: any (required)
          input
        
        
        
        Headers:
        - ChannelType: integer
          Channel identifier from where the TXN has originated (Internet, Mobile, ATM, Branch Channel )
        - co-Relationid: integer
          Unique ID for the service invoked, will be set by the TXN system
        - entity: string
          entity
        - initiatingSystem: string
          Indicating the initiated system
        - languageCode: integer
          languageCode
        - serviceMode: integer
          Used for branch channel to indicate the type of customer
        - userId: integer
          userId
        - uuidSeqNo: integer
          UUID Sequence Number
        
        
        """
        
        
        # Prepare request data
        
        # Single body parameter - send directly
        data = request_body if request_body is not None else {}
        
        
        
        # Prepare query parameters
        params = {}
        
        
        # Replace path parameters in URL
        path = "/tradeFinance/charges/simulation/save"
        
        
        # Prepare headers
        headers = {}
        if channeltype is not None:
            headers["ChannelType"] = str(channeltype)
        if co_relationid is not None:
            headers["co-Relationid"] = str(co_relationid)
        if entity is not None:
            headers["entity"] = str(entity)
        if initiatingsystem is not None:
            headers["initiatingSystem"] = str(initiatingsystem)
        if languagecode is not None:
            headers["languageCode"] = str(languagecode)
        if servicemode is not None:
            headers["serviceMode"] = str(servicemode)
        if userid is not None:
            headers["userId"] = str(userid)
        if uuidseqno is not None:
            headers["uuidSeqNo"] = str(uuidseqno)
        
        
        return await make_api_request(
            "PUT", 
            path, 
            data=data, 
            params=params if params else None, 
            headers=headers if headers else None
        )
    
    
    
    @mcp.tool()
    async def edcbt1020_edcacpt_refusal_postusing_put(
        request_body:Dict[str, Any] ,  # acceptRefusalRequest,
        accesstoken: Optional[str] = None,
        channeltype: Optional[int] = None,
        co_relationid: Optional[int] = None,
        entity: Optional[str] = None,
        initiatingsystem: Optional[str] = None,
        languagecode: Optional[int] = None,
        referenceid: Optional[str] = None,
        servicemode: Optional[int] = None,
        userid: Optional[int] = None,
        uuidseqno: Optional[int] = None
    ) -> Dict[str, Any]:
        """
        Export DC Accept Refusal
        
        Generated from: PUT /tradeFinance/exportCollectionBills/acceptRefusal
        Source: swagger_2_0
        Operation ID: EDCBT1020EDCAcptRefusal_POSTUsingPUT
        
        
        Authentication: Not required
        
        Parameters:
        - request_body: any (required)
          input
        
        
        
        Headers:
        - Accesstoken: string
          Authorization Token to validation the caller
        - ChannelType: integer
          Channel identifier from where the TXN has originated (Internet, Mobile, ATM, Branch Channel )
        - co-Relationid: integer
          Unique ID for the service invoked, will be set by the TXN system
        - entity: string
          entity
        - initiatingSystem: string
          Indicating the initiated system
        - languageCode: integer
          languageCode
        - referenceId: string
          Place holder for Token based authentication
        - serviceMode: integer
          Used for branch channel to indicate the type of customer
        - userId: integer
          userId
        - uuidSeqNo: integer
          UUID Sequence Number
        
        
        """
        
        
        # Prepare request data
        
        # Single body parameter - send directly
        data = request_body if request_body is not None else {}
        
        
        
        # Prepare query parameters
        params = {}
        
        
        # Replace path parameters in URL
        path = "/tradeFinance/exportCollectionBills/acceptRefusal"
        
        
        # Prepare headers
        headers = {}
        if accesstoken is not None:
            headers["Accesstoken"] = str(accesstoken)
        if channeltype is not None:
            headers["ChannelType"] = str(channeltype)
        if co_relationid is not None:
            headers["co-Relationid"] = str(co_relationid)
        if entity is not None:
            headers["entity"] = str(entity)
        if initiatingsystem is not None:
            headers["initiatingSystem"] = str(initiatingsystem)
        if languagecode is not None:
            headers["languageCode"] = str(languagecode)
        if referenceid is not None:
            headers["referenceId"] = str(referenceid)
        if servicemode is not None:
            headers["serviceMode"] = str(servicemode)
        if userid is not None:
            headers["userId"] = str(userid)
        if uuidseqno is not None:
            headers["uuidSeqNo"] = str(uuidseqno)
        
        
        return await make_api_request(
            "PUT", 
            path, 
            data=data, 
            params=params if params else None, 
            headers=headers if headers else None
        )
    
    
    
    @mcp.tool()
    async def edcbt1016_edcacpt_ref_pndng_postusing_put(
        request_body:Dict[str, Any] ,  # acceptRefusalPendingRequest,
        accesstoken: Optional[str] = None,
        channeltype: Optional[int] = None,
        co_relationid: Optional[int] = None,
        entity: Optional[str] = None,
        initiatingsystem: Optional[str] = None,
        languagecode: Optional[int] = None,
        referenceid: Optional[str] = None,
        servicemode: Optional[int] = None,
        userid: Optional[int] = None,
        uuidseqno: Optional[int] = None
    ) -> Dict[str, Any]:
        """
        Accept Refusal Pending
        
        Generated from: PUT /tradeFinance/exportCollectionBills/acceptRefusalPending
        Source: swagger_2_0
        Operation ID: EDCBT1016EDCAcptRefPndng_POSTUsingPUT
        
        
        Authentication: Not required
        
        Parameters:
        - request_body: any (required)
          input
        
        
        
        Headers:
        - Accesstoken: string
          Authorization Token to validation the caller
        - ChannelType: integer
          Channel identifier from where the TXN has originated (Internet, Mobile, ATM, Branch Channel )
        - co-Relationid: integer
          Unique ID for the service invoked, will be set by the TXN system
        - entity: string
          entity
        - initiatingSystem: string
          Indicating the initiated system
        - languageCode: integer
          languageCode
        - referenceId: string
          Place holder for Token based authentication
        - serviceMode: integer
          Used for branch channel to indicate the type of customer
        - userId: integer
          userId
        - uuidSeqNo: integer
          UUID Sequence Number
        
        
        """
        
        
        # Prepare request data
        
        # Single body parameter - send directly
        data = request_body if request_body is not None else {}
        
        
        
        # Prepare query parameters
        params = {}
        
        
        # Replace path parameters in URL
        path = "/tradeFinance/exportCollectionBills/acceptRefusalPending"
        
        
        # Prepare headers
        headers = {}
        if accesstoken is not None:
            headers["Accesstoken"] = str(accesstoken)
        if channeltype is not None:
            headers["ChannelType"] = str(channeltype)
        if co_relationid is not None:
            headers["co-Relationid"] = str(co_relationid)
        if entity is not None:
            headers["entity"] = str(entity)
        if initiatingsystem is not None:
            headers["initiatingSystem"] = str(initiatingsystem)
        if languagecode is not None:
            headers["languageCode"] = str(languagecode)
        if referenceid is not None:
            headers["referenceId"] = str(referenceid)
        if servicemode is not None:
            headers["serviceMode"] = str(servicemode)
        if userid is not None:
            headers["userId"] = str(userid)
        if uuidseqno is not None:
            headers["uuidSeqNo"] = str(uuidseqno)
        
        
        return await make_api_request(
            "PUT", 
            path, 
            data=data, 
            params=params if params else None, 
            headers=headers if headers else None
        )
    
    
    
    @mcp.tool()
    async def edcbt1017_edcacpt_ref_verified_postusing_put(
        request_body:Dict[str, Any] ,  # acceptRefusalVerifiedRequest,
        accesstoken: Optional[str] = None,
        channeltype: Optional[int] = None,
        co_relationid: Optional[int] = None,
        entity: Optional[str] = None,
        initiatingsystem: Optional[str] = None,
        languagecode: Optional[int] = None,
        referenceid: Optional[str] = None,
        servicemode: Optional[int] = None,
        userid: Optional[int] = None,
        uuidseqno: Optional[int] = None
    ) -> Dict[str, Any]:
        """
        Accept Refusal Pending to Verified
        
        Generated from: PUT /tradeFinance/exportCollectionBills/acceptRefusalVerified
        Source: swagger_2_0
        Operation ID: EDCBT1017EDCAcptRefVerified_POSTUsingPUT
        
        
        Authentication: Not required
        
        Parameters:
        - request_body: any (required)
          input
        
        
        
        Headers:
        - Accesstoken: string
          Authorization Token to validation the caller
        - ChannelType: integer
          Channel identifier from where the TXN has originated (Internet, Mobile, ATM, Branch Channel )
        - co-Relationid: integer
          Unique ID for the service invoked, will be set by the TXN system
        - entity: string
          entity
        - initiatingSystem: string
          Indicating the initiated system
        - languageCode: integer
          languageCode
        - referenceId: string
          Place holder for Token based authentication
        - serviceMode: integer
          Used for branch channel to indicate the type of customer
        - userId: integer
          userId
        - uuidSeqNo: integer
          UUID Sequence Number
        
        
        """
        
        
        # Prepare request data
        
        # Single body parameter - send directly
        data = request_body if request_body is not None else {}
        
        
        
        # Prepare query parameters
        params = {}
        
        
        # Replace path parameters in URL
        path = "/tradeFinance/exportCollectionBills/acceptRefusalVerified"
        
        
        # Prepare headers
        headers = {}
        if accesstoken is not None:
            headers["Accesstoken"] = str(accesstoken)
        if channeltype is not None:
            headers["ChannelType"] = str(channeltype)
        if co_relationid is not None:
            headers["co-Relationid"] = str(co_relationid)
        if entity is not None:
            headers["entity"] = str(entity)
        if initiatingsystem is not None:
            headers["initiatingSystem"] = str(initiatingsystem)
        if languagecode is not None:
            headers["languageCode"] = str(languagecode)
        if referenceid is not None:
            headers["referenceId"] = str(referenceid)
        if servicemode is not None:
            headers["serviceMode"] = str(servicemode)
        if userid is not None:
            headers["userId"] = str(userid)
        if uuidseqno is not None:
            headers["uuidSeqNo"] = str(uuidseqno)
        
        
        return await make_api_request(
            "PUT", 
            path, 
            data=data, 
            params=params if params else None, 
            headers=headers if headers else None
        )
    
    
    
    @mcp.tool()
    async def edcbt4001_blamnd_rlsdto_exec_postusing_post(
        request_body:Dict[str, Any] ,  # AmendExportDCAuthRequest,
        accesstoken: Optional[str] = None,
        channeltype: Optional[int] = None,
        co_relationid: Optional[int] = None,
        entity: Optional[str] = None,
        initiatingsystem: Optional[str] = None,
        languagecode: Optional[int] = None,
        mu_id: Optional[str] = None,
        referenceid: Optional[str] = None,
        servicemode: Optional[int] = None,
        userid: Optional[int] = None,
        uuidseqno: Optional[int] = None
    ) -> Dict[str, Any]:
        """
        Authorize Export Documentary Collections Amendment
        
        Generated from: POST /tradeFinance/exportCollectionBills/amend/authorize
        Source: swagger_2_0
        Operation ID: EDCBT4001BLAmndRlsdtoExec_POSTUsingPOST
        
        
        Authentication: Not required
        
        Parameters:
        - request_body: any (required)
          input
        
        
        
        Headers:
        - Accesstoken: string
          Authorization Token to validation the caller
        - ChannelType: integer
          Channel identifier from where the TXN has originated (Internet, Mobile, ATM, Branch Channel )
        - co-Relationid: integer
          Unique ID for the service invoked, will be set by the TXN system
        - entity: string
          entity
        - initiatingSystem: string
          Indicating the initiated system
        - languageCode: integer
          languageCode
        - mu_Id: string
          Muid
        - referenceId: string
          Place holder for Token based authentication
        - serviceMode: integer
          Used for branch channel to indicate the type of customer
        - userId: integer
          userId
        - uuidSeqNo: integer
          UUID Sequence Number
        
        
        """
        
        
        # Prepare request data
        
        # Single body parameter - send directly
        data = request_body if request_body is not None else {}
        
        
        
        # Prepare query parameters
        params = {}
        
        
        # Replace path parameters in URL
        path = "/tradeFinance/exportCollectionBills/amend/authorize"
        
        
        # Prepare headers
        headers = {}
        if accesstoken is not None:
            headers["Accesstoken"] = str(accesstoken)
        if channeltype is not None:
            headers["ChannelType"] = str(channeltype)
        if co_relationid is not None:
            headers["co-Relationid"] = str(co_relationid)
        if entity is not None:
            headers["entity"] = str(entity)
        if initiatingsystem is not None:
            headers["initiatingSystem"] = str(initiatingsystem)
        if languagecode is not None:
            headers["languageCode"] = str(languagecode)
        if mu_id is not None:
            headers["mu_Id"] = str(mu_id)
        if referenceid is not None:
            headers["referenceId"] = str(referenceid)
        if servicemode is not None:
            headers["serviceMode"] = str(servicemode)
        if userid is not None:
            headers["userId"] = str(userid)
        if uuidseqno is not None:
            headers["uuidSeqNo"] = str(uuidseqno)
        
        
        return await make_api_request(
            "POST", 
            path, 
            data=data, 
            params=params if params else None, 
            headers=headers if headers else None
        )
    
    
    
    @mcp.tool()
    async def edcbt4001_blamnd_rlsdto_on_hold_postusing_post(
        request_body:Dict[str, Any] ,  # AmendExportDCSendBackRequest,
        accesstoken: Optional[str] = None,
        channeltype: Optional[int] = None,
        co_relationid: Optional[int] = None,
        entity: Optional[str] = None,
        initiatingsystem: Optional[str] = None,
        languagecode: Optional[int] = None,
        referenceid: Optional[str] = None,
        servicemode: Optional[int] = None,
        userid: Optional[int] = None,
        uuidseqno: Optional[int] = None
    ) -> Dict[str, Any]:
        """
        Sendback Export Documentary Collections Amendment
        
        Generated from: POST /tradeFinance/exportCollectionBills/amend/sendback
        Source: swagger_2_0
        Operation ID: EDCBT4001BLAmndRlsdtoOnHold_POSTUsingPOST
        
        
        Authentication: Not required
        
        Parameters:
        - request_body: any (required)
          input
        
        
        
        Headers:
        - Accesstoken: string
          Authorization Token to validation the caller
        - ChannelType: integer
          Channel identifier from where the TXN has originated (Internet, Mobile, ATM, Branch Channel )
        - co-Relationid: integer
          Unique ID for the service invoked, will be set by the TXN system
        - entity: string
          entity
        - initiatingSystem: string
          Indicating the initiated system
        - languageCode: integer
          languageCode
        - referenceId: string
          Place holder for Token based authentication
        - serviceMode: integer
          Used for branch channel to indicate the type of customer
        - userId: integer
          userId
        - uuidSeqNo: integer
          UUID Sequence Number
        
        
        """
        
        
        # Prepare request data
        
        # Single body parameter - send directly
        data = request_body if request_body is not None else {}
        
        
        
        # Prepare query parameters
        params = {}
        
        
        # Replace path parameters in URL
        path = "/tradeFinance/exportCollectionBills/amend/sendback"
        
        
        # Prepare headers
        headers = {}
        if accesstoken is not None:
            headers["Accesstoken"] = str(accesstoken)
        if channeltype is not None:
            headers["ChannelType"] = str(channeltype)
        if co_relationid is not None:
            headers["co-Relationid"] = str(co_relationid)
        if entity is not None:
            headers["entity"] = str(entity)
        if initiatingsystem is not None:
            headers["initiatingSystem"] = str(initiatingsystem)
        if languagecode is not None:
            headers["languageCode"] = str(languagecode)
        if referenceid is not None:
            headers["referenceId"] = str(referenceid)
        if servicemode is not None:
            headers["serviceMode"] = str(servicemode)
        if userid is not None:
            headers["userId"] = str(userid)
        if uuidseqno is not None:
            headers["uuidSeqNo"] = str(uuidseqno)
        
        
        return await make_api_request(
            "POST", 
            path, 
            data=data, 
            params=params if params else None, 
            headers=headers if headers else None
        )
    
    
    
    @mcp.tool()
    async def edcbt4001_crt_blamndmnt_on_hold_postusing_post(
        request_body:Dict[str, Any] ,  # EdcCollectionsBillsAmendmentRequest,
        accesstoken: Optional[str] = None,
        channeltype: Optional[int] = None,
        co_relationid: Optional[int] = None,
        entity: Optional[str] = None,
        initiatingsystem: Optional[str] = None,
        languagecode: Optional[int] = None,
        referenceid: Optional[str] = None,
        servicemode: Optional[int] = None,
        userid: Optional[int] = None,
        uuidseqno: Optional[int] = None
    ) -> Dict[str, Any]:
        """
        Amend Export DC Bill Onhold
        
        Generated from: POST /tradeFinance/exportCollectionBills/amendment
        Source: swagger_2_0
        Operation ID: EDCBT4001CrtBLAmndmntOnHold_POSTUsingPOST
        
        
        Authentication: Not required
        
        Parameters:
        - request_body: any (required)
          input
        
        
        
        Headers:
        - Accesstoken: string
          Authorization Token to validation the caller
        - ChannelType: integer
          Channel identifier from where the TXN has originated (Internet, Mobile, ATM, Branch Channel )
        - co-Relationid: integer
          Unique ID for the service invoked, will be set by the TXN system
        - entity: string
          entity
        - initiatingSystem: string
          Indicating the initiated system
        - languageCode: integer
          languageCode
        - referenceId: string
          Place holder for Token based authentication
        - serviceMode: integer
          Used for branch channel to indicate the type of customer
        - userId: integer
          userId
        - uuidSeqNo: integer
          UUID Sequence Number
        
        
        """
        
        
        # Prepare request data
        
        # Single body parameter - send directly
        data = request_body if request_body is not None else {}
        
        
        
        # Prepare query parameters
        params = {}
        
        
        # Replace path parameters in URL
        path = "/tradeFinance/exportCollectionBills/amendment"
        
        
        # Prepare headers
        headers = {}
        if accesstoken is not None:
            headers["Accesstoken"] = str(accesstoken)
        if channeltype is not None:
            headers["ChannelType"] = str(channeltype)
        if co_relationid is not None:
            headers["co-Relationid"] = str(co_relationid)
        if entity is not None:
            headers["entity"] = str(entity)
        if initiatingsystem is not None:
            headers["initiatingSystem"] = str(initiatingsystem)
        if languagecode is not None:
            headers["languageCode"] = str(languagecode)
        if referenceid is not None:
            headers["referenceId"] = str(referenceid)
        if servicemode is not None:
            headers["serviceMode"] = str(servicemode)
        if userid is not None:
            headers["userId"] = str(userid)
        if uuidseqno is not None:
            headers["uuidSeqNo"] = str(uuidseqno)
        
        
        return await make_api_request(
            "POST", 
            path, 
            data=data, 
            params=params if params else None, 
            headers=headers if headers else None
        )
    
    
    
    @mcp.tool()
    async def edcet4002_fetch_amnd_list_postusing_get(
        amendnumber: Optional[int] = None,
        amendmentdate: Optional[str] = None,
        billamnt: Optional[float] = None,
        customerid: Optional[int] = None,
        customername: Optional[str] = None,
        edcrefexternal: Optional[str] = None,
        edcrefinternal: Optional[str] = None,
        entityid: Optional[str] = None,
        evntlegid: Optional[int] = None,
        startdate: Optional[str] = None,
        transactionid: Optional[int] = None,
        transactiontype: Optional[int] = None,
        benfcryid: Optional[int] = None,
        benificiaryname: Optional[str] = None,
        enddate: Optional[str] = None,
        pagenum: Optional[int] = None,
        pagesize: Optional[int] = None,
        status: Optional[int] = None,
        accesstoken: Optional[str] = None,
        channeltype: Optional[int] = None,
        co_relationid: Optional[int] = None,
        entity: Optional[str] = None,
        initiatingsystem: Optional[str] = None,
        languagecode: Optional[int] = None,
        referenceid: Optional[str] = None,
        servicemode: Optional[int] = None,
        userid: Optional[int] = None,
        uuidseqno: Optional[int] = None
    ) -> Dict[str, Any]:
        """
        Amend Export DC List
        
        Generated from: GET /tradeFinance/exportCollectionBills/amendment/list
        Source: swagger_2_0
        Operation ID: EDCET4002FetchAmndList_POSTUsingGET
        
        
        Authentication: Not required
        
        Parameters:
        - AmendNumber: integer
          Amendment Number
        - AmendmentDate: string
          Amendment Date
        - BillAmnt: number
          Amount
        - CustomerId: integer
          ID
        - CustomerName: string
          Name
        - EdcRefExternal: string
          Edc Reference External
        - EdcRefInternal: string
          Edc Reference Internal
        - EntityId: string
          Entity ID
        - EvntLegId: integer
          Event Leg ID
        - StartDate: string
          Start Date
        - TransactionId: integer
          Transaction ID
        - TransactionType: integer
          Transaction Type
        - benfcryId: integer
          Ref No
        - benificiaryName: string
          Benificiary Name
        - endDate: string
          End Date
        - pageNum: integer
          pageNum
        - pageSize: integer
          pageSize
        - status: integer
          Status
        
        
        
        Headers:
        - Accesstoken: string
          Authorization Token to validation the caller
        - ChannelType: integer
          Channel identifier from where the TXN has originated (Internet, Mobile, ATM, Branch Channel )
        - co-Relationid: integer
          Unique ID for the service invoked, will be set by the TXN system
        - entity: string
          entity
        - initiatingSystem: string
          Indicating the initiated system
        - languageCode: integer
          languageCode
        - referenceId: string
          Place holder for Token based authentication
        - serviceMode: integer
          Used for branch channel to indicate the type of customer
        - userId: integer
          userId
        - uuidSeqNo: integer
          UUID Sequence Number
        
        
        """
        
        
        # Prepare query parameters
        params = {}
        if amendnumber is not None:
            params["AmendNumber"] = amendnumber
            
        if amendmentdate is not None:
            params["AmendmentDate"] = amendmentdate
            
        if billamnt is not None:
            params["BillAmnt"] = billamnt
            
        if customerid is not None:
            params["CustomerId"] = customerid
            
        if customername is not None:
            params["CustomerName"] = customername
            
        if edcrefexternal is not None:
            params["EdcRefExternal"] = edcrefexternal
            
        if edcrefinternal is not None:
            params["EdcRefInternal"] = edcrefinternal
            
        if entityid is not None:
            params["EntityId"] = entityid
            
        if evntlegid is not None:
            params["EvntLegId"] = evntlegid
            
        if startdate is not None:
            params["StartDate"] = startdate
            
        if transactionid is not None:
            params["TransactionId"] = transactionid
            
        if transactiontype is not None:
            params["TransactionType"] = transactiontype
            
        if benfcryid is not None:
            params["benfcryId"] = benfcryid
            
        if benificiaryname is not None:
            params["benificiaryName"] = benificiaryname
            
        if enddate is not None:
            params["endDate"] = enddate
            
        if pagenum is not None:
            params["pageNum"] = pagenum
            
        if pagesize is not None:
            params["pageSize"] = pagesize
            
        if status is not None:
            params["status"] = status
            
        
        
        # Replace path parameters in URL
        path = "/tradeFinance/exportCollectionBills/amendment/list"
        
        
        # Prepare headers
        headers = {}
        if accesstoken is not None:
            headers["Accesstoken"] = str(accesstoken)
        if channeltype is not None:
            headers["ChannelType"] = str(channeltype)
        if co_relationid is not None:
            headers["co-Relationid"] = str(co_relationid)
        if entity is not None:
            headers["entity"] = str(entity)
        if initiatingsystem is not None:
            headers["initiatingSystem"] = str(initiatingsystem)
        if languagecode is not None:
            headers["languageCode"] = str(languagecode)
        if referenceid is not None:
            headers["referenceId"] = str(referenceid)
        if servicemode is not None:
            headers["serviceMode"] = str(servicemode)
        if userid is not None:
            headers["userId"] = str(userid)
        if uuidseqno is not None:
            headers["uuidSeqNo"] = str(uuidseqno)
        
        
        return await make_api_request(
            "GET", 
            path, 
            
            params=params if params else None, 
            headers=headers if headers else None
        )
    
    
    
    @mcp.tool()
    async def edcbt4001_blamnd_on_hold_to_rlsd_postusing_post(
        request_body:Dict[str, Any] ,  # ReleaseEdcCollectionsBillsAmendmentRequest,
        accesstoken: Optional[str] = None,
        channeltype: Optional[int] = None,
        co_relationid: Optional[int] = None,
        entity: Optional[str] = None,
        initiatingsystem: Optional[str] = None,
        languagecode: Optional[int] = None,
        referenceid: Optional[str] = None,
        servicemode: Optional[int] = None,
        userid: Optional[int] = None,
        uuidseqno: Optional[int] = None
    ) -> Dict[str, Any]:
        """
        EDCBT4001BLAmndOnHoldToRlsd
        
        Generated from: POST /tradeFinance/exportCollectionBills/amendment/release
        Source: swagger_2_0
        Operation ID: EDCBT4001BLAmndOnHoldToRlsd_POSTUsingPOST
        
        
        Authentication: Not required
        
        Parameters:
        - request_body: any (required)
          input
        
        
        
        Headers:
        - Accesstoken: string
          Authorization Token to validation the caller
        - ChannelType: integer
          Channel identifier from where the TXN has originated (Internet, Mobile, ATM, Branch Channel )
        - co-Relationid: integer
          Unique ID for the service invoked, will be set by the TXN system
        - entity: string
          entity
        - initiatingSystem: string
          Indicating the initiated system
        - languageCode: integer
          languageCode
        - referenceId: string
          Place holder for Token based authentication
        - serviceMode: integer
          Used for branch channel to indicate the type of customer
        - userId: integer
          userId
        - uuidSeqNo: integer
          UUID Sequence Number
        
        
        """
        
        
        # Prepare request data
        
        # Single body parameter - send directly
        data = request_body if request_body is not None else {}
        
        
        
        # Prepare query parameters
        params = {}
        
        
        # Replace path parameters in URL
        path = "/tradeFinance/exportCollectionBills/amendment/release"
        
        
        # Prepare headers
        headers = {}
        if accesstoken is not None:
            headers["Accesstoken"] = str(accesstoken)
        if channeltype is not None:
            headers["ChannelType"] = str(channeltype)
        if co_relationid is not None:
            headers["co-Relationid"] = str(co_relationid)
        if entity is not None:
            headers["entity"] = str(entity)
        if initiatingsystem is not None:
            headers["initiatingSystem"] = str(initiatingsystem)
        if languagecode is not None:
            headers["languageCode"] = str(languagecode)
        if referenceid is not None:
            headers["referenceId"] = str(referenceid)
        if servicemode is not None:
            headers["serviceMode"] = str(servicemode)
        if userid is not None:
            headers["userId"] = str(userid)
        if uuidseqno is not None:
            headers["uuidSeqNo"] = str(uuidseqno)
        
        
        return await make_api_request(
            "POST", 
            path, 
            data=data, 
            params=params if params else None, 
            headers=headers if headers else None
        )
    
    
    
    @mcp.tool()
    async def edcet4002_get_blamnd_dtls_postusing_get(
        edcpostype: Optional[int] = None,
        entityid: Optional[str] = None,
        evntlegid: Optional[int] = None,
        transactionid: Optional[int] = None,
        pagenum: Optional[int] = None,
        pagesize: Optional[int] = None,
        accesstoken: Optional[str] = None,
        channeltype: Optional[int] = None,
        co_relationid: Optional[int] = None,
        entity: Optional[str] = None,
        initiatingsystem: Optional[str] = None,
        languagecode: Optional[int] = None,
        referenceid: Optional[str] = None,
        servicemode: Optional[int] = None,
        userid: Optional[int] = None,
        uuidseqno: Optional[int] = None
    ) -> Dict[str, Any]:
        """
        Amend Export DC View
        
        Generated from: GET /tradeFinance/exportCollectionBills/amendment/view
        Source: swagger_2_0
        Operation ID: EDCET4002GetBLAmndDtls_POSTUsingGET
        
        
        Authentication: Not required
        
        Parameters:
        - EdcPosType: integer
          Transaction Type
        - EntityId: string
          Entity ID
        - EvntLegId: integer
          Event Leg ID
        - TransactionId: integer
          Transaction Id
        - pageNum: integer
          pageNum
        - pageSize: integer
          pageSize
        
        
        
        Headers:
        - Accesstoken: string
          Authorization Token to validation the caller
        - ChannelType: integer
          Channel identifier from where the TXN has originated (Internet, Mobile, ATM, Branch Channel )
        - co-Relationid: integer
          Unique ID for the service invoked, will be set by the TXN system
        - entity: string
          entity
        - initiatingSystem: string
          Indicating the initiated system
        - languageCode: integer
          languageCode
        - referenceId: string
          Place holder for Token based authentication
        - serviceMode: integer
          Used for branch channel to indicate the type of customer
        - userId: integer
          userId
        - uuidSeqNo: integer
          UUID Sequence Number
        
        
        """
        
        
        # Prepare query parameters
        params = {}
        if edcpostype is not None:
            params["EdcPosType"] = edcpostype
            
        if entityid is not None:
            params["EntityId"] = entityid
            
        if evntlegid is not None:
            params["EvntLegId"] = evntlegid
            
        if transactionid is not None:
            params["TransactionId"] = transactionid
            
        if pagenum is not None:
            params["pageNum"] = pagenum
            
        if pagesize is not None:
            params["pageSize"] = pagesize
            
        
        
        # Replace path parameters in URL
        path = "/tradeFinance/exportCollectionBills/amendment/view"
        
        
        # Prepare headers
        headers = {}
        if accesstoken is not None:
            headers["Accesstoken"] = str(accesstoken)
        if channeltype is not None:
            headers["ChannelType"] = str(channeltype)
        if co_relationid is not None:
            headers["co-Relationid"] = str(co_relationid)
        if entity is not None:
            headers["entity"] = str(entity)
        if initiatingsystem is not None:
            headers["initiatingSystem"] = str(initiatingsystem)
        if languagecode is not None:
            headers["languageCode"] = str(languagecode)
        if referenceid is not None:
            headers["referenceId"] = str(referenceid)
        if servicemode is not None:
            headers["serviceMode"] = str(servicemode)
        if userid is not None:
            headers["userId"] = str(userid)
        if uuidseqno is not None:
            headers["uuidSeqNo"] = str(uuidseqno)
        
        
        return await make_api_request(
            "GET", 
            path, 
            
            params=params if params else None, 
            headers=headers if headers else None
        )
    
    
    
    @mcp.tool()
    async def edcbt1005_dcrlsd_to_exec_postusing_post(
        request_body:Dict[str, Any] ,  # RegisterExportDCAuthRequest,
        accesstoken: Optional[str] = None,
        channeltype: Optional[int] = None,
        co_relationid: Optional[int] = None,
        entity: Optional[str] = None,
        initiatingsystem: Optional[str] = None,
        languagecode: Optional[int] = None,
        mu_id: Optional[str] = None,
        referenceid: Optional[str] = None,
        servicemode: Optional[int] = None,
        userid: Optional[int] = None,
        uuidseqno: Optional[int] = None
    ) -> Dict[str, Any]:
        """
        Authorize Export Documentary Collections
        
        Generated from: POST /tradeFinance/exportCollectionBills/authorize
        Source: swagger_2_0
        Operation ID: EDCBT1005DCRlsdToExec_POSTUsingPOST
        
        
        Authentication: Not required
        
        Parameters:
        - request_body: any (required)
          input
        
        
        
        Headers:
        - Accesstoken: string
          Authorization Token to validation the caller
        - ChannelType: integer
          Channel identifier from where the TXN has originated (Internet, Mobile, ATM, Branch Channel )
        - co-Relationid: integer
          Unique ID for the service invoked, will be set by the TXN system
        - entity: string
          entity
        - initiatingSystem: string
          Indicating the initiated system
        - languageCode: integer
          languageCode
        - mu_Id: string
          Muid
        - referenceId: string
          Place holder for Token based authentication
        - serviceMode: integer
          Used for branch channel to indicate the type of customer
        - userId: integer
          userId
        - uuidSeqNo: integer
          UUID Sequence Number
        
        
        """
        
        
        # Prepare request data
        
        # Single body parameter - send directly
        data = request_body if request_body is not None else {}
        
        
        
        # Prepare query parameters
        params = {}
        
        
        # Replace path parameters in URL
        path = "/tradeFinance/exportCollectionBills/authorize"
        
        
        # Prepare headers
        headers = {}
        if accesstoken is not None:
            headers["Accesstoken"] = str(accesstoken)
        if channeltype is not None:
            headers["ChannelType"] = str(channeltype)
        if co_relationid is not None:
            headers["co-Relationid"] = str(co_relationid)
        if entity is not None:
            headers["entity"] = str(entity)
        if initiatingsystem is not None:
            headers["initiatingSystem"] = str(initiatingsystem)
        if languagecode is not None:
            headers["languageCode"] = str(languagecode)
        if mu_id is not None:
            headers["mu_Id"] = str(mu_id)
        if referenceid is not None:
            headers["referenceId"] = str(referenceid)
        if servicemode is not None:
            headers["serviceMode"] = str(servicemode)
        if userid is not None:
            headers["userId"] = str(userid)
        if uuidseqno is not None:
            headers["uuidSeqNo"] = str(uuidseqno)
        
        
        return await make_api_request(
            "POST", 
            path, 
            data=data, 
            params=params if params else None, 
            headers=headers if headers else None
        )
    
    
    
    @mcp.tool()
    async def edcbt1004_dcon_hold_to_rjct_postusing_post(
        request_body:Dict[str, Any] ,  # RegisterExportDCCancelRequest,
        accesstoken: Optional[str] = None,
        channeltype: Optional[int] = None,
        co_relationid: Optional[int] = None,
        entity: Optional[str] = None,
        initiatingsystem: Optional[str] = None,
        languagecode: Optional[int] = None,
        referenceid: Optional[str] = None,
        servicemode: Optional[int] = None,
        userid: Optional[int] = None,
        uuidseqno: Optional[int] = None
    ) -> Dict[str, Any]:
        """
        Cancel Export Documentary Collections
        
        Generated from: POST /tradeFinance/exportCollectionBills/cancel
        Source: swagger_2_0
        Operation ID: EDCBT1004DCOnHoldToRjct_POSTUsingPOST
        
        
        Authentication: Not required
        
        Parameters:
        - request_body: any (required)
          input
        
        
        
        Headers:
        - Accesstoken: string
          Authorization Token to validation the caller
        - ChannelType: integer
          Channel identifier from where the TXN has originated (Internet, Mobile, ATM, Branch Channel )
        - co-Relationid: integer
          Unique ID for the service invoked, will be set by the TXN system
        - entity: string
          entity
        - initiatingSystem: string
          Indicating the initiated system
        - languageCode: integer
          languageCode
        - referenceId: string
          Place holder for Token based authentication
        - serviceMode: integer
          Used for branch channel to indicate the type of customer
        - userId: integer
          userId
        - uuidSeqNo: integer
          UUID Sequence Number
        
        
        """
        
        
        # Prepare request data
        
        # Single body parameter - send directly
        data = request_body if request_body is not None else {}
        
        
        
        # Prepare query parameters
        params = {}
        
        
        # Replace path parameters in URL
        path = "/tradeFinance/exportCollectionBills/cancel"
        
        
        # Prepare headers
        headers = {}
        if accesstoken is not None:
            headers["Accesstoken"] = str(accesstoken)
        if channeltype is not None:
            headers["ChannelType"] = str(channeltype)
        if co_relationid is not None:
            headers["co-Relationid"] = str(co_relationid)
        if entity is not None:
            headers["entity"] = str(entity)
        if initiatingsystem is not None:
            headers["initiatingSystem"] = str(initiatingsystem)
        if languagecode is not None:
            headers["languageCode"] = str(languagecode)
        if referenceid is not None:
            headers["referenceId"] = str(referenceid)
        if servicemode is not None:
            headers["serviceMode"] = str(servicemode)
        if userid is not None:
            headers["userId"] = str(userid)
        if uuidseqno is not None:
            headers["uuidSeqNo"] = str(uuidseqno)
        
        
        return await make_api_request(
            "POST", 
            path, 
            data=data, 
            params=params if params else None, 
            headers=headers if headers else None
        )
    
    
    
    @mcp.tool()
    async def edcbt1001_crt_dcon_hold_postusing_post(
        request_body:Dict[str, Any] ,  # RegisterExportDCCreateRequest,
        accesstoken: Optional[str] = None,
        channeltype: Optional[int] = None,
        co_relationid: Optional[int] = None,
        entity: Optional[str] = None,
        initiatingsystem: Optional[str] = None,
        languagecode: Optional[int] = None,
        mu_id: Optional[str] = None,
        referenceid: Optional[str] = None,
        servicemode: Optional[int] = None,
        userid: Optional[int] = None,
        uuidseqno: Optional[int] = None
    ) -> Dict[str, Any]:
        """
        Register Export documentary Collections On Hold
        
        Generated from: POST /tradeFinance/exportCollectionBills/createOnHold
        Source: swagger_2_0
        Operation ID: EDCBT1001CrtDCOnHold_POSTUsingPOST
        
        
        Authentication: Not required
        
        Parameters:
        - request_body: any (required)
          input
        
        
        
        Headers:
        - Accesstoken: string
          Authorization Token to validation the caller
        - ChannelType: integer
          Channel identifier from where the TXN has originated (Internet, Mobile, ATM, Branch Channel )
        - co-Relationid: integer
          Unique ID for the service invoked, will be set by the TXN system
        - entity: string
          entity
        - initiatingSystem: string
          Indicating the initiated system
        - languageCode: integer
          languageCode
        - mu_Id: string
          Muid
        - referenceId: string
          Place holder for Token based authentication
        - serviceMode: integer
          Used for branch channel to indicate the type of customer
        - userId: integer
          userId
        - uuidSeqNo: integer
          UUID Sequence Number
        
        
        """
        
        
        # Prepare request data
        
        # Single body parameter - send directly
        data = request_body if request_body is not None else {}
        
        
        
        # Prepare query parameters
        params = {}
        
        
        # Replace path parameters in URL
        path = "/tradeFinance/exportCollectionBills/createOnHold"
        
        
        # Prepare headers
        headers = {}
        if accesstoken is not None:
            headers["Accesstoken"] = str(accesstoken)
        if channeltype is not None:
            headers["ChannelType"] = str(channeltype)
        if co_relationid is not None:
            headers["co-Relationid"] = str(co_relationid)
        if entity is not None:
            headers["entity"] = str(entity)
        if initiatingsystem is not None:
            headers["initiatingSystem"] = str(initiatingsystem)
        if languagecode is not None:
            headers["languageCode"] = str(languagecode)
        if mu_id is not None:
            headers["mu_Id"] = str(mu_id)
        if referenceid is not None:
            headers["referenceId"] = str(referenceid)
        if servicemode is not None:
            headers["serviceMode"] = str(servicemode)
        if userid is not None:
            headers["userId"] = str(userid)
        if uuidseqno is not None:
            headers["uuidSeqNo"] = str(uuidseqno)
        
        
        return await make_api_request(
            "POST", 
            path, 
            data=data, 
            params=params if params else None, 
            headers=headers if headers else None
        )
    
    
    
    @mcp.tool()
    async def edcet1302_fetch_dcdoc_dtls_postusing_get(
        entity1: Optional[str] = None,
        transactioneventid: Optional[int] = None,
        transactionid: Optional[int] = None,
        transactiontype: Optional[int] = None,
        pagenum: Optional[int] = None,
        pagesize: Optional[int] = None,
        accesstoken: Optional[str] = None,
        channeltype: Optional[int] = None,
        co_relationid: Optional[int] = None,
        entity: Optional[str] = None,
        initiatingsystem: Optional[str] = None,
        languagecode: Optional[int] = None,
        referenceid: Optional[str] = None,
        servicemode: Optional[int] = None,
        userid: Optional[int] = None,
        uuidseqno: Optional[int] = None
    ) -> Dict[str, Any]:
        """
        Documents Details under Documentary Collections-List
        
        Generated from: GET /tradeFinance/exportCollectionBills/documentList
        Source: swagger_2_0
        Operation ID: EDCET1302FetchDCDocDtls_POSTUsingGET
        
        
        Authentication: Not required
        
        Parameters:
        - Entity1: string
          Entity ID
        - TransactionEventID: integer
          Event Leg ID
        - TransactionID: integer
          Export documentary collection Pos ID
        - TransactionType: integer
          Export documentary collection Pos Type
        - pageNum: integer
          pageNum
        - pageSize: integer
          pageSize
        
        
        
        Headers:
        - Accesstoken: string
          Authorization Token to validation the caller
        - ChannelType: integer
          Channel identifier from where the TXN has originated (Internet, Mobile, ATM, Branch Channel )
        - co-Relationid: integer
          Unique ID for the service invoked, will be set by the TXN system
        - entity: string
          entity
        - initiatingSystem: string
          Indicating the initiated system
        - languageCode: integer
          languageCode
        - referenceId: string
          Place holder for Token based authentication
        - serviceMode: integer
          Used for branch channel to indicate the type of customer
        - userId: integer
          userId
        - uuidSeqNo: integer
          UUID Sequence Number
        
        
        """
        
        
        # Prepare query parameters
        params = {}
        if entity1 is not None:
            params["Entity1"] = entity1
            
        if transactioneventid is not None:
            params["TransactionEventID"] = transactioneventid
            
        if transactionid is not None:
            params["TransactionID"] = transactionid
            
        if transactiontype is not None:
            params["TransactionType"] = transactiontype
            
        if pagenum is not None:
            params["pageNum"] = pagenum
            
        if pagesize is not None:
            params["pageSize"] = pagesize
            
        
        
        # Replace path parameters in URL
        path = "/tradeFinance/exportCollectionBills/documentList"
        
        
        # Prepare headers
        headers = {}
        if accesstoken is not None:
            headers["Accesstoken"] = str(accesstoken)
        if channeltype is not None:
            headers["ChannelType"] = str(channeltype)
        if co_relationid is not None:
            headers["co-Relationid"] = str(co_relationid)
        if entity is not None:
            headers["entity"] = str(entity)
        if initiatingsystem is not None:
            headers["initiatingSystem"] = str(initiatingsystem)
        if languagecode is not None:
            headers["languageCode"] = str(languagecode)
        if referenceid is not None:
            headers["referenceId"] = str(referenceid)
        if servicemode is not None:
            headers["serviceMode"] = str(servicemode)
        if userid is not None:
            headers["userId"] = str(userid)
        if uuidseqno is not None:
            headers["uuidSeqNo"] = str(uuidseqno)
        
        
        return await make_api_request(
            "GET", 
            path, 
            
            params=params if params else None, 
            headers=headers if headers else None
        )
    
    
    
    @mcp.tool()
    async def edcet1303_get_dcdoc_dtls_postusing_get(
        documentid: Optional[int] = None,
        entity1: Optional[str] = None,
        transactioneventid: Optional[int] = None,
        transactionid: Optional[int] = None,
        transactiontype: Optional[int] = None,
        pagenum: Optional[int] = None,
        pagesize: Optional[int] = None,
        accesstoken: Optional[str] = None,
        channeltype: Optional[int] = None,
        co_relationid: Optional[int] = None,
        entity: Optional[str] = None,
        initiatingsystem: Optional[str] = None,
        languagecode: Optional[int] = None,
        referenceid: Optional[str] = None,
        servicemode: Optional[int] = None,
        userid: Optional[int] = None,
        uuidseqno: Optional[int] = None
    ) -> Dict[str, Any]:
        """
        Documents Details under Documentary Collections-View
        
        Generated from: GET /tradeFinance/exportCollectionBills/documentView
        Source: swagger_2_0
        Operation ID: EDCET1303GetDCDocDtls_POSTUsingGET
        
        
        Authentication: Not required
        
        Parameters:
        - DocumentID: integer
          Document ID
        - Entity1: string
          Entity ID
        - TransactionEventID: integer
          Event Leg ID
        - TransactionID: integer
          Export documentary collection Pos ID
        - TransactionType: integer
          Export documentary collection Pos Type
        - pageNum: integer
          pageNum
        - pageSize: integer
          pageSize
        
        
        
        Headers:
        - Accesstoken: string
          Authorization Token to validation the caller
        - ChannelType: integer
          Channel identifier from where the TXN has originated (Internet, Mobile, ATM, Branch Channel )
        - co-Relationid: integer
          Unique ID for the service invoked, will be set by the TXN system
        - entity: string
          entity
        - initiatingSystem: string
          Indicating the initiated system
        - languageCode: integer
          languageCode
        - referenceId: string
          Place holder for Token based authentication
        - serviceMode: integer
          Used for branch channel to indicate the type of customer
        - userId: integer
          userId
        - uuidSeqNo: integer
          UUID Sequence Number
        
        
        """
        
        
        # Prepare query parameters
        params = {}
        if documentid is not None:
            params["DocumentID"] = documentid
            
        if entity1 is not None:
            params["Entity1"] = entity1
            
        if transactioneventid is not None:
            params["TransactionEventID"] = transactioneventid
            
        if transactionid is not None:
            params["TransactionID"] = transactionid
            
        if transactiontype is not None:
            params["TransactionType"] = transactiontype
            
        if pagenum is not None:
            params["pageNum"] = pagenum
            
        if pagesize is not None:
            params["pageSize"] = pagesize
            
        
        
        # Replace path parameters in URL
        path = "/tradeFinance/exportCollectionBills/documentView"
        
        
        # Prepare headers
        headers = {}
        if accesstoken is not None:
            headers["Accesstoken"] = str(accesstoken)
        if channeltype is not None:
            headers["ChannelType"] = str(channeltype)
        if co_relationid is not None:
            headers["co-Relationid"] = str(co_relationid)
        if entity is not None:
            headers["entity"] = str(entity)
        if initiatingsystem is not None:
            headers["initiatingSystem"] = str(initiatingsystem)
        if languagecode is not None:
            headers["languageCode"] = str(languagecode)
        if referenceid is not None:
            headers["referenceId"] = str(referenceid)
        if servicemode is not None:
            headers["serviceMode"] = str(servicemode)
        if userid is not None:
            headers["userId"] = str(userid)
        if uuidseqno is not None:
            headers["uuidSeqNo"] = str(uuidseqno)
        
        
        return await make_api_request(
            "GET", 
            path, 
            
            params=params if params else None, 
            headers=headers if headers else None
        )
    
    
    
    @mcp.tool()
    async def edcbt1301_set_up_dcdoc_dtls_postusing_post(
        request_body:Dict[str, Any] ,  # RegisterExportDCDocRequest,
        accesstoken: Optional[str] = None,
        channeltype: Optional[int] = None,
        co_relationid: Optional[int] = None,
        entity: Optional[str] = None,
        initiatingsystem: Optional[str] = None,
        languagecode: Optional[int] = None,
        referenceid: Optional[str] = None,
        servicemode: Optional[int] = None,
        userid: Optional[int] = None,
        uuidseqno: Optional[int] = None
    ) -> Dict[str, Any]:
        """
        Documents Details under Documentary Collections-Setup
        
        Generated from: POST /tradeFinance/exportCollectionBills/documentsSetup
        Source: swagger_2_0
        Operation ID: EDCBT1301SetUpDCDocDtls_POSTUsingPOST
        
        
        Authentication: Not required
        
        Parameters:
        - request_body: any (required)
          input
        
        
        
        Headers:
        - Accesstoken: string
          Authorization Token to validation the caller
        - ChannelType: integer
          Channel identifier from where the TXN has originated (Internet, Mobile, ATM, Branch Channel )
        - co-Relationid: integer
          Unique ID for the service invoked, will be set by the TXN system
        - entity: string
          entity
        - initiatingSystem: string
          Indicating the initiated system
        - languageCode: integer
          languageCode
        - referenceId: string
          Place holder for Token based authentication
        - serviceMode: integer
          Used for branch channel to indicate the type of customer
        - userId: integer
          userId
        - uuidSeqNo: integer
          UUID Sequence Number
        
        
        """
        
        
        # Prepare request data
        
        # Single body parameter - send directly
        data = request_body if request_body is not None else {}
        
        
        
        # Prepare query parameters
        params = {}
        
        
        # Replace path parameters in URL
        path = "/tradeFinance/exportCollectionBills/documentsSetup"
        
        
        # Prepare headers
        headers = {}
        if accesstoken is not None:
            headers["Accesstoken"] = str(accesstoken)
        if channeltype is not None:
            headers["ChannelType"] = str(channeltype)
        if co_relationid is not None:
            headers["co-Relationid"] = str(co_relationid)
        if entity is not None:
            headers["entity"] = str(entity)
        if initiatingsystem is not None:
            headers["initiatingSystem"] = str(initiatingsystem)
        if languagecode is not None:
            headers["languageCode"] = str(languagecode)
        if referenceid is not None:
            headers["referenceId"] = str(referenceid)
        if servicemode is not None:
            headers["serviceMode"] = str(servicemode)
        if userid is not None:
            headers["userId"] = str(userid)
        if uuidseqno is not None:
            headers["uuidSeqNo"] = str(uuidseqno)
        
        
        return await make_api_request(
            "POST", 
            path, 
            data=data, 
            params=params if params else None, 
            headers=headers if headers else None
        )
    
    
    
    @mcp.tool()
    async def edcbt1201_set_up_dcdraft_dtls_postusing_post(
        request_body:Dict[str, Any] ,  # RegisterExportDCDraftRequest,
        accesstoken: Optional[str] = None,
        channeltype: Optional[int] = None,
        co_relationid: Optional[int] = None,
        entity: Optional[str] = None,
        initiatingsystem: Optional[str] = None,
        languagecode: Optional[int] = None,
        referenceid: Optional[str] = None,
        servicemode: Optional[int] = None,
        userid: Optional[int] = None,
        uuidseqno: Optional[int] = None
    ) -> Dict[str, Any]:
        """
        Draft Details under Documentary Collections- Setup
        
        Generated from: POST /tradeFinance/exportCollectionBills/draftSetup
        Source: swagger_2_0
        Operation ID: EDCBT1201SetUpDCDraftDtls_POSTUsingPOST
        
        
        Authentication: Not required
        
        Parameters:
        - request_body: any (required)
          input
        
        
        
        Headers:
        - Accesstoken: string
          Authorization Token to validation the caller
        - ChannelType: integer
          Channel identifier from where the TXN has originated (Internet, Mobile, ATM, Branch Channel )
        - co-Relationid: integer
          Unique ID for the service invoked, will be set by the TXN system
        - entity: string
          entity
        - initiatingSystem: string
          Indicating the initiated system
        - languageCode: integer
          languageCode
        - referenceId: string
          Place holder for Token based authentication
        - serviceMode: integer
          Used for branch channel to indicate the type of customer
        - userId: integer
          userId
        - uuidSeqNo: integer
          UUID Sequence Number
        
        
        """
        
        
        # Prepare request data
        
        # Single body parameter - send directly
        data = request_body if request_body is not None else {}
        
        
        
        # Prepare query parameters
        params = {}
        
        
        # Replace path parameters in URL
        path = "/tradeFinance/exportCollectionBills/draftSetup"
        
        
        # Prepare headers
        headers = {}
        if accesstoken is not None:
            headers["Accesstoken"] = str(accesstoken)
        if channeltype is not None:
            headers["ChannelType"] = str(channeltype)
        if co_relationid is not None:
            headers["co-Relationid"] = str(co_relationid)
        if entity is not None:
            headers["entity"] = str(entity)
        if initiatingsystem is not None:
            headers["initiatingSystem"] = str(initiatingsystem)
        if languagecode is not None:
            headers["languageCode"] = str(languagecode)
        if referenceid is not None:
            headers["referenceId"] = str(referenceid)
        if servicemode is not None:
            headers["serviceMode"] = str(servicemode)
        if userid is not None:
            headers["userId"] = str(userid)
        if uuidseqno is not None:
            headers["uuidSeqNo"] = str(uuidseqno)
        
        
        return await make_api_request(
            "POST", 
            path, 
            data=data, 
            params=params if params else None, 
            headers=headers if headers else None
        )
    
    
    
    @mcp.tool()
    async def edcet1202_get_dcdraft_dtls_postusing_get(
        entity1: Optional[str] = None,
        transactioneventid: Optional[int] = None,
        transactionid: Optional[int] = None,
        transactiontype: Optional[int] = None,
        pagenum: Optional[int] = None,
        pagesize: Optional[int] = None,
        accesstoken: Optional[str] = None,
        channeltype: Optional[int] = None,
        co_relationid: Optional[int] = None,
        entity: Optional[str] = None,
        initiatingsystem: Optional[str] = None,
        languagecode: Optional[int] = None,
        referenceid: Optional[str] = None,
        servicemode: Optional[int] = None,
        userid: Optional[int] = None,
        uuidseqno: Optional[int] = None
    ) -> Dict[str, Any]:
        """
        Draft Details under Documentary Collections- View
        
        Generated from: GET /tradeFinance/exportCollectionBills/draftView
        Source: swagger_2_0
        Operation ID: EDCET1202GetDCDraftDtls_POSTUsingGET
        
        
        Authentication: Not required
        
        Parameters:
        - Entity1: string
          Entity ID
        - TransactionEventID: integer
          Event Leg ID
        - TransactionID: integer
          Export documentary collection Pos ID
        - TransactionType: integer
          Export documentary collection Pos Type
        - pageNum: integer
          pageNum
        - pageSize: integer
          pageSize
        
        
        
        Headers:
        - Accesstoken: string
          Authorization Token to validation the caller
        - ChannelType: integer
          Channel identifier from where the TXN has originated (Internet, Mobile, ATM, Branch Channel )
        - co-Relationid: integer
          Unique ID for the service invoked, will be set by the TXN system
        - entity: string
          entity
        - initiatingSystem: string
          Indicating the initiated system
        - languageCode: integer
          languageCode
        - referenceId: string
          Place holder for Token based authentication
        - serviceMode: integer
          Used for branch channel to indicate the type of customer
        - userId: integer
          userId
        - uuidSeqNo: integer
          UUID Sequence Number
        
        
        """
        
        
        # Prepare query parameters
        params = {}
        if entity1 is not None:
            params["Entity1"] = entity1
            
        if transactioneventid is not None:
            params["TransactionEventID"] = transactioneventid
            
        if transactionid is not None:
            params["TransactionID"] = transactionid
            
        if transactiontype is not None:
            params["TransactionType"] = transactiontype
            
        if pagenum is not None:
            params["pageNum"] = pagenum
            
        if pagesize is not None:
            params["pageSize"] = pagesize
            
        
        
        # Replace path parameters in URL
        path = "/tradeFinance/exportCollectionBills/draftView"
        
        
        # Prepare headers
        headers = {}
        if accesstoken is not None:
            headers["Accesstoken"] = str(accesstoken)
        if channeltype is not None:
            headers["ChannelType"] = str(channeltype)
        if co_relationid is not None:
            headers["co-Relationid"] = str(co_relationid)
        if entity is not None:
            headers["entity"] = str(entity)
        if initiatingsystem is not None:
            headers["initiatingSystem"] = str(initiatingsystem)
        if languagecode is not None:
            headers["languageCode"] = str(languagecode)
        if referenceid is not None:
            headers["referenceId"] = str(referenceid)
        if servicemode is not None:
            headers["serviceMode"] = str(servicemode)
        if userid is not None:
            headers["userId"] = str(userid)
        if uuidseqno is not None:
            headers["uuidSeqNo"] = str(uuidseqno)
        
        
        return await make_api_request(
            "GET", 
            path, 
            
            params=params if params else None, 
            headers=headers if headers else None
        )
    
    
    
    @mcp.tool()
    async def edcet1021_fetch_dclist_postusing_get(
        benfname: Optional[str] = None,
        billcurrency: Optional[str] = None,
        billrefext: Optional[str] = None,
        billrefint: Optional[str] = None,
        blamount: Optional[str] = None,
        custid: Optional[str] = None,
        custname: Optional[str] = None,
        edcinstrumentnm: Optional[str] = None,
        entityid: Optional[str] = None,
        stat: Optional[str] = None,
        transactionid: Optional[str] = None,
        transactiontype: Optional[str] = None,
        enddate: Optional[str] = None,
        pagenum: Optional[int] = None,
        pagesize: Optional[int] = None,
        startdate: Optional[str] = None,
        accesstoken: Optional[str] = None,
        channeltype: Optional[int] = None,
        co_relationid: Optional[int] = None,
        entity: Optional[str] = None,
        initiatingsystem: Optional[str] = None,
        languagecode: Optional[int] = None,
        referenceid: Optional[str] = None,
        servicemode: Optional[int] = None,
        userid: Optional[int] = None,
        uuidseqno: Optional[int] = None
    ) -> Dict[str, Any]:
        """
        Documentary Collections List
        
        Generated from: GET /tradeFinance/exportCollectionBills/list
        Source: swagger_2_0
        Operation ID: EDCET1021FetchDCList_POSTUsingGET
        
        
        Authentication: Not required
        
        Parameters:
        - BenfName: string
          Benf Name
        - BillCurrency: string
          Bill Currency 
        - BillRefExt: string
          BillRefExtf
        - BillRefInt: string
          Bill Referance External
        - BlAmount: string
          Bill Amount
        - CustId: string
          Customer ID
        - CustName: string
          Customer Name
        - EdcInstrumentNm: string
          Instrument Name From Value
        - EntityId: string
          Entity ID
        - Stat: string
          Bill Status
        - TransactionId: string
          Transaction ID
        - TransactionType: string
          Transaction Type
        - endDate: string
          End Date. Date Format :[dd/MM/yyyy]
        - pageNum: integer
          pageNum
        - pageSize: integer
          pageSize
        - startDate: string
          Start Date. Date Format :[dd/MM/yyyy]
        
        
        
        Headers:
        - Accesstoken: string
          Authorization Token to validation the caller
        - ChannelType: integer
          Channel identifier from where the TXN has originated (Internet, Mobile, ATM, Branch Channel )
        - co-Relationid: integer
          Unique ID for the service invoked, will be set by the TXN system
        - entity: string
          entity
        - initiatingSystem: string
          Indicating the initiated system
        - languageCode: integer
          languageCode
        - referenceId: string
          Place holder for Token based authentication
        - serviceMode: integer
          Used for branch channel to indicate the type of customer
        - userId: integer
          userId
        - uuidSeqNo: integer
          UUID Sequence Number
        
        
        """
        
        
        # Prepare query parameters
        params = {}
        if benfname is not None:
            params["BenfName"] = benfname
            
        if billcurrency is not None:
            params["BillCurrency"] = billcurrency
            
        if billrefext is not None:
            params["BillRefExt"] = billrefext
            
        if billrefint is not None:
            params["BillRefInt"] = billrefint
            
        if blamount is not None:
            params["BlAmount"] = blamount
            
        if custid is not None:
            params["CustId"] = custid
            
        if custname is not None:
            params["CustName"] = custname
            
        if edcinstrumentnm is not None:
            params["EdcInstrumentNm"] = edcinstrumentnm
            
        if entityid is not None:
            params["EntityId"] = entityid
            
        if stat is not None:
            params["Stat"] = stat
            
        if transactionid is not None:
            params["TransactionId"] = transactionid
            
        if transactiontype is not None:
            params["TransactionType"] = transactiontype
            
        if enddate is not None:
            params["endDate"] = enddate
            
        if pagenum is not None:
            params["pageNum"] = pagenum
            
        if pagesize is not None:
            params["pageSize"] = pagesize
            
        if startdate is not None:
            params["startDate"] = startdate
            
        
        
        # Replace path parameters in URL
        path = "/tradeFinance/exportCollectionBills/list"
        
        
        # Prepare headers
        headers = {}
        if accesstoken is not None:
            headers["Accesstoken"] = str(accesstoken)
        if channeltype is not None:
            headers["ChannelType"] = str(channeltype)
        if co_relationid is not None:
            headers["co-Relationid"] = str(co_relationid)
        if entity is not None:
            headers["entity"] = str(entity)
        if initiatingsystem is not None:
            headers["initiatingSystem"] = str(initiatingsystem)
        if languagecode is not None:
            headers["languageCode"] = str(languagecode)
        if referenceid is not None:
            headers["referenceId"] = str(referenceid)
        if servicemode is not None:
            headers["serviceMode"] = str(servicemode)
        if userid is not None:
            headers["userId"] = str(userid)
        if uuidseqno is not None:
            headers["uuidSeqNo"] = str(uuidseqno)
        
        
        return await make_api_request(
            "GET", 
            path, 
            
            params=params if params else None, 
            headers=headers if headers else None
        )
    
    
    
    @mcp.tool()
    async def edcbt1002_dcon_hold_to_on_hold_postusing_post(
        request_body:Dict[str, Any] ,  # RegisterExportDCModifyRequest,
        accesstoken: Optional[str] = None,
        channeltype: Optional[int] = None,
        co_relationid: Optional[int] = None,
        entity: Optional[str] = None,
        initiatingsystem: Optional[str] = None,
        languagecode: Optional[int] = None,
        referenceid: Optional[str] = None,
        servicemode: Optional[int] = None,
        userid: Optional[int] = None,
        uuidseqno: Optional[int] = None
    ) -> Dict[str, Any]:
        """
        Export documentary Collection Modify
        
        Generated from: POST /tradeFinance/exportCollectionBills/modify
        Source: swagger_2_0
        Operation ID: EDCBT1002DCOnHoldToOnHold_POSTUsingPOST
        
        
        Authentication: Not required
        
        Parameters:
        - request_body: any (required)
          input
        
        
        
        Headers:
        - Accesstoken: string
          Authorization Token to validation the caller
        - ChannelType: integer
          Channel identifier from where the TXN has originated (Internet, Mobile, ATM, Branch Channel )
        - co-Relationid: integer
          Unique ID for the service invoked, will be set by the TXN system
        - entity: string
          entity
        - initiatingSystem: string
          Indicating the initiated system
        - languageCode: integer
          languageCode
        - referenceId: string
          Place holder for Token based authentication
        - serviceMode: integer
          Used for branch channel to indicate the type of customer
        - userId: integer
          userId
        - uuidSeqNo: integer
          UUID Sequence Number
        
        
        """
        
        
        # Prepare request data
        
        # Single body parameter - send directly
        data = request_body if request_body is not None else {}
        
        
        
        # Prepare query parameters
        params = {}
        
        
        # Replace path parameters in URL
        path = "/tradeFinance/exportCollectionBills/modify"
        
        
        # Prepare headers
        headers = {}
        if accesstoken is not None:
            headers["Accesstoken"] = str(accesstoken)
        if channeltype is not None:
            headers["ChannelType"] = str(channeltype)
        if co_relationid is not None:
            headers["co-Relationid"] = str(co_relationid)
        if entity is not None:
            headers["entity"] = str(entity)
        if initiatingsystem is not None:
            headers["initiatingSystem"] = str(initiatingsystem)
        if languagecode is not None:
            headers["languageCode"] = str(languagecode)
        if referenceid is not None:
            headers["referenceId"] = str(referenceid)
        if servicemode is not None:
            headers["serviceMode"] = str(servicemode)
        if userid is not None:
            headers["userId"] = str(userid)
        if uuidseqno is not None:
            headers["uuidSeqNo"] = str(uuidseqno)
        
        
        return await make_api_request(
            "POST", 
            path, 
            data=data, 
            params=params if params else None, 
            headers=headers if headers else None
        )
    
    
    
    @mcp.tool()
    async def edcbt5984_modify_draft_dtls_postusing_post(
        modeflag: int,
        request_body:Dict[str, Any] ,  # edcBillDraftDtlsModifyDraftDtlsRequest,
        channeltype: Optional[int] = None,
        co_relationid: Optional[int] = None,
        entity: Optional[str] = None,
        initiatingsystem: Optional[str] = None,
        languagecode: Optional[int] = None,
        referenceid: Optional[str] = None,
        requesthash: Optional[str] = None,
        servicemode: Optional[int] = None,
        userid: Optional[int] = None,
        uuidseqno: Optional[int] = None
    ) -> Dict[str, Any]:
        """
        Modify Draft Details
        
        Generated from: POST /tradeFinance/exportCollectionBills/modifyMaturityDate
        Source: swagger_2_0
        Operation ID: EDCBT5984ModifyDraftDtls_POSTUsingPOST
        
        
        Authentication: Not required
        
        Parameters:
        - modeFlag: integer (required)
          Mode Flag. Possible values : 1 - Add, 10 - Authorize, 11 - Reject Domain name :  d_ModeFlg_Add,d_ModeFlg_Authorised and d_ModeFlg_Reject 
        - request_body: any (required)
          input
        
        
        
        Headers:
        - ChannelType: integer
          Channel identifier from where the TXN has originated (Internet, Mobile, ATM, Branch Channel )
        - co-Relationid: integer
          Unique ID for the service invoked, will be set by the TXN system
        - entity: string
          entity
        - initiatingSystem: string
          Indicating the initiated system
        - languageCode: integer
          languageCode
        - referenceId: string
          Place holder for Token based authentication
        - requestHash: string
          Request payload for hash validation
        - serviceMode: integer
          Used for branch channel to indicate the type of customer
        - userId: integer
          userId
        - uuidSeqNo: integer
          UUID Sequence Number
        
        
        """
        
        
        # Prepare request data
        
        # Single body parameter - send directly
        data = request_body if request_body is not None else {}
        
        
        
        # Prepare query parameters
        params = {}
        if modeflag is not None:
            params["modeFlag"] = modeflag
            
        
        
        # Replace path parameters in URL
        path = "/tradeFinance/exportCollectionBills/modifyMaturityDate"
        
        
        # Prepare headers
        headers = {}
        if channeltype is not None:
            headers["ChannelType"] = str(channeltype)
        if co_relationid is not None:
            headers["co-Relationid"] = str(co_relationid)
        if entity is not None:
            headers["entity"] = str(entity)
        if initiatingsystem is not None:
            headers["initiatingSystem"] = str(initiatingsystem)
        if languagecode is not None:
            headers["languageCode"] = str(languagecode)
        if referenceid is not None:
            headers["referenceId"] = str(referenceid)
        if requesthash is not None:
            headers["requestHash"] = str(requesthash)
        if servicemode is not None:
            headers["serviceMode"] = str(servicemode)
        if userid is not None:
            headers["userId"] = str(userid)
        if uuidseqno is not None:
            headers["uuidSeqNo"] = str(uuidseqno)
        
        
        return await make_api_request(
            "POST", 
            path, 
            data=data, 
            params=params if params else None, 
            headers=headers if headers else None
        )
    
    
    
    @mcp.tool()
    async def edcbt1101_set_up_dcprty_dtls_postusing_post(
        request_body:Dict[str, Any] ,  # RegisterExportDCPartyRequest,
        accesstoken: Optional[str] = None,
        channeltype: Optional[int] = None,
        co_relationid: Optional[int] = None,
        entity: Optional[str] = None,
        initiatingsystem: Optional[str] = None,
        languagecode: Optional[int] = None,
        referenceid: Optional[str] = None,
        servicemode: Optional[int] = None,
        userid: Optional[int] = None,
        uuidseqno: Optional[int] = None
    ) -> Dict[str, Any]:
        """
        Party Details under Documentary Collections- Setup
        
        Generated from: POST /tradeFinance/exportCollectionBills/partySetup
        Source: swagger_2_0
        Operation ID: EDCBT1101SetUpDCPrtyDtls_POSTUsingPOST
        
        
        Authentication: Not required
        
        Parameters:
        - request_body: any (required)
          input
        
        
        
        Headers:
        - Accesstoken: string
          Authorization Token to validation the caller
        - ChannelType: integer
          Channel identifier from where the TXN has originated (Internet, Mobile, ATM, Branch Channel )
        - co-Relationid: integer
          Unique ID for the service invoked, will be set by the TXN system
        - entity: string
          entity
        - initiatingSystem: string
          Indicating the initiated system
        - languageCode: integer
          languageCode
        - referenceId: string
          Place holder for Token based authentication
        - serviceMode: integer
          Used for branch channel to indicate the type of customer
        - userId: integer
          userId
        - uuidSeqNo: integer
          UUID Sequence Number
        
        
        """
        
        
        # Prepare request data
        
        # Single body parameter - send directly
        data = request_body if request_body is not None else {}
        
        
        
        # Prepare query parameters
        params = {}
        
        
        # Replace path parameters in URL
        path = "/tradeFinance/exportCollectionBills/partySetup"
        
        
        # Prepare headers
        headers = {}
        if accesstoken is not None:
            headers["Accesstoken"] = str(accesstoken)
        if channeltype is not None:
            headers["ChannelType"] = str(channeltype)
        if co_relationid is not None:
            headers["co-Relationid"] = str(co_relationid)
        if entity is not None:
            headers["entity"] = str(entity)
        if initiatingsystem is not None:
            headers["initiatingSystem"] = str(initiatingsystem)
        if languagecode is not None:
            headers["languageCode"] = str(languagecode)
        if referenceid is not None:
            headers["referenceId"] = str(referenceid)
        if servicemode is not None:
            headers["serviceMode"] = str(servicemode)
        if userid is not None:
            headers["userId"] = str(userid)
        if uuidseqno is not None:
            headers["uuidSeqNo"] = str(uuidseqno)
        
        
        return await make_api_request(
            "POST", 
            path, 
            data=data, 
            params=params if params else None, 
            headers=headers if headers else None
        )
    
    
    
    @mcp.tool()
    async def edcet1102_get_dcprty_dtls_postusing_get(
        entity1: Optional[str] = None,
        transactioneventid: Optional[int] = None,
        transactionid: Optional[int] = None,
        transactiontype: Optional[int] = None,
        pagenum: Optional[int] = None,
        pagesize: Optional[int] = None,
        accesstoken: Optional[str] = None,
        channeltype: Optional[int] = None,
        co_relationid: Optional[int] = None,
        entity: Optional[str] = None,
        initiatingsystem: Optional[str] = None,
        languagecode: Optional[int] = None,
        referenceid: Optional[str] = None,
        servicemode: Optional[int] = None,
        userid: Optional[int] = None,
        uuidseqno: Optional[int] = None
    ) -> Dict[str, Any]:
        """
        Party Details under Documentary Collections- View
        
        Generated from: GET /tradeFinance/exportCollectionBills/partyView
        Source: swagger_2_0
        Operation ID: EDCET1102GetDCPrtyDtls_POSTUsingGET
        
        
        Authentication: Not required
        
        Parameters:
        - Entity1: string
          Entity ID
        - TransactionEventID: integer
          Event Leg ID
        - TransactionID: integer
          Export Documentary collection Pos ID
        - TransactionType: integer
          Export Documentary collection Pos Type
        - pageNum: integer
          pageNum
        - pageSize: integer
          pageSize
        
        
        
        Headers:
        - Accesstoken: string
          Authorization Token to validation the caller
        - ChannelType: integer
          Channel identifier from where the TXN has originated (Internet, Mobile, ATM, Branch Channel )
        - co-Relationid: integer
          Unique ID for the service invoked, will be set by the TXN system
        - entity: string
          entity
        - initiatingSystem: string
          Indicating the initiated system
        - languageCode: integer
          languageCode
        - referenceId: string
          Place holder for Token based authentication
        - serviceMode: integer
          Used for branch channel to indicate the type of customer
        - userId: integer
          userId
        - uuidSeqNo: integer
          UUID Sequence Number
        
        
        """
        
        
        # Prepare query parameters
        params = {}
        if entity1 is not None:
            params["Entity1"] = entity1
            
        if transactioneventid is not None:
            params["TransactionEventID"] = transactioneventid
            
        if transactionid is not None:
            params["TransactionID"] = transactionid
            
        if transactiontype is not None:
            params["TransactionType"] = transactiontype
            
        if pagenum is not None:
            params["pageNum"] = pagenum
            
        if pagesize is not None:
            params["pageSize"] = pagesize
            
        
        
        # Replace path parameters in URL
        path = "/tradeFinance/exportCollectionBills/partyView"
        
        
        # Prepare headers
        headers = {}
        if accesstoken is not None:
            headers["Accesstoken"] = str(accesstoken)
        if channeltype is not None:
            headers["ChannelType"] = str(channeltype)
        if co_relationid is not None:
            headers["co-Relationid"] = str(co_relationid)
        if entity is not None:
            headers["entity"] = str(entity)
        if initiatingsystem is not None:
            headers["initiatingSystem"] = str(initiatingsystem)
        if languagecode is not None:
            headers["languageCode"] = str(languagecode)
        if referenceid is not None:
            headers["referenceId"] = str(referenceid)
        if servicemode is not None:
            headers["serviceMode"] = str(servicemode)
        if userid is not None:
            headers["userId"] = str(userid)
        if uuidseqno is not None:
            headers["uuidSeqNo"] = str(uuidseqno)
        
        
        return await make_api_request(
            "GET", 
            path, 
            
            params=params if params else None, 
            headers=headers if headers else None
        )
    
    
    
    @mcp.tool()
    async def edcbt3001_crt_blpay_on_hold_postusing_post(
        request_body:Dict[str, Any] ,  # RegisterExportDCPaymentRequest,
        accesstoken: Optional[str] = None,
        channeltype: Optional[int] = None,
        co_relationid: Optional[int] = None,
        entity: Optional[str] = None,
        initiatingsystem: Optional[str] = None,
        languagecode: Optional[int] = None,
        mu_id: Optional[str] = None,
        referenceid: Optional[str] = None,
        servicemode: Optional[int] = None,
        userid: Optional[int] = None,
        uuidseqno: Optional[int] = None
    ) -> Dict[str, Any]:
        """
        Registration of Export DC Bill Payment
        
        Generated from: POST /tradeFinance/exportCollectionBills/payments
        Source: swagger_2_0
        Operation ID: EDCBT3001CrtBLPayOnHold_POSTUsingPOST
        
        
        Authentication: Not required
        
        Parameters:
        - request_body: any (required)
          input
        
        
        
        Headers:
        - Accesstoken: string
          Authorization Token to validation the caller
        - ChannelType: integer
          Channel identifier from where the TXN has originated (Internet, Mobile, ATM, Branch Channel )
        - co-Relationid: integer
          Unique ID for the service invoked, will be set by the TXN system
        - entity: string
          entity
        - initiatingSystem: string
          Indicating the initiated system
        - languageCode: integer
          languageCode
        - mu_Id: string
          Muid
        - referenceId: string
          Place holder for Token based authentication
        - serviceMode: integer
          Used for branch channel to indicate the type of customer
        - userId: integer
          userId
        - uuidSeqNo: integer
          UUID Sequence Number
        
        
        """
        
        
        # Prepare request data
        
        # Single body parameter - send directly
        data = request_body if request_body is not None else {}
        
        
        
        # Prepare query parameters
        params = {}
        
        
        # Replace path parameters in URL
        path = "/tradeFinance/exportCollectionBills/payments"
        
        
        # Prepare headers
        headers = {}
        if accesstoken is not None:
            headers["Accesstoken"] = str(accesstoken)
        if channeltype is not None:
            headers["ChannelType"] = str(channeltype)
        if co_relationid is not None:
            headers["co-Relationid"] = str(co_relationid)
        if entity is not None:
            headers["entity"] = str(entity)
        if initiatingsystem is not None:
            headers["initiatingSystem"] = str(initiatingsystem)
        if languagecode is not None:
            headers["languageCode"] = str(languagecode)
        if mu_id is not None:
            headers["mu_Id"] = str(mu_id)
        if referenceid is not None:
            headers["referenceId"] = str(referenceid)
        if servicemode is not None:
            headers["serviceMode"] = str(servicemode)
        if userid is not None:
            headers["userId"] = str(userid)
        if uuidseqno is not None:
            headers["uuidSeqNo"] = str(uuidseqno)
        
        
        return await make_api_request(
            "POST", 
            path, 
            data=data, 
            params=params if params else None, 
            headers=headers if headers else None
        )
    
    
    
    @mcp.tool()
    async def edcbt3004_blpay_on_hold_to_rjct_postusing_post(
        request_body:Dict[str, Any] ,  # EdcBillPaymentOnHoldToCancelRequest,
        accesstoken: Optional[str] = None,
        channeltype: Optional[int] = None,
        co_relationid: Optional[int] = None,
        entity: Optional[str] = None,
        initiatingsystem: Optional[str] = None,
        languagecode: Optional[int] = None,
        referenceid: Optional[str] = None,
        servicemode: Optional[int] = None,
        userid: Optional[int] = None,
        uuidseqno: Optional[int] = None
    ) -> Dict[str, Any]:
        """
        Cancel Registration of Export DC Bill Payment
        
        Generated from: POST /tradeFinance/exportCollectionBills/payments/cancel
        Source: swagger_2_0
        Operation ID: EDCBT3004BLPayOnHoldToRjct_POSTUsingPOST
        
        
        Authentication: Not required
        
        Parameters:
        - request_body: any (required)
          input
        
        
        
        Headers:
        - Accesstoken: string
          Authorization Token to validation the caller
        - ChannelType: integer
          Channel identifier from where the TXN has originated (Internet, Mobile, ATM, Branch Channel )
        - co-Relationid: integer
          Unique ID for the service invoked, will be set by the TXN system
        - entity: string
          entity
        - initiatingSystem: string
          Indicating the initiated system
        - languageCode: integer
          languageCode
        - referenceId: string
          Place holder for Token based authentication
        - serviceMode: integer
          Used for branch channel to indicate the type of customer
        - userId: integer
          userId
        - uuidSeqNo: integer
          UUID Sequence Number
        
        
        """
        
        
        # Prepare request data
        
        # Single body parameter - send directly
        data = request_body if request_body is not None else {}
        
        
        
        # Prepare query parameters
        params = {}
        
        
        # Replace path parameters in URL
        path = "/tradeFinance/exportCollectionBills/payments/cancel"
        
        
        # Prepare headers
        headers = {}
        if accesstoken is not None:
            headers["Accesstoken"] = str(accesstoken)
        if channeltype is not None:
            headers["ChannelType"] = str(channeltype)
        if co_relationid is not None:
            headers["co-Relationid"] = str(co_relationid)
        if entity is not None:
            headers["entity"] = str(entity)
        if initiatingsystem is not None:
            headers["initiatingSystem"] = str(initiatingsystem)
        if languagecode is not None:
            headers["languageCode"] = str(languagecode)
        if referenceid is not None:
            headers["referenceId"] = str(referenceid)
        if servicemode is not None:
            headers["serviceMode"] = str(servicemode)
        if userid is not None:
            headers["userId"] = str(userid)
        if uuidseqno is not None:
            headers["uuidSeqNo"] = str(uuidseqno)
        
        
        return await make_api_request(
            "POST", 
            path, 
            data=data, 
            params=params if params else None, 
            headers=headers if headers else None
        )
    
    
    
    @mcp.tool()
    async def edcet3028_fetch_blpay_list_postusing_get(
        benfname: Optional[str] = None,
        benificiaryname: Optional[str] = None,
        billamount: Optional[str] = None,
        billcurrency: Optional[str] = None,
        billexternalreference: Optional[str] = None,
        cifid: Optional[str] = None,
        customername: Optional[str] = None,
        entityid: Optional[str] = None,
        netamountpay: Optional[str] = None,
        payamount: Optional[str] = None,
        paycurrency: Optional[str] = None,
        paydate: Optional[str] = None,
        paymentexternalreference: Optional[str] = None,
        paymentinternalreference: Optional[str] = None,
        stat: Optional[str] = None,
        transactionid: Optional[str] = None,
        edcstartdate: Optional[str] = None,
        enddate: Optional[str] = None,
        pagenum: Optional[int] = None,
        pagesize: Optional[int] = None,
        raterequeststatus: Optional[int] = None,
        accesstoken: Optional[str] = None,
        channeltype: Optional[int] = None,
        co_relationid: Optional[int] = None,
        entity: Optional[str] = None,
        initiatingsystem: Optional[str] = None,
        languagecode: Optional[int] = None,
        referenceid: Optional[str] = None,
        servicemode: Optional[int] = None,
        userid: Optional[int] = None,
        uuidseqno: Optional[int] = None
    ) -> Dict[str, Any]:
        """
        Registration of Export DC Bill Payment List
        
        Generated from: GET /tradeFinance/exportCollectionBills/payments/list
        Source: swagger_2_0
        Operation ID: EDCET3028FetchBLPayList_POSTUsingGET
        
        
        Authentication: Not required
        
        Parameters:
        - BenfName: string
          BenfName
        - BenificiaryName: string
          BenificiaryName
        - BillAmount: string
          BillAmount
        - BillCurrency: string
          BillCurrency
        - BillExternalReference: string
          BillExternalReference
        - CIFId: string
          CIFId
        - CustomerName: string
          CustomerName
        - EntityID: string
          EntityID
        - NetAmountPay: string
          NetAmountPay
        - PayAmount: string
          Payment Amount
        - PayCurrency: string
          Payment Currency
        - Paydate: string
          Paydate
        - PaymentExternalReference: string
          PaymentExternalReference
        - PaymentInternalReference: string
          PaymentInternalReference
        - Stat: string
          Payment Status(Possible values: OnHold -1 ,Released -2 ,Verified -3 ,Rejected -4 ,Executed -5 ,Settled -6)
        - TransactionId: string
          TransactionID
        - edcstartDate: string
          Start Date
        - endDate: string
          End Date
        - pageNum: integer
          pageNum
        - pageSize: integer
          pageSize
        - rateRequestStatus: integer
          Rate Request Status
        
        
        
        Headers:
        - Accesstoken: string
          Authorization Token to validation the caller
        - ChannelType: integer
          Channel identifier from where the TXN has originated (Internet, Mobile, ATM, Branch Channel )
        - co-Relationid: integer
          Unique ID for the service invoked, will be set by the TXN system
        - entity: string
          entity
        - initiatingSystem: string
          Indicating the initiated system
        - languageCode: integer
          languageCode
        - referenceId: string
          Place holder for Token based authentication
        - serviceMode: integer
          Used for branch channel to indicate the type of customer
        - userId: integer
          userId
        - uuidSeqNo: integer
          UUID Sequence Number
        
        
        """
        
        
        # Prepare query parameters
        params = {}
        if benfname is not None:
            params["BenfName"] = benfname
            
        if benificiaryname is not None:
            params["BenificiaryName"] = benificiaryname
            
        if billamount is not None:
            params["BillAmount"] = billamount
            
        if billcurrency is not None:
            params["BillCurrency"] = billcurrency
            
        if billexternalreference is not None:
            params["BillExternalReference"] = billexternalreference
            
        if cifid is not None:
            params["CIFId"] = cifid
            
        if customername is not None:
            params["CustomerName"] = customername
            
        if entityid is not None:
            params["EntityID"] = entityid
            
        if netamountpay is not None:
            params["NetAmountPay"] = netamountpay
            
        if payamount is not None:
            params["PayAmount"] = payamount
            
        if paycurrency is not None:
            params["PayCurrency"] = paycurrency
            
        if paydate is not None:
            params["Paydate"] = paydate
            
        if paymentexternalreference is not None:
            params["PaymentExternalReference"] = paymentexternalreference
            
        if paymentinternalreference is not None:
            params["PaymentInternalReference"] = paymentinternalreference
            
        if stat is not None:
            params["Stat"] = stat
            
        if transactionid is not None:
            params["TransactionId"] = transactionid
            
        if edcstartdate is not None:
            params["edcstartDate"] = edcstartdate
            
        if enddate is not None:
            params["endDate"] = enddate
            
        if pagenum is not None:
            params["pageNum"] = pagenum
            
        if pagesize is not None:
            params["pageSize"] = pagesize
            
        if raterequeststatus is not None:
            params["rateRequestStatus"] = raterequeststatus
            
        
        
        # Replace path parameters in URL
        path = "/tradeFinance/exportCollectionBills/payments/list"
        
        
        # Prepare headers
        headers = {}
        if accesstoken is not None:
            headers["Accesstoken"] = str(accesstoken)
        if channeltype is not None:
            headers["ChannelType"] = str(channeltype)
        if co_relationid is not None:
            headers["co-Relationid"] = str(co_relationid)
        if entity is not None:
            headers["entity"] = str(entity)
        if initiatingsystem is not None:
            headers["initiatingSystem"] = str(initiatingsystem)
        if languagecode is not None:
            headers["languageCode"] = str(languagecode)
        if referenceid is not None:
            headers["referenceId"] = str(referenceid)
        if servicemode is not None:
            headers["serviceMode"] = str(servicemode)
        if userid is not None:
            headers["userId"] = str(userid)
        if uuidseqno is not None:
            headers["uuidSeqNo"] = str(uuidseqno)
        
        
        return await make_api_request(
            "GET", 
            path, 
            
            params=params if params else None, 
            headers=headers if headers else None
        )
    
    
    
    @mcp.tool()
    async def edcbt3002_blpay_on_hold_to_on_hold_postusing_put(
        request_body:Dict[str, Any] ,  # ModifyExportDCPaymentRequest,
        accesstoken: Optional[str] = None,
        channeltype: Optional[int] = None,
        co_relationid: Optional[int] = None,
        entity: Optional[str] = None,
        initiatingsystem: Optional[str] = None,
        languagecode: Optional[int] = None,
        referenceid: Optional[str] = None,
        servicemode: Optional[int] = None,
        userid: Optional[int] = None,
        uuidseqno: Optional[int] = None
    ) -> Dict[str, Any]:
        """
        Modify Registration of Export DC Bill Payment
        
        Generated from: PUT /tradeFinance/exportCollectionBills/payments/modify
        Source: swagger_2_0
        Operation ID: EDCBT3002BLPayOnHoldToOnHold_POSTUsingPUT
        
        
        Authentication: Not required
        
        Parameters:
        - request_body: any (required)
          input
        
        
        
        Headers:
        - Accesstoken: string
          Authorization Token to validation the caller
        - ChannelType: integer
          Channel identifier from where the TXN has originated (Internet, Mobile, ATM, Branch Channel )
        - co-Relationid: integer
          Unique ID for the service invoked, will be set by the TXN system
        - entity: string
          entity
        - initiatingSystem: string
          Indicating the initiated system
        - languageCode: integer
          languageCode
        - referenceId: string
          Place holder for Token based authentication
        - serviceMode: integer
          Used for branch channel to indicate the type of customer
        - userId: integer
          userId
        - uuidSeqNo: integer
          UUID Sequence Number
        
        
        """
        
        
        # Prepare request data
        
        # Single body parameter - send directly
        data = request_body if request_body is not None else {}
        
        
        
        # Prepare query parameters
        params = {}
        
        
        # Replace path parameters in URL
        path = "/tradeFinance/exportCollectionBills/payments/modify"
        
        
        # Prepare headers
        headers = {}
        if accesstoken is not None:
            headers["Accesstoken"] = str(accesstoken)
        if channeltype is not None:
            headers["ChannelType"] = str(channeltype)
        if co_relationid is not None:
            headers["co-Relationid"] = str(co_relationid)
        if entity is not None:
            headers["entity"] = str(entity)
        if initiatingsystem is not None:
            headers["initiatingSystem"] = str(initiatingsystem)
        if languagecode is not None:
            headers["languageCode"] = str(languagecode)
        if referenceid is not None:
            headers["referenceId"] = str(referenceid)
        if servicemode is not None:
            headers["serviceMode"] = str(servicemode)
        if userid is not None:
            headers["userId"] = str(userid)
        if uuidseqno is not None:
            headers["uuidSeqNo"] = str(uuidseqno)
        
        
        return await make_api_request(
            "PUT", 
            path, 
            data=data, 
            params=params if params else None, 
            headers=headers if headers else None
        )
    
    
    
    @mcp.tool()
    async def edcbt3003_blpay_on_hold_to_released_postusing_put(
        request_body:Dict[str, Any] ,  # ReleaseExportDCPaymentRequest,
        accesstoken: Optional[str] = None,
        channeltype: Optional[int] = None,
        co_relationid: Optional[int] = None,
        entity: Optional[str] = None,
        initiatingsystem: Optional[str] = None,
        languagecode: Optional[int] = None,
        referenceid: Optional[str] = None,
        servicemode: Optional[int] = None,
        userid: Optional[int] = None,
        uuidseqno: Optional[int] = None
    ) -> Dict[str, Any]:
        """
        Release Registration of Export DC Bill Payment
        
        Generated from: PUT /tradeFinance/exportCollectionBills/payments/userConfirmation
        Source: swagger_2_0
        Operation ID: EDCBT3003BLPayOnHoldToReleased_POSTUsingPUT
        
        
        Authentication: Not required
        
        Parameters:
        - request_body: any (required)
          input
        
        
        
        Headers:
        - Accesstoken: string
          Authorization Token to validation the caller
        - ChannelType: integer
          Channel identifier from where the TXN has originated (Internet, Mobile, ATM, Branch Channel )
        - co-Relationid: integer
          Unique ID for the service invoked, will be set by the TXN system
        - entity: string
          entity
        - initiatingSystem: string
          Indicating the initiated system
        - languageCode: integer
          languageCode
        - referenceId: string
          Place holder for Token based authentication
        - serviceMode: integer
          Used for branch channel to indicate the type of customer
        - userId: integer
          userId
        - uuidSeqNo: integer
          UUID Sequence Number
        
        
        """
        
        
        # Prepare request data
        
        # Single body parameter - send directly
        data = request_body if request_body is not None else {}
        
        
        
        # Prepare query parameters
        params = {}
        
        
        # Replace path parameters in URL
        path = "/tradeFinance/exportCollectionBills/payments/userConfirmation"
        
        
        # Prepare headers
        headers = {}
        if accesstoken is not None:
            headers["Accesstoken"] = str(accesstoken)
        if channeltype is not None:
            headers["ChannelType"] = str(channeltype)
        if co_relationid is not None:
            headers["co-Relationid"] = str(co_relationid)
        if entity is not None:
            headers["entity"] = str(entity)
        if initiatingsystem is not None:
            headers["initiatingSystem"] = str(initiatingsystem)
        if languagecode is not None:
            headers["languageCode"] = str(languagecode)
        if referenceid is not None:
            headers["referenceId"] = str(referenceid)
        if servicemode is not None:
            headers["serviceMode"] = str(servicemode)
        if userid is not None:
            headers["userId"] = str(userid)
        if uuidseqno is not None:
            headers["uuidSeqNo"] = str(uuidseqno)
        
        
        return await make_api_request(
            "PUT", 
            path, 
            data=data, 
            params=params if params else None, 
            headers=headers if headers else None
        )
    
    
    
    @mcp.tool()
    async def edcet3011_get_blpay_dtls_postusing_get(
        billreference: Optional[str] = None,
        identifier: Optional[int] = None,
        paymentexternalreference: Optional[str] = None,
        pagenum: Optional[int] = None,
        pagesize: Optional[int] = None,
        accesstoken: Optional[str] = None,
        channeltype: Optional[int] = None,
        co_relationid: Optional[int] = None,
        entity: Optional[str] = None,
        initiatingsystem: Optional[str] = None,
        languagecode: Optional[int] = None,
        referenceid: Optional[str] = None,
        servicemode: Optional[int] = None,
        userid: Optional[int] = None,
        uuidseqno: Optional[int] = None
    ) -> Dict[str, Any]:
        """
        View Registration of Export DC Bill Payment
        
        Generated from: GET /tradeFinance/exportCollectionBills/payments/view
        Source: swagger_2_0
        Operation ID: EDCET3011GetBLPayDtls_POSTUsingGET
        
        
        Authentication: Not required
        
        Parameters:
        - BillReference: string
          Export Documentry Collection Bill Referance
        - Identifier: integer
          Identifier value =1 to view Bill
        - PaymentexternalReference: string
          Payment External Reference
        - pageNum: integer
          pageNum
        - pageSize: integer
          pageSize
        
        
        
        Headers:
        - Accesstoken: string
          Authorization Token to validation the caller
        - ChannelType: integer
          Channel identifier from where the TXN has originated (Internet, Mobile, ATM, Branch Channel )
        - co-Relationid: integer
          Unique ID for the service invoked, will be set by the TXN system
        - entity: string
          entity
        - initiatingSystem: string
          Indicating the initiated system
        - languageCode: integer
          languageCode
        - referenceId: string
          Place holder for Token based authentication
        - serviceMode: integer
          Used for branch channel to indicate the type of customer
        - userId: integer
          userId
        - uuidSeqNo: integer
          UUID Sequence Number
        
        
        """
        
        
        # Prepare query parameters
        params = {}
        if billreference is not None:
            params["BillReference"] = billreference
            
        if identifier is not None:
            params["Identifier"] = identifier
            
        if paymentexternalreference is not None:
            params["PaymentexternalReference"] = paymentexternalreference
            
        if pagenum is not None:
            params["pageNum"] = pagenum
            
        if pagesize is not None:
            params["pageSize"] = pagesize
            
        
        
        # Replace path parameters in URL
        path = "/tradeFinance/exportCollectionBills/payments/view"
        
        
        # Prepare headers
        headers = {}
        if accesstoken is not None:
            headers["Accesstoken"] = str(accesstoken)
        if channeltype is not None:
            headers["ChannelType"] = str(channeltype)
        if co_relationid is not None:
            headers["co-Relationid"] = str(co_relationid)
        if entity is not None:
            headers["entity"] = str(entity)
        if initiatingsystem is not None:
            headers["initiatingSystem"] = str(initiatingsystem)
        if languagecode is not None:
            headers["languageCode"] = str(languagecode)
        if referenceid is not None:
            headers["referenceId"] = str(referenceid)
        if servicemode is not None:
            headers["serviceMode"] = str(servicemode)
        if userid is not None:
            headers["userId"] = str(userid)
        if uuidseqno is not None:
            headers["uuidSeqNo"] = str(uuidseqno)
        
        
        return await make_api_request(
            "GET", 
            path, 
            
            params=params if params else None, 
            headers=headers if headers else None
        )
    
    
    
    @mcp.tool()
    async def edcbt3005_blpay_rlsd_to_exec_postusing_put(
        externalreference: str,
        request_body:Dict[str, Any] ,  # AuthorizeExportDCPaymentRequest,
        accesstoken: Optional[str] = None,
        channeltype: Optional[int] = None,
        co_relationid: Optional[int] = None,
        entity: Optional[str] = None,
        initiatingsystem: Optional[str] = None,
        languagecode: Optional[int] = None,
        mu_id: Optional[str] = None,
        referenceid: Optional[str] = None,
        servicemode: Optional[int] = None,
        userid: Optional[int] = None,
        uuidseqno: Optional[int] = None
    ) -> Dict[str, Any]:
        """
        Authorize Registration of Export DC Bill Payment
        
        Generated from: PUT /tradeFinance/exportCollectionBills/payments/{externalReference}/authorize
        Source: swagger_2_0
        Operation ID: EDCBT3005BLPayRlsdToExec_POSTUsingPUT
        
        
        Authentication: Not required
        
        Parameters:
        - externalReference: string (required)
          Payment Export Documentary Collection Payment Referance External
        - request_body: any (required)
          input
        
        
        
        Headers:
        - Accesstoken: string
          Authorization Token to validation the caller
        - ChannelType: integer
          Channel identifier from where the TXN has originated (Internet, Mobile, ATM, Branch Channel )
        - co-Relationid: integer
          Unique ID for the service invoked, will be set by the TXN system
        - entity: string
          entity
        - initiatingSystem: string
          Indicating the initiated system
        - languageCode: integer
          languageCode
        - mu_Id: string
          Muid
        - referenceId: string
          Place holder for Token based authentication
        - serviceMode: integer
          Used for branch channel to indicate the type of customer
        - userId: integer
          userId
        - uuidSeqNo: integer
          UUID Sequence Number
        
        
        """
        
        
        # Prepare request data
        
        # Single body parameter - send directly
        data = request_body if request_body is not None else {}
        
        
        
        # Prepare query parameters
        params = {}
        
        
        # Replace path parameters in URL
        path = "/tradeFinance/exportCollectionBills/payments/{externalReference}/authorize"
        if externalreference is not None:
            path = path.replace("{externalReference}", str(externalreference))
        
        
        # Prepare headers
        headers = {}
        if accesstoken is not None:
            headers["Accesstoken"] = str(accesstoken)
        if channeltype is not None:
            headers["ChannelType"] = str(channeltype)
        if co_relationid is not None:
            headers["co-Relationid"] = str(co_relationid)
        if entity is not None:
            headers["entity"] = str(entity)
        if initiatingsystem is not None:
            headers["initiatingSystem"] = str(initiatingsystem)
        if languagecode is not None:
            headers["languageCode"] = str(languagecode)
        if mu_id is not None:
            headers["mu_Id"] = str(mu_id)
        if referenceid is not None:
            headers["referenceId"] = str(referenceid)
        if servicemode is not None:
            headers["serviceMode"] = str(servicemode)
        if userid is not None:
            headers["userId"] = str(userid)
        if uuidseqno is not None:
            headers["uuidSeqNo"] = str(uuidseqno)
        
        
        return await make_api_request(
            "PUT", 
            path, 
            data=data, 
            params=params if params else None, 
            headers=headers if headers else None
        )
    
    
    
    @mcp.tool()
    async def edcbt3006_blpay_rlsd_to_rjct_postusing_put(
        externalreference: str,
        accesstoken: Optional[str] = None,
        channeltype: Optional[int] = None,
        co_relationid: Optional[int] = None,
        entity: Optional[str] = None,
        initiatingsystem: Optional[str] = None,
        languagecode: Optional[int] = None,
        referenceid: Optional[str] = None,
        servicemode: Optional[int] = None,
        userid: Optional[int] = None,
        uuidseqno: Optional[int] = None
    ) -> Dict[str, Any]:
        """
        Reject Registration of Export DC Bill Payment
        
        Generated from: PUT /tradeFinance/exportCollectionBills/payments/{externalReference}/reject
        Source: swagger_2_0
        Operation ID: EDCBT3006BLPayRlsdToRjct_POSTUsingPUT
        
        
        Authentication: Not required
        
        Parameters:
        - externalReference: string (required)
          Payment Export Documentary Collection Payment Referance External
        
        
        
        Headers:
        - Accesstoken: string
          Authorization Token to validation the caller
        - ChannelType: integer
          Channel identifier from where the TXN has originated (Internet, Mobile, ATM, Branch Channel )
        - co-Relationid: integer
          Unique ID for the service invoked, will be set by the TXN system
        - entity: string
          entity
        - initiatingSystem: string
          Indicating the initiated system
        - languageCode: integer
          languageCode
        - referenceId: string
          Place holder for Token based authentication
        - serviceMode: integer
          Used for branch channel to indicate the type of customer
        - userId: integer
          userId
        - uuidSeqNo: integer
          UUID Sequence Number
        
        
        """
        
        
        # Prepare query parameters
        params = {}
        
        
        # Replace path parameters in URL
        path = "/tradeFinance/exportCollectionBills/payments/{externalReference}/reject"
        if externalreference is not None:
            path = path.replace("{externalReference}", str(externalreference))
        
        
        # Prepare headers
        headers = {}
        if accesstoken is not None:
            headers["Accesstoken"] = str(accesstoken)
        if channeltype is not None:
            headers["ChannelType"] = str(channeltype)
        if co_relationid is not None:
            headers["co-Relationid"] = str(co_relationid)
        if entity is not None:
            headers["entity"] = str(entity)
        if initiatingsystem is not None:
            headers["initiatingSystem"] = str(initiatingsystem)
        if languagecode is not None:
            headers["languageCode"] = str(languagecode)
        if referenceid is not None:
            headers["referenceId"] = str(referenceid)
        if servicemode is not None:
            headers["serviceMode"] = str(servicemode)
        if userid is not None:
            headers["userId"] = str(userid)
        if uuidseqno is not None:
            headers["uuidSeqNo"] = str(uuidseqno)
        
        
        return await make_api_request(
            "PUT", 
            path, 
            
            params=params if params else None, 
            headers=headers if headers else None
        )
    
    
    
    @mcp.tool()
    async def edcbt3007_blpay_rlsd_to_on_hold_postusing_put(
        externalreference: str,
        accesstoken: Optional[str] = None,
        channeltype: Optional[int] = None,
        co_relationid: Optional[int] = None,
        entity: Optional[str] = None,
        initiatingsystem: Optional[str] = None,
        languagecode: Optional[int] = None,
        referenceid: Optional[str] = None,
        servicemode: Optional[int] = None,
        userid: Optional[int] = None,
        uuidseqno: Optional[int] = None
    ) -> Dict[str, Any]:
        """
        SendBack Registration of Export DC Bill Payment
        
        Generated from: PUT /tradeFinance/exportCollectionBills/payments/{externalReference}/sendBack
        Source: swagger_2_0
        Operation ID: EDCBT3007BLPayRlsdToOnHold_POSTUsingPUT
        
        
        Authentication: Not required
        
        Parameters:
        - externalReference: string (required)
          Payment External Reference
        
        
        
        Headers:
        - Accesstoken: string
          Authorization Token to validation the caller
        - ChannelType: integer
          Channel identifier from where the TXN has originated (Internet, Mobile, ATM, Branch Channel )
        - co-Relationid: integer
          Unique ID for the service invoked, will be set by the TXN system
        - entity: string
          entity
        - initiatingSystem: string
          Indicating the initiated system
        - languageCode: integer
          languageCode
        - referenceId: string
          Place holder for Token based authentication
        - serviceMode: integer
          Used for branch channel to indicate the type of customer
        - userId: integer
          userId
        - uuidSeqNo: integer
          UUID Sequence Number
        
        
        """
        
        
        # Prepare query parameters
        params = {}
        
        
        # Replace path parameters in URL
        path = "/tradeFinance/exportCollectionBills/payments/{externalReference}/sendBack"
        if externalreference is not None:
            path = path.replace("{externalReference}", str(externalreference))
        
        
        # Prepare headers
        headers = {}
        if accesstoken is not None:
            headers["Accesstoken"] = str(accesstoken)
        if channeltype is not None:
            headers["ChannelType"] = str(channeltype)
        if co_relationid is not None:
            headers["co-Relationid"] = str(co_relationid)
        if entity is not None:
            headers["entity"] = str(entity)
        if initiatingsystem is not None:
            headers["initiatingSystem"] = str(initiatingsystem)
        if languagecode is not None:
            headers["languageCode"] = str(languagecode)
        if referenceid is not None:
            headers["referenceId"] = str(referenceid)
        if servicemode is not None:
            headers["serviceMode"] = str(servicemode)
        if userid is not None:
            headers["userId"] = str(userid)
        if uuidseqno is not None:
            headers["uuidSeqNo"] = str(uuidseqno)
        
        
        return await make_api_request(
            "PUT", 
            path, 
            
            params=params if params else None, 
            headers=headers if headers else None
        )
    
    
    
    @mcp.tool()
    async def edcbt5978_poclose_postusing_put(
        transactionid: int,
        request_body:Dict[str, Any] ,  # edcPurchaseOrderCloseRequest,
        accesstoken: Optional[str] = None,
        channeltype: Optional[int] = None,
        co_relationid: Optional[int] = None,
        entity: Optional[str] = None,
        initiatingsystem: Optional[str] = None,
        languagecode: Optional[int] = None,
        referenceid: Optional[str] = None,
        servicemode: Optional[int] = None,
        userid: Optional[int] = None,
        uuidseqno: Optional[int] = None
    ) -> Dict[str, Any]:
        """
        Purchase Order Close
        
        Generated from: PUT /tradeFinance/exportCollectionBills/purchaseOrder/close
        Source: swagger_2_0
        Operation ID: EDCBT5978POClose_POSTUsingPUT
        
        
        Authentication: Not required
        
        Parameters:
        - transactionID: integer (required)
          Transaction ID
        - request_body: any (required)
          input
        
        
        
        Headers:
        - Accesstoken: string
          Authorization Token to validation the caller
        - ChannelType: integer
          Channel identifier from where the TXN has originated (Internet, Mobile, ATM, Branch Channel )
        - co-Relationid: integer
          Unique ID for the service invoked, will be set by the TXN system
        - entity: string
          entity
        - initiatingSystem: string
          Indicating the initiated system
        - languageCode: integer
          languageCode
        - referenceId: string
          Place holder for Token based authentication
        - serviceMode: integer
          Used for branch channel to indicate the type of customer
        - userId: integer
          userId
        - uuidSeqNo: integer
          UUID Sequence Number
        
        
        """
        
        
        # Prepare request data
        
        # Single body parameter - send directly
        data = request_body if request_body is not None else {}
        
        
        
        # Prepare query parameters
        params = {}
        if transactionid is not None:
            params["transactionID"] = transactionid
            
        
        
        # Replace path parameters in URL
        path = "/tradeFinance/exportCollectionBills/purchaseOrder/close"
        
        
        # Prepare headers
        headers = {}
        if accesstoken is not None:
            headers["Accesstoken"] = str(accesstoken)
        if channeltype is not None:
            headers["ChannelType"] = str(channeltype)
        if co_relationid is not None:
            headers["co-Relationid"] = str(co_relationid)
        if entity is not None:
            headers["entity"] = str(entity)
        if initiatingsystem is not None:
            headers["initiatingSystem"] = str(initiatingsystem)
        if languagecode is not None:
            headers["languageCode"] = str(languagecode)
        if referenceid is not None:
            headers["referenceId"] = str(referenceid)
        if servicemode is not None:
            headers["serviceMode"] = str(servicemode)
        if userid is not None:
            headers["userId"] = str(userid)
        if uuidseqno is not None:
            headers["uuidSeqNo"] = str(uuidseqno)
        
        
        return await make_api_request(
            "PUT", 
            path, 
            data=data, 
            params=params if params else None, 
            headers=headers if headers else None
        )
    
    
    
    @mcp.tool()
    async def edcbt5978_pocrt_modify_postusing_post(
        request_body:Dict[str, Any] ,  # edcPurchaseOrderCreateModifyRequest,
        accesstoken: Optional[str] = None,
        channeltype: Optional[int] = None,
        co_relationid: Optional[int] = None,
        entity: Optional[str] = None,
        initiatingsystem: Optional[str] = None,
        languagecode: Optional[int] = None,
        referenceid: Optional[str] = None,
        servicemode: Optional[int] = None,
        userid: Optional[int] = None,
        uuidseqno: Optional[int] = None
    ) -> Dict[str, Any]:
        """
        Purchase Order Create Modify
        
        Generated from: POST /tradeFinance/exportCollectionBills/purchaseOrder/crtModify
        Source: swagger_2_0
        Operation ID: EDCBT5978POCrtModify_POSTUsingPOST
        
        
        Authentication: Not required
        
        Parameters:
        - request_body: any (required)
          input
        
        
        
        Headers:
        - Accesstoken: string
          Authorization Token to validation the caller
        - ChannelType: integer
          Channel identifier from where the TXN has originated (Internet, Mobile, ATM, Branch Channel )
        - co-Relationid: integer
          Unique ID for the service invoked, will be set by the TXN system
        - entity: string
          entity
        - initiatingSystem: string
          Indicating the initiated system
        - languageCode: integer
          languageCode
        - referenceId: string
          Place holder for Token based authentication
        - serviceMode: integer
          Used for branch channel to indicate the type of customer
        - userId: integer
          userId
        - uuidSeqNo: integer
          UUID Sequence Number
        
        
        """
        
        
        # Prepare request data
        
        # Single body parameter - send directly
        data = request_body if request_body is not None else {}
        
        
        
        # Prepare query parameters
        params = {}
        
        
        # Replace path parameters in URL
        path = "/tradeFinance/exportCollectionBills/purchaseOrder/crtModify"
        
        
        # Prepare headers
        headers = {}
        if accesstoken is not None:
            headers["Accesstoken"] = str(accesstoken)
        if channeltype is not None:
            headers["ChannelType"] = str(channeltype)
        if co_relationid is not None:
            headers["co-Relationid"] = str(co_relationid)
        if entity is not None:
            headers["entity"] = str(entity)
        if initiatingsystem is not None:
            headers["initiatingSystem"] = str(initiatingsystem)
        if languagecode is not None:
            headers["languageCode"] = str(languagecode)
        if referenceid is not None:
            headers["referenceId"] = str(referenceid)
        if servicemode is not None:
            headers["serviceMode"] = str(servicemode)
        if userid is not None:
            headers["userId"] = str(userid)
        if uuidseqno is not None:
            headers["uuidSeqNo"] = str(uuidseqno)
        
        
        return await make_api_request(
            "POST", 
            path, 
            data=data, 
            params=params if params else None, 
            headers=headers if headers else None
        )
    
    
    
    @mcp.tool()
    async def edcet5978_fetch_polist_postusing_get(
        currency: Optional[str] = None,
        custrefnum: Optional[str] = None,
        customername: Optional[str] = None,
        customerreference: Optional[int] = None,
        dateofdocument: Optional[str] = None,
        eligibleamount: Optional[float] = None,
        enddate: Optional[str] = None,
        pagenum: Optional[int] = None,
        pagesize: Optional[int] = None,
        poreferenceexternal: Optional[str] = None,
        potransactiontype: Optional[int] = None,
        startdate: Optional[str] = None,
        status: Optional[int] = None,
        transactionid: Optional[int] = None,
        accesstoken: Optional[str] = None,
        channeltype: Optional[int] = None,
        co_relationid: Optional[int] = None,
        entity: Optional[str] = None,
        initiatingsystem: Optional[str] = None,
        languagecode: Optional[int] = None,
        referenceid: Optional[str] = None,
        servicemode: Optional[int] = None,
        userid: Optional[int] = None,
        uuidseqno: Optional[int] = None
    ) -> Dict[str, Any]:
        """
        Fetch Purchase Order List
        
        Generated from: GET /tradeFinance/exportCollectionBills/purchaseOrder/fetchList
        Source: swagger_2_0
        Operation ID: EDCET5978FetchPOList_POSTUsingGET
        
        
        Authentication: Not required
        
        Parameters:
        - currency: string
          currency
        - custRefNum: string
          customer Reference Number
        - customerName: string
          Customer Name
        - customerReference: integer
          CIF Id
        - dateOfDocument: string
          date of Document
        - eligibleAmount: number
          eligible Amount
        - endDate: string
          end Date
        - pageNum: integer
          pageNum
        - pageSize: integer
          pageSize
        - poReferenceExternal: string
          po Reference External
        - poTransactionType: integer
          po Transaction Type
        - startDate: string
          start Date
        - status: integer
          status (PO Status.Possible Values:1 - OnHold, 2 - Released, 3 - Verified, 4 - PendingClosure, 5 - Closed, 6 - Executed, 7 - Expired, 8 - Rejected, 9 - WaitingForRate, 10 - AmndmntInit, 11 - AcptRefPndng, 13 - Refused, 12 - Final1, 14 - SuspWdrwPndng, 15 - CnclClosePndng, 16 - RevivalPndng, 17 - Cancelled Domain, 18 - ModifyOnHold, 19 - ModifyReleased, 20 - SentBack, 21 - NRCancel, 22 - ComplianceFailed, 23 - ComplianceOnHold,24 - modifyAmnd, 25 - modifyAmndRelease: d_TFBGStatus)
        - transactionId: integer
          Transaction Id
        
        
        
        Headers:
        - Accesstoken: string
          Authorization Token to validation the caller
        - ChannelType: integer
          Channel identifier from where the TXN has originated (Internet, Mobile, ATM, Branch Channel )
        - co-Relationid: integer
          Unique ID for the service invoked, will be set by the TXN system
        - entity: string
          entity
        - initiatingSystem: string
          Indicating the initiated system
        - languageCode: integer
          languageCode
        - referenceId: string
          Place holder for Token based authentication
        - serviceMode: integer
          Used for branch channel to indicate the type of customer
        - userId: integer
          userId
        - uuidSeqNo: integer
          UUID Sequence Number
        
        
        """
        
        
        # Prepare query parameters
        params = {}
        if currency is not None:
            params["currency"] = currency
            
        if custrefnum is not None:
            params["custRefNum"] = custrefnum
            
        if customername is not None:
            params["customerName"] = customername
            
        if customerreference is not None:
            params["customerReference"] = customerreference
            
        if dateofdocument is not None:
            params["dateOfDocument"] = dateofdocument
            
        if eligibleamount is not None:
            params["eligibleAmount"] = eligibleamount
            
        if enddate is not None:
            params["endDate"] = enddate
            
        if pagenum is not None:
            params["pageNum"] = pagenum
            
        if pagesize is not None:
            params["pageSize"] = pagesize
            
        if poreferenceexternal is not None:
            params["poReferenceExternal"] = poreferenceexternal
            
        if potransactiontype is not None:
            params["poTransactionType"] = potransactiontype
            
        if startdate is not None:
            params["startDate"] = startdate
            
        if status is not None:
            params["status"] = status
            
        if transactionid is not None:
            params["transactionId"] = transactionid
            
        
        
        # Replace path parameters in URL
        path = "/tradeFinance/exportCollectionBills/purchaseOrder/fetchList"
        
        
        # Prepare headers
        headers = {}
        if accesstoken is not None:
            headers["Accesstoken"] = str(accesstoken)
        if channeltype is not None:
            headers["ChannelType"] = str(channeltype)
        if co_relationid is not None:
            headers["co-Relationid"] = str(co_relationid)
        if entity is not None:
            headers["entity"] = str(entity)
        if initiatingsystem is not None:
            headers["initiatingSystem"] = str(initiatingsystem)
        if languagecode is not None:
            headers["languageCode"] = str(languagecode)
        if referenceid is not None:
            headers["referenceId"] = str(referenceid)
        if servicemode is not None:
            headers["serviceMode"] = str(servicemode)
        if userid is not None:
            headers["userId"] = str(userid)
        if uuidseqno is not None:
            headers["uuidSeqNo"] = str(uuidseqno)
        
        
        return await make_api_request(
            "GET", 
            path, 
            
            params=params if params else None, 
            headers=headers if headers else None
        )
    
    
    
    @mcp.tool()
    async def edcbt5978_pouser_confirmation_postusing_post(
        request_body:Dict[str, Any] ,  # edcPurchaseOrderUserConfirmationRequest,
        accesstoken: Optional[str] = None,
        channeltype: Optional[int] = None,
        co_relationid: Optional[int] = None,
        entity: Optional[str] = None,
        initiatingsystem: Optional[str] = None,
        languagecode: Optional[int] = None,
        referenceid: Optional[str] = None,
        servicemode: Optional[int] = None,
        userid: Optional[int] = None,
        uuidseqno: Optional[int] = None
    ) -> Dict[str, Any]:
        """
        Purchase Order User Confirmation
        
        Generated from: POST /tradeFinance/exportCollectionBills/purchaseOrder/userConfirmation
        Source: swagger_2_0
        Operation ID: EDCBT5978POUserConfirmation_POSTUsingPOST
        
        
        Authentication: Not required
        
        Parameters:
        - request_body: any (required)
          input
        
        
        
        Headers:
        - Accesstoken: string
          Authorization Token to validation the caller
        - ChannelType: integer
          Channel identifier from where the TXN has originated (Internet, Mobile, ATM, Branch Channel )
        - co-Relationid: integer
          Unique ID for the service invoked, will be set by the TXN system
        - entity: string
          entity
        - initiatingSystem: string
          Indicating the initiated system
        - languageCode: integer
          languageCode
        - referenceId: string
          Place holder for Token based authentication
        - serviceMode: integer
          Used for branch channel to indicate the type of customer
        - userId: integer
          userId
        - uuidSeqNo: integer
          UUID Sequence Number
        
        
        """
        
        
        # Prepare request data
        
        # Single body parameter - send directly
        data = request_body if request_body is not None else {}
        
        
        
        # Prepare query parameters
        params = {}
        
        
        # Replace path parameters in URL
        path = "/tradeFinance/exportCollectionBills/purchaseOrder/userConfirmation"
        
        
        # Prepare headers
        headers = {}
        if accesstoken is not None:
            headers["Accesstoken"] = str(accesstoken)
        if channeltype is not None:
            headers["ChannelType"] = str(channeltype)
        if co_relationid is not None:
            headers["co-Relationid"] = str(co_relationid)
        if entity is not None:
            headers["entity"] = str(entity)
        if initiatingsystem is not None:
            headers["initiatingSystem"] = str(initiatingsystem)
        if languagecode is not None:
            headers["languageCode"] = str(languagecode)
        if referenceid is not None:
            headers["referenceId"] = str(referenceid)
        if servicemode is not None:
            headers["serviceMode"] = str(servicemode)
        if userid is not None:
            headers["userId"] = str(userid)
        if uuidseqno is not None:
            headers["uuidSeqNo"] = str(uuidseqno)
        
        
        return await make_api_request(
            "POST", 
            path, 
            data=data, 
            params=params if params else None, 
            headers=headers if headers else None
        )
    
    
    
    @mcp.tool()
    async def edcbt5978_poauth_reject_postusing_put(
        poreferenceexternal: str,
        authoriseflag: int,
        transactionid: Optional[int] = None,
        accesstoken: Optional[str] = None,
        channeltype: Optional[int] = None,
        co_relationid: Optional[int] = None,
        entity: Optional[str] = None,
        initiatingsystem: Optional[str] = None,
        languagecode: Optional[int] = None,
        referenceid: Optional[str] = None,
        servicemode: Optional[int] = None,
        userid: Optional[int] = None,
        uuidseqno: Optional[int] = None
    ) -> Dict[str, Any]:
        """
        Purchase Order Authorize Reject
        
        Generated from: PUT /tradeFinance/exportCollectionBills/purchaseOrder/{poReferenceExternal}/authReject
        Source: swagger_2_0
        Operation ID: EDCBT5978POAuthReject_POSTUsingPUT
        
        
        Authentication: Not required
        
        Parameters:
        - authoriseFlag: integer (required)
          Authorise Flag. Possible values : 10 - Authorise, 11 - Reject Domain name :  d_ModeFlg_Authorised and d_ModeFlg_Reject
        - poReferenceExternal: string (required)
          poReferenceExternal
        - transactionID: integer
          transaction ID
        
        
        
        Headers:
        - Accesstoken: string
          Authorization Token to validation the caller
        - ChannelType: integer
          Channel identifier from where the TXN has originated (Internet, Mobile, ATM, Branch Channel )
        - co-Relationid: integer
          Unique ID for the service invoked, will be set by the TXN system
        - entity: string
          entity
        - initiatingSystem: string
          Indicating the initiated system
        - languageCode: integer
          languageCode
        - referenceId: string
          Place holder for Token based authentication
        - serviceMode: integer
          Used for branch channel to indicate the type of customer
        - userId: integer
          userId
        - uuidSeqNo: integer
          UUID Sequence Number
        
        
        """
        
        
        # Prepare query parameters
        params = {}
        if authoriseflag is not None:
            params["authoriseFlag"] = authoriseflag
            
        if transactionid is not None:
            params["transactionID"] = transactionid
            
        
        
        # Replace path parameters in URL
        path = "/tradeFinance/exportCollectionBills/purchaseOrder/{poReferenceExternal}/authReject"
        if poreferenceexternal is not None:
            path = path.replace("{poReferenceExternal}", str(poreferenceexternal))
        
        
        # Prepare headers
        headers = {}
        if accesstoken is not None:
            headers["Accesstoken"] = str(accesstoken)
        if channeltype is not None:
            headers["ChannelType"] = str(channeltype)
        if co_relationid is not None:
            headers["co-Relationid"] = str(co_relationid)
        if entity is not None:
            headers["entity"] = str(entity)
        if initiatingsystem is not None:
            headers["initiatingSystem"] = str(initiatingsystem)
        if languagecode is not None:
            headers["languageCode"] = str(languagecode)
        if referenceid is not None:
            headers["referenceId"] = str(referenceid)
        if servicemode is not None:
            headers["serviceMode"] = str(servicemode)
        if userid is not None:
            headers["userId"] = str(userid)
        if uuidseqno is not None:
            headers["uuidSeqNo"] = str(uuidseqno)
        
        
        return await make_api_request(
            "PUT", 
            path, 
            
            params=params if params else None, 
            headers=headers if headers else None
        )
    
    
    
    @mcp.tool()
    async def edcbt5978_poon_hold_to_cancel_postusing_post(
        poreferenceexternal: str,
        accesstoken: Optional[str] = None,
        channeltype: Optional[int] = None,
        co_relationid: Optional[int] = None,
        entity: Optional[str] = None,
        initiatingsystem: Optional[str] = None,
        languagecode: Optional[int] = None,
        referenceid: Optional[str] = None,
        servicemode: Optional[int] = None,
        userid: Optional[int] = None,
        uuidseqno: Optional[int] = None
    ) -> Dict[str, Any]:
        """
        Purchase Order Cancel
        
        Generated from: POST /tradeFinance/exportCollectionBills/purchaseOrder/{poReferenceExternal}/cancel
        Source: swagger_2_0
        Operation ID: EDCBT5978POOnHoldToCancel_POSTUsingPOST
        
        
        Authentication: Not required
        
        Parameters:
        - poReferenceExternal: string (required)
          poReferenceExternal
        
        
        
        Headers:
        - Accesstoken: string
          Authorization Token to validation the caller
        - ChannelType: integer
          Channel identifier from where the TXN has originated (Internet, Mobile, ATM, Branch Channel )
        - co-Relationid: integer
          Unique ID for the service invoked, will be set by the TXN system
        - entity: string
          entity
        - initiatingSystem: string
          Indicating the initiated system
        - languageCode: integer
          languageCode
        - referenceId: string
          Place holder for Token based authentication
        - serviceMode: integer
          Used for branch channel to indicate the type of customer
        - userId: integer
          userId
        - uuidSeqNo: integer
          UUID Sequence Number
        
        
        """
        
        
        # Prepare query parameters
        params = {}
        
        
        # Replace path parameters in URL
        path = "/tradeFinance/exportCollectionBills/purchaseOrder/{poReferenceExternal}/cancel"
        if poreferenceexternal is not None:
            path = path.replace("{poReferenceExternal}", str(poreferenceexternal))
        
        
        # Prepare headers
        headers = {}
        if accesstoken is not None:
            headers["Accesstoken"] = str(accesstoken)
        if channeltype is not None:
            headers["ChannelType"] = str(channeltype)
        if co_relationid is not None:
            headers["co-Relationid"] = str(co_relationid)
        if entity is not None:
            headers["entity"] = str(entity)
        if initiatingsystem is not None:
            headers["initiatingSystem"] = str(initiatingsystem)
        if languagecode is not None:
            headers["languageCode"] = str(languagecode)
        if referenceid is not None:
            headers["referenceId"] = str(referenceid)
        if servicemode is not None:
            headers["serviceMode"] = str(servicemode)
        if userid is not None:
            headers["userId"] = str(userid)
        if uuidseqno is not None:
            headers["uuidSeqNo"] = str(uuidseqno)
        
        
        return await make_api_request(
            "POST", 
            path, 
            
            params=params if params else None, 
            headers=headers if headers else None
        )
    
    
    
    @mcp.tool()
    async def edcet5978_get_podetails_postusing_get(
        poreferenceexternal: str,
        accesstoken: Optional[str] = None,
        channeltype: Optional[int] = None,
        co_relationid: Optional[int] = None,
        entity: Optional[str] = None,
        initiatingsystem: Optional[str] = None,
        languagecode: Optional[int] = None,
        referenceid: Optional[str] = None,
        servicemode: Optional[int] = None,
        userid: Optional[int] = None,
        uuidseqno: Optional[int] = None
    ) -> Dict[str, Any]:
        """
        Get Purchase Order Details
        
        Generated from: GET /tradeFinance/exportCollectionBills/purchaseOrder/{poReferenceExternal}/getDetails
        Source: swagger_2_0
        Operation ID: EDCET5978GetPODetails_POSTUsingGET
        
        
        Authentication: Not required
        
        Parameters:
        - poReferenceExternal: string (required)
          poReferenceExternal
        
        
        
        Headers:
        - Accesstoken: string
          Authorization Token to validation the caller
        - ChannelType: integer
          Channel identifier from where the TXN has originated (Internet, Mobile, ATM, Branch Channel )
        - co-Relationid: integer
          Unique ID for the service invoked, will be set by the TXN system
        - entity: string
          entity
        - initiatingSystem: string
          Indicating the initiated system
        - languageCode: integer
          languageCode
        - referenceId: string
          Place holder for Token based authentication
        - serviceMode: integer
          Used for branch channel to indicate the type of customer
        - userId: integer
          userId
        - uuidSeqNo: integer
          UUID Sequence Number
        
        
        """
        
        
        # Prepare query parameters
        params = {}
        
        
        # Replace path parameters in URL
        path = "/tradeFinance/exportCollectionBills/purchaseOrder/{poReferenceExternal}/getDetails"
        if poreferenceexternal is not None:
            path = path.replace("{poReferenceExternal}", str(poreferenceexternal))
        
        
        # Prepare headers
        headers = {}
        if accesstoken is not None:
            headers["Accesstoken"] = str(accesstoken)
        if channeltype is not None:
            headers["ChannelType"] = str(channeltype)
        if co_relationid is not None:
            headers["co-Relationid"] = str(co_relationid)
        if entity is not None:
            headers["entity"] = str(entity)
        if initiatingsystem is not None:
            headers["initiatingSystem"] = str(initiatingsystem)
        if languagecode is not None:
            headers["languageCode"] = str(languagecode)
        if referenceid is not None:
            headers["referenceId"] = str(referenceid)
        if servicemode is not None:
            headers["serviceMode"] = str(servicemode)
        if userid is not None:
            headers["userId"] = str(userid)
        if uuidseqno is not None:
            headers["uuidSeqNo"] = str(uuidseqno)
        
        
        return await make_api_request(
            "GET", 
            path, 
            
            params=params if params else None, 
            headers=headers if headers else None
        )
    
    
    
    @mcp.tool()
    async def edcbt5978_poreleased_to_sent_back_postusing_put(
        poreferenceexternal: str,
        accesstoken: Optional[str] = None,
        channeltype: Optional[int] = None,
        co_relationid: Optional[int] = None,
        entity: Optional[str] = None,
        initiatingsystem: Optional[str] = None,
        languagecode: Optional[int] = None,
        referenceid: Optional[str] = None,
        servicemode: Optional[int] = None,
        userid: Optional[int] = None,
        uuidseqno: Optional[int] = None
    ) -> Dict[str, Any]:
        """
        Purchase Order SentBack
        
        Generated from: PUT /tradeFinance/exportCollectionBills/purchaseOrder/{poReferenceExternal}/sentback
        Source: swagger_2_0
        Operation ID: EDCBT5978POReleasedToSentBack_POSTUsingPUT
        
        
        Authentication: Not required
        
        Parameters:
        - poReferenceExternal: string (required)
          poReferenceExternal
        
        
        
        Headers:
        - Accesstoken: string
          Authorization Token to validation the caller
        - ChannelType: integer
          Channel identifier from where the TXN has originated (Internet, Mobile, ATM, Branch Channel )
        - co-Relationid: integer
          Unique ID for the service invoked, will be set by the TXN system
        - entity: string
          entity
        - initiatingSystem: string
          Indicating the initiated system
        - languageCode: integer
          languageCode
        - referenceId: string
          Place holder for Token based authentication
        - serviceMode: integer
          Used for branch channel to indicate the type of customer
        - userId: integer
          userId
        - uuidSeqNo: integer
          UUID Sequence Number
        
        
        """
        
        
        # Prepare query parameters
        params = {}
        
        
        # Replace path parameters in URL
        path = "/tradeFinance/exportCollectionBills/purchaseOrder/{poReferenceExternal}/sentback"
        if poreferenceexternal is not None:
            path = path.replace("{poReferenceExternal}", str(poreferenceexternal))
        
        
        # Prepare headers
        headers = {}
        if accesstoken is not None:
            headers["Accesstoken"] = str(accesstoken)
        if channeltype is not None:
            headers["ChannelType"] = str(channeltype)
        if co_relationid is not None:
            headers["co-Relationid"] = str(co_relationid)
        if entity is not None:
            headers["entity"] = str(entity)
        if initiatingsystem is not None:
            headers["initiatingSystem"] = str(initiatingsystem)
        if languagecode is not None:
            headers["languageCode"] = str(languagecode)
        if referenceid is not None:
            headers["referenceId"] = str(referenceid)
        if servicemode is not None:
            headers["serviceMode"] = str(servicemode)
        if userid is not None:
            headers["userId"] = str(userid)
        if uuidseqno is not None:
            headers["uuidSeqNo"] = str(uuidseqno)
        
        
        return await make_api_request(
            "PUT", 
            path, 
            
            params=params if params else None, 
            headers=headers if headers else None
        )
    
    
    
    @mcp.tool()
    async def edcbt1006_dcrlsd_to_rjct_postusing_post(
        request_body:Dict[str, Any] ,  # RegisterExportDCRejectRequest,
        accesstoken: Optional[str] = None,
        channeltype: Optional[int] = None,
        co_relationid: Optional[int] = None,
        entity: Optional[str] = None,
        initiatingsystem: Optional[str] = None,
        languagecode: Optional[int] = None,
        referenceid: Optional[str] = None,
        servicemode: Optional[int] = None,
        userid: Optional[int] = None,
        uuidseqno: Optional[int] = None
    ) -> Dict[str, Any]:
        """
        Reject Export Documentary Collections
        
        Generated from: POST /tradeFinance/exportCollectionBills/reject
        Source: swagger_2_0
        Operation ID: EDCBT1006DCRlsdToRjct_POSTUsingPOST
        
        
        Authentication: Not required
        
        Parameters:
        - request_body: any (required)
          input
        
        
        
        Headers:
        - Accesstoken: string
          Authorization Token to validation the caller
        - ChannelType: integer
          Channel identifier from where the TXN has originated (Internet, Mobile, ATM, Branch Channel )
        - co-Relationid: integer
          Unique ID for the service invoked, will be set by the TXN system
        - entity: string
          entity
        - initiatingSystem: string
          Indicating the initiated system
        - languageCode: integer
          languageCode
        - referenceId: string
          Place holder for Token based authentication
        - serviceMode: integer
          Used for branch channel to indicate the type of customer
        - userId: integer
          userId
        - uuidSeqNo: integer
          UUID Sequence Number
        
        
        """
        
        
        # Prepare request data
        
        # Single body parameter - send directly
        data = request_body if request_body is not None else {}
        
        
        
        # Prepare query parameters
        params = {}
        
        
        # Replace path parameters in URL
        path = "/tradeFinance/exportCollectionBills/reject"
        
        
        # Prepare headers
        headers = {}
        if accesstoken is not None:
            headers["Accesstoken"] = str(accesstoken)
        if channeltype is not None:
            headers["ChannelType"] = str(channeltype)
        if co_relationid is not None:
            headers["co-Relationid"] = str(co_relationid)
        if entity is not None:
            headers["entity"] = str(entity)
        if initiatingsystem is not None:
            headers["initiatingSystem"] = str(initiatingsystem)
        if languagecode is not None:
            headers["languageCode"] = str(languagecode)
        if referenceid is not None:
            headers["referenceId"] = str(referenceid)
        if servicemode is not None:
            headers["serviceMode"] = str(servicemode)
        if userid is not None:
            headers["userId"] = str(userid)
        if uuidseqno is not None:
            headers["uuidSeqNo"] = str(uuidseqno)
        
        
        return await make_api_request(
            "POST", 
            path, 
            data=data, 
            params=params if params else None, 
            headers=headers if headers else None
        )
    
    
    
    @mcp.tool()
    async def edcet1012_fetch_dcdtls_postusing_get(
        billreferenceinternal: Optional[str] = None,
        billexternalreference: Optional[str] = None,
        customerid: Optional[int] = None,
        customername: Optional[str] = None,
        pagenum: Optional[int] = None,
        pagesize: Optional[int] = None,
        transactionid: Optional[int] = None,
        accesstoken: Optional[str] = None,
        channeltype: Optional[int] = None,
        co_relationid: Optional[int] = None,
        entity: Optional[str] = None,
        initiatingsystem: Optional[str] = None,
        languagecode: Optional[int] = None,
        referenceid: Optional[str] = None,
        servicemode: Optional[int] = None,
        userid: Optional[int] = None,
        uuidseqno: Optional[int] = None
    ) -> Dict[str, Any]:
        """
        Documentary Collections Search
        
        Generated from: GET /tradeFinance/exportCollectionBills/search
        Source: swagger_2_0
        Operation ID: EDCET1012FetchDCDtls_POSTUsingGET
        
        
        Authentication: Not required
        
        Parameters:
        - billReferenceInternal: string
          Bill Reference Internal
        - billexternalReference: string
          Bill External Reference
        - customerID: integer
          Customer ID
        - customerName: string
          Customer Name
        - pageNum: integer
          pageNum
        - pageSize: integer
          pageSize
        - transactionID: integer
          Transaction ID
        
        
        
        Headers:
        - Accesstoken: string
          Authorization Token to validation the caller
        - ChannelType: integer
          Channel identifier from where the TXN has originated (Internet, Mobile, ATM, Branch Channel )
        - co-Relationid: integer
          Unique ID for the service invoked, will be set by the TXN system
        - entity: string
          entity
        - initiatingSystem: string
          Indicating the initiated system
        - languageCode: integer
          languageCode
        - referenceId: string
          Place holder for Token based authentication
        - serviceMode: integer
          Used for branch channel to indicate the type of customer
        - userId: integer
          userId
        - uuidSeqNo: integer
          UUID Sequence Number
        
        
        """
        
        
        # Prepare query parameters
        params = {}
        if billreferenceinternal is not None:
            params["billReferenceInternal"] = billreferenceinternal
            
        if billexternalreference is not None:
            params["billexternalReference"] = billexternalreference
            
        if customerid is not None:
            params["customerID"] = customerid
            
        if customername is not None:
            params["customerName"] = customername
            
        if pagenum is not None:
            params["pageNum"] = pagenum
            
        if pagesize is not None:
            params["pageSize"] = pagesize
            
        if transactionid is not None:
            params["transactionID"] = transactionid
            
        
        
        # Replace path parameters in URL
        path = "/tradeFinance/exportCollectionBills/search"
        
        
        # Prepare headers
        headers = {}
        if accesstoken is not None:
            headers["Accesstoken"] = str(accesstoken)
        if channeltype is not None:
            headers["ChannelType"] = str(channeltype)
        if co_relationid is not None:
            headers["co-Relationid"] = str(co_relationid)
        if entity is not None:
            headers["entity"] = str(entity)
        if initiatingsystem is not None:
            headers["initiatingSystem"] = str(initiatingsystem)
        if languagecode is not None:
            headers["languageCode"] = str(languagecode)
        if referenceid is not None:
            headers["referenceId"] = str(referenceid)
        if servicemode is not None:
            headers["serviceMode"] = str(servicemode)
        if userid is not None:
            headers["userId"] = str(userid)
        if uuidseqno is not None:
            headers["uuidSeqNo"] = str(uuidseqno)
        
        
        return await make_api_request(
            "GET", 
            path, 
            
            params=params if params else None, 
            headers=headers if headers else None
        )
    
    
    
    @mcp.tool()
    async def edcbt1007_dcrlsd_to_on_hold_postusing_post(
        request_body:Dict[str, Any] ,  # RegisterExportDCSendBackRequest,
        accesstoken: Optional[str] = None,
        channeltype: Optional[int] = None,
        co_relationid: Optional[int] = None,
        entity: Optional[str] = None,
        initiatingsystem: Optional[str] = None,
        languagecode: Optional[int] = None,
        referenceid: Optional[str] = None,
        servicemode: Optional[int] = None,
        userid: Optional[int] = None,
        uuidseqno: Optional[int] = None
    ) -> Dict[str, Any]:
        """
        Sendback Export Documentary Collections
        
        Generated from: POST /tradeFinance/exportCollectionBills/sendBack
        Source: swagger_2_0
        Operation ID: EDCBT1007DCRlsdToOnHold_POSTUsingPOST
        
        
        Authentication: Not required
        
        Parameters:
        - request_body: any (required)
          input
        
        
        
        Headers:
        - Accesstoken: string
          Authorization Token to validation the caller
        - ChannelType: integer
          Channel identifier from where the TXN has originated (Internet, Mobile, ATM, Branch Channel )
        - co-Relationid: integer
          Unique ID for the service invoked, will be set by the TXN system
        - entity: string
          entity
        - initiatingSystem: string
          Indicating the initiated system
        - languageCode: integer
          languageCode
        - referenceId: string
          Place holder for Token based authentication
        - serviceMode: integer
          Used for branch channel to indicate the type of customer
        - userId: integer
          userId
        - uuidSeqNo: integer
          UUID Sequence Number
        
        
        """
        
        
        # Prepare request data
        
        # Single body parameter - send directly
        data = request_body if request_body is not None else {}
        
        
        
        # Prepare query parameters
        params = {}
        
        
        # Replace path parameters in URL
        path = "/tradeFinance/exportCollectionBills/sendBack"
        
        
        # Prepare headers
        headers = {}
        if accesstoken is not None:
            headers["Accesstoken"] = str(accesstoken)
        if channeltype is not None:
            headers["ChannelType"] = str(channeltype)
        if co_relationid is not None:
            headers["co-Relationid"] = str(co_relationid)
        if entity is not None:
            headers["entity"] = str(entity)
        if initiatingsystem is not None:
            headers["initiatingSystem"] = str(initiatingsystem)
        if languagecode is not None:
            headers["languageCode"] = str(languagecode)
        if referenceid is not None:
            headers["referenceId"] = str(referenceid)
        if servicemode is not None:
            headers["serviceMode"] = str(servicemode)
        if userid is not None:
            headers["userId"] = str(userid)
        if uuidseqno is not None:
            headers["uuidSeqNo"] = str(uuidseqno)
        
        
        return await make_api_request(
            "POST", 
            path, 
            data=data, 
            params=params if params else None, 
            headers=headers if headers else None
        )
    
    
    
    @mcp.tool()
    async def edcbt1401_set_up_dcshpmnt_dtls_postusing_post(
        request_body:Dict[str, Any] ,  # RegisterExportDCShipRequest,
        accesstoken: Optional[str] = None,
        channeltype: Optional[int] = None,
        co_relationid: Optional[int] = None,
        entity: Optional[str] = None,
        initiatingsystem: Optional[str] = None,
        languagecode: Optional[int] = None,
        referenceid: Optional[str] = None,
        servicemode: Optional[int] = None,
        userid: Optional[int] = None,
        uuidseqno: Optional[int] = None
    ) -> Dict[str, Any]:
        """
        Shipment Details under Documentary Collections-Setup
        
        Generated from: POST /tradeFinance/exportCollectionBills/shipmentSetup
        Source: swagger_2_0
        Operation ID: EDCBT1401SetUpDCShpmntDtls_POSTUsingPOST
        
        
        Authentication: Not required
        
        Parameters:
        - request_body: any (required)
          input
        
        
        
        Headers:
        - Accesstoken: string
          Authorization Token to validation the caller
        - ChannelType: integer
          Channel identifier from where the TXN has originated (Internet, Mobile, ATM, Branch Channel )
        - co-Relationid: integer
          Unique ID for the service invoked, will be set by the TXN system
        - entity: string
          entity
        - initiatingSystem: string
          Indicating the initiated system
        - languageCode: integer
          languageCode
        - referenceId: string
          Place holder for Token based authentication
        - serviceMode: integer
          Used for branch channel to indicate the type of customer
        - userId: integer
          userId
        - uuidSeqNo: integer
          UUID Sequence Number
        
        
        """
        
        
        # Prepare request data
        
        # Single body parameter - send directly
        data = request_body if request_body is not None else {}
        
        
        
        # Prepare query parameters
        params = {}
        
        
        # Replace path parameters in URL
        path = "/tradeFinance/exportCollectionBills/shipmentSetup"
        
        
        # Prepare headers
        headers = {}
        if accesstoken is not None:
            headers["Accesstoken"] = str(accesstoken)
        if channeltype is not None:
            headers["ChannelType"] = str(channeltype)
        if co_relationid is not None:
            headers["co-Relationid"] = str(co_relationid)
        if entity is not None:
            headers["entity"] = str(entity)
        if initiatingsystem is not None:
            headers["initiatingSystem"] = str(initiatingsystem)
        if languagecode is not None:
            headers["languageCode"] = str(languagecode)
        if referenceid is not None:
            headers["referenceId"] = str(referenceid)
        if servicemode is not None:
            headers["serviceMode"] = str(servicemode)
        if userid is not None:
            headers["userId"] = str(userid)
        if uuidseqno is not None:
            headers["uuidSeqNo"] = str(uuidseqno)
        
        
        return await make_api_request(
            "POST", 
            path, 
            data=data, 
            params=params if params else None, 
            headers=headers if headers else None
        )
    
    
    
    @mcp.tool()
    async def edcet1402_get_dcshpmnt_dtls_postusing_get(
        entity1: Optional[str] = None,
        transactioneventid: Optional[int] = None,
        transactionid: Optional[int] = None,
        transactiontype: Optional[int] = None,
        pagenum: Optional[int] = None,
        pagesize: Optional[int] = None,
        accesstoken: Optional[str] = None,
        channeltype: Optional[int] = None,
        co_relationid: Optional[int] = None,
        entity: Optional[str] = None,
        initiatingsystem: Optional[str] = None,
        languagecode: Optional[int] = None,
        referenceid: Optional[str] = None,
        servicemode: Optional[int] = None,
        userid: Optional[int] = None,
        uuidseqno: Optional[int] = None
    ) -> Dict[str, Any]:
        """
        Shipment Details under Documentary Collections-View
        
        Generated from: GET /tradeFinance/exportCollectionBills/shipmentView
        Source: swagger_2_0
        Operation ID: EDCET1402GetDCShpmntDtls_POSTUsingGET
        
        
        Authentication: Not required
        
        Parameters:
        - Entity1: string
          Entity ID
        - TransactionEventID: integer
          Event Leg ID
        - TransactionID: integer
          Export Documentary collection Pos ID
        - TransactionType: integer
          Export Documentary collection Pos Type
        - pageNum: integer
          pageNum
        - pageSize: integer
          pageSize
        
        
        
        Headers:
        - Accesstoken: string
          Authorization Token to validation the caller
        - ChannelType: integer
          Channel identifier from where the TXN has originated (Internet, Mobile, ATM, Branch Channel )
        - co-Relationid: integer
          Unique ID for the service invoked, will be set by the TXN system
        - entity: string
          entity
        - initiatingSystem: string
          Indicating the initiated system
        - languageCode: integer
          languageCode
        - referenceId: string
          Place holder for Token based authentication
        - serviceMode: integer
          Used for branch channel to indicate the type of customer
        - userId: integer
          userId
        - uuidSeqNo: integer
          UUID Sequence Number
        
        
        """
        
        
        # Prepare query parameters
        params = {}
        if entity1 is not None:
            params["Entity1"] = entity1
            
        if transactioneventid is not None:
            params["TransactionEventID"] = transactioneventid
            
        if transactionid is not None:
            params["TransactionID"] = transactionid
            
        if transactiontype is not None:
            params["TransactionType"] = transactiontype
            
        if pagenum is not None:
            params["pageNum"] = pagenum
            
        if pagesize is not None:
            params["pageSize"] = pagesize
            
        
        
        # Replace path parameters in URL
        path = "/tradeFinance/exportCollectionBills/shipmentView"
        
        
        # Prepare headers
        headers = {}
        if accesstoken is not None:
            headers["Accesstoken"] = str(accesstoken)
        if channeltype is not None:
            headers["ChannelType"] = str(channeltype)
        if co_relationid is not None:
            headers["co-Relationid"] = str(co_relationid)
        if entity is not None:
            headers["entity"] = str(entity)
        if initiatingsystem is not None:
            headers["initiatingSystem"] = str(initiatingsystem)
        if languagecode is not None:
            headers["languageCode"] = str(languagecode)
        if referenceid is not None:
            headers["referenceId"] = str(referenceid)
        if servicemode is not None:
            headers["serviceMode"] = str(servicemode)
        if userid is not None:
            headers["userId"] = str(userid)
        if uuidseqno is not None:
            headers["uuidSeqNo"] = str(uuidseqno)
        
        
        return await make_api_request(
            "GET", 
            path, 
            
            params=params if params else None, 
            headers=headers if headers else None
        )
    
    
    
    @mcp.tool()
    async def edcbt1003_dcon_hold_to_released_postusing_post(
        request_body:Dict[str, Any] ,  # RegisterExportDCConfirmRequest,
        accesstoken: Optional[str] = None,
        channeltype: Optional[int] = None,
        co_relationid: Optional[int] = None,
        entity: Optional[str] = None,
        initiatingsystem: Optional[str] = None,
        languagecode: Optional[int] = None,
        referenceid: Optional[str] = None,
        servicemode: Optional[int] = None,
        userid: Optional[int] = None,
        uuidseqno: Optional[int] = None
    ) -> Dict[str, Any]:
        """
        User Confirmation
        
        Generated from: POST /tradeFinance/exportCollectionBills/userConfirmation
        Source: swagger_2_0
        Operation ID: EDCBT1003DCOnHoldToReleased_POSTUsingPOST
        
        
        Authentication: Not required
        
        Parameters:
        - request_body: any (required)
          input
        
        
        
        Headers:
        - Accesstoken: string
          Authorization Token to validation the caller
        - ChannelType: integer
          Channel identifier from where the TXN has originated (Internet, Mobile, ATM, Branch Channel )
        - co-Relationid: integer
          Unique ID for the service invoked, will be set by the TXN system
        - entity: string
          entity
        - initiatingSystem: string
          Indicating the initiated system
        - languageCode: integer
          languageCode
        - referenceId: string
          Place holder for Token based authentication
        - serviceMode: integer
          Used for branch channel to indicate the type of customer
        - userId: integer
          userId
        - uuidSeqNo: integer
          UUID Sequence Number
        
        
        """
        
        
        # Prepare request data
        
        # Single body parameter - send directly
        data = request_body if request_body is not None else {}
        
        
        
        # Prepare query parameters
        params = {}
        
        
        # Replace path parameters in URL
        path = "/tradeFinance/exportCollectionBills/userConfirmation"
        
        
        # Prepare headers
        headers = {}
        if accesstoken is not None:
            headers["Accesstoken"] = str(accesstoken)
        if channeltype is not None:
            headers["ChannelType"] = str(channeltype)
        if co_relationid is not None:
            headers["co-Relationid"] = str(co_relationid)
        if entity is not None:
            headers["entity"] = str(entity)
        if initiatingsystem is not None:
            headers["initiatingSystem"] = str(initiatingsystem)
        if languagecode is not None:
            headers["languageCode"] = str(languagecode)
        if referenceid is not None:
            headers["referenceId"] = str(referenceid)
        if servicemode is not None:
            headers["serviceMode"] = str(servicemode)
        if userid is not None:
            headers["userId"] = str(userid)
        if uuidseqno is not None:
            headers["uuidSeqNo"] = str(uuidseqno)
        
        
        return await make_api_request(
            "POST", 
            path, 
            data=data, 
            params=params if params else None, 
            headers=headers if headers else None
        )
    
    
    
    @mcp.tool()
    async def edcet1011_get_dcdtls_postusing_get(
        edcposid: Optional[int] = None,
        edcpostype: Optional[int] = None,
        entityid: Optional[str] = None,
        evntlegid: Optional[int] = None,
        pagenum: Optional[int] = None,
        pagesize: Optional[int] = None,
        accesstoken: Optional[str] = None,
        channeltype: Optional[int] = None,
        co_relationid: Optional[int] = None,
        entity: Optional[str] = None,
        initiatingsystem: Optional[str] = None,
        languagecode: Optional[int] = None,
        referenceid: Optional[str] = None,
        servicemode: Optional[int] = None,
        userid: Optional[int] = None,
        uuidseqno: Optional[int] = None
    ) -> Dict[str, Any]:
        """
        Documentary Collections View
        
        Generated from: GET /tradeFinance/exportCollectionBills/view
        Source: swagger_2_0
        Operation ID: EDCET1011GetDCDtls_POSTUsingGET
        
        
        Authentication: Not required
        
        Parameters:
        - EdcPosId: integer
          Export Documentary CollectionPosID
        - EdcPosType: integer
          Export Documentary Collection Pos Type
        - EntityId: string
          Entity ID
        - EvntLegId: integer
          Event Leg ID
        - pageNum: integer
          pageNum
        - pageSize: integer
          pageSize
        
        
        
        Headers:
        - Accesstoken: string
          Authorization Token to validation the caller
        - ChannelType: integer
          Channel identifier from where the TXN has originated (Internet, Mobile, ATM, Branch Channel )
        - co-Relationid: integer
          Unique ID for the service invoked, will be set by the TXN system
        - entity: string
          entity
        - initiatingSystem: string
          Indicating the initiated system
        - languageCode: integer
          languageCode
        - referenceId: string
          Place holder for Token based authentication
        - serviceMode: integer
          Used for branch channel to indicate the type of customer
        - userId: integer
          userId
        - uuidSeqNo: integer
          UUID Sequence Number
        
        
        """
        
        
        # Prepare query parameters
        params = {}
        if edcposid is not None:
            params["EdcPosId"] = edcposid
            
        if edcpostype is not None:
            params["EdcPosType"] = edcpostype
            
        if entityid is not None:
            params["EntityId"] = entityid
            
        if evntlegid is not None:
            params["EvntLegId"] = evntlegid
            
        if pagenum is not None:
            params["pageNum"] = pagenum
            
        if pagesize is not None:
            params["pageSize"] = pagesize
            
        
        
        # Replace path parameters in URL
        path = "/tradeFinance/exportCollectionBills/view"
        
        
        # Prepare headers
        headers = {}
        if accesstoken is not None:
            headers["Accesstoken"] = str(accesstoken)
        if channeltype is not None:
            headers["ChannelType"] = str(channeltype)
        if co_relationid is not None:
            headers["co-Relationid"] = str(co_relationid)
        if entity is not None:
            headers["entity"] = str(entity)
        if initiatingsystem is not None:
            headers["initiatingSystem"] = str(initiatingsystem)
        if languagecode is not None:
            headers["languageCode"] = str(languagecode)
        if referenceid is not None:
            headers["referenceId"] = str(referenceid)
        if servicemode is not None:
            headers["serviceMode"] = str(servicemode)
        if userid is not None:
            headers["userId"] = str(userid)
        if uuidseqno is not None:
            headers["uuidSeqNo"] = str(uuidseqno)
        
        
        return await make_api_request(
            "GET", 
            path, 
            
            params=params if params else None, 
            headers=headers if headers else None
        )
    
    
    
    @mcp.tool()
    async def edcet1011_get_edcdtls_postusing_get(
        billtransactionid: int,
        eventlegid: int,
        accesstoken: Optional[str] = None,
        channeltype: Optional[int] = None,
        co_relationid: Optional[int] = None,
        entity: Optional[str] = None,
        initiatingsystem: Optional[str] = None,
        languagecode: Optional[int] = None,
        referenceid: Optional[str] = None,
        servicemode: Optional[int] = None,
        userid: Optional[int] = None,
        uuidseqno: Optional[int] = None
    ) -> Dict[str, Any]:
        """
        Export DC Details
        
        Generated from: GET /tradeFinance/exportCollectionBills/{billTransactionId}/{eventLegId}
        Source: swagger_2_0
        Operation ID: EDCET1011GetEDCDtls_POSTUsingGET
        
        
        Authentication: Not required
        
        Parameters:
        - billTransactionId: integer (required)
          Bill Transaction ID
        - eventLegId: integer (required)
          Event Leg ID
        
        
        
        Headers:
        - Accesstoken: string
          Authorization Token to validation the caller
        - ChannelType: integer
          Channel identifier from where the TXN has originated (Internet, Mobile, ATM, Branch Channel )
        - co-Relationid: integer
          Unique ID for the service invoked, will be set by the TXN system
        - entity: string
          entity
        - initiatingSystem: string
          Indicating the initiated system
        - languageCode: integer
          languageCode
        - referenceId: string
          Place holder for Token based authentication
        - serviceMode: integer
          Used for branch channel to indicate the type of customer
        - userId: integer
          userId
        - uuidSeqNo: integer
          UUID Sequence Number
        
        
        """
        
        
        # Prepare query parameters
        params = {}
        
        
        # Replace path parameters in URL
        path = "/tradeFinance/exportCollectionBills/{billTransactionId}/{eventLegId}"
        if billtransactionid is not None:
            path = path.replace("{billTransactionId}", str(billtransactionid))
        if eventlegid is not None:
            path = path.replace("{eventLegId}", str(eventlegid))
        
        
        # Prepare headers
        headers = {}
        if accesstoken is not None:
            headers["Accesstoken"] = str(accesstoken)
        if channeltype is not None:
            headers["ChannelType"] = str(channeltype)
        if co_relationid is not None:
            headers["co-Relationid"] = str(co_relationid)
        if entity is not None:
            headers["entity"] = str(entity)
        if initiatingsystem is not None:
            headers["initiatingSystem"] = str(initiatingsystem)
        if languagecode is not None:
            headers["languageCode"] = str(languagecode)
        if referenceid is not None:
            headers["referenceId"] = str(referenceid)
        if servicemode is not None:
            headers["serviceMode"] = str(servicemode)
        if userid is not None:
            headers["userId"] = str(userid)
        if uuidseqno is not None:
            headers["uuidSeqNo"] = str(uuidseqno)
        
        
        return await make_api_request(
            "GET", 
            path, 
            
            params=params if params else None, 
            headers=headers if headers else None
        )
    
    
    
    @mcp.tool()
    async def edcbt4001_blamnd_on_holdto_on_hold_postusing_post(
        request_body:Dict[str, Any] ,  # EdcCollectionsBillsModifyAmendmentRequest,
        accesstoken: Optional[str] = None,
        channeltype: Optional[int] = None,
        co_relationid: Optional[int] = None,
        entity: Optional[str] = None,
        initiatingsystem: Optional[str] = None,
        languagecode: Optional[int] = None,
        referenceid: Optional[str] = None,
        servicemode: Optional[int] = None,
        userid: Optional[int] = None,
        uuidseqno: Optional[int] = None
    ) -> Dict[str, Any]:
        """
        Modify Amend Export DC Bill Onhold
        
        Generated from: POST /tradeFinance/exportCollectionBillsLodge/amendment/modify
        Source: swagger_2_0
        Operation ID: EDCBT4001BLAmndOnHoldtoOnHold_POSTUsingPOST
        
        
        Authentication: Not required
        
        Parameters:
        - request_body: any (required)
          input
        
        
        
        Headers:
        - Accesstoken: string
          Authorization Token to validation the caller
        - ChannelType: integer
          Channel identifier from where the TXN has originated (Internet, Mobile, ATM, Branch Channel )
        - co-Relationid: integer
          Unique ID for the service invoked, will be set by the TXN system
        - entity: string
          entity
        - initiatingSystem: string
          Indicating the initiated system
        - languageCode: integer
          languageCode
        - referenceId: string
          Place holder for Token based authentication
        - serviceMode: integer
          Used for branch channel to indicate the type of customer
        - userId: integer
          userId
        - uuidSeqNo: integer
          UUID Sequence Number
        
        
        """
        
        
        # Prepare request data
        
        # Single body parameter - send directly
        data = request_body if request_body is not None else {}
        
        
        
        # Prepare query parameters
        params = {}
        
        
        # Replace path parameters in URL
        path = "/tradeFinance/exportCollectionBillsLodge/amendment/modify"
        
        
        # Prepare headers
        headers = {}
        if accesstoken is not None:
            headers["Accesstoken"] = str(accesstoken)
        if channeltype is not None:
            headers["ChannelType"] = str(channeltype)
        if co_relationid is not None:
            headers["co-Relationid"] = str(co_relationid)
        if entity is not None:
            headers["entity"] = str(entity)
        if initiatingsystem is not None:
            headers["initiatingSystem"] = str(initiatingsystem)
        if languagecode is not None:
            headers["languageCode"] = str(languagecode)
        if referenceid is not None:
            headers["referenceId"] = str(referenceid)
        if servicemode is not None:
            headers["serviceMode"] = str(servicemode)
        if userid is not None:
            headers["userId"] = str(userid)
        if uuidseqno is not None:
            headers["uuidSeqNo"] = str(uuidseqno)
        
        
        return await make_api_request(
            "POST", 
            path, 
            data=data, 
            params=params if params else None, 
            headers=headers if headers else None
        )
    
    
    
    @mcp.tool()
    async def elcbt4001_blamnd_rlsdto_on_hold_postusing_post(
        request_body:Dict[str, Any] ,  # AmendExportLCSendBackRequest,
        accesstoken: Optional[str] = None,
        channeltype: Optional[int] = None,
        co_relationid: Optional[int] = None,
        entity: Optional[str] = None,
        initiatingsystem: Optional[str] = None,
        languagecode: Optional[int] = None,
        referenceid: Optional[str] = None,
        servicemode: Optional[int] = None,
        userid: Optional[int] = None,
        uuidseqno: Optional[int] = None
    ) -> Dict[str, Any]:
        """
        Sendback Export Documentary Collections Amendment
        
        Generated from: POST /tradeFinance/exportLetterOfCredit/amend/sendback
        Source: swagger_2_0
        Operation ID: ELCBT4001BLAmndRlsdtoOnHold_POSTUsingPOST
        
        
        Authentication: Not required
        
        Parameters:
        - request_body: any (required)
          input
        
        
        
        Headers:
        - Accesstoken: string
          Authorization Token to validation the caller
        - ChannelType: integer
          Channel identifier from where the TXN has originated (Internet, Mobile, ATM, Branch Channel )
        - co-Relationid: integer
          Unique ID for the service invoked, will be set by the TXN system
        - entity: string
          entity
        - initiatingSystem: string
          Indicating the initiated system
        - languageCode: integer
          languageCode
        - referenceId: string
          Place holder for Token based authentication
        - serviceMode: integer
          Used for branch channel to indicate the type of customer
        - userId: integer
          userId
        - uuidSeqNo: integer
          UUID Sequence Number
        
        
        """
        
        
        # Prepare request data
        
        # Single body parameter - send directly
        data = request_body if request_body is not None else {}
        
        
        
        # Prepare query parameters
        params = {}
        
        
        # Replace path parameters in URL
        path = "/tradeFinance/exportLetterOfCredit/amend/sendback"
        
        
        # Prepare headers
        headers = {}
        if accesstoken is not None:
            headers["Accesstoken"] = str(accesstoken)
        if channeltype is not None:
            headers["ChannelType"] = str(channeltype)
        if co_relationid is not None:
            headers["co-Relationid"] = str(co_relationid)
        if entity is not None:
            headers["entity"] = str(entity)
        if initiatingsystem is not None:
            headers["initiatingSystem"] = str(initiatingsystem)
        if languagecode is not None:
            headers["languageCode"] = str(languagecode)
        if referenceid is not None:
            headers["referenceId"] = str(referenceid)
        if servicemode is not None:
            headers["serviceMode"] = str(servicemode)
        if userid is not None:
            headers["userId"] = str(userid)
        if uuidseqno is not None:
            headers["uuidSeqNo"] = str(uuidseqno)
        
        
        return await make_api_request(
            "POST", 
            path, 
            data=data, 
            params=params if params else None, 
            headers=headers if headers else None
        )
    
    
    
    @mcp.tool()
    async def elcbt6541_auth_elcamend_confirm_postusing_put(
        request_body:Dict[str, Any] ,  # AuthRejectSentbackELCAmendConfirmationRequest,
        accesstoken: Optional[str] = None,
        channeltype: Optional[int] = None,
        co_relationid: Optional[int] = None,
        entity: Optional[str] = None,
        initiatingsystem: Optional[str] = None,
        languagecode: Optional[int] = None,
        mu_id: Optional[str] = None,
        referenceid: Optional[str] = None,
        servicemode: Optional[int] = None,
        userid: Optional[int] = None,
        uuidseqno: Optional[int] = None
    ) -> Dict[str, Any]:
        """
        Authorise ELC Amend Confirmation
        
        Generated from: PUT /tradeFinance/exportLetterOfCredit/amendConfirmation/authorize
        Source: swagger_2_0
        Operation ID: ELCBT6541AuthELCAmendConfirm_POSTUsingPUT
        
        
        Authentication: Not required
        
        Parameters:
        - request_body: any (required)
          input
        
        
        
        Headers:
        - Accesstoken: string
          Authorization Token to validation the caller
        - ChannelType: integer
          Channel identifier from where the TXN has originated (Internet, Mobile, ATM, Branch Channel )
        - co-Relationid: integer
          Unique ID for the service invoked, will be set by the TXN system
        - entity: string
          entity
        - initiatingSystem: string
          Indicating the initiated system
        - languageCode: integer
          languageCode
        - mu_Id: string
          Muid
        - referenceId: string
          Place holder for Token based authentication
        - serviceMode: integer
          Used for branch channel to indicate the type of customer
        - userId: integer
          userId
        - uuidSeqNo: integer
          UUID Sequence Number
        
        
        """
        
        
        # Prepare request data
        
        # Single body parameter - send directly
        data = request_body if request_body is not None else {}
        
        
        
        # Prepare query parameters
        params = {}
        
        
        # Replace path parameters in URL
        path = "/tradeFinance/exportLetterOfCredit/amendConfirmation/authorize"
        
        
        # Prepare headers
        headers = {}
        if accesstoken is not None:
            headers["Accesstoken"] = str(accesstoken)
        if channeltype is not None:
            headers["ChannelType"] = str(channeltype)
        if co_relationid is not None:
            headers["co-Relationid"] = str(co_relationid)
        if entity is not None:
            headers["entity"] = str(entity)
        if initiatingsystem is not None:
            headers["initiatingSystem"] = str(initiatingsystem)
        if languagecode is not None:
            headers["languageCode"] = str(languagecode)
        if mu_id is not None:
            headers["mu_Id"] = str(mu_id)
        if referenceid is not None:
            headers["referenceId"] = str(referenceid)
        if servicemode is not None:
            headers["serviceMode"] = str(servicemode)
        if userid is not None:
            headers["userId"] = str(userid)
        if uuidseqno is not None:
            headers["uuidSeqNo"] = str(uuidseqno)
        
        
        return await make_api_request(
            "PUT", 
            path, 
            data=data, 
            params=params if params else None, 
            headers=headers if headers else None
        )
    
    
    
    @mcp.tool()
    async def elcbt6541_elcamend_confirm_postusing_post(
        request_body:Dict[str, Any] ,  # ELC_AMEND_ELCBT6541ELCAmendConfirm_Resource,
        accesstoken: Optional[str] = None,
        channeltype: Optional[int] = None,
        co_relationid: Optional[int] = None,
        entity: Optional[str] = None,
        initiatingsystem: Optional[str] = None,
        languagecode: Optional[int] = None,
        mu_id: Optional[str] = None,
        referenceid: Optional[str] = None,
        servicemode: Optional[int] = None,
        userid: Optional[int] = None,
        uuidseqno: Optional[int] = None
    ) -> Dict[str, Any]:
        """
        Create ELC Amend Confirmation
        
        Generated from: POST /tradeFinance/exportLetterOfCredit/amendConfirmation/create
        Source: swagger_2_0
        Operation ID: ELCBT6541ELCAmendConfirm_POSTUsingPOST
        
        
        Authentication: Not required
        
        Parameters:
        - request_body: any (required)
          input
        
        
        
        Headers:
        - Accesstoken: string
          Authorization Token to validation the caller
        - ChannelType: integer
          Channel identifier from where the TXN has originated (Internet, Mobile, ATM, Branch Channel )
        - co-Relationid: integer
          Unique ID for the service invoked, will be set by the TXN system
        - entity: string
          entity
        - initiatingSystem: string
          Indicating the initiated system
        - languageCode: integer
          languageCode
        - mu_Id: string
          Used to indicate the Branch Id of user
        - referenceId: string
          Place holder for Token based authentication
        - serviceMode: integer
          Used for branch channel to indicate the type of customer
        - userId: integer
          userId
        - uuidSeqNo: integer
          UUID Sequence Number
        
        
        """
        
        
        # Prepare request data
        
        # Single body parameter - send directly
        data = request_body if request_body is not None else {}
        
        
        
        # Prepare query parameters
        params = {}
        
        
        # Replace path parameters in URL
        path = "/tradeFinance/exportLetterOfCredit/amendConfirmation/create"
        
        
        # Prepare headers
        headers = {}
        if accesstoken is not None:
            headers["Accesstoken"] = str(accesstoken)
        if channeltype is not None:
            headers["ChannelType"] = str(channeltype)
        if co_relationid is not None:
            headers["co-Relationid"] = str(co_relationid)
        if entity is not None:
            headers["entity"] = str(entity)
        if initiatingsystem is not None:
            headers["initiatingSystem"] = str(initiatingsystem)
        if languagecode is not None:
            headers["languageCode"] = str(languagecode)
        if mu_id is not None:
            headers["mu_Id"] = str(mu_id)
        if referenceid is not None:
            headers["referenceId"] = str(referenceid)
        if servicemode is not None:
            headers["serviceMode"] = str(servicemode)
        if userid is not None:
            headers["userId"] = str(userid)
        if uuidseqno is not None:
            headers["uuidSeqNo"] = str(uuidseqno)
        
        
        return await make_api_request(
            "POST", 
            path, 
            data=data, 
            params=params if params else None, 
            headers=headers if headers else None
        )
    
    
    
    @mcp.tool()
    async def elcbt91_elcamend_on_hold_postusing_post(
        request_body:Dict[str, Any] ,  # ElcAmendmentRequest,
        accesstoken: Optional[str] = None,
        channeltype: Optional[int] = None,
        co_relationid: Optional[int] = None,
        entity: Optional[str] = None,
        initiatingsystem: Optional[str] = None,
        languagecode: Optional[int] = None,
        referenceid: Optional[str] = None,
        servicemode: Optional[int] = None,
        userid: Optional[int] = None,
        uuidseqno: Optional[int] = None
    ) -> Dict[str, Any]:
        """
        Amend Export LC Onhold
        
        Generated from: POST /tradeFinance/exportLetterOfCredit/amendment
        Source: swagger_2_0
        Operation ID: ELCBT91ELCAmendOnHold_POSTUsingPOST
        
        
        Authentication: Not required
        
        Parameters:
        - request_body: any (required)
          input
        
        
        
        Headers:
        - Accesstoken: string
          Authorization Token to validation the caller
        - ChannelType: integer
          Channel identifier from where the TXN has originated (Internet, Mobile, ATM, Branch Channel )
        - co-Relationid: integer
          Unique ID for the service invoked, will be set by the TXN system
        - entity: string
          entity
        - initiatingSystem: string
          Indicating the initiated system
        - languageCode: integer
          languageCode
        - referenceId: string
          Place holder for Token based authentication
        - serviceMode: integer
          Used for branch channel to indicate the type of customer
        - userId: integer
          userId
        - uuidSeqNo: integer
          UUID Sequence Number
        
        
        """
        
        
        # Prepare request data
        
        # Single body parameter - send directly
        data = request_body if request_body is not None else {}
        
        
        
        # Prepare query parameters
        params = {}
        
        
        # Replace path parameters in URL
        path = "/tradeFinance/exportLetterOfCredit/amendment"
        
        
        # Prepare headers
        headers = {}
        if accesstoken is not None:
            headers["Accesstoken"] = str(accesstoken)
        if channeltype is not None:
            headers["ChannelType"] = str(channeltype)
        if co_relationid is not None:
            headers["co-Relationid"] = str(co_relationid)
        if entity is not None:
            headers["entity"] = str(entity)
        if initiatingsystem is not None:
            headers["initiatingSystem"] = str(initiatingsystem)
        if languagecode is not None:
            headers["languageCode"] = str(languagecode)
        if referenceid is not None:
            headers["referenceId"] = str(referenceid)
        if servicemode is not None:
            headers["serviceMode"] = str(servicemode)
        if userid is not None:
            headers["userId"] = str(userid)
        if uuidseqno is not None:
            headers["uuidSeqNo"] = str(uuidseqno)
        
        
        return await make_api_request(
            "POST", 
            path, 
            data=data, 
            params=params if params else None, 
            headers=headers if headers else None
        )
    
    
    
    @mcp.tool()
    async def elcbt9004_lcamend_on_hold_to_rjct_postusing_post(
        request_body:Dict[str, Any] ,  # ElcAmendmentRejectRequest,
        accesstoken: Optional[str] = None,
        channeltype: Optional[int] = None,
        co_relationid: Optional[int] = None,
        entity: Optional[str] = None,
        initiatingsystem: Optional[str] = None,
        languagecode: Optional[int] = None,
        referenceid: Optional[str] = None,
        servicemode: Optional[int] = None,
        userid: Optional[int] = None,
        uuidseqno: Optional[int] = None
    ) -> Dict[str, Any]:
        """
        Export LC Amend Registration Reject
        
        Generated from: POST /tradeFinance/exportLetterOfCredit/amendment/Reject
        Source: swagger_2_0
        Operation ID: ELCBT9004LCAmendOnHoldToRjct_POSTUsingPOST
        
        
        Authentication: Not required
        
        Parameters:
        - request_body: any (required)
          input
        
        
        
        Headers:
        - Accesstoken: string
          Authorization Token to validation the caller
        - ChannelType: integer
          Channel identifier from where the TXN has originated (Internet, Mobile, ATM, Branch Channel )
        - co-Relationid: integer
          Unique ID for the service invoked, will be set by the TXN system
        - entity: string
          entity
        - initiatingSystem: string
          Indicating the initiated system
        - languageCode: integer
          languageCode
        - referenceId: string
          Place holder for Token based authentication
        - serviceMode: integer
          Used for branch channel to indicate the type of customer
        - userId: integer
          userId
        - uuidSeqNo: integer
          UUID Sequence Number
        
        
        """
        
        
        # Prepare request data
        
        # Single body parameter - send directly
        data = request_body if request_body is not None else {}
        
        
        
        # Prepare query parameters
        params = {}
        
        
        # Replace path parameters in URL
        path = "/tradeFinance/exportLetterOfCredit/amendment/Reject"
        
        
        # Prepare headers
        headers = {}
        if accesstoken is not None:
            headers["Accesstoken"] = str(accesstoken)
        if channeltype is not None:
            headers["ChannelType"] = str(channeltype)
        if co_relationid is not None:
            headers["co-Relationid"] = str(co_relationid)
        if entity is not None:
            headers["entity"] = str(entity)
        if initiatingsystem is not None:
            headers["initiatingSystem"] = str(initiatingsystem)
        if languagecode is not None:
            headers["languageCode"] = str(languagecode)
        if referenceid is not None:
            headers["referenceId"] = str(referenceid)
        if servicemode is not None:
            headers["serviceMode"] = str(servicemode)
        if userid is not None:
            headers["userId"] = str(userid)
        if uuidseqno is not None:
            headers["uuidSeqNo"] = str(uuidseqno)
        
        
        return await make_api_request(
            "POST", 
            path, 
            data=data, 
            params=params if params else None, 
            headers=headers if headers else None
        )
    
    
    
    @mcp.tool()
    async def elcbt5299_elcamend_rlsd_to_sentback_postusing_post(
        request_body:Dict[str, Any] ,  # ElcAmendmentSentbackRequest,
        accesstoken: Optional[str] = None,
        channeltype: Optional[int] = None,
        co_relationid: Optional[int] = None,
        entity: Optional[str] = None,
        initiatingsystem: Optional[str] = None,
        languagecode: Optional[int] = None,
        referenceid: Optional[str] = None,
        servicemode: Optional[int] = None,
        userid: Optional[int] = None,
        uuidseqno: Optional[int] = None
    ) -> Dict[str, Any]:
        """
        Export LC Amend Registration Sentback
        
        Generated from: POST /tradeFinance/exportLetterOfCredit/amendment/Sentback
        Source: swagger_2_0
        Operation ID: ELCBT5299ELCAmendRlsdToSentback_POSTUsingPOST
        
        
        Authentication: Not required
        
        Parameters:
        - request_body: any (required)
          input
        
        
        
        Headers:
        - Accesstoken: string
          Authorization Token to validation the caller
        - ChannelType: integer
          Channel identifier from where the TXN has originated (Internet, Mobile, ATM, Branch Channel )
        - co-Relationid: integer
          Unique ID for the service invoked, will be set by the TXN system
        - entity: string
          entity
        - initiatingSystem: string
          Indicating the initiated system
        - languageCode: integer
          languageCode
        - referenceId: string
          Place holder for Token based authentication
        - serviceMode: integer
          Used for branch channel to indicate the type of customer
        - userId: integer
          userId
        - uuidSeqNo: integer
          UUID Sequence Number
        
        
        """
        
        
        # Prepare request data
        
        # Single body parameter - send directly
        data = request_body if request_body is not None else {}
        
        
        
        # Prepare query parameters
        params = {}
        
        
        # Replace path parameters in URL
        path = "/tradeFinance/exportLetterOfCredit/amendment/Sentback"
        
        
        # Prepare headers
        headers = {}
        if accesstoken is not None:
            headers["Accesstoken"] = str(accesstoken)
        if channeltype is not None:
            headers["ChannelType"] = str(channeltype)
        if co_relationid is not None:
            headers["co-Relationid"] = str(co_relationid)
        if entity is not None:
            headers["entity"] = str(entity)
        if initiatingsystem is not None:
            headers["initiatingSystem"] = str(initiatingsystem)
        if languagecode is not None:
            headers["languageCode"] = str(languagecode)
        if referenceid is not None:
            headers["referenceId"] = str(referenceid)
        if servicemode is not None:
            headers["serviceMode"] = str(servicemode)
        if userid is not None:
            headers["userId"] = str(userid)
        if uuidseqno is not None:
            headers["uuidSeqNo"] = str(uuidseqno)
        
        
        return await make_api_request(
            "POST", 
            path, 
            data=data, 
            params=params if params else None, 
            headers=headers if headers else None
        )
    
    
    
    @mcp.tool()
    async def elcbt9019_elcamend_acpt_refusal_postusing_put(
        request_body:Dict[str, Any] ,  # AuthorizationForAmendmentRequest,
        accesstoken: Optional[str] = None,
        channeltype: Optional[int] = None,
        co_relationid: Optional[int] = None,
        entity: Optional[str] = None,
        initiatingsystem: Optional[str] = None,
        languagecode: Optional[int] = None,
        referenceid: Optional[str] = None,
        servicemode: Optional[int] = None,
        userid: Optional[int] = None,
        uuidseqno: Optional[int] = None
    ) -> Dict[str, Any]:
        """
        Acceptance/Refusal Authorization For Amendment
        
        Generated from: PUT /tradeFinance/exportLetterOfCredit/amendment/acceptRefusalAuth
        Source: swagger_2_0
        Operation ID: ELCBT9019ELCAmendAcptRefusal_POSTUsingPUT
        
        
        Authentication: Not required
        
        Parameters:
        - request_body: any (required)
          input
        
        
        
        Headers:
        - Accesstoken: string
          Authorization Token to validation the caller
        - ChannelType: integer
          Channel identifier from where the TXN has originated (Internet, Mobile, ATM, Branch Channel )
        - co-Relationid: integer
          Unique ID for the service invoked, will be set by the TXN system
        - entity: string
          entity
        - initiatingSystem: string
          Indicating the initiated system
        - languageCode: integer
          languageCode
        - referenceId: string
          Place holder for Token based authentication
        - serviceMode: integer
          Used for branch channel to indicate the type of customer
        - userId: integer
          userId
        - uuidSeqNo: integer
          UUID Sequence Number
        
        
        """
        
        
        # Prepare request data
        
        # Single body parameter - send directly
        data = request_body if request_body is not None else {}
        
        
        
        # Prepare query parameters
        params = {}
        
        
        # Replace path parameters in URL
        path = "/tradeFinance/exportLetterOfCredit/amendment/acceptRefusalAuth"
        
        
        # Prepare headers
        headers = {}
        if accesstoken is not None:
            headers["Accesstoken"] = str(accesstoken)
        if channeltype is not None:
            headers["ChannelType"] = str(channeltype)
        if co_relationid is not None:
            headers["co-Relationid"] = str(co_relationid)
        if entity is not None:
            headers["entity"] = str(entity)
        if initiatingsystem is not None:
            headers["initiatingSystem"] = str(initiatingsystem)
        if languagecode is not None:
            headers["languageCode"] = str(languagecode)
        if referenceid is not None:
            headers["referenceId"] = str(referenceid)
        if servicemode is not None:
            headers["serviceMode"] = str(servicemode)
        if userid is not None:
            headers["userId"] = str(userid)
        if uuidseqno is not None:
            headers["uuidSeqNo"] = str(uuidseqno)
        
        
        return await make_api_request(
            "PUT", 
            path, 
            data=data, 
            params=params if params else None, 
            headers=headers if headers else None
        )
    
    
    
    @mcp.tool()
    async def elcbt9017_elcamend_acpt_ref_pndng_postusing_put(
        request_body:Dict[str, Any] ,  # AmendmentAcceptRefusalPendingRequest,
        accesstoken: Optional[str] = None,
        channeltype: Optional[int] = None,
        co_relationid: Optional[int] = None,
        entity: Optional[str] = None,
        initiatingsystem: Optional[str] = None,
        languagecode: Optional[int] = None,
        referenceid: Optional[str] = None,
        servicemode: Optional[int] = None,
        userid: Optional[int] = None,
        uuidseqno: Optional[int] = None
    ) -> Dict[str, Any]:
        """
        Accept Refusal of Amendment to Pending
        
        Generated from: PUT /tradeFinance/exportLetterOfCredit/amendment/acceptRefusalPending
        Source: swagger_2_0
        Operation ID: ELCBT9017ELCAmendAcptRefPndng_POSTUsingPUT
        
        
        Authentication: Not required
        
        Parameters:
        - request_body: any (required)
          input
        
        
        
        Headers:
        - Accesstoken: string
          Authorization Token to validation the caller
        - ChannelType: integer
          Channel identifier from where the TXN has originated (Internet, Mobile, ATM, Branch Channel )
        - co-Relationid: integer
          Unique ID for the service invoked, will be set by the TXN system
        - entity: string
          entity
        - initiatingSystem: string
          Indicating the initiated system
        - languageCode: integer
          languageCode
        - referenceId: string
          Place holder for Token based authentication
        - serviceMode: integer
          Used for branch channel to indicate the type of customer
        - userId: integer
          userId
        - uuidSeqNo: integer
          UUID Sequence Number
        
        
        """
        
        
        # Prepare request data
        
        # Single body parameter - send directly
        data = request_body if request_body is not None else {}
        
        
        
        # Prepare query parameters
        params = {}
        
        
        # Replace path parameters in URL
        path = "/tradeFinance/exportLetterOfCredit/amendment/acceptRefusalPending"
        
        
        # Prepare headers
        headers = {}
        if accesstoken is not None:
            headers["Accesstoken"] = str(accesstoken)
        if channeltype is not None:
            headers["ChannelType"] = str(channeltype)
        if co_relationid is not None:
            headers["co-Relationid"] = str(co_relationid)
        if entity is not None:
            headers["entity"] = str(entity)
        if initiatingsystem is not None:
            headers["initiatingSystem"] = str(initiatingsystem)
        if languagecode is not None:
            headers["languageCode"] = str(languagecode)
        if referenceid is not None:
            headers["referenceId"] = str(referenceid)
        if servicemode is not None:
            headers["serviceMode"] = str(servicemode)
        if userid is not None:
            headers["userId"] = str(userid)
        if uuidseqno is not None:
            headers["uuidSeqNo"] = str(uuidseqno)
        
        
        return await make_api_request(
            "PUT", 
            path, 
            data=data, 
            params=params if params else None, 
            headers=headers if headers else None
        )
    
    
    
    @mcp.tool()
    async def elcbt9018_elcamend_acpt_ref_verified_postusing_put(
        request_body:Dict[str, Any] ,  # AmendmentAcceptRefusalVerifiedRequest,
        accesstoken: Optional[str] = None,
        channeltype: Optional[int] = None,
        co_relationid: Optional[int] = None,
        entity: Optional[str] = None,
        initiatingsystem: Optional[str] = None,
        languagecode: Optional[int] = None,
        referenceid: Optional[str] = None,
        servicemode: Optional[int] = None,
        userid: Optional[int] = None,
        uuidseqno: Optional[int] = None
    ) -> Dict[str, Any]:
        """
        Accept Refusal from Pending to Verified
        
        Generated from: PUT /tradeFinance/exportLetterOfCredit/amendment/acceptRefusalVerified
        Source: swagger_2_0
        Operation ID: ELCBT9018ELCAmendAcptRefVerified_POSTUsingPUT
        
        
        Authentication: Not required
        
        Parameters:
        - request_body: any (required)
          input
        
        
        
        Headers:
        - Accesstoken: string
          Authorization Token to validation the caller
        - ChannelType: integer
          Channel identifier from where the TXN has originated (Internet, Mobile, ATM, Branch Channel )
        - co-Relationid: integer
          Unique ID for the service invoked, will be set by the TXN system
        - entity: string
          entity
        - initiatingSystem: string
          Indicating the initiated system
        - languageCode: integer
          languageCode
        - referenceId: string
          Place holder for Token based authentication
        - serviceMode: integer
          Used for branch channel to indicate the type of customer
        - userId: integer
          userId
        - uuidSeqNo: integer
          UUID Sequence Number
        
        
        """
        
        
        # Prepare request data
        
        # Single body parameter - send directly
        data = request_body if request_body is not None else {}
        
        
        
        # Prepare query parameters
        params = {}
        
        
        # Replace path parameters in URL
        path = "/tradeFinance/exportLetterOfCredit/amendment/acceptRefusalVerified"
        
        
        # Prepare headers
        headers = {}
        if accesstoken is not None:
            headers["Accesstoken"] = str(accesstoken)
        if channeltype is not None:
            headers["ChannelType"] = str(channeltype)
        if co_relationid is not None:
            headers["co-Relationid"] = str(co_relationid)
        if entity is not None:
            headers["entity"] = str(entity)
        if initiatingsystem is not None:
            headers["initiatingSystem"] = str(initiatingsystem)
        if languagecode is not None:
            headers["languageCode"] = str(languagecode)
        if referenceid is not None:
            headers["referenceId"] = str(referenceid)
        if servicemode is not None:
            headers["serviceMode"] = str(servicemode)
        if userid is not None:
            headers["userId"] = str(userid)
        if uuidseqno is not None:
            headers["uuidSeqNo"] = str(uuidseqno)
        
        
        return await make_api_request(
            "PUT", 
            path, 
            data=data, 
            params=params if params else None, 
            headers=headers if headers else None
        )
    
    
    
    @mcp.tool()
    async def elcbt9009_elcamend_verified_to_exec_postusing_post(
        request_body:Dict[str, Any] ,  # ElcAmendmentAuthRequest,
        accesstoken: Optional[str] = None,
        channeltype: Optional[int] = None,
        co_relationid: Optional[int] = None,
        entity: Optional[str] = None,
        initiatingsystem: Optional[str] = None,
        languagecode: Optional[int] = None,
        mu_id: Optional[str] = None,
        referenceid: Optional[str] = None,
        servicemode: Optional[int] = None,
        userid: Optional[int] = None,
        uuidseqno: Optional[int] = None
    ) -> Dict[str, Any]:
        """
        Authorize Export LC Amendment
        
        Generated from: POST /tradeFinance/exportLetterOfCredit/amendment/authorize
        Source: swagger_2_0
        Operation ID: ELCBT9009ELCAmendVerifiedToExec_POSTUsingPOST
        
        
        Authentication: Not required
        
        Parameters:
        - request_body: any (required)
          input
        
        
        
        Headers:
        - Accesstoken: string
          Authorization Token to validation the caller
        - ChannelType: integer
          Channel identifier from where the TXN has originated (Internet, Mobile, ATM, Branch Channel )
        - co-Relationid: integer
          Unique ID for the service invoked, will be set by the TXN system
        - entity: string
          entity
        - initiatingSystem: string
          Indicating the initiated system
        - languageCode: integer
          languageCode
        - mu_Id: string
          Muid
        - referenceId: string
          Place holder for Token based authentication
        - serviceMode: integer
          Used for branch channel to indicate the type of customer
        - userId: integer
          userId
        - uuidSeqNo: integer
          UUID Sequence Number
        
        
        """
        
        
        # Prepare request data
        
        # Single body parameter - send directly
        data = request_body if request_body is not None else {}
        
        
        
        # Prepare query parameters
        params = {}
        
        
        # Replace path parameters in URL
        path = "/tradeFinance/exportLetterOfCredit/amendment/authorize"
        
        
        # Prepare headers
        headers = {}
        if accesstoken is not None:
            headers["Accesstoken"] = str(accesstoken)
        if channeltype is not None:
            headers["ChannelType"] = str(channeltype)
        if co_relationid is not None:
            headers["co-Relationid"] = str(co_relationid)
        if entity is not None:
            headers["entity"] = str(entity)
        if initiatingsystem is not None:
            headers["initiatingSystem"] = str(initiatingsystem)
        if languagecode is not None:
            headers["languageCode"] = str(languagecode)
        if mu_id is not None:
            headers["mu_Id"] = str(mu_id)
        if referenceid is not None:
            headers["referenceId"] = str(referenceid)
        if servicemode is not None:
            headers["serviceMode"] = str(servicemode)
        if userid is not None:
            headers["userId"] = str(userid)
        if uuidseqno is not None:
            headers["uuidSeqNo"] = str(uuidseqno)
        
        
        return await make_api_request(
            "POST", 
            path, 
            data=data, 
            params=params if params else None, 
            headers=headers if headers else None
        )
    
    
    
    @mcp.tool()
    async def elcet7014_fetch_elcdtls_postusing_get(
        customerid: Optional[int] = None,
        customername: Optional[str] = None,
        documentarycreditnumber: Optional[str] = None,
        elcadvisingreference: Optional[str] = None,
        elcinstrumentid: Optional[str] = None,
        issuedate: Optional[str] = None,
        pagenum: Optional[int] = None,
        pagesize: Optional[int] = None,
        transactionid: Optional[int] = None,
        accesstoken: Optional[str] = None,
        channeltype: Optional[int] = None,
        co_relationid: Optional[int] = None,
        entity: Optional[str] = None,
        initiatingsystem: Optional[str] = None,
        languagecode: Optional[int] = None,
        referenceid: Optional[str] = None,
        servicemode: Optional[int] = None,
        userid: Optional[int] = None,
        uuidseqno: Optional[int] = None
    ) -> Dict[str, Any]:
        """
        Fetch Registered Export LC Details
        
        Generated from: GET /tradeFinance/exportLetterOfCredit/amendment/detailedList
        Source: swagger_2_0
        Operation ID: ELCET7014FetchELCDtls_POSTUsingGET
        
        
        Authentication: Not required
        
        Parameters:
        - CustomerId: integer
          Customer ID
        - customerName: string
          CustomerName
        - documentaryCreditNumber: string
          Documentary Credit Number/ LC External Reference
        - elcAdvisingReference: string
          LC Advising Reference/ LC Internal Reference
        - elcInstrumentId: string
          Instrument ID
        - issueDate: string
          Issue Date
        - pageNum: integer
          pageNum
        - pageSize: integer
          pageSize
        - transactionId: integer
          Unique reference ID
        
        
        
        Headers:
        - Accesstoken: string
          Authorization Token to validation the caller
        - ChannelType: integer
          Channel identifier from where the TXN has originated (Internet, Mobile, ATM, Branch Channel )
        - co-Relationid: integer
          Unique ID for the service invoked, will be set by the TXN system
        - entity: string
          entity
        - initiatingSystem: string
          Indicating the initiated system
        - languageCode: integer
          languageCode
        - referenceId: string
          Place holder for Token based authentication
        - serviceMode: integer
          Used for branch channel to indicate the type of customer
        - userId: integer
          userId
        - uuidSeqNo: integer
          UUID Sequence Number
        
        
        """
        
        
        # Prepare query parameters
        params = {}
        if customerid is not None:
            params["CustomerId"] = customerid
            
        if customername is not None:
            params["customerName"] = customername
            
        if documentarycreditnumber is not None:
            params["documentaryCreditNumber"] = documentarycreditnumber
            
        if elcadvisingreference is not None:
            params["elcAdvisingReference"] = elcadvisingreference
            
        if elcinstrumentid is not None:
            params["elcInstrumentId"] = elcinstrumentid
            
        if issuedate is not None:
            params["issueDate"] = issuedate
            
        if pagenum is not None:
            params["pageNum"] = pagenum
            
        if pagesize is not None:
            params["pageSize"] = pagesize
            
        if transactionid is not None:
            params["transactionId"] = transactionid
            
        
        
        # Replace path parameters in URL
        path = "/tradeFinance/exportLetterOfCredit/amendment/detailedList"
        
        
        # Prepare headers
        headers = {}
        if accesstoken is not None:
            headers["Accesstoken"] = str(accesstoken)
        if channeltype is not None:
            headers["ChannelType"] = str(channeltype)
        if co_relationid is not None:
            headers["co-Relationid"] = str(co_relationid)
        if entity is not None:
            headers["entity"] = str(entity)
        if initiatingsystem is not None:
            headers["initiatingSystem"] = str(initiatingsystem)
        if languagecode is not None:
            headers["languageCode"] = str(languagecode)
        if referenceid is not None:
            headers["referenceId"] = str(referenceid)
        if servicemode is not None:
            headers["serviceMode"] = str(servicemode)
        if userid is not None:
            headers["userId"] = str(userid)
        if uuidseqno is not None:
            headers["uuidSeqNo"] = str(uuidseqno)
        
        
        return await make_api_request(
            "GET", 
            path, 
            
            params=params if params else None, 
            headers=headers if headers else None
        )
    
    
    
    @mcp.tool()
    async def elcbt7201_set_up_doc_dtls_amend_postusing_post(
        request_body:Dict[str, Any] ,  # SetupDocumentDetailsAmendRequest,
        accesstoken: Optional[str] = None,
        channeltype: Optional[int] = None,
        co_relationid: Optional[int] = None,
        entity: Optional[str] = None,
        initiatingsystem: Optional[str] = None,
        languagecode: Optional[int] = None,
        referenceid: Optional[str] = None,
        servicemode: Optional[int] = None,
        userid: Optional[int] = None,
        uuidseqno: Optional[int] = None
    ) -> Dict[str, Any]:
        """
        Setup Export LC Document Details Amend
        
        Generated from: POST /tradeFinance/exportLetterOfCredit/amendment/documentDetails/create
        Source: swagger_2_0
        Operation ID: ELCBT7201SetUpDocDtlsAmend_POSTUsingPOST
        
        
        Authentication: Not required
        
        Parameters:
        - request_body: any (required)
          input
        
        
        
        Headers:
        - Accesstoken: string
          Authorization Token to validation the caller
        - ChannelType: integer
          Channel identifier from where the TXN has originated (Internet, Mobile, ATM, Branch Channel )
        - co-Relationid: integer
          Unique ID for the service invoked, will be set by the TXN system
        - entity: string
          entity
        - initiatingSystem: string
          Indicating the initiated system
        - languageCode: integer
          languageCode
        - referenceId: string
          Place holder for Token based authentication
        - serviceMode: integer
          Used for branch channel to indicate the type of customer
        - userId: integer
          userId
        - uuidSeqNo: integer
          UUID Sequence Number
        
        
        """
        
        
        # Prepare request data
        
        # Single body parameter - send directly
        data = request_body if request_body is not None else {}
        
        
        
        # Prepare query parameters
        params = {}
        
        
        # Replace path parameters in URL
        path = "/tradeFinance/exportLetterOfCredit/amendment/documentDetails/create"
        
        
        # Prepare headers
        headers = {}
        if accesstoken is not None:
            headers["Accesstoken"] = str(accesstoken)
        if channeltype is not None:
            headers["ChannelType"] = str(channeltype)
        if co_relationid is not None:
            headers["co-Relationid"] = str(co_relationid)
        if entity is not None:
            headers["entity"] = str(entity)
        if initiatingsystem is not None:
            headers["initiatingSystem"] = str(initiatingsystem)
        if languagecode is not None:
            headers["languageCode"] = str(languagecode)
        if referenceid is not None:
            headers["referenceId"] = str(referenceid)
        if servicemode is not None:
            headers["serviceMode"] = str(servicemode)
        if userid is not None:
            headers["userId"] = str(userid)
        if uuidseqno is not None:
            headers["uuidSeqNo"] = str(uuidseqno)
        
        
        return await make_api_request(
            "POST", 
            path, 
            data=data, 
            params=params if params else None, 
            headers=headers if headers else None
        )
    
    
    
    @mcp.tool()
    async def elcet7202_fetch_doc_dtls_amend_postusing_get(
        elcreferenceexternal: str,
        pagenum: Optional[int] = None,
        pagesize: Optional[int] = None,
        accesstoken: Optional[str] = None,
        channeltype: Optional[int] = None,
        co_relationid: Optional[int] = None,
        entity: Optional[str] = None,
        initiatingsystem: Optional[str] = None,
        languagecode: Optional[int] = None,
        referenceid: Optional[str] = None,
        servicemode: Optional[int] = None,
        userid: Optional[int] = None,
        uuidseqno: Optional[int] = None
    ) -> Dict[str, Any]:
        """
        Fetch ELC Document Amend
        
        Generated from: GET /tradeFinance/exportLetterOfCredit/amendment/documentDetails/list/{elcReferenceExternal}
        Source: swagger_2_0
        Operation ID: ELCET7202FetchDocDtlsAmend_POSTUsingGET
        
        
        Authentication: Not required
        
        Parameters:
        - elcReferenceExternal: string (required)
          Elc Amend Reference External
        - pageNum: integer
          pageNum
        - pageSize: integer
          pageSize
        
        
        
        Headers:
        - Accesstoken: string
          Authorization Token to validation the caller
        - ChannelType: integer
          Channel identifier from where the TXN has originated (Internet, Mobile, ATM, Branch Channel )
        - co-Relationid: integer
          Unique ID for the service invoked, will be set by the TXN system
        - entity: string
          entity
        - initiatingSystem: string
          Indicating the initiated system
        - languageCode: integer
          languageCode
        - referenceId: string
          Place holder for Token based authentication
        - serviceMode: integer
          Used for branch channel to indicate the type of customer
        - userId: integer
          userId
        - uuidSeqNo: integer
          UUID Sequence Number
        
        
        """
        
        
        # Prepare query parameters
        params = {}
        if pagenum is not None:
            params["pageNum"] = pagenum
            
        if pagesize is not None:
            params["pageSize"] = pagesize
            
        
        
        # Replace path parameters in URL
        path = "/tradeFinance/exportLetterOfCredit/amendment/documentDetails/list/{elcReferenceExternal}"
        if elcreferenceexternal is not None:
            path = path.replace("{elcReferenceExternal}", str(elcreferenceexternal))
        
        
        # Prepare headers
        headers = {}
        if accesstoken is not None:
            headers["Accesstoken"] = str(accesstoken)
        if channeltype is not None:
            headers["ChannelType"] = str(channeltype)
        if co_relationid is not None:
            headers["co-Relationid"] = str(co_relationid)
        if entity is not None:
            headers["entity"] = str(entity)
        if initiatingsystem is not None:
            headers["initiatingSystem"] = str(initiatingsystem)
        if languagecode is not None:
            headers["languageCode"] = str(languagecode)
        if referenceid is not None:
            headers["referenceId"] = str(referenceid)
        if servicemode is not None:
            headers["serviceMode"] = str(servicemode)
        if userid is not None:
            headers["userId"] = str(userid)
        if uuidseqno is not None:
            headers["uuidSeqNo"] = str(uuidseqno)
        
        
        return await make_api_request(
            "GET", 
            path, 
            
            params=params if params else None, 
            headers=headers if headers else None
        )
    
    
    
    @mcp.tool()
    async def elcet7203_get_doc_dtls_amend_postusing_get(
        elcreferenceexternal: str,
        documentid: int,
        pagenum: Optional[int] = None,
        pagesize: Optional[int] = None,
        accesstoken: Optional[str] = None,
        channeltype: Optional[int] = None,
        co_relationid: Optional[int] = None,
        entity: Optional[str] = None,
        initiatingsystem: Optional[str] = None,
        languagecode: Optional[int] = None,
        referenceid: Optional[str] = None,
        servicemode: Optional[int] = None,
        userid: Optional[int] = None,
        uuidseqno: Optional[int] = None
    ) -> Dict[str, Any]:
        """
        View ELC Document Details Amend
        
        Generated from: GET /tradeFinance/exportLetterOfCredit/amendment/documentDetails/{elcReferenceExternal}/view
        Source: swagger_2_0
        Operation ID: ELCET7203GetDocDtlsAmend_POSTUsingGET
        
        
        Authentication: Not required
        
        Parameters:
        - documentID: integer (required)
          Document Id
        - elcReferenceExternal: string (required)
          Elc Amend Reference External
        - pageNum: integer
          pageNum
        - pageSize: integer
          pageSize
        
        
        
        Headers:
        - Accesstoken: string
          Authorization Token to validation the caller
        - ChannelType: integer
          Channel identifier from where the TXN has originated (Internet, Mobile, ATM, Branch Channel )
        - co-Relationid: integer
          Unique ID for the service invoked, will be set by the TXN system
        - entity: string
          entity
        - initiatingSystem: string
          Indicating the initiated system
        - languageCode: integer
          languageCode
        - referenceId: string
          Place holder for Token based authentication
        - serviceMode: integer
          Used for branch channel to indicate the type of customer
        - userId: integer
          userId
        - uuidSeqNo: integer
          UUID Sequence Number
        
        
        """
        
        
        # Prepare query parameters
        params = {}
        if documentid is not None:
            params["documentID"] = documentid
            
        if pagenum is not None:
            params["pageNum"] = pagenum
            
        if pagesize is not None:
            params["pageSize"] = pagesize
            
        
        
        # Replace path parameters in URL
        path = "/tradeFinance/exportLetterOfCredit/amendment/documentDetails/{elcReferenceExternal}/view"
        if elcreferenceexternal is not None:
            path = path.replace("{elcReferenceExternal}", str(elcreferenceexternal))
        
        
        # Prepare headers
        headers = {}
        if accesstoken is not None:
            headers["Accesstoken"] = str(accesstoken)
        if channeltype is not None:
            headers["ChannelType"] = str(channeltype)
        if co_relationid is not None:
            headers["co-Relationid"] = str(co_relationid)
        if entity is not None:
            headers["entity"] = str(entity)
        if initiatingsystem is not None:
            headers["initiatingSystem"] = str(initiatingsystem)
        if languagecode is not None:
            headers["languageCode"] = str(languagecode)
        if referenceid is not None:
            headers["referenceId"] = str(referenceid)
        if servicemode is not None:
            headers["serviceMode"] = str(servicemode)
        if userid is not None:
            headers["userId"] = str(userid)
        if uuidseqno is not None:
            headers["uuidSeqNo"] = str(uuidseqno)
        
        
        return await make_api_request(
            "GET", 
            path, 
            
            params=params if params else None, 
            headers=headers if headers else None
        )
    
    
    
    @mcp.tool()
    async def elcet9022_fetch_amend_elclist_postusing_get(
        amendlcrefexternal: Optional[str] = None,
        amendlcrefinternal: Optional[str] = None,
        amendmentdate: Optional[str] = None,
        amendmentnumber: Optional[str] = None,
        applicantname: Optional[str] = None,
        beneficiaryid: Optional[str] = None,
        dateofexpiry: Optional[str] = None,
        documentarycreditnumber: Optional[str] = None,
        elcadvisingreference: Optional[str] = None,
        elcamount: Optional[str] = None,
        elccurrency: Optional[str] = None,
        enddate: Optional[str] = None,
        entityid: Optional[str] = None,
        eventlegid: Optional[str] = None,
        modeoftransmission: Optional[str] = None,
        pagenum: Optional[int] = None,
        pagesize: Optional[int] = None,
        startdate: Optional[str] = None,
        status: Optional[str] = None,
        transactionid: Optional[str] = None,
        accesstoken: Optional[str] = None,
        channeltype: Optional[int] = None,
        co_relationid: Optional[int] = None,
        entity: Optional[str] = None,
        initiatingsystem: Optional[str] = None,
        languagecode: Optional[int] = None,
        referenceid: Optional[str] = None,
        servicemode: Optional[int] = None,
        userid: Optional[int] = None,
        uuidseqno: Optional[int] = None
    ) -> Dict[str, Any]:
        """
        Export LC Amend List
        
        Generated from: GET /tradeFinance/exportLetterOfCredit/amendment/list
        Source: swagger_2_0
        Operation ID: ELCET9022FetchAmendELCList_POSTUsingGET
        
        
        Authentication: Not required
        
        Parameters:
        - amendLCRefExternal: string
          Amendment Reference External
        - amendLCRefInternal: string
          LC Amend Advising Reference/ LC Amend Internal Reference
        - amendmentDate: string
          Amendment Date
        - amendmentNumber: string
          Amendment Number
        - applicantName: string
          Applicant Name
        - beneficiaryId: string
          Customer ID
        - dateOfExpiry: string
          Expiry Date
        - documentaryCreditNumber: string
          Documentary Credit Number/ LC External Reference
        - elcAdvisingReference: string
          LC Advising Reference/ LC Internal Reference
        - elcAmount: string
          Export LC Amount
        - elcCurrency: string
          Export LC Currency
        - endDate: string
          End Date
        - entityId: string
          Entity
        - eventLegId: string
          Event Leg Id
        - modeOfTransmission: string
          Mode of Transmission 1. Physical 2. Swift
        - pageNum: integer
          pageNum
        - pageSize: integer
          pageSize
        - startDate: string
          Start Date
        - status: string
          LC Amend Status - Possible values: OnHold -1 ,Released -2 ,Verified -3 ,Executed -4 ,Rejected -5 ,AmndmntInit -6, WaitingForRate-7 , Accepted- 8 , AmndmntSent- 9 , AcptRefPndng- 10 , AcptRefVerified-11, Refused 12
        - transactionId: string
          Transaction ID
        
        
        
        Headers:
        - Accesstoken: string
          Authorization Token to validation the caller
        - ChannelType: integer
          Channel identifier from where the TXN has originated (Internet, Mobile, ATM, Branch Channel )
        - co-Relationid: integer
          Unique ID for the service invoked, will be set by the TXN system
        - entity: string
          entity
        - initiatingSystem: string
          Indicating the initiated system
        - languageCode: integer
          languageCode
        - referenceId: string
          Place holder for Token based authentication
        - serviceMode: integer
          Used for branch channel to indicate the type of customer
        - userId: integer
          userId
        - uuidSeqNo: integer
          UUID Sequence Number
        
        
        """
        
        
        # Prepare query parameters
        params = {}
        if amendlcrefexternal is not None:
            params["amendLCRefExternal"] = amendlcrefexternal
            
        if amendlcrefinternal is not None:
            params["amendLCRefInternal"] = amendlcrefinternal
            
        if amendmentdate is not None:
            params["amendmentDate"] = amendmentdate
            
        if amendmentnumber is not None:
            params["amendmentNumber"] = amendmentnumber
            
        if applicantname is not None:
            params["applicantName"] = applicantname
            
        if beneficiaryid is not None:
            params["beneficiaryId"] = beneficiaryid
            
        if dateofexpiry is not None:
            params["dateOfExpiry"] = dateofexpiry
            
        if documentarycreditnumber is not None:
            params["documentaryCreditNumber"] = documentarycreditnumber
            
        if elcadvisingreference is not None:
            params["elcAdvisingReference"] = elcadvisingreference
            
        if elcamount is not None:
            params["elcAmount"] = elcamount
            
        if elccurrency is not None:
            params["elcCurrency"] = elccurrency
            
        if enddate is not None:
            params["endDate"] = enddate
            
        if entityid is not None:
            params["entityId"] = entityid
            
        if eventlegid is not None:
            params["eventLegId"] = eventlegid
            
        if modeoftransmission is not None:
            params["modeOfTransmission"] = modeoftransmission
            
        if pagenum is not None:
            params["pageNum"] = pagenum
            
        if pagesize is not None:
            params["pageSize"] = pagesize
            
        if startdate is not None:
            params["startDate"] = startdate
            
        if status is not None:
            params["status"] = status
            
        if transactionid is not None:
            params["transactionId"] = transactionid
            
        
        
        # Replace path parameters in URL
        path = "/tradeFinance/exportLetterOfCredit/amendment/list"
        
        
        # Prepare headers
        headers = {}
        if accesstoken is not None:
            headers["Accesstoken"] = str(accesstoken)
        if channeltype is not None:
            headers["ChannelType"] = str(channeltype)
        if co_relationid is not None:
            headers["co-Relationid"] = str(co_relationid)
        if entity is not None:
            headers["entity"] = str(entity)
        if initiatingsystem is not None:
            headers["initiatingSystem"] = str(initiatingsystem)
        if languagecode is not None:
            headers["languageCode"] = str(languagecode)
        if referenceid is not None:
            headers["referenceId"] = str(referenceid)
        if servicemode is not None:
            headers["serviceMode"] = str(servicemode)
        if userid is not None:
            headers["userId"] = str(userid)
        if uuidseqno is not None:
            headers["uuidSeqNo"] = str(uuidseqno)
        
        
        return await make_api_request(
            "GET", 
            path, 
            
            params=params if params else None, 
            headers=headers if headers else None
        )
    
    
    
    @mcp.tool()
    async def elcbt9002_elcamend_on_hold_to_on_hold_postusing_post(
        request_body:Dict[str, Any] ,  # ElcAmendmentModifyOnHoldRequest,
        accesstoken: Optional[str] = None,
        channeltype: Optional[int] = None,
        co_relationid: Optional[int] = None,
        entity: Optional[str] = None,
        initiatingsystem: Optional[str] = None,
        languagecode: Optional[int] = None,
        referenceid: Optional[str] = None,
        servicemode: Optional[int] = None,
        userid: Optional[int] = None,
        uuidseqno: Optional[int] = None
    ) -> Dict[str, Any]:
        """
        Modify Export LC Amendment OnHold
        
        Generated from: POST /tradeFinance/exportLetterOfCredit/amendment/modifyOnHold
        Source: swagger_2_0
        Operation ID: ELCBT9002ELCAmendOnHoldToOnHold_POSTUsingPOST
        
        
        Authentication: Not required
        
        Parameters:
        - request_body: any (required)
          input
        
        
        
        Headers:
        - Accesstoken: string
          Authorization Token to validation the caller
        - ChannelType: integer
          Channel identifier from where the TXN has originated (Internet, Mobile, ATM, Branch Channel )
        - co-Relationid: integer
          Unique ID for the service invoked, will be set by the TXN system
        - entity: string
          entity
        - initiatingSystem: string
          Indicating the initiated system
        - languageCode: integer
          languageCode
        - referenceId: string
          Place holder for Token based authentication
        - serviceMode: integer
          Used for branch channel to indicate the type of customer
        - userId: integer
          userId
        - uuidSeqNo: integer
          UUID Sequence Number
        
        
        """
        
        
        # Prepare request data
        
        # Single body parameter - send directly
        data = request_body if request_body is not None else {}
        
        
        
        # Prepare query parameters
        params = {}
        
        
        # Replace path parameters in URL
        path = "/tradeFinance/exportLetterOfCredit/amendment/modifyOnHold"
        
        
        # Prepare headers
        headers = {}
        if accesstoken is not None:
            headers["Accesstoken"] = str(accesstoken)
        if channeltype is not None:
            headers["ChannelType"] = str(channeltype)
        if co_relationid is not None:
            headers["co-Relationid"] = str(co_relationid)
        if entity is not None:
            headers["entity"] = str(entity)
        if initiatingsystem is not None:
            headers["initiatingSystem"] = str(initiatingsystem)
        if languagecode is not None:
            headers["languageCode"] = str(languagecode)
        if referenceid is not None:
            headers["referenceId"] = str(referenceid)
        if servicemode is not None:
            headers["serviceMode"] = str(servicemode)
        if userid is not None:
            headers["userId"] = str(userid)
        if uuidseqno is not None:
            headers["uuidSeqNo"] = str(uuidseqno)
        
        
        return await make_api_request(
            "POST", 
            path, 
            data=data, 
            params=params if params else None, 
            headers=headers if headers else None
        )
    
    
    
    @mcp.tool()
    async def elcbt9003_elcamend_on_hold_to_released_postusing_post(
        request_body:Dict[str, Any] ,  # ElcAmendmentReleaseRequest,
        accesstoken: Optional[str] = None,
        channeltype: Optional[int] = None,
        co_relationid: Optional[int] = None,
        entity: Optional[str] = None,
        initiatingsystem: Optional[str] = None,
        languagecode: Optional[int] = None,
        referenceid: Optional[str] = None,
        servicemode: Optional[int] = None,
        userid: Optional[int] = None,
        uuidseqno: Optional[int] = None
    ) -> Dict[str, Any]:
        """
        Release Export LC Amendment
        
        Generated from: POST /tradeFinance/exportLetterOfCredit/amendment/release
        Source: swagger_2_0
        Operation ID: ELCBT9003ELCAmendOnHoldToReleased_POSTUsingPOST
        
        
        Authentication: Not required
        
        Parameters:
        - request_body: any (required)
          input
        
        
        
        Headers:
        - Accesstoken: string
          Authorization Token to validation the caller
        - ChannelType: integer
          Channel identifier from where the TXN has originated (Internet, Mobile, ATM, Branch Channel )
        - co-Relationid: integer
          Unique ID for the service invoked, will be set by the TXN system
        - entity: string
          entity
        - initiatingSystem: string
          Indicating the initiated system
        - languageCode: integer
          languageCode
        - referenceId: string
          Place holder for Token based authentication
        - serviceMode: integer
          Used for branch channel to indicate the type of customer
        - userId: integer
          userId
        - uuidSeqNo: integer
          UUID Sequence Number
        
        
        """
        
        
        # Prepare request data
        
        # Single body parameter - send directly
        data = request_body if request_body is not None else {}
        
        
        
        # Prepare query parameters
        params = {}
        
        
        # Replace path parameters in URL
        path = "/tradeFinance/exportLetterOfCredit/amendment/release"
        
        
        # Prepare headers
        headers = {}
        if accesstoken is not None:
            headers["Accesstoken"] = str(accesstoken)
        if channeltype is not None:
            headers["ChannelType"] = str(channeltype)
        if co_relationid is not None:
            headers["co-Relationid"] = str(co_relationid)
        if entity is not None:
            headers["entity"] = str(entity)
        if initiatingsystem is not None:
            headers["initiatingSystem"] = str(initiatingsystem)
        if languagecode is not None:
            headers["languageCode"] = str(languagecode)
        if referenceid is not None:
            headers["referenceId"] = str(referenceid)
        if servicemode is not None:
            headers["serviceMode"] = str(servicemode)
        if userid is not None:
            headers["userId"] = str(userid)
        if uuidseqno is not None:
            headers["uuidSeqNo"] = str(uuidseqno)
        
        
        return await make_api_request(
            "POST", 
            path, 
            data=data, 
            params=params if params else None, 
            headers=headers if headers else None
        )
    
    
    
    @mcp.tool()
    async def elcbt9006_elcamend_rlsd_to_verified_postusing_post(
        request_body:Dict[str, Any] ,  # ElcAmendmentVerifyRequest,
        accesstoken: Optional[str] = None,
        channeltype: Optional[int] = None,
        co_relationid: Optional[int] = None,
        entity: Optional[str] = None,
        initiatingsystem: Optional[str] = None,
        languagecode: Optional[int] = None,
        referenceid: Optional[str] = None,
        servicemode: Optional[int] = None,
        userid: Optional[int] = None,
        uuidseqno: Optional[int] = None
    ) -> Dict[str, Any]:
        """
        Verify Export LC Amendment
        
        Generated from: POST /tradeFinance/exportLetterOfCredit/amendment/verify
        Source: swagger_2_0
        Operation ID: ELCBT9006ELCAmendRlsdToVerified_POSTUsingPOST
        
        
        Authentication: Not required
        
        Parameters:
        - request_body: any (required)
          input
        
        
        
        Headers:
        - Accesstoken: string
          Authorization Token to validation the caller
        - ChannelType: integer
          Channel identifier from where the TXN has originated (Internet, Mobile, ATM, Branch Channel )
        - co-Relationid: integer
          Unique ID for the service invoked, will be set by the TXN system
        - entity: string
          entity
        - initiatingSystem: string
          Indicating the initiated system
        - languageCode: integer
          languageCode
        - referenceId: string
          Place holder for Token based authentication
        - serviceMode: integer
          Used for branch channel to indicate the type of customer
        - userId: integer
          userId
        - uuidSeqNo: integer
          UUID Sequence Number
        
        
        """
        
        
        # Prepare request data
        
        # Single body parameter - send directly
        data = request_body if request_body is not None else {}
        
        
        
        # Prepare query parameters
        params = {}
        
        
        # Replace path parameters in URL
        path = "/tradeFinance/exportLetterOfCredit/amendment/verify"
        
        
        # Prepare headers
        headers = {}
        if accesstoken is not None:
            headers["Accesstoken"] = str(accesstoken)
        if channeltype is not None:
            headers["ChannelType"] = str(channeltype)
        if co_relationid is not None:
            headers["co-Relationid"] = str(co_relationid)
        if entity is not None:
            headers["entity"] = str(entity)
        if initiatingsystem is not None:
            headers["initiatingSystem"] = str(initiatingsystem)
        if languagecode is not None:
            headers["languageCode"] = str(languagecode)
        if referenceid is not None:
            headers["referenceId"] = str(referenceid)
        if servicemode is not None:
            headers["serviceMode"] = str(servicemode)
        if userid is not None:
            headers["userId"] = str(userid)
        if uuidseqno is not None:
            headers["uuidSeqNo"] = str(uuidseqno)
        
        
        return await make_api_request(
            "POST", 
            path, 
            data=data, 
            params=params if params else None, 
            headers=headers if headers else None
        )
    
    
    
    @mcp.tool()
    async def elcet9013_get_elcamend_dtls_postusing_get(
        elcadvisingreference: str,
        eventlegid: int,
        accesstoken: Optional[str] = None,
        channeltype: Optional[int] = None,
        co_relationid: Optional[int] = None,
        entity: Optional[str] = None,
        initiatingsystem: Optional[str] = None,
        languagecode: Optional[int] = None,
        referenceid: Optional[str] = None,
        servicemode: Optional[int] = None,
        userid: Optional[int] = None,
        uuidseqno: Optional[int] = None
    ) -> Dict[str, Any]:
        """
        Export LC Amend Details
        
        Generated from: GET /tradeFinance/exportLetterOfCredit/amendment/{elcAdvisingReference}
        Source: swagger_2_0
        Operation ID: ELCET9013GetELCAmendDtls_POSTUsingGET
        
        
        Authentication: Not required
        
        Parameters:
        - elcAdvisingReference: string (required)
          Export LC Advising Reference
        - eventLegId: integer (required)
          Amendment Sequence Number
        
        
        
        Headers:
        - Accesstoken: string
          Authorization Token to validation the caller
        - ChannelType: integer
          Channel identifier from where the TXN has originated (Internet, Mobile, ATM, Branch Channel )
        - co-Relationid: integer
          Unique ID for the service invoked, will be set by the TXN system
        - entity: string
          entity
        - initiatingSystem: string
          Indicating the initiated system
        - languageCode: integer
          languageCode
        - referenceId: string
          Place holder for Token based authentication
        - serviceMode: integer
          Used for branch channel to indicate the type of customer
        - userId: integer
          userId
        - uuidSeqNo: integer
          UUID Sequence Number
        
        
        """
        
        
        # Prepare query parameters
        params = {}
        if eventlegid is not None:
            params["eventLegId"] = eventlegid
            
        
        
        # Replace path parameters in URL
        path = "/tradeFinance/exportLetterOfCredit/amendment/{elcAdvisingReference}"
        if elcadvisingreference is not None:
            path = path.replace("{elcAdvisingReference}", str(elcadvisingreference))
        
        
        # Prepare headers
        headers = {}
        if accesstoken is not None:
            headers["Accesstoken"] = str(accesstoken)
        if channeltype is not None:
            headers["ChannelType"] = str(channeltype)
        if co_relationid is not None:
            headers["co-Relationid"] = str(co_relationid)
        if entity is not None:
            headers["entity"] = str(entity)
        if initiatingsystem is not None:
            headers["initiatingSystem"] = str(initiatingsystem)
        if languagecode is not None:
            headers["languageCode"] = str(languagecode)
        if referenceid is not None:
            headers["referenceId"] = str(referenceid)
        if servicemode is not None:
            headers["serviceMode"] = str(servicemode)
        if userid is not None:
            headers["userId"] = str(userid)
        if uuidseqno is not None:
            headers["uuidSeqNo"] = str(uuidseqno)
        
        
        return await make_api_request(
            "GET", 
            path, 
            
            params=params if params else None, 
            headers=headers if headers else None
        )
    
    
    
    @mcp.tool()
    async def elcbt3001_crt_blpay_on_hold_postusing_post(
        request_body:Dict[str, Any] ,  # ElcBillPaymentOnHoldRequest,
        accesstoken: Optional[str] = None,
        channeltype: Optional[int] = None,
        co_relationid: Optional[int] = None,
        entity: Optional[str] = None,
        initiatingsystem: Optional[str] = None,
        languagecode: Optional[int] = None,
        referenceid: Optional[str] = None,
        requesthash: Optional[str] = None,
        servicemode: Optional[int] = None,
        userid: Optional[int] = None,
        uuidseqno: Optional[int] = None
    ) -> Dict[str, Any]:
        """
        Export Bill Payment Onhold
        
        Generated from: POST /tradeFinance/exportLetterOfCredit/billPayment
        Source: swagger_2_0
        Operation ID: ELCBT3001CrtBLPayOnHold_POSTUsingPOST
        
        
        Authentication: Not required
        
        Parameters:
        - request_body: any (required)
          input
        
        
        
        Headers:
        - Accesstoken: string
          Authorization Token to validation the caller
        - ChannelType: integer
          Channel identifier from where the TXN has originated (Internet, Mobile, ATM, Branch Channel )
        - co-Relationid: integer
          Unique ID for the service invoked, will be set by the TXN system
        - entity: string
          entity
        - initiatingSystem: string
          Indicating the initiated system
        - languageCode: integer
          languageCode
        - referenceId: string
          Place holder for Token based authentication
        - requesthash: string
          Request payload for hash validation
        - serviceMode: integer
          Used for branch channel to indicate the type of customer
        - userId: integer
          userId
        - uuidSeqNo: integer
          UUID Sequence Number
        
        
        """
        
        
        # Prepare request data
        
        # Single body parameter - send directly
        data = request_body if request_body is not None else {}
        
        
        
        # Prepare query parameters
        params = {}
        
        
        # Replace path parameters in URL
        path = "/tradeFinance/exportLetterOfCredit/billPayment"
        
        
        # Prepare headers
        headers = {}
        if accesstoken is not None:
            headers["Accesstoken"] = str(accesstoken)
        if channeltype is not None:
            headers["ChannelType"] = str(channeltype)
        if co_relationid is not None:
            headers["co-Relationid"] = str(co_relationid)
        if entity is not None:
            headers["entity"] = str(entity)
        if initiatingsystem is not None:
            headers["initiatingSystem"] = str(initiatingsystem)
        if languagecode is not None:
            headers["languageCode"] = str(languagecode)
        if referenceid is not None:
            headers["referenceId"] = str(referenceid)
        if requesthash is not None:
            headers["requesthash"] = str(requesthash)
        if servicemode is not None:
            headers["serviceMode"] = str(servicemode)
        if userid is not None:
            headers["userId"] = str(userid)
        if uuidseqno is not None:
            headers["uuidSeqNo"] = str(uuidseqno)
        
        
        return await make_api_request(
            "POST", 
            path, 
            data=data, 
            params=params if params else None, 
            headers=headers if headers else None
        )
    
    
    
    @mcp.tool()
    async def elcbt3005_blpay_rlsd_to_exec_postusing_post(
        request_body:Dict[str, Any] ,  # ElcBillPaymentAuthRequest,
        accesstoken: Optional[str] = None,
        channeltype: Optional[int] = None,
        co_relationid: Optional[int] = None,
        entity: Optional[str] = None,
        initiatingsystem: Optional[str] = None,
        languagecode: Optional[int] = None,
        mu_id: Optional[str] = None,
        referenceid: Optional[str] = None,
        requesthash: Optional[str] = None,
        servicemode: Optional[int] = None,
        userid: Optional[int] = None,
        uuidseqno: Optional[int] = None
    ) -> Dict[str, Any]:
        """
        Export Bill Payment Authorization
        
        Generated from: POST /tradeFinance/exportLetterOfCredit/billPayment/auth
        Source: swagger_2_0
        Operation ID: ELCBT3005BLPayRlsdToExec_POSTUsingPOST
        
        
        Authentication: Not required
        
        Parameters:
        - request_body: any (required)
          input
        
        
        
        Headers:
        - Accesstoken: string
          Authorization Token to validation the caller
        - ChannelType: integer
          Channel identifier from where the TXN has originated (Internet, Mobile, ATM, Branch Channel )
        - co-Relationid: integer
          Unique ID for the service invoked, will be set by the TXN system
        - entity: string
          entity
        - initiatingSystem: string
          Indicating the initiated system
        - languageCode: integer
          languageCode
        - mu_Id: string
          Muid
        - referenceId: string
          Place holder for Token based authentication
        - requesthash: string
          Request payload for hash validation
        - serviceMode: integer
          Used for branch channel to indicate the type of customer
        - userId: integer
          userId
        - uuidSeqNo: integer
          UUID Sequence Number
        
        
        """
        
        
        # Prepare request data
        
        # Single body parameter - send directly
        data = request_body if request_body is not None else {}
        
        
        
        # Prepare query parameters
        params = {}
        
        
        # Replace path parameters in URL
        path = "/tradeFinance/exportLetterOfCredit/billPayment/auth"
        
        
        # Prepare headers
        headers = {}
        if accesstoken is not None:
            headers["Accesstoken"] = str(accesstoken)
        if channeltype is not None:
            headers["ChannelType"] = str(channeltype)
        if co_relationid is not None:
            headers["co-Relationid"] = str(co_relationid)
        if entity is not None:
            headers["entity"] = str(entity)
        if initiatingsystem is not None:
            headers["initiatingSystem"] = str(initiatingsystem)
        if languagecode is not None:
            headers["languageCode"] = str(languagecode)
        if mu_id is not None:
            headers["mu_Id"] = str(mu_id)
        if referenceid is not None:
            headers["referenceId"] = str(referenceid)
        if requesthash is not None:
            headers["requesthash"] = str(requesthash)
        if servicemode is not None:
            headers["serviceMode"] = str(servicemode)
        if userid is not None:
            headers["userId"] = str(userid)
        if uuidseqno is not None:
            headers["uuidSeqNo"] = str(uuidseqno)
        
        
        return await make_api_request(
            "POST", 
            path, 
            data=data, 
            params=params if params else None, 
            headers=headers if headers else None
        )
    
    
    
    @mcp.tool()
    async def elcet3028_fetch_blpay_list_postusing_get(
        billpaymentreference: Optional[str] = None,
        billpaytransactionid: Optional[str] = None,
        customerid: Optional[str] = None,
        customername: Optional[str] = None,
        elcstartdate: Optional[str] = None,
        enddate: Optional[str] = None,
        lcreferenceinternal: Optional[str] = None,
        netamountpay: Optional[str] = None,
        pagenum: Optional[int] = None,
        pagesize: Optional[int] = None,
        paycurrency: Optional[str] = None,
        paydate: Optional[str] = None,
        raterequeststatus: Optional[int] = None,
        status: Optional[str] = None,
        accesstoken: Optional[str] = None,
        channeltype: Optional[int] = None,
        co_relationid: Optional[int] = None,
        entity: Optional[str] = None,
        initiatingsystem: Optional[str] = None,
        languagecode: Optional[int] = None,
        referenceid: Optional[str] = None,
        servicemode: Optional[int] = None,
        userid: Optional[int] = None,
        uuidseqno: Optional[int] = None
    ) -> Dict[str, Any]:
        """
        Export Bill Payment List
        
        Generated from: GET /tradeFinance/exportLetterOfCredit/billPayment/list
        Source: swagger_2_0
        Operation ID: ELCET3028FetchBLPayList_POSTUsingGET
        
        
        Authentication: Not required
        
        Parameters:
        - BillPaymentReference: string
          Bill Payment Reference
        - billPayTransactionId: string
          Unique reference ID
        - customerId: string
          Customer ID
        - customerName: string
          Customer Name
        - elcStartDate: string
          Start Date
        - endDate: string
          End Date
        - lcReferenceInternal: string
          Export Letter of Credit Adivising Reference
        - netAmountPay: string
          Bill Amount
        - pageNum: integer
          pageNum
        - pageSize: integer
          pageSize
        - payCurrency: string
          Bill Currency
        - payDate: string
          Maturity Date
        - rateRequestStatus: integer
          Rate Request Status
        - status: string
          Letter of Credit Status - Available status supported in system: 1 - OnHold,2 - Released,3 - Verified,5 - Executed,4 - Rejected,6 -Settled. For All Available Status Reference er d_TFBlPayStat
        
        
        
        Headers:
        - Accesstoken: string
          Authorization Token to validation the caller
        - ChannelType: integer
          Channel identifier from where the TXN has originated (Internet, Mobile, ATM, Branch Channel )
        - co-Relationid: integer
          Unique ID for the service invoked, will be set by the TXN system
        - entity: string
          entity
        - initiatingSystem: string
          Indicating the initiated system
        - languageCode: integer
          languageCode
        - referenceId: string
          Place holder for Token based authentication
        - serviceMode: integer
          Used for branch channel to indicate the type of customer
        - userId: integer
          userId
        - uuidSeqNo: integer
          UUID Sequence Number
        
        
        """
        
        
        # Prepare query parameters
        params = {}
        if billpaymentreference is not None:
            params["BillPaymentReference"] = billpaymentreference
            
        if billpaytransactionid is not None:
            params["billPayTransactionId"] = billpaytransactionid
            
        if customerid is not None:
            params["customerId"] = customerid
            
        if customername is not None:
            params["customerName"] = customername
            
        if elcstartdate is not None:
            params["elcStartDate"] = elcstartdate
            
        if enddate is not None:
            params["endDate"] = enddate
            
        if lcreferenceinternal is not None:
            params["lcReferenceInternal"] = lcreferenceinternal
            
        if netamountpay is not None:
            params["netAmountPay"] = netamountpay
            
        if pagenum is not None:
            params["pageNum"] = pagenum
            
        if pagesize is not None:
            params["pageSize"] = pagesize
            
        if paycurrency is not None:
            params["payCurrency"] = paycurrency
            
        if paydate is not None:
            params["payDate"] = paydate
            
        if raterequeststatus is not None:
            params["rateRequestStatus"] = raterequeststatus
            
        if status is not None:
            params["status"] = status
            
        
        
        # Replace path parameters in URL
        path = "/tradeFinance/exportLetterOfCredit/billPayment/list"
        
        
        # Prepare headers
        headers = {}
        if accesstoken is not None:
            headers["Accesstoken"] = str(accesstoken)
        if channeltype is not None:
            headers["ChannelType"] = str(channeltype)
        if co_relationid is not None:
            headers["co-Relationid"] = str(co_relationid)
        if entity is not None:
            headers["entity"] = str(entity)
        if initiatingsystem is not None:
            headers["initiatingSystem"] = str(initiatingsystem)
        if languagecode is not None:
            headers["languageCode"] = str(languagecode)
        if referenceid is not None:
            headers["referenceId"] = str(referenceid)
        if servicemode is not None:
            headers["serviceMode"] = str(servicemode)
        if userid is not None:
            headers["userId"] = str(userid)
        if uuidseqno is not None:
            headers["uuidSeqNo"] = str(uuidseqno)
        
        
        return await make_api_request(
            "GET", 
            path, 
            
            params=params if params else None, 
            headers=headers if headers else None
        )
    
    
    
    @mcp.tool()
    async def elcbt3002_blpay_on_hold_to_on_hold_postusing_post(
        request_body:Dict[str, Any] ,  # ElcBillPaymentOnholdToOnholdRequest,
        accesstoken: Optional[str] = None,
        channeltype: Optional[int] = None,
        co_relationid: Optional[int] = None,
        entity: Optional[str] = None,
        initiatingsystem: Optional[str] = None,
        languagecode: Optional[int] = None,
        referenceid: Optional[str] = None,
        requesthash: Optional[str] = None,
        servicemode: Optional[int] = None,
        userid: Optional[int] = None,
        uuidseqno: Optional[int] = None
    ) -> Dict[str, Any]:
        """
        Export Bill Payment Onhold to Onhold
        
        Generated from: POST /tradeFinance/exportLetterOfCredit/billPayment/modifyOnholdToOnhold
        Source: swagger_2_0
        Operation ID: ELCBT3002BLPayOnHoldToOnHold_POSTUsingPOST
        
        
        Authentication: Not required
        
        Parameters:
        - request_body: any (required)
          input
        
        
        
        Headers:
        - Accesstoken: string
          Authorization Token to validation the caller
        - ChannelType: integer
          Channel identifier from where the TXN has originated (Internet, Mobile, ATM, Branch Channel )
        - co-Relationid: integer
          Unique ID for the service invoked, will be set by the TXN system
        - entity: string
          entity
        - initiatingSystem: string
          Indicating the initiated system
        - languageCode: integer
          languageCode
        - referenceId: string
          Place holder for Token based authentication
        - requesthash: string
          Request payload for hash validation
        - serviceMode: integer
          Used for branch channel to indicate the type of customer
        - userId: integer
          userId
        - uuidSeqNo: integer
          UUID Sequence Number
        
        
        """
        
        
        # Prepare request data
        
        # Single body parameter - send directly
        data = request_body if request_body is not None else {}
        
        
        
        # Prepare query parameters
        params = {}
        
        
        # Replace path parameters in URL
        path = "/tradeFinance/exportLetterOfCredit/billPayment/modifyOnholdToOnhold"
        
        
        # Prepare headers
        headers = {}
        if accesstoken is not None:
            headers["Accesstoken"] = str(accesstoken)
        if channeltype is not None:
            headers["ChannelType"] = str(channeltype)
        if co_relationid is not None:
            headers["co-Relationid"] = str(co_relationid)
        if entity is not None:
            headers["entity"] = str(entity)
        if initiatingsystem is not None:
            headers["initiatingSystem"] = str(initiatingsystem)
        if languagecode is not None:
            headers["languageCode"] = str(languagecode)
        if referenceid is not None:
            headers["referenceId"] = str(referenceid)
        if requesthash is not None:
            headers["requesthash"] = str(requesthash)
        if servicemode is not None:
            headers["serviceMode"] = str(servicemode)
        if userid is not None:
            headers["userId"] = str(userid)
        if uuidseqno is not None:
            headers["uuidSeqNo"] = str(uuidseqno)
        
        
        return await make_api_request(
            "POST", 
            path, 
            data=data, 
            params=params if params else None, 
            headers=headers if headers else None
        )
    
    
    
    @mcp.tool()
    async def elcbt3004_blpay_on_hold_to_rjct_postusing_post(
        request_body:Dict[str, Any] ,  # ElcBillPaymentOnHoldToRejectRequest,
        accesstoken: Optional[str] = None,
        channeltype: Optional[int] = None,
        co_relationid: Optional[int] = None,
        entity: Optional[str] = None,
        initiatingsystem: Optional[str] = None,
        languagecode: Optional[int] = None,
        referenceid: Optional[str] = None,
        requesthash: Optional[str] = None,
        servicemode: Optional[int] = None,
        userid: Optional[int] = None,
        uuidseqno: Optional[int] = None
    ) -> Dict[str, Any]:
        """
        Export Bill Payment OnHold to reject
        
        Generated from: POST /tradeFinance/exportLetterOfCredit/billPayment/onholdToReject
        Source: swagger_2_0
        Operation ID: ELCBT3004BLPayOnHoldToRjct_POSTUsingPOST
        
        
        Authentication: Not required
        
        Parameters:
        - request_body: any (required)
          input
        
        
        
        Headers:
        - Accesstoken: string
          Authorization Token to validation the caller
        - ChannelType: integer
          Channel identifier from where the TXN has originated (Internet, Mobile, ATM, Branch Channel )
        - co-Relationid: integer
          Unique ID for the service invoked, will be set by the TXN system
        - entity: string
          entity
        - initiatingSystem: string
          Indicating the initiated system
        - languageCode: integer
          languageCode
        - referenceId: string
          Place holder for Token based authentication
        - requesthash: string
          Request payload for hash validation
        - serviceMode: integer
          Used for branch channel to indicate the type of customer
        - userId: integer
          userId
        - uuidSeqNo: integer
          UUID Sequence Number
        
        
        """
        
        
        # Prepare request data
        
        # Single body parameter - send directly
        data = request_body if request_body is not None else {}
        
        
        
        # Prepare query parameters
        params = {}
        
        
        # Replace path parameters in URL
        path = "/tradeFinance/exportLetterOfCredit/billPayment/onholdToReject"
        
        
        # Prepare headers
        headers = {}
        if accesstoken is not None:
            headers["Accesstoken"] = str(accesstoken)
        if channeltype is not None:
            headers["ChannelType"] = str(channeltype)
        if co_relationid is not None:
            headers["co-Relationid"] = str(co_relationid)
        if entity is not None:
            headers["entity"] = str(entity)
        if initiatingsystem is not None:
            headers["initiatingSystem"] = str(initiatingsystem)
        if languagecode is not None:
            headers["languageCode"] = str(languagecode)
        if referenceid is not None:
            headers["referenceId"] = str(referenceid)
        if requesthash is not None:
            headers["requesthash"] = str(requesthash)
        if servicemode is not None:
            headers["serviceMode"] = str(servicemode)
        if userid is not None:
            headers["userId"] = str(userid)
        if uuidseqno is not None:
            headers["uuidSeqNo"] = str(uuidseqno)
        
        
        return await make_api_request(
            "POST", 
            path, 
            data=data, 
            params=params if params else None, 
            headers=headers if headers else None
        )
    
    
    
    @mcp.tool()
    async def elcbt3003_blpay_on_hold_to_released_postusing_post(
        request_body:Dict[str, Any] ,  # ElcBillPaymentReleaseRequest,
        accesstoken: Optional[str] = None,
        channeltype: Optional[int] = None,
        co_relationid: Optional[int] = None,
        entity: Optional[str] = None,
        initiatingsystem: Optional[str] = None,
        languagecode: Optional[int] = None,
        referenceid: Optional[str] = None,
        requesthash: Optional[str] = None,
        servicemode: Optional[int] = None,
        userid: Optional[int] = None,
        uuidseqno: Optional[int] = None
    ) -> Dict[str, Any]:
        """
        Export Bill Payment Release
        
        Generated from: POST /tradeFinance/exportLetterOfCredit/billPayment/release
        Source: swagger_2_0
        Operation ID: ELCBT3003BLPayOnHoldToReleased_POSTUsingPOST
        
        
        Authentication: Not required
        
        Parameters:
        - request_body: any (required)
          input
        
        
        
        Headers:
        - Accesstoken: string
          Authorization Token to validation the caller
        - ChannelType: integer
          Channel identifier from where the TXN has originated (Internet, Mobile, ATM, Branch Channel )
        - co-Relationid: integer
          Unique ID for the service invoked, will be set by the TXN system
        - entity: string
          entity
        - initiatingSystem: string
          Indicating the initiated system
        - languageCode: integer
          languageCode
        - referenceId: string
          Place holder for Token based authentication
        - requesthash: string
          Request payload for hash validation
        - serviceMode: integer
          Used for branch channel to indicate the type of customer
        - userId: integer
          userId
        - uuidSeqNo: integer
          UUID Sequence Number
        
        
        """
        
        
        # Prepare request data
        
        # Single body parameter - send directly
        data = request_body if request_body is not None else {}
        
        
        
        # Prepare query parameters
        params = {}
        
        
        # Replace path parameters in URL
        path = "/tradeFinance/exportLetterOfCredit/billPayment/release"
        
        
        # Prepare headers
        headers = {}
        if accesstoken is not None:
            headers["Accesstoken"] = str(accesstoken)
        if channeltype is not None:
            headers["ChannelType"] = str(channeltype)
        if co_relationid is not None:
            headers["co-Relationid"] = str(co_relationid)
        if entity is not None:
            headers["entity"] = str(entity)
        if initiatingsystem is not None:
            headers["initiatingSystem"] = str(initiatingsystem)
        if languagecode is not None:
            headers["languageCode"] = str(languagecode)
        if referenceid is not None:
            headers["referenceId"] = str(referenceid)
        if requesthash is not None:
            headers["requesthash"] = str(requesthash)
        if servicemode is not None:
            headers["serviceMode"] = str(servicemode)
        if userid is not None:
            headers["userId"] = str(userid)
        if uuidseqno is not None:
            headers["uuidSeqNo"] = str(uuidseqno)
        
        
        return await make_api_request(
            "POST", 
            path, 
            data=data, 
            params=params if params else None, 
            headers=headers if headers else None
        )
    
    
    
    @mcp.tool()
    async def elcbt3007_blpay_rlsd_to_on_hold_postusing_post(
        request_body:Dict[str, Any] ,  # ElcBillPaymentReleasetoOnHoldRequest,
        accesstoken: Optional[str] = None,
        channeltype: Optional[int] = None,
        co_relationid: Optional[int] = None,
        entity: Optional[str] = None,
        initiatingsystem: Optional[str] = None,
        languagecode: Optional[int] = None,
        referenceid: Optional[str] = None,
        requesthash: Optional[str] = None,
        servicemode: Optional[int] = None,
        userid: Optional[int] = None,
        uuidseqno: Optional[int] = None
    ) -> Dict[str, Any]:
        """
        Export Bill Payment Release to Onhold
        
        Generated from: POST /tradeFinance/exportLetterOfCredit/billPayment/releaseToOnhold
        Source: swagger_2_0
        Operation ID: ELCBT3007BLPayRlsdToOnHold_POSTUsingPOST
        
        
        Authentication: Not required
        
        Parameters:
        - request_body: any (required)
          input
        
        
        
        Headers:
        - Accesstoken: string
          Authorization Token to validation the caller
        - ChannelType: integer
          Channel identifier from where the TXN has originated (Internet, Mobile, ATM, Branch Channel )
        - co-Relationid: integer
          Unique ID for the service invoked, will be set by the TXN system
        - entity: string
          entity
        - initiatingSystem: string
          Indicating the initiated system
        - languageCode: integer
          languageCode
        - referenceId: string
          Place holder for Token based authentication
        - requesthash: string
          Request payload for hash validation
        - serviceMode: integer
          Used for branch channel to indicate the type of customer
        - userId: integer
          userId
        - uuidSeqNo: integer
          UUID Sequence Number
        
        
        """
        
        
        # Prepare request data
        
        # Single body parameter - send directly
        data = request_body if request_body is not None else {}
        
        
        
        # Prepare query parameters
        params = {}
        
        
        # Replace path parameters in URL
        path = "/tradeFinance/exportLetterOfCredit/billPayment/releaseToOnhold"
        
        
        # Prepare headers
        headers = {}
        if accesstoken is not None:
            headers["Accesstoken"] = str(accesstoken)
        if channeltype is not None:
            headers["ChannelType"] = str(channeltype)
        if co_relationid is not None:
            headers["co-Relationid"] = str(co_relationid)
        if entity is not None:
            headers["entity"] = str(entity)
        if initiatingsystem is not None:
            headers["initiatingSystem"] = str(initiatingsystem)
        if languagecode is not None:
            headers["languageCode"] = str(languagecode)
        if referenceid is not None:
            headers["referenceId"] = str(referenceid)
        if requesthash is not None:
            headers["requesthash"] = str(requesthash)
        if servicemode is not None:
            headers["serviceMode"] = str(servicemode)
        if userid is not None:
            headers["userId"] = str(userid)
        if uuidseqno is not None:
            headers["uuidSeqNo"] = str(uuidseqno)
        
        
        return await make_api_request(
            "POST", 
            path, 
            data=data, 
            params=params if params else None, 
            headers=headers if headers else None
        )
    
    
    
    @mcp.tool()
    async def elcbt3006_blpay_rlsd_to_rjct_postusing_post(
        request_body:Dict[str, Any] ,  # ElcBillPaymentReleaseToRejectRequest,
        accesstoken: Optional[str] = None,
        channeltype: Optional[int] = None,
        co_relationid: Optional[int] = None,
        entity: Optional[str] = None,
        initiatingsystem: Optional[str] = None,
        languagecode: Optional[int] = None,
        referenceid: Optional[str] = None,
        requesthash: Optional[str] = None,
        servicemode: Optional[int] = None,
        userid: Optional[int] = None,
        uuidseqno: Optional[int] = None
    ) -> Dict[str, Any]:
        """
        Export Bill Payment Release to Reject
        
        Generated from: POST /tradeFinance/exportLetterOfCredit/billPayment/releasetoReject
        Source: swagger_2_0
        Operation ID: ELCBT3006BLPayRlsdToRjct_POSTUsingPOST
        
        
        Authentication: Not required
        
        Parameters:
        - request_body: any (required)
          input
        
        
        
        Headers:
        - Accesstoken: string
          Authorization Token to validation the caller
        - ChannelType: integer
          Channel identifier from where the TXN has originated (Internet, Mobile, ATM, Branch Channel )
        - co-Relationid: integer
          Unique ID for the service invoked, will be set by the TXN system
        - entity: string
          entity
        - initiatingSystem: string
          Indicating the initiated system
        - languageCode: integer
          languageCode
        - referenceId: string
          Place holder for Token based authentication
        - requesthash: string
          Request payload for hash validation
        - serviceMode: integer
          Used for branch channel to indicate the type of customer
        - userId: integer
          userId
        - uuidSeqNo: integer
          UUID Sequence Number
        
        
        """
        
        
        # Prepare request data
        
        # Single body parameter - send directly
        data = request_body if request_body is not None else {}
        
        
        
        # Prepare query parameters
        params = {}
        
        
        # Replace path parameters in URL
        path = "/tradeFinance/exportLetterOfCredit/billPayment/releasetoReject"
        
        
        # Prepare headers
        headers = {}
        if accesstoken is not None:
            headers["Accesstoken"] = str(accesstoken)
        if channeltype is not None:
            headers["ChannelType"] = str(channeltype)
        if co_relationid is not None:
            headers["co-Relationid"] = str(co_relationid)
        if entity is not None:
            headers["entity"] = str(entity)
        if initiatingsystem is not None:
            headers["initiatingSystem"] = str(initiatingsystem)
        if languagecode is not None:
            headers["languageCode"] = str(languagecode)
        if referenceid is not None:
            headers["referenceId"] = str(referenceid)
        if requesthash is not None:
            headers["requesthash"] = str(requesthash)
        if servicemode is not None:
            headers["serviceMode"] = str(servicemode)
        if userid is not None:
            headers["userId"] = str(userid)
        if uuidseqno is not None:
            headers["uuidSeqNo"] = str(uuidseqno)
        
        
        return await make_api_request(
            "POST", 
            path, 
            data=data, 
            params=params if params else None, 
            headers=headers if headers else None
        )
    
    
    
    @mcp.tool()
    async def elcbt5299_blpay_rlsd_to_sentback_postusing_post(
        request_body:Dict[str, Any] ,  # ElcBillPaymentReleaseToSentbackRequest,
        accesstoken: Optional[str] = None,
        channeltype: Optional[int] = None,
        co_relationid: Optional[int] = None,
        entity: Optional[str] = None,
        initiatingsystem: Optional[str] = None,
        languagecode: Optional[int] = None,
        referenceid: Optional[str] = None,
        servicemode: Optional[int] = None,
        userid: Optional[int] = None,
        uuidseqno: Optional[int] = None
    ) -> Dict[str, Any]:
        """
        Export Bill Payment Release to Sentback
        
        Generated from: POST /tradeFinance/exportLetterOfCredit/billPayment/releasetoSentback
        Source: swagger_2_0
        Operation ID: ELCBT5299BLPayRlsdToSentback_POSTUsingPOST
        
        
        Authentication: Not required
        
        Parameters:
        - request_body: any (required)
          input
        
        
        
        Headers:
        - Accesstoken: string
          Authorization Token to validation the caller
        - ChannelType: integer
          Channel identifier from where the TXN has originated (Internet, Mobile, ATM, Branch Channel )
        - co-Relationid: integer
          Unique ID for the service invoked, will be set by the TXN system
        - entity: string
          entity
        - initiatingSystem: string
          Indicating the initiated system
        - languageCode: integer
          languageCode
        - referenceId: string
          Place holder for Token based authentication
        - serviceMode: integer
          Used for branch channel to indicate the type of customer
        - userId: integer
          userId
        - uuidSeqNo: integer
          UUID Sequence Number
        
        
        """
        
        
        # Prepare request data
        
        # Single body parameter - send directly
        data = request_body if request_body is not None else {}
        
        
        
        # Prepare query parameters
        params = {}
        
        
        # Replace path parameters in URL
        path = "/tradeFinance/exportLetterOfCredit/billPayment/releasetoSentback"
        
        
        # Prepare headers
        headers = {}
        if accesstoken is not None:
            headers["Accesstoken"] = str(accesstoken)
        if channeltype is not None:
            headers["ChannelType"] = str(channeltype)
        if co_relationid is not None:
            headers["co-Relationid"] = str(co_relationid)
        if entity is not None:
            headers["entity"] = str(entity)
        if initiatingsystem is not None:
            headers["initiatingSystem"] = str(initiatingsystem)
        if languagecode is not None:
            headers["languageCode"] = str(languagecode)
        if referenceid is not None:
            headers["referenceId"] = str(referenceid)
        if servicemode is not None:
            headers["serviceMode"] = str(servicemode)
        if userid is not None:
            headers["userId"] = str(userid)
        if uuidseqno is not None:
            headers["uuidSeqNo"] = str(uuidseqno)
        
        
        return await make_api_request(
            "POST", 
            path, 
            data=data, 
            params=params if params else None, 
            headers=headers if headers else None
        )
    
    
    
    @mcp.tool()
    async def elcet3011_get_blpay_dtls_postusing_get(
        billpaymentreference: str,
        accesstoken: Optional[str] = None,
        channeltype: Optional[int] = None,
        co_relationid: Optional[int] = None,
        entity: Optional[str] = None,
        initiatingsystem: Optional[str] = None,
        languagecode: Optional[int] = None,
        referenceid: Optional[str] = None,
        servicemode: Optional[int] = None,
        userid: Optional[int] = None,
        uuidseqno: Optional[int] = None
    ) -> Dict[str, Any]:
        """
        View Export Bill Payment
        
        Generated from: GET /tradeFinance/exportLetterOfCredit/billPayment/{billPaymentReference}
        Source: swagger_2_0
        Operation ID: ELCET3011GetBLPayDtls_POSTUsingGET
        
        
        Authentication: Not required
        
        Parameters:
        - billPaymentReference: string (required)
          Bill Payment Reference
        
        
        
        Headers:
        - Accesstoken: string
          Authorization Token to validation the caller
        - ChannelType: integer
          Channel identifier from where the TXN has originated (Internet, Mobile, ATM, Branch Channel )
        - co-Relationid: integer
          Unique ID for the service invoked, will be set by the TXN system
        - entity: string
          entity
        - initiatingSystem: string
          Indicating the initiated system
        - languageCode: integer
          languageCode
        - referenceId: string
          Place holder for Token based authentication
        - serviceMode: integer
          Used for branch channel to indicate the type of customer
        - userId: integer
          userId
        - uuidSeqNo: integer
          UUID Sequence Number
        
        
        """
        
        
        # Prepare query parameters
        params = {}
        
        
        # Replace path parameters in URL
        path = "/tradeFinance/exportLetterOfCredit/billPayment/{billPaymentReference}"
        if billpaymentreference is not None:
            path = path.replace("{billPaymentReference}", str(billpaymentreference))
        
        
        # Prepare headers
        headers = {}
        if accesstoken is not None:
            headers["Accesstoken"] = str(accesstoken)
        if channeltype is not None:
            headers["ChannelType"] = str(channeltype)
        if co_relationid is not None:
            headers["co-Relationid"] = str(co_relationid)
        if entity is not None:
            headers["entity"] = str(entity)
        if initiatingsystem is not None:
            headers["initiatingSystem"] = str(initiatingsystem)
        if languagecode is not None:
            headers["languageCode"] = str(languagecode)
        if referenceid is not None:
            headers["referenceId"] = str(referenceid)
        if servicemode is not None:
            headers["serviceMode"] = str(servicemode)
        if userid is not None:
            headers["userId"] = str(userid)
        if uuidseqno is not None:
            headers["uuidSeqNo"] = str(uuidseqno)
        
        
        return await make_api_request(
            "GET", 
            path, 
            
            params=params if params else None, 
            headers=headers if headers else None
        )
    
    
    
    @mcp.tool()
    async def elcbt5299_blrlsd_to_sentback_postusing_post(
        request_body:Dict[str, Any] ,  # RegisterExportBillSentbackRequest,
        accesstoken: Optional[str] = None,
        channeltype: Optional[int] = None,
        co_relationid: Optional[int] = None,
        entity: Optional[str] = None,
        initiatingsystem: Optional[str] = None,
        languagecode: Optional[int] = None,
        referenceid: Optional[str] = None,
        servicemode: Optional[int] = None,
        userid: Optional[int] = None,
        uuidseqno: Optional[int] = None
    ) -> Dict[str, Any]:
        """
        Sentback Export Bill Lodgement
        
        Generated from: POST /tradeFinance/exportLetterOfCredit/bills/Sentback
        Source: swagger_2_0
        Operation ID: ELCBT5299BLRlsdToSentback_POSTUsingPOST
        
        
        Authentication: Not required
        
        Parameters:
        - request_body: any (required)
          input
        
        
        
        Headers:
        - Accesstoken: string
          Authorization Token to validation the caller
        - ChannelType: integer
          Channel identifier from where the TXN has originated (Internet, Mobile, ATM, Branch Channel )
        - co-Relationid: integer
          Unique ID for the service invoked, will be set by the TXN system
        - entity: string
          entity
        - initiatingSystem: string
          Indicating the initiated system
        - languageCode: integer
          languageCode
        - referenceId: string
          Place holder for Token based authentication
        - serviceMode: integer
          Used for branch channel to indicate the type of customer
        - userId: integer
          userId
        - uuidSeqNo: integer
          UUID Sequence Number
        
        
        """
        
        
        # Prepare request data
        
        # Single body parameter - send directly
        data = request_body if request_body is not None else {}
        
        
        
        # Prepare query parameters
        params = {}
        
        
        # Replace path parameters in URL
        path = "/tradeFinance/exportLetterOfCredit/bills/Sentback"
        
        
        # Prepare headers
        headers = {}
        if accesstoken is not None:
            headers["Accesstoken"] = str(accesstoken)
        if channeltype is not None:
            headers["ChannelType"] = str(channeltype)
        if co_relationid is not None:
            headers["co-Relationid"] = str(co_relationid)
        if entity is not None:
            headers["entity"] = str(entity)
        if initiatingsystem is not None:
            headers["initiatingSystem"] = str(initiatingsystem)
        if languagecode is not None:
            headers["languageCode"] = str(languagecode)
        if referenceid is not None:
            headers["referenceId"] = str(referenceid)
        if servicemode is not None:
            headers["serviceMode"] = str(servicemode)
        if userid is not None:
            headers["userId"] = str(userid)
        if uuidseqno is not None:
            headers["uuidSeqNo"] = str(uuidseqno)
        
        
        return await make_api_request(
            "POST", 
            path, 
            data=data, 
            params=params if params else None, 
            headers=headers if headers else None
        )
    
    
    
    @mcp.tool()
    async def elcbt4564_blacpt_auth_postusing_put(
        request_body:Dict[str, Any] ,  # exportLcBillsAcceptRefusalAuthResource,
        accesstoken: Optional[str] = None,
        channeltype: Optional[int] = None,
        co_relationid: Optional[int] = None,
        entity: Optional[str] = None,
        initiatingsystem: Optional[str] = None,
        languagecode: Optional[int] = None,
        referenceid: Optional[str] = None,
        servicemode: Optional[int] = None,
        userid: Optional[int] = None,
        uuidseqno: Optional[int] = None
    ) -> Dict[str, Any]:
        """
        Authorise Bill Lodgement Acceptance Refusal
        
        Generated from: PUT /tradeFinance/exportLetterOfCredit/bills/acceptRefusalAuth
        Source: swagger_2_0
        Operation ID: ELCBT4564BLAcptAuth_POSTUsingPUT
        
        
        Authentication: Not required
        
        Parameters:
        - request_body: any (required)
          input
        
        
        
        Headers:
        - Accesstoken: string
          Authorization Token to validation the caller
        - ChannelType: integer
          Channel identifier from where the TXN has originated (Internet, Mobile, ATM, Branch Channel )
        - co-Relationid: integer
          Unique ID for the service invoked, will be set by the TXN system
        - entity: string
          entity
        - initiatingSystem: string
          Indicating the initiated system
        - languageCode: integer
          languageCode
        - referenceId: string
          Place holder for Token based authentication
        - serviceMode: integer
          Used for branch channel to indicate the type of customer
        - userId: integer
          userId
        - uuidSeqNo: integer
          UUID Sequence Number
        
        
        """
        
        
        # Prepare request data
        
        # Single body parameter - send directly
        data = request_body if request_body is not None else {}
        
        
        
        # Prepare query parameters
        params = {}
        
        
        # Replace path parameters in URL
        path = "/tradeFinance/exportLetterOfCredit/bills/acceptRefusalAuth"
        
        
        # Prepare headers
        headers = {}
        if accesstoken is not None:
            headers["Accesstoken"] = str(accesstoken)
        if channeltype is not None:
            headers["ChannelType"] = str(channeltype)
        if co_relationid is not None:
            headers["co-Relationid"] = str(co_relationid)
        if entity is not None:
            headers["entity"] = str(entity)
        if initiatingsystem is not None:
            headers["initiatingSystem"] = str(initiatingsystem)
        if languagecode is not None:
            headers["languageCode"] = str(languagecode)
        if referenceid is not None:
            headers["referenceId"] = str(referenceid)
        if servicemode is not None:
            headers["serviceMode"] = str(servicemode)
        if userid is not None:
            headers["userId"] = str(userid)
        if uuidseqno is not None:
            headers["uuidSeqNo"] = str(uuidseqno)
        
        
        return await make_api_request(
            "PUT", 
            path, 
            data=data, 
            params=params if params else None, 
            headers=headers if headers else None
        )
    
    
    
    @mcp.tool()
    async def elcbt4564_blacpt_ref_pndng_postusing_put(
        request_body:Dict[str, Any] ,  # exportLcBillsAcceptRefusalResource,
        accesstoken: Optional[str] = None,
        channeltype: Optional[int] = None,
        co_relationid: Optional[int] = None,
        entity: Optional[str] = None,
        initiatingsystem: Optional[str] = None,
        languagecode: Optional[int] = None,
        referenceid: Optional[str] = None,
        servicemode: Optional[int] = None,
        userid: Optional[int] = None,
        uuidseqno: Optional[int] = None
    ) -> Dict[str, Any]:
        """
        Bill Lodgement Acceptance Refusal Pending
        
        Generated from: PUT /tradeFinance/exportLetterOfCredit/bills/acceptRefusalPending
        Source: swagger_2_0
        Operation ID: ELCBT4564BLAcptRefPndng_POSTUsingPUT
        
        
        Authentication: Not required
        
        Parameters:
        - request_body: any (required)
          input
        
        
        
        Headers:
        - Accesstoken: string
          Authorization Token to validation the caller
        - ChannelType: integer
          Channel identifier from where the TXN has originated (Internet, Mobile, ATM, Branch Channel )
        - co-Relationid: integer
          Unique ID for the service invoked, will be set by the TXN system
        - entity: string
          entity
        - initiatingSystem: string
          Indicating the initiated system
        - languageCode: integer
          languageCode
        - referenceId: string
          Place holder for Token based authentication
        - serviceMode: integer
          Used for branch channel to indicate the type of customer
        - userId: integer
          userId
        - uuidSeqNo: integer
          UUID Sequence Number
        
        
        """
        
        
        # Prepare request data
        
        # Single body parameter - send directly
        data = request_body if request_body is not None else {}
        
        
        
        # Prepare query parameters
        params = {}
        
        
        # Replace path parameters in URL
        path = "/tradeFinance/exportLetterOfCredit/bills/acceptRefusalPending"
        
        
        # Prepare headers
        headers = {}
        if accesstoken is not None:
            headers["Accesstoken"] = str(accesstoken)
        if channeltype is not None:
            headers["ChannelType"] = str(channeltype)
        if co_relationid is not None:
            headers["co-Relationid"] = str(co_relationid)
        if entity is not None:
            headers["entity"] = str(entity)
        if initiatingsystem is not None:
            headers["initiatingSystem"] = str(initiatingsystem)
        if languagecode is not None:
            headers["languageCode"] = str(languagecode)
        if referenceid is not None:
            headers["referenceId"] = str(referenceid)
        if servicemode is not None:
            headers["serviceMode"] = str(servicemode)
        if userid is not None:
            headers["userId"] = str(userid)
        if uuidseqno is not None:
            headers["uuidSeqNo"] = str(uuidseqno)
        
        
        return await make_api_request(
            "PUT", 
            path, 
            data=data, 
            params=params if params else None, 
            headers=headers if headers else None
        )
    
    
    
    @mcp.tool()
    async def elcbt4001_crt_blamndmnt_on_hold_postusing_post(
        request_body:Dict[str, Any] ,  # ElcCollectionsBillsAmendmentRequest,
        accesstoken: Optional[str] = None,
        channeltype: Optional[int] = None,
        co_relationid: Optional[int] = None,
        entity: Optional[str] = None,
        initiatingsystem: Optional[str] = None,
        languagecode: Optional[int] = None,
        referenceid: Optional[str] = None,
        servicemode: Optional[int] = None,
        userid: Optional[int] = None,
        uuidseqno: Optional[int] = None
    ) -> Dict[str, Any]:
        """
        Amend Export LC Bill Onhold
        
        Generated from: POST /tradeFinance/exportLetterOfCredit/bills/amendment
        Source: swagger_2_0
        Operation ID: ELCBT4001CrtBLAmndmntOnHold_POSTUsingPOST
        
        
        Authentication: Not required
        
        Parameters:
        - request_body: any (required)
          input
        
        
        
        Headers:
        - Accesstoken: string
          Authorization Token to validation the caller
        - ChannelType: integer
          Channel identifier from where the TXN has originated (Internet, Mobile, ATM, Branch Channel )
        - co-Relationid: integer
          Unique ID for the service invoked, will be set by the TXN system
        - entity: string
          entity
        - initiatingSystem: string
          Indicating the initiated system
        - languageCode: integer
          languageCode
        - referenceId: string
          Place holder for Token based authentication
        - serviceMode: integer
          Used for branch channel to indicate the type of customer
        - userId: integer
          userId
        - uuidSeqNo: integer
          UUID Sequence Number
        
        
        """
        
        
        # Prepare request data
        
        # Single body parameter - send directly
        data = request_body if request_body is not None else {}
        
        
        
        # Prepare query parameters
        params = {}
        
        
        # Replace path parameters in URL
        path = "/tradeFinance/exportLetterOfCredit/bills/amendment"
        
        
        # Prepare headers
        headers = {}
        if accesstoken is not None:
            headers["Accesstoken"] = str(accesstoken)
        if channeltype is not None:
            headers["ChannelType"] = str(channeltype)
        if co_relationid is not None:
            headers["co-Relationid"] = str(co_relationid)
        if entity is not None:
            headers["entity"] = str(entity)
        if initiatingsystem is not None:
            headers["initiatingSystem"] = str(initiatingsystem)
        if languagecode is not None:
            headers["languageCode"] = str(languagecode)
        if referenceid is not None:
            headers["referenceId"] = str(referenceid)
        if servicemode is not None:
            headers["serviceMode"] = str(servicemode)
        if userid is not None:
            headers["userId"] = str(userid)
        if uuidseqno is not None:
            headers["uuidSeqNo"] = str(uuidseqno)
        
        
        return await make_api_request(
            "POST", 
            path, 
            data=data, 
            params=params if params else None, 
            headers=headers if headers else None
        )
    
    
    
    @mcp.tool()
    async def elcbt4001_blamnd_rlsdto_exec_postusing_put(
        request_body:Dict[str, Any] ,  # amendExportLCAuthRequest,
        accesstoken: Optional[str] = None,
        channeltype: Optional[int] = None,
        co_relationid: Optional[int] = None,
        entity: Optional[str] = None,
        initiatingsystem: Optional[str] = None,
        languagecode: Optional[int] = None,
        referenceid: Optional[str] = None,
        servicemode: Optional[int] = None,
        userid: Optional[int] = None,
        uuidseqno: Optional[int] = None
    ) -> Dict[str, Any]:
        """
        Authorise ELC Bill Amendment
        
        Generated from: PUT /tradeFinance/exportLetterOfCredit/bills/amendment/auth
        Source: swagger_2_0
        Operation ID: ELCBT4001BLAmndRlsdtoExec_POSTUsingPUT
        
        
        Authentication: Not required
        
        Parameters:
        - request_body: any (required)
          input
        
        
        
        Headers:
        - Accesstoken: string
          Authorization Token to validation the caller
        - ChannelType: integer
          Channel identifier from where the TXN has originated (Internet, Mobile, ATM, Branch Channel )
        - co-Relationid: integer
          Unique ID for the service invoked, will be set by the TXN system
        - entity: string
          entity
        - initiatingSystem: string
          Indicating the initiated system
        - languageCode: integer
          languageCode
        - referenceId: string
          Place holder for Token based authentication
        - serviceMode: integer
          Used for branch channel to indicate the type of customer
        - userId: integer
          userId
        - uuidSeqNo: integer
          UUID Sequence Number
        
        
        """
        
        
        # Prepare request data
        
        # Single body parameter - send directly
        data = request_body if request_body is not None else {}
        
        
        
        # Prepare query parameters
        params = {}
        
        
        # Replace path parameters in URL
        path = "/tradeFinance/exportLetterOfCredit/bills/amendment/auth"
        
        
        # Prepare headers
        headers = {}
        if accesstoken is not None:
            headers["Accesstoken"] = str(accesstoken)
        if channeltype is not None:
            headers["ChannelType"] = str(channeltype)
        if co_relationid is not None:
            headers["co-Relationid"] = str(co_relationid)
        if entity is not None:
            headers["entity"] = str(entity)
        if initiatingsystem is not None:
            headers["initiatingSystem"] = str(initiatingsystem)
        if languagecode is not None:
            headers["languageCode"] = str(languagecode)
        if referenceid is not None:
            headers["referenceId"] = str(referenceid)
        if servicemode is not None:
            headers["serviceMode"] = str(servicemode)
        if userid is not None:
            headers["userId"] = str(userid)
        if uuidseqno is not None:
            headers["uuidSeqNo"] = str(uuidseqno)
        
        
        return await make_api_request(
            "PUT", 
            path, 
            data=data, 
            params=params if params else None, 
            headers=headers if headers else None
        )
    
    
    
    @mcp.tool()
    async def elcet4967_get_bldoc_dtls_postusing_get(
        eblrefextrnl: str,
        documentid: int,
        evntlegid: int,
        pagenum: Optional[int] = None,
        pagesize: Optional[int] = None,
        accesstoken: Optional[str] = None,
        channeltype: Optional[int] = None,
        co_relationid: Optional[int] = None,
        entity: Optional[str] = None,
        initiatingsystem: Optional[str] = None,
        languagecode: Optional[int] = None,
        referenceid: Optional[str] = None,
        servicemode: Optional[int] = None,
        userid: Optional[int] = None,
        uuidseqno: Optional[int] = None
    ) -> Dict[str, Any]:
        """
        View ELC BILL Document Details Amend
        
        Generated from: GET /tradeFinance/exportLetterOfCredit/bills/amendment/documentDetails/{eblRefExtrnl}/view
        Source: swagger_2_0
        Operation ID: ELCET4967GetBLDocDtls_POSTUsingGET
        
        
        Authentication: Not required
        
        Parameters:
        - documentID: integer (required)
          Document Id
        - eblRefExtrnl: string (required)
          Ebl Amend Reference External
        - evntLegId: integer (required)
          EVNT_LEG_ID
        - pageNum: integer
          pageNum
        - pageSize: integer
          pageSize
        
        
        
        Headers:
        - Accesstoken: string
          Authorization Token to validation the caller
        - ChannelType: integer
          Channel identifier from where the TXN has originated (Internet, Mobile, ATM, Branch Channel )
        - co-Relationid: integer
          Unique ID for the service invoked, will be set by the TXN system
        - entity: string
          entity
        - initiatingSystem: string
          Indicating the initiated system
        - languageCode: integer
          languageCode
        - referenceId: string
          Place holder for Token based authentication
        - serviceMode: integer
          Used for branch channel to indicate the type of customer
        - userId: integer
          userId
        - uuidSeqNo: integer
          UUID Sequence Number
        
        
        """
        
        
        # Prepare query parameters
        params = {}
        if documentid is not None:
            params["documentID"] = documentid
            
        if evntlegid is not None:
            params["evntLegId"] = evntlegid
            
        if pagenum is not None:
            params["pageNum"] = pagenum
            
        if pagesize is not None:
            params["pageSize"] = pagesize
            
        
        
        # Replace path parameters in URL
        path = "/tradeFinance/exportLetterOfCredit/bills/amendment/documentDetails/{eblRefExtrnl}/view"
        if eblrefextrnl is not None:
            path = path.replace("{eblRefExtrnl}", str(eblrefextrnl))
        
        
        # Prepare headers
        headers = {}
        if accesstoken is not None:
            headers["Accesstoken"] = str(accesstoken)
        if channeltype is not None:
            headers["ChannelType"] = str(channeltype)
        if co_relationid is not None:
            headers["co-Relationid"] = str(co_relationid)
        if entity is not None:
            headers["entity"] = str(entity)
        if initiatingsystem is not None:
            headers["initiatingSystem"] = str(initiatingsystem)
        if languagecode is not None:
            headers["languageCode"] = str(languagecode)
        if referenceid is not None:
            headers["referenceId"] = str(referenceid)
        if servicemode is not None:
            headers["serviceMode"] = str(servicemode)
        if userid is not None:
            headers["userId"] = str(userid)
        if uuidseqno is not None:
            headers["uuidSeqNo"] = str(uuidseqno)
        
        
        return await make_api_request(
            "GET", 
            path, 
            
            params=params if params else None, 
            headers=headers if headers else None
        )
    
    
    
    @mcp.tool()
    async def elcet4966_fetch_bldoc_dtls_postusing_get(
        ebltransactionid: Optional[int] = None,
        ebltransactiontype: Optional[int] = None,
        entityid: Optional[str] = None,
        evntlegid: Optional[int] = None,
        pagenum: Optional[int] = None,
        pagesize: Optional[int] = None,
        accesstoken: Optional[str] = None,
        channeltype: Optional[int] = None,
        co_relationid: Optional[int] = None,
        entity: Optional[str] = None,
        initiatingsystem: Optional[str] = None,
        languagecode: Optional[int] = None,
        referenceid: Optional[str] = None,
        servicemode: Optional[int] = None,
        userid: Optional[int] = None,
        uuidseqno: Optional[int] = None
    ) -> Dict[str, Any]:
        """
        ELCET4966FetDocuments Details under Export Bill Lodgement-ListchBLDocDtls
        
        Generated from: GET /tradeFinance/exportLetterOfCredit/bills/amendment/documentList
        Source: swagger_2_0
        Operation ID: ELCET4966FetchBLDocDtls_POSTUsingGET
        
        
        Authentication: Not required
        
        Parameters:
        - eblTransactionId: integer
          eblTransactionId
        - eblTransactionType: integer
          Export Bill Transaction Type
        - entityId: string
          Entity ID
        - evntLegId: integer
          evntLegId
        - pageNum: integer
          pageNum
        - pageSize: integer
          pageSize
        
        
        
        Headers:
        - Accesstoken: string
          Authorization Token to validation the caller
        - ChannelType: integer
          Channel identifier from where the TXN has originated (Internet, Mobile, ATM, Branch Channel )
        - co-Relationid: integer
          Unique ID for the service invoked, will be set by the TXN system
        - entity: string
          entity
        - initiatingSystem: string
          Indicating the initiated system
        - languageCode: integer
          languageCode
        - referenceId: string
          Place holder for Token based authentication
        - serviceMode: integer
          Used for branch channel to indicate the type of customer
        - userId: integer
          userId
        - uuidSeqNo: integer
          UUID Sequence Number
        
        
        """
        
        
        # Prepare query parameters
        params = {}
        if ebltransactionid is not None:
            params["eblTransactionId"] = ebltransactionid
            
        if ebltransactiontype is not None:
            params["eblTransactionType"] = ebltransactiontype
            
        if entityid is not None:
            params["entityId"] = entityid
            
        if evntlegid is not None:
            params["evntLegId"] = evntlegid
            
        if pagenum is not None:
            params["pageNum"] = pagenum
            
        if pagesize is not None:
            params["pageSize"] = pagesize
            
        
        
        # Replace path parameters in URL
        path = "/tradeFinance/exportLetterOfCredit/bills/amendment/documentList"
        
        
        # Prepare headers
        headers = {}
        if accesstoken is not None:
            headers["Accesstoken"] = str(accesstoken)
        if channeltype is not None:
            headers["ChannelType"] = str(channeltype)
        if co_relationid is not None:
            headers["co-Relationid"] = str(co_relationid)
        if entity is not None:
            headers["entity"] = str(entity)
        if initiatingsystem is not None:
            headers["initiatingSystem"] = str(initiatingsystem)
        if languagecode is not None:
            headers["languageCode"] = str(languagecode)
        if referenceid is not None:
            headers["referenceId"] = str(referenceid)
        if servicemode is not None:
            headers["serviceMode"] = str(servicemode)
        if userid is not None:
            headers["userId"] = str(userid)
        if uuidseqno is not None:
            headers["uuidSeqNo"] = str(uuidseqno)
        
        
        return await make_api_request(
            "GET", 
            path, 
            
            params=params if params else None, 
            headers=headers if headers else None
        )
    
    
    
    @mcp.tool()
    async def elcbt4965_set_up_bldoc_dtls_postusing_post(
        request_body:Dict[str, Any] ,  # RegisterExportBillDocumentRequest,
        accesstoken: Optional[str] = None,
        channeltype: Optional[int] = None,
        co_relationid: Optional[int] = None,
        entity: Optional[str] = None,
        initiatingsystem: Optional[str] = None,
        languagecode: Optional[int] = None,
        referenceid: Optional[str] = None,
        servicemode: Optional[int] = None,
        userid: Optional[int] = None,
        uuidseqno: Optional[int] = None
    ) -> Dict[str, Any]:
        """
        Document Details Amend under Export Bill Lodgement- Setup
        
        Generated from: POST /tradeFinance/exportLetterOfCredit/bills/amendment/documentSetup
        Source: swagger_2_0
        Operation ID: ELCBT4965SetUpBLDocDtls_POSTUsingPOST
        
        
        Authentication: Not required
        
        Parameters:
        - request_body: any (required)
          input
        
        
        
        Headers:
        - Accesstoken: string
          Authorization Token to validation the caller
        - ChannelType: integer
          Channel identifier from where the TXN has originated (Internet, Mobile, ATM, Branch Channel )
        - co-Relationid: integer
          Unique ID for the service invoked, will be set by the TXN system
        - entity: string
          entity
        - initiatingSystem: string
          Indicating the initiated system
        - languageCode: integer
          languageCode
        - referenceId: string
          Place holder for Token based authentication
        - serviceMode: integer
          Used for branch channel to indicate the type of customer
        - userId: integer
          userId
        - uuidSeqNo: integer
          UUID Sequence Number
        
        
        """
        
        
        # Prepare request data
        
        # Single body parameter - send directly
        data = request_body if request_body is not None else {}
        
        
        
        # Prepare query parameters
        params = {}
        
        
        # Replace path parameters in URL
        path = "/tradeFinance/exportLetterOfCredit/bills/amendment/documentSetup"
        
        
        # Prepare headers
        headers = {}
        if accesstoken is not None:
            headers["Accesstoken"] = str(accesstoken)
        if channeltype is not None:
            headers["ChannelType"] = str(channeltype)
        if co_relationid is not None:
            headers["co-Relationid"] = str(co_relationid)
        if entity is not None:
            headers["entity"] = str(entity)
        if initiatingsystem is not None:
            headers["initiatingSystem"] = str(initiatingsystem)
        if languagecode is not None:
            headers["languageCode"] = str(languagecode)
        if referenceid is not None:
            headers["referenceId"] = str(referenceid)
        if servicemode is not None:
            headers["serviceMode"] = str(servicemode)
        if userid is not None:
            headers["userId"] = str(userid)
        if uuidseqno is not None:
            headers["uuidSeqNo"] = str(uuidseqno)
        
        
        return await make_api_request(
            "POST", 
            path, 
            data=data, 
            params=params if params else None, 
            headers=headers if headers else None
        )
    
    
    
    @mcp.tool()
    async def elcet4002_fetch_amnd_list_postusing_get(
        amendnumber: Optional[int] = None,
        amendmentdate: Optional[str] = None,
        billamnt: Optional[float] = None,
        eblrefexternal: Optional[str] = None,
        eblrefinternal: Optional[str] = None,
        evntlegid: Optional[int] = None,
        id: Optional[int] = None,
        benificiaryname: Optional[str] = None,
        enddate: Optional[str] = None,
        name: Optional[str] = None,
        pagenum: Optional[int] = None,
        pagesize: Optional[int] = None,
        startdate: Optional[str] = None,
        status: Optional[int] = None,
        transactionid: Optional[int] = None,
        transactiontype: Optional[int] = None,
        accesstoken: Optional[str] = None,
        channeltype: Optional[int] = None,
        co_relationid: Optional[int] = None,
        entity: Optional[str] = None,
        initiatingsystem: Optional[str] = None,
        languagecode: Optional[int] = None,
        mu_id: Optional[str] = None,
        referenceid: Optional[str] = None,
        servicemode: Optional[int] = None,
        userid: Optional[int] = None,
        uuidseqno: Optional[int] = None
    ) -> Dict[str, Any]:
        """
        Amend Export LC List
        
        Generated from: GET /tradeFinance/exportLetterOfCredit/bills/amendment/list
        Source: swagger_2_0
        Operation ID: ELCET4002FetchAmndList_POSTUsingGET
        
        
        Authentication: Not required
        
        Parameters:
        - AmendNumber: integer
          Amendment Number
        - AmendmentDate: string
          Amendment Date
        - BillAmnt: number
          Amount
        - EblRefExternal: string
          Elc Reference External
        - EblRefInternal: string
          Ebl Reference Internal
        - EvntLegId: integer
          Event Leg ID
        - Id: integer
          Customer Id
        - benificiaryName: string
          Benificiary Name
        - endDate: string
          End Date
        - name: string
          Customer Name
        - pageNum: integer
          pageNum
        - pageSize: integer
          pageSize
        - startDate: string
          Start Date
        - status: integer
          Status
        - transactionId: integer
          Transaction ID
        - transactionType: integer
          Transaction Type
        
        
        
        Headers:
        - Accesstoken: string
          Authorization Token to validation the caller
        - ChannelType: integer
          Channel identifier from where the TXN has originated (Internet, Mobile, ATM, Branch Channel )
        - co-Relationid: integer
          Unique ID for the service invoked, will be set by the TXN system
        - entity: string
          entity
        - initiatingSystem: string
          Indicating the initiated system
        - languageCode: integer
          languageCode
        - mu_Id: string
          Used to indicate the Branch Id of user
        - referenceId: string
          Place holder for Token based authentication
        - serviceMode: integer
          Used for branch channel to indicate the type of customer
        - userId: integer
          userId
        - uuidSeqNo: integer
          UUID Sequence Number
        
        
        """
        
        
        # Prepare query parameters
        params = {}
        if amendnumber is not None:
            params["AmendNumber"] = amendnumber
            
        if amendmentdate is not None:
            params["AmendmentDate"] = amendmentdate
            
        if billamnt is not None:
            params["BillAmnt"] = billamnt
            
        if eblrefexternal is not None:
            params["EblRefExternal"] = eblrefexternal
            
        if eblrefinternal is not None:
            params["EblRefInternal"] = eblrefinternal
            
        if evntlegid is not None:
            params["EvntLegId"] = evntlegid
            
        if id is not None:
            params["Id"] = id
            
        if benificiaryname is not None:
            params["benificiaryName"] = benificiaryname
            
        if enddate is not None:
            params["endDate"] = enddate
            
        if name is not None:
            params["name"] = name
            
        if pagenum is not None:
            params["pageNum"] = pagenum
            
        if pagesize is not None:
            params["pageSize"] = pagesize
            
        if startdate is not None:
            params["startDate"] = startdate
            
        if status is not None:
            params["status"] = status
            
        if transactionid is not None:
            params["transactionId"] = transactionid
            
        if transactiontype is not None:
            params["transactionType"] = transactiontype
            
        
        
        # Replace path parameters in URL
        path = "/tradeFinance/exportLetterOfCredit/bills/amendment/list"
        
        
        # Prepare headers
        headers = {}
        if accesstoken is not None:
            headers["Accesstoken"] = str(accesstoken)
        if channeltype is not None:
            headers["ChannelType"] = str(channeltype)
        if co_relationid is not None:
            headers["co-Relationid"] = str(co_relationid)
        if entity is not None:
            headers["entity"] = str(entity)
        if initiatingsystem is not None:
            headers["initiatingSystem"] = str(initiatingsystem)
        if languagecode is not None:
            headers["languageCode"] = str(languagecode)
        if mu_id is not None:
            headers["mu_Id"] = str(mu_id)
        if referenceid is not None:
            headers["referenceId"] = str(referenceid)
        if servicemode is not None:
            headers["serviceMode"] = str(servicemode)
        if userid is not None:
            headers["userId"] = str(userid)
        if uuidseqno is not None:
            headers["uuidSeqNo"] = str(uuidseqno)
        
        
        return await make_api_request(
            "GET", 
            path, 
            
            params=params if params else None, 
            headers=headers if headers else None
        )
    
    
    
    @mcp.tool()
    async def elcbt4001_blamnd_on_hold_to_rlsd_postusing_post(
        request_body:Dict[str, Any] ,  # UserConfirmBlAmendDtlsRequest,
        accesstoken: Optional[str] = None,
        channeltype: Optional[int] = None,
        co_relationid: Optional[int] = None,
        entity: Optional[str] = None,
        initiatingsystem: Optional[str] = None,
        languagecode: Optional[int] = None,
        referenceid: Optional[str] = None,
        servicemode: Optional[int] = None,
        userid: Optional[int] = None,
        uuidseqno: Optional[int] = None
    ) -> Dict[str, Any]:
        """
        ELCBT4001BLAmndOnHoldToRlsd
        
        Generated from: POST /tradeFinance/exportLetterOfCredit/bills/amendment/release
        Source: swagger_2_0
        Operation ID: ELCBT4001BLAmndOnHoldToRlsd_POSTUsingPOST
        
        
        Authentication: Not required
        
        Parameters:
        - request_body: any (required)
          input
        
        
        
        Headers:
        - Accesstoken: string
          Authorization Token to validation the caller
        - ChannelType: integer
          Channel identifier from where the TXN has originated (Internet, Mobile, ATM, Branch Channel )
        - co-Relationid: integer
          Unique ID for the service invoked, will be set by the TXN system
        - entity: string
          entity
        - initiatingSystem: string
          Indicating the initiated system
        - languageCode: integer
          languageCode
        - referenceId: string
          Place holder for Token based authentication
        - serviceMode: integer
          Used for branch channel to indicate the type of customer
        - userId: integer
          userId
        - uuidSeqNo: integer
          UUID Sequence Number
        
        
        """
        
        
        # Prepare request data
        
        # Single body parameter - send directly
        data = request_body if request_body is not None else {}
        
        
        
        # Prepare query parameters
        params = {}
        
        
        # Replace path parameters in URL
        path = "/tradeFinance/exportLetterOfCredit/bills/amendment/release"
        
        
        # Prepare headers
        headers = {}
        if accesstoken is not None:
            headers["Accesstoken"] = str(accesstoken)
        if channeltype is not None:
            headers["ChannelType"] = str(channeltype)
        if co_relationid is not None:
            headers["co-Relationid"] = str(co_relationid)
        if entity is not None:
            headers["entity"] = str(entity)
        if initiatingsystem is not None:
            headers["initiatingSystem"] = str(initiatingsystem)
        if languagecode is not None:
            headers["languageCode"] = str(languagecode)
        if referenceid is not None:
            headers["referenceId"] = str(referenceid)
        if servicemode is not None:
            headers["serviceMode"] = str(servicemode)
        if userid is not None:
            headers["userId"] = str(userid)
        if uuidseqno is not None:
            headers["uuidSeqNo"] = str(uuidseqno)
        
        
        return await make_api_request(
            "POST", 
            path, 
            data=data, 
            params=params if params else None, 
            headers=headers if headers else None
        )
    
    
    
    @mcp.tool()
    async def elcet4002_get_blamnd_dtls_postusing_get(
        eblrefexternal: Optional[str] = None,
        entityid: Optional[str] = None,
        evntlegid: Optional[int] = None,
        pagenum: Optional[int] = None,
        pagesize: Optional[int] = None,
        transactionid: Optional[int] = None,
        transactiontype: Optional[int] = None,
        accesstoken: Optional[str] = None,
        channeltype: Optional[int] = None,
        co_relationid: Optional[int] = None,
        entity: Optional[str] = None,
        initiatingsystem: Optional[str] = None,
        languagecode: Optional[int] = None,
        referenceid: Optional[str] = None,
        servicemode: Optional[int] = None,
        userid: Optional[int] = None,
        uuidseqno: Optional[int] = None
    ) -> Dict[str, Any]:
        """
        Amend Export LC View
        
        Generated from: GET /tradeFinance/exportLetterOfCredit/bills/amendment/view
        Source: swagger_2_0
        Operation ID: ELCET4002GetBLAmndDtls_POSTUsingGET
        
        
        Authentication: Not required
        
        Parameters:
        - EblRefExternal: string
          Elc Reference External
        - EntityId: string
          Entity ID
        - EvntLegId: integer
          Event Leg ID
        - pageNum: integer
          pageNum
        - pageSize: integer
          pageSize
        - transactionId: integer
          Transaction ID
        - transactionType: integer
          Transaction Type
        
        
        
        Headers:
        - Accesstoken: string
          Authorization Token to validation the caller
        - ChannelType: integer
          Channel identifier from where the TXN has originated (Internet, Mobile, ATM, Branch Channel )
        - co-Relationid: integer
          Unique ID for the service invoked, will be set by the TXN system
        - entity: string
          entity
        - initiatingSystem: string
          Indicating the initiated system
        - languageCode: integer
          languageCode
        - referenceId: string
          Place holder for Token based authentication
        - serviceMode: integer
          Used for branch channel to indicate the type of customer
        - userId: integer
          userId
        - uuidSeqNo: integer
          UUID Sequence Number
        
        
        """
        
        
        # Prepare query parameters
        params = {}
        if eblrefexternal is not None:
            params["EblRefExternal"] = eblrefexternal
            
        if entityid is not None:
            params["EntityId"] = entityid
            
        if evntlegid is not None:
            params["EvntLegId"] = evntlegid
            
        if pagenum is not None:
            params["pageNum"] = pagenum
            
        if pagesize is not None:
            params["pageSize"] = pagesize
            
        if transactionid is not None:
            params["transactionId"] = transactionid
            
        if transactiontype is not None:
            params["transactionType"] = transactiontype
            
        
        
        # Replace path parameters in URL
        path = "/tradeFinance/exportLetterOfCredit/bills/amendment/view"
        
        
        # Prepare headers
        headers = {}
        if accesstoken is not None:
            headers["Accesstoken"] = str(accesstoken)
        if channeltype is not None:
            headers["ChannelType"] = str(channeltype)
        if co_relationid is not None:
            headers["co-Relationid"] = str(co_relationid)
        if entity is not None:
            headers["entity"] = str(entity)
        if initiatingsystem is not None:
            headers["initiatingSystem"] = str(initiatingsystem)
        if languagecode is not None:
            headers["languageCode"] = str(languagecode)
        if referenceid is not None:
            headers["referenceId"] = str(referenceid)
        if servicemode is not None:
            headers["serviceMode"] = str(servicemode)
        if userid is not None:
            headers["userId"] = str(userid)
        if uuidseqno is not None:
            headers["uuidSeqNo"] = str(uuidseqno)
        
        
        return await make_api_request(
            "GET", 
            path, 
            
            params=params if params else None, 
            headers=headers if headers else None
        )
    
    
    
    @mcp.tool()
    async def elcbt2005_blrlsd_to_exec_postusing_post(
        request_body:Dict[str, Any] ,  # RegisterExportBillAuthRequest,
        accesstoken: Optional[str] = None,
        channeltype: Optional[int] = None,
        co_relationid: Optional[int] = None,
        entity: Optional[str] = None,
        initiatingsystem: Optional[str] = None,
        languagecode: Optional[int] = None,
        mu_id: Optional[str] = None,
        referenceid: Optional[str] = None,
        servicemode: Optional[int] = None,
        userid: Optional[int] = None,
        uuidseqno: Optional[int] = None
    ) -> Dict[str, Any]:
        """
        Authorize Export Bill Lodgement
        
        Generated from: POST /tradeFinance/exportLetterOfCredit/bills/authorize
        Source: swagger_2_0
        Operation ID: ELCBT2005BLRlsdToExec_POSTUsingPOST
        
        
        Authentication: Not required
        
        Parameters:
        - request_body: any (required)
          input
        
        
        
        Headers:
        - Accesstoken: string
          Authorization Token to validation the caller
        - ChannelType: integer
          Channel identifier from where the TXN has originated (Internet, Mobile, ATM, Branch Channel )
        - co-Relationid: integer
          Unique ID for the service invoked, will be set by the TXN system
        - entity: string
          entity
        - initiatingSystem: string
          Indicating the initiated system
        - languageCode: integer
          languageCode
        - mu_Id: string
          Muid
        - referenceId: string
          Place holder for Token based authentication
        - serviceMode: integer
          Used for branch channel to indicate the type of customer
        - userId: integer
          userId
        - uuidSeqNo: integer
          UUID Sequence Number
        
        
        """
        
        
        # Prepare request data
        
        # Single body parameter - send directly
        data = request_body if request_body is not None else {}
        
        
        
        # Prepare query parameters
        params = {}
        
        
        # Replace path parameters in URL
        path = "/tradeFinance/exportLetterOfCredit/bills/authorize"
        
        
        # Prepare headers
        headers = {}
        if accesstoken is not None:
            headers["Accesstoken"] = str(accesstoken)
        if channeltype is not None:
            headers["ChannelType"] = str(channeltype)
        if co_relationid is not None:
            headers["co-Relationid"] = str(co_relationid)
        if entity is not None:
            headers["entity"] = str(entity)
        if initiatingsystem is not None:
            headers["initiatingSystem"] = str(initiatingsystem)
        if languagecode is not None:
            headers["languageCode"] = str(languagecode)
        if mu_id is not None:
            headers["mu_Id"] = str(mu_id)
        if referenceid is not None:
            headers["referenceId"] = str(referenceid)
        if servicemode is not None:
            headers["serviceMode"] = str(servicemode)
        if userid is not None:
            headers["userId"] = str(userid)
        if uuidseqno is not None:
            headers["uuidSeqNo"] = str(uuidseqno)
        
        
        return await make_api_request(
            "POST", 
            path, 
            data=data, 
            params=params if params else None, 
            headers=headers if headers else None
        )
    
    
    
    @mcp.tool()
    async def elcbt2004_blon_hold_to_rjct_postusing_post(
        request_body:Dict[str, Any] ,  # RegisterExportCancelRequest,
        accesstoken: Optional[str] = None,
        channeltype: Optional[int] = None,
        co_relationid: Optional[int] = None,
        entity: Optional[str] = None,
        initiatingsystem: Optional[str] = None,
        languagecode: Optional[int] = None,
        referenceid: Optional[str] = None,
        servicemode: Optional[int] = None,
        userid: Optional[int] = None,
        uuidseqno: Optional[int] = None
    ) -> Dict[str, Any]:
        """
        Cancel Export Bill Lodgement
        
        Generated from: POST /tradeFinance/exportLetterOfCredit/bills/cancel
        Source: swagger_2_0
        Operation ID: ELCBT2004BLOnHoldToRjct_POSTUsingPOST
        
        
        Authentication: Not required
        
        Parameters:
        - request_body: any (required)
          input
        
        
        
        Headers:
        - Accesstoken: string
          Authorization Token to validation the caller
        - ChannelType: integer
          Channel identifier from where the TXN has originated (Internet, Mobile, ATM, Branch Channel )
        - co-Relationid: integer
          Unique ID for the service invoked, will be set by the TXN system
        - entity: string
          entity
        - initiatingSystem: string
          Indicating the initiated system
        - languageCode: integer
          languageCode
        - referenceId: string
          Place holder for Token based authentication
        - serviceMode: integer
          Used for branch channel to indicate the type of customer
        - userId: integer
          userId
        - uuidSeqNo: integer
          UUID Sequence Number
        
        
        """
        
        
        # Prepare request data
        
        # Single body parameter - send directly
        data = request_body if request_body is not None else {}
        
        
        
        # Prepare query parameters
        params = {}
        
        
        # Replace path parameters in URL
        path = "/tradeFinance/exportLetterOfCredit/bills/cancel"
        
        
        # Prepare headers
        headers = {}
        if accesstoken is not None:
            headers["Accesstoken"] = str(accesstoken)
        if channeltype is not None:
            headers["ChannelType"] = str(channeltype)
        if co_relationid is not None:
            headers["co-Relationid"] = str(co_relationid)
        if entity is not None:
            headers["entity"] = str(entity)
        if initiatingsystem is not None:
            headers["initiatingSystem"] = str(initiatingsystem)
        if languagecode is not None:
            headers["languageCode"] = str(languagecode)
        if referenceid is not None:
            headers["referenceId"] = str(referenceid)
        if servicemode is not None:
            headers["serviceMode"] = str(servicemode)
        if userid is not None:
            headers["userId"] = str(userid)
        if uuidseqno is not None:
            headers["uuidSeqNo"] = str(uuidseqno)
        
        
        return await make_api_request(
            "POST", 
            path, 
            data=data, 
            params=params if params else None, 
            headers=headers if headers else None
        )
    
    
    
    @mcp.tool()
    async def elcbt2001_crt_blon_hold_postusing_post(
        request_body:Dict[str, Any] ,  # RegisterExportBillCreateRequest,
        accesstoken: Optional[str] = None,
        channeltype: Optional[int] = None,
        co_relationid: Optional[int] = None,
        entity: Optional[str] = None,
        initiatingsystem: Optional[str] = None,
        languagecode: Optional[int] = None,
        referenceid: Optional[str] = None,
        servicemode: Optional[int] = None,
        userid: Optional[int] = None,
        uuidseqno: Optional[int] = None
    ) -> Dict[str, Any]:
        """
        Register Export Bill Lodgement On Hold
        
        Generated from: POST /tradeFinance/exportLetterOfCredit/bills/createOnHold
        Source: swagger_2_0
        Operation ID: ELCBT2001CrtBLOnHold_POSTUsingPOST
        
        
        Authentication: Not required
        
        Parameters:
        - request_body: any (required)
          input
        
        
        
        Headers:
        - Accesstoken: string
          Authorization Token to validation the caller
        - ChannelType: integer
          Channel identifier from where the TXN has originated (Internet, Mobile, ATM, Branch Channel )
        - co-Relationid: integer
          Unique ID for the service invoked, will be set by the TXN system
        - entity: string
          entity
        - initiatingSystem: string
          Indicating the initiated system
        - languageCode: integer
          languageCode
        - referenceId: string
          Place holder for Token based authentication
        - serviceMode: integer
          Used for branch channel to indicate the type of customer
        - userId: integer
          userId
        - uuidSeqNo: integer
          UUID Sequence Number
        
        
        """
        
        
        # Prepare request data
        
        # Single body parameter - send directly
        data = request_body if request_body is not None else {}
        
        
        
        # Prepare query parameters
        params = {}
        
        
        # Replace path parameters in URL
        path = "/tradeFinance/exportLetterOfCredit/bills/createOnHold"
        
        
        # Prepare headers
        headers = {}
        if accesstoken is not None:
            headers["Accesstoken"] = str(accesstoken)
        if channeltype is not None:
            headers["ChannelType"] = str(channeltype)
        if co_relationid is not None:
            headers["co-Relationid"] = str(co_relationid)
        if entity is not None:
            headers["entity"] = str(entity)
        if initiatingsystem is not None:
            headers["initiatingSystem"] = str(initiatingsystem)
        if languagecode is not None:
            headers["languageCode"] = str(languagecode)
        if referenceid is not None:
            headers["referenceId"] = str(referenceid)
        if servicemode is not None:
            headers["serviceMode"] = str(servicemode)
        if userid is not None:
            headers["userId"] = str(userid)
        if uuidseqno is not None:
            headers["uuidSeqNo"] = str(uuidseqno)
        
        
        return await make_api_request(
            "POST", 
            path, 
            data=data, 
            params=params if params else None, 
            headers=headers if headers else None
        )
    
    
    
    @mcp.tool()
    async def elcet2016_ftch_bldscrpncy_postusing_get(
        entity1: Optional[str] = None,
        transactionid: Optional[int] = None,
        transactiontype: Optional[int] = None,
        pagenum: Optional[int] = None,
        pagesize: Optional[int] = None,
        accesstoken: Optional[str] = None,
        channeltype: Optional[int] = None,
        co_relationid: Optional[int] = None,
        entity: Optional[str] = None,
        initiatingsystem: Optional[str] = None,
        languagecode: Optional[int] = None,
        referenceid: Optional[str] = None,
        servicemode: Optional[int] = None,
        userid: Optional[int] = None,
        uuidseqno: Optional[int] = None
    ) -> Dict[str, Any]:
        """
        Export Bill Lodgement Discepancy
        
        Generated from: GET /tradeFinance/exportLetterOfCredit/bills/discrepancyList
        Source: swagger_2_0
        Operation ID: ELCET2016FtchBLDscrpncy_POSTUsingGET
        
        
        Authentication: Not required
        
        Parameters:
        - Entity1: string
          Entity ID
        - TransactionID: integer
          Export Bill Transaction ID
        - TransactionType: integer
          Export Bill Transaction Type
        - pageNum: integer
          pageNum
        - pageSize: integer
          pageSize
        
        
        
        Headers:
        - Accesstoken: string
          Authorization Token to validation the caller
        - ChannelType: integer
          Channel identifier from where the TXN has originated (Internet, Mobile, ATM, Branch Channel )
        - co-Relationid: integer
          Unique ID for the service invoked, will be set by the TXN system
        - entity: string
          entity
        - initiatingSystem: string
          Indicating the initiated system
        - languageCode: integer
          languageCode
        - referenceId: string
          Place holder for Token based authentication
        - serviceMode: integer
          Used for branch channel to indicate the type of customer
        - userId: integer
          userId
        - uuidSeqNo: integer
          UUID Sequence Number
        
        
        """
        
        
        # Prepare query parameters
        params = {}
        if entity1 is not None:
            params["Entity1"] = entity1
            
        if transactionid is not None:
            params["TransactionID"] = transactionid
            
        if transactiontype is not None:
            params["TransactionType"] = transactiontype
            
        if pagenum is not None:
            params["pageNum"] = pagenum
            
        if pagesize is not None:
            params["pageSize"] = pagesize
            
        
        
        # Replace path parameters in URL
        path = "/tradeFinance/exportLetterOfCredit/bills/discrepancyList"
        
        
        # Prepare headers
        headers = {}
        if accesstoken is not None:
            headers["Accesstoken"] = str(accesstoken)
        if channeltype is not None:
            headers["ChannelType"] = str(channeltype)
        if co_relationid is not None:
            headers["co-Relationid"] = str(co_relationid)
        if entity is not None:
            headers["entity"] = str(entity)
        if initiatingsystem is not None:
            headers["initiatingSystem"] = str(initiatingsystem)
        if languagecode is not None:
            headers["languageCode"] = str(languagecode)
        if referenceid is not None:
            headers["referenceId"] = str(referenceid)
        if servicemode is not None:
            headers["serviceMode"] = str(servicemode)
        if userid is not None:
            headers["userId"] = str(userid)
        if uuidseqno is not None:
            headers["uuidSeqNo"] = str(uuidseqno)
        
        
        return await make_api_request(
            "GET", 
            path, 
            
            params=params if params else None, 
            headers=headers if headers else None
        )
    
    
    
    @mcp.tool()
    async def elcet2302_fetch_bldoc_dtls_postusing_get(
        entity1: Optional[str] = None,
        transactionid: Optional[int] = None,
        transactiontype: Optional[int] = None,
        pagenum: Optional[int] = None,
        pagesize: Optional[int] = None,
        accesstoken: Optional[str] = None,
        channeltype: Optional[int] = None,
        co_relationid: Optional[int] = None,
        entity: Optional[str] = None,
        initiatingsystem: Optional[str] = None,
        languagecode: Optional[int] = None,
        referenceid: Optional[str] = None,
        servicemode: Optional[int] = None,
        userid: Optional[int] = None,
        uuidseqno: Optional[int] = None
    ) -> Dict[str, Any]:
        """
        Documents Details under Export Bill Lodgement-List
        
        Generated from: GET /tradeFinance/exportLetterOfCredit/bills/documentList
        Source: swagger_2_0
        Operation ID: ELCET2302FetchBLDocDtls_POSTUsingGET
        
        
        Authentication: Not required
        
        Parameters:
        - Entity1: string
          Entity ID
        - TransactionID: integer
          Export Bill Transaction ID
        - TransactionType: integer
          Export Bill Transaction Type
        - pageNum: integer
          pageNum
        - pageSize: integer
          pageSize
        
        
        
        Headers:
        - Accesstoken: string
          Authorization Token to validation the caller
        - ChannelType: integer
          Channel identifier from where the TXN has originated (Internet, Mobile, ATM, Branch Channel )
        - co-Relationid: integer
          Unique ID for the service invoked, will be set by the TXN system
        - entity: string
          entity
        - initiatingSystem: string
          Indicating the initiated system
        - languageCode: integer
          languageCode
        - referenceId: string
          Place holder for Token based authentication
        - serviceMode: integer
          Used for branch channel to indicate the type of customer
        - userId: integer
          userId
        - uuidSeqNo: integer
          UUID Sequence Number
        
        
        """
        
        
        # Prepare query parameters
        params = {}
        if entity1 is not None:
            params["Entity1"] = entity1
            
        if transactionid is not None:
            params["TransactionID"] = transactionid
            
        if transactiontype is not None:
            params["TransactionType"] = transactiontype
            
        if pagenum is not None:
            params["pageNum"] = pagenum
            
        if pagesize is not None:
            params["pageSize"] = pagesize
            
        
        
        # Replace path parameters in URL
        path = "/tradeFinance/exportLetterOfCredit/bills/documentList"
        
        
        # Prepare headers
        headers = {}
        if accesstoken is not None:
            headers["Accesstoken"] = str(accesstoken)
        if channeltype is not None:
            headers["ChannelType"] = str(channeltype)
        if co_relationid is not None:
            headers["co-Relationid"] = str(co_relationid)
        if entity is not None:
            headers["entity"] = str(entity)
        if initiatingsystem is not None:
            headers["initiatingSystem"] = str(initiatingsystem)
        if languagecode is not None:
            headers["languageCode"] = str(languagecode)
        if referenceid is not None:
            headers["referenceId"] = str(referenceid)
        if servicemode is not None:
            headers["serviceMode"] = str(servicemode)
        if userid is not None:
            headers["userId"] = str(userid)
        if uuidseqno is not None:
            headers["uuidSeqNo"] = str(uuidseqno)
        
        
        return await make_api_request(
            "GET", 
            path, 
            
            params=params if params else None, 
            headers=headers if headers else None
        )
    
    
    
    @mcp.tool()
    async def elcbt2301_set_up_bldoc_dtls_postusing_post(
        request_body:Dict[str, Any] ,  # RegisterExportBillDocumentRequest,
        accesstoken: Optional[str] = None,
        channeltype: Optional[int] = None,
        co_relationid: Optional[int] = None,
        entity: Optional[str] = None,
        initiatingsystem: Optional[str] = None,
        languagecode: Optional[int] = None,
        referenceid: Optional[str] = None,
        servicemode: Optional[int] = None,
        userid: Optional[int] = None,
        uuidseqno: Optional[int] = None
    ) -> Dict[str, Any]:
        """
        Document Details under Export Bill Lodgement- Setup
        
        Generated from: POST /tradeFinance/exportLetterOfCredit/bills/documentSetup
        Source: swagger_2_0
        Operation ID: ELCBT2301SetUpBLDocDtls_POSTUsingPOST
        
        
        Authentication: Not required
        
        Parameters:
        - request_body: any (required)
          input
        
        
        
        Headers:
        - Accesstoken: string
          Authorization Token to validation the caller
        - ChannelType: integer
          Channel identifier from where the TXN has originated (Internet, Mobile, ATM, Branch Channel )
        - co-Relationid: integer
          Unique ID for the service invoked, will be set by the TXN system
        - entity: string
          entity
        - initiatingSystem: string
          Indicating the initiated system
        - languageCode: integer
          languageCode
        - referenceId: string
          Place holder for Token based authentication
        - serviceMode: integer
          Used for branch channel to indicate the type of customer
        - userId: integer
          userId
        - uuidSeqNo: integer
          UUID Sequence Number
        
        
        """
        
        
        # Prepare request data
        
        # Single body parameter - send directly
        data = request_body if request_body is not None else {}
        
        
        
        # Prepare query parameters
        params = {}
        
        
        # Replace path parameters in URL
        path = "/tradeFinance/exportLetterOfCredit/bills/documentSetup"
        
        
        # Prepare headers
        headers = {}
        if accesstoken is not None:
            headers["Accesstoken"] = str(accesstoken)
        if channeltype is not None:
            headers["ChannelType"] = str(channeltype)
        if co_relationid is not None:
            headers["co-Relationid"] = str(co_relationid)
        if entity is not None:
            headers["entity"] = str(entity)
        if initiatingsystem is not None:
            headers["initiatingSystem"] = str(initiatingsystem)
        if languagecode is not None:
            headers["languageCode"] = str(languagecode)
        if referenceid is not None:
            headers["referenceId"] = str(referenceid)
        if servicemode is not None:
            headers["serviceMode"] = str(servicemode)
        if userid is not None:
            headers["userId"] = str(userid)
        if uuidseqno is not None:
            headers["uuidSeqNo"] = str(uuidseqno)
        
        
        return await make_api_request(
            "POST", 
            path, 
            data=data, 
            params=params if params else None, 
            headers=headers if headers else None
        )
    
    
    
    @mcp.tool()
    async def elcbt2201_set_up_bldraft_dtls_postusing_post(
        request_body:Dict[str, Any] ,  # RegisterExportBillDraftRequest,
        accesstoken: Optional[str] = None,
        channeltype: Optional[int] = None,
        co_relationid: Optional[int] = None,
        entity: Optional[str] = None,
        initiatingsystem: Optional[str] = None,
        languagecode: Optional[int] = None,
        referenceid: Optional[str] = None,
        servicemode: Optional[int] = None,
        userid: Optional[int] = None,
        uuidseqno: Optional[int] = None
    ) -> Dict[str, Any]:
        """
        Draft Details under Export Bill Lodgement- Setup
        
        Generated from: POST /tradeFinance/exportLetterOfCredit/bills/draftSetup
        Source: swagger_2_0
        Operation ID: ELCBT2201SetUpBLDraftDtls_POSTUsingPOST
        
        
        Authentication: Not required
        
        Parameters:
        - request_body: any (required)
          input
        
        
        
        Headers:
        - Accesstoken: string
          Authorization Token to validation the caller
        - ChannelType: integer
          Channel identifier from where the TXN has originated (Internet, Mobile, ATM, Branch Channel )
        - co-Relationid: integer
          Unique ID for the service invoked, will be set by the TXN system
        - entity: string
          entity
        - initiatingSystem: string
          Indicating the initiated system
        - languageCode: integer
          languageCode
        - referenceId: string
          Place holder for Token based authentication
        - serviceMode: integer
          Used for branch channel to indicate the type of customer
        - userId: integer
          userId
        - uuidSeqNo: integer
          UUID Sequence Number
        
        
        """
        
        
        # Prepare request data
        
        # Single body parameter - send directly
        data = request_body if request_body is not None else {}
        
        
        
        # Prepare query parameters
        params = {}
        
        
        # Replace path parameters in URL
        path = "/tradeFinance/exportLetterOfCredit/bills/draftSetup"
        
        
        # Prepare headers
        headers = {}
        if accesstoken is not None:
            headers["Accesstoken"] = str(accesstoken)
        if channeltype is not None:
            headers["ChannelType"] = str(channeltype)
        if co_relationid is not None:
            headers["co-Relationid"] = str(co_relationid)
        if entity is not None:
            headers["entity"] = str(entity)
        if initiatingsystem is not None:
            headers["initiatingSystem"] = str(initiatingsystem)
        if languagecode is not None:
            headers["languageCode"] = str(languagecode)
        if referenceid is not None:
            headers["referenceId"] = str(referenceid)
        if servicemode is not None:
            headers["serviceMode"] = str(servicemode)
        if userid is not None:
            headers["userId"] = str(userid)
        if uuidseqno is not None:
            headers["uuidSeqNo"] = str(uuidseqno)
        
        
        return await make_api_request(
            "POST", 
            path, 
            data=data, 
            params=params if params else None, 
            headers=headers if headers else None
        )
    
    
    
    @mcp.tool()
    async def elcet2202_get_bldraft_dtls_postusing_get(
        entity1: Optional[str] = None,
        transactionid: Optional[int] = None,
        transactiontype: Optional[int] = None,
        pagenum: Optional[int] = None,
        pagesize: Optional[int] = None,
        accesstoken: Optional[str] = None,
        channeltype: Optional[int] = None,
        co_relationid: Optional[int] = None,
        entity: Optional[str] = None,
        initiatingsystem: Optional[str] = None,
        languagecode: Optional[int] = None,
        referenceid: Optional[str] = None,
        servicemode: Optional[int] = None,
        userid: Optional[int] = None,
        uuidseqno: Optional[int] = None
    ) -> Dict[str, Any]:
        """
        Draft Details under Export Bill Lodgement- View
        
        Generated from: GET /tradeFinance/exportLetterOfCredit/bills/draftView
        Source: swagger_2_0
        Operation ID: ELCET2202GetBLDraftDtls_POSTUsingGET
        
        
        Authentication: Not required
        
        Parameters:
        - Entity1: string
          Entity ID
        - TransactionID: integer
          Ebl Transaction ID
        - TransactionType: integer
          Ebl Transaction Type
        - pageNum: integer
          pageNum
        - pageSize: integer
          pageSize
        
        
        
        Headers:
        - Accesstoken: string
          Authorization Token to validation the caller
        - ChannelType: integer
          Channel identifier from where the TXN has originated (Internet, Mobile, ATM, Branch Channel )
        - co-Relationid: integer
          Unique ID for the service invoked, will be set by the TXN system
        - entity: string
          entity
        - initiatingSystem: string
          Indicating the initiated system
        - languageCode: integer
          languageCode
        - referenceId: string
          Place holder for Token based authentication
        - serviceMode: integer
          Used for branch channel to indicate the type of customer
        - userId: integer
          userId
        - uuidSeqNo: integer
          UUID Sequence Number
        
        
        """
        
        
        # Prepare query parameters
        params = {}
        if entity1 is not None:
            params["Entity1"] = entity1
            
        if transactionid is not None:
            params["TransactionID"] = transactionid
            
        if transactiontype is not None:
            params["TransactionType"] = transactiontype
            
        if pagenum is not None:
            params["pageNum"] = pagenum
            
        if pagesize is not None:
            params["pageSize"] = pagesize
            
        
        
        # Replace path parameters in URL
        path = "/tradeFinance/exportLetterOfCredit/bills/draftView"
        
        
        # Prepare headers
        headers = {}
        if accesstoken is not None:
            headers["Accesstoken"] = str(accesstoken)
        if channeltype is not None:
            headers["ChannelType"] = str(channeltype)
        if co_relationid is not None:
            headers["co-Relationid"] = str(co_relationid)
        if entity is not None:
            headers["entity"] = str(entity)
        if initiatingsystem is not None:
            headers["initiatingSystem"] = str(initiatingsystem)
        if languagecode is not None:
            headers["languageCode"] = str(languagecode)
        if referenceid is not None:
            headers["referenceId"] = str(referenceid)
        if servicemode is not None:
            headers["serviceMode"] = str(servicemode)
        if userid is not None:
            headers["userId"] = str(userid)
        if uuidseqno is not None:
            headers["uuidSeqNo"] = str(uuidseqno)
        
        
        return await make_api_request(
            "GET", 
            path, 
            
            params=params if params else None, 
            headers=headers if headers else None
        )
    
    
    
    @mcp.tool()
    async def elcet2021_fetch_bill_list_postusing_get(
        billamt: Optional[str] = None,
        billcurr: Optional[str] = None,
        customerid: Optional[str] = None,
        customername: Optional[str] = None,
        eblextreference: Optional[str] = None,
        elcadvisingref: Optional[str] = None,
        elcstartdate: Optional[str] = None,
        enddate: Optional[str] = None,
        pagenum: Optional[int] = None,
        pagesize: Optional[int] = None,
        startdate: Optional[str] = None,
        status: Optional[str] = None,
        transactionid: Optional[str] = None,
        accesstoken: Optional[str] = None,
        channeltype: Optional[int] = None,
        co_relationid: Optional[int] = None,
        entity: Optional[str] = None,
        initiatingsystem: Optional[str] = None,
        languagecode: Optional[int] = None,
        referenceid: Optional[str] = None,
        servicemode: Optional[int] = None,
        userid: Optional[int] = None,
        uuidseqno: Optional[int] = None
    ) -> Dict[str, Any]:
        """
        Export Bill Lodgement List
        
        Generated from: GET /tradeFinance/exportLetterOfCredit/bills/list
        Source: swagger_2_0
        Operation ID: ELCET2021FetchBillList_POSTUsingGET
        
        
        Authentication: Not required
        
        Parameters:
        - billAmt: string
          Bill Amount
        - billCurr: string
          Bill currency
        - customerId: string
          CIF ID
        - customerName: string
          Customer Name
        - eblExtReference: string
          Bill Reference
        - elcAdvisingRef: string
          LC Advising Ref
        - elcStartDate: string
          Start Date
        - endDate: string
          End Date
        - pageNum: integer
          pageNum
        - pageSize: integer
          pageSize
        - startDate: string
          Bill Date
        - status: string
          Bill Status - Available status supported in system: 1 - OnHold,2 - Released,3 - Verified,4 - Rejected,5 - Accepted,6 - Lodged,9 - Refused,10 - PartiallyPaid,11 - BillPaid. For All Available Status refer d_TFBlStat
        - transactionId: string
          Unique reference ID
        
        
        
        Headers:
        - Accesstoken: string
          Authorization Token to validation the caller
        - ChannelType: integer
          Channel identifier from where the TXN has originated (Internet, Mobile, ATM, Branch Channel )
        - co-Relationid: integer
          Unique ID for the service invoked, will be set by the TXN system
        - entity: string
          entity
        - initiatingSystem: string
          Indicating the initiated system
        - languageCode: integer
          languageCode
        - referenceId: string
          Place holder for Token based authentication
        - serviceMode: integer
          Used for branch channel to indicate the type of customer
        - userId: integer
          userId
        - uuidSeqNo: integer
          UUID Sequence Number
        
        
        """
        
        
        # Prepare query parameters
        params = {}
        if billamt is not None:
            params["billAmt"] = billamt
            
        if billcurr is not None:
            params["billCurr"] = billcurr
            
        if customerid is not None:
            params["customerId"] = customerid
            
        if customername is not None:
            params["customerName"] = customername
            
        if eblextreference is not None:
            params["eblExtReference"] = eblextreference
            
        if elcadvisingref is not None:
            params["elcAdvisingRef"] = elcadvisingref
            
        if elcstartdate is not None:
            params["elcStartDate"] = elcstartdate
            
        if enddate is not None:
            params["endDate"] = enddate
            
        if pagenum is not None:
            params["pageNum"] = pagenum
            
        if pagesize is not None:
            params["pageSize"] = pagesize
            
        if startdate is not None:
            params["startDate"] = startdate
            
        if status is not None:
            params["status"] = status
            
        if transactionid is not None:
            params["transactionId"] = transactionid
            
        
        
        # Replace path parameters in URL
        path = "/tradeFinance/exportLetterOfCredit/bills/list"
        
        
        # Prepare headers
        headers = {}
        if accesstoken is not None:
            headers["Accesstoken"] = str(accesstoken)
        if channeltype is not None:
            headers["ChannelType"] = str(channeltype)
        if co_relationid is not None:
            headers["co-Relationid"] = str(co_relationid)
        if entity is not None:
            headers["entity"] = str(entity)
        if initiatingsystem is not None:
            headers["initiatingSystem"] = str(initiatingsystem)
        if languagecode is not None:
            headers["languageCode"] = str(languagecode)
        if referenceid is not None:
            headers["referenceId"] = str(referenceid)
        if servicemode is not None:
            headers["serviceMode"] = str(servicemode)
        if userid is not None:
            headers["userId"] = str(userid)
        if uuidseqno is not None:
            headers["uuidSeqNo"] = str(uuidseqno)
        
        
        return await make_api_request(
            "GET", 
            path, 
            
            params=params if params else None, 
            headers=headers if headers else None
        )
    
    
    
    @mcp.tool()
    async def elcbt2002_blon_hold_to_on_hold_postusing_post(
        request_body:Dict[str, Any] ,  # RegisterExportBillModifyRequest,
        accesstoken: Optional[str] = None,
        channeltype: Optional[int] = None,
        co_relationid: Optional[int] = None,
        entity: Optional[str] = None,
        initiatingsystem: Optional[str] = None,
        languagecode: Optional[int] = None,
        referenceid: Optional[str] = None,
        servicemode: Optional[int] = None,
        userid: Optional[int] = None,
        uuidseqno: Optional[int] = None
    ) -> Dict[str, Any]:
        """
        Export Bill Lodgement Modify
        
        Generated from: POST /tradeFinance/exportLetterOfCredit/bills/modify
        Source: swagger_2_0
        Operation ID: ELCBT2002BLOnHoldToOnHold_POSTUsingPOST
        
        
        Authentication: Not required
        
        Parameters:
        - request_body: any (required)
          input
        
        
        
        Headers:
        - Accesstoken: string
          Authorization Token to validation the caller
        - ChannelType: integer
          Channel identifier from where the TXN has originated (Internet, Mobile, ATM, Branch Channel )
        - co-Relationid: integer
          Unique ID for the service invoked, will be set by the TXN system
        - entity: string
          entity
        - initiatingSystem: string
          Indicating the initiated system
        - languageCode: integer
          languageCode
        - referenceId: string
          Place holder for Token based authentication
        - serviceMode: integer
          Used for branch channel to indicate the type of customer
        - userId: integer
          userId
        - uuidSeqNo: integer
          UUID Sequence Number
        
        
        """
        
        
        # Prepare request data
        
        # Single body parameter - send directly
        data = request_body if request_body is not None else {}
        
        
        
        # Prepare query parameters
        params = {}
        
        
        # Replace path parameters in URL
        path = "/tradeFinance/exportLetterOfCredit/bills/modify"
        
        
        # Prepare headers
        headers = {}
        if accesstoken is not None:
            headers["Accesstoken"] = str(accesstoken)
        if channeltype is not None:
            headers["ChannelType"] = str(channeltype)
        if co_relationid is not None:
            headers["co-Relationid"] = str(co_relationid)
        if entity is not None:
            headers["entity"] = str(entity)
        if initiatingsystem is not None:
            headers["initiatingSystem"] = str(initiatingsystem)
        if languagecode is not None:
            headers["languageCode"] = str(languagecode)
        if referenceid is not None:
            headers["referenceId"] = str(referenceid)
        if servicemode is not None:
            headers["serviceMode"] = str(servicemode)
        if userid is not None:
            headers["userId"] = str(userid)
        if uuidseqno is not None:
            headers["uuidSeqNo"] = str(uuidseqno)
        
        
        return await make_api_request(
            "POST", 
            path, 
            data=data, 
            params=params if params else None, 
            headers=headers if headers else None
        )
    
    
    
    @mcp.tool()
    async def elcbt5985_modify_draft_dtls_postusing_post(
        modeflg: int,
        request_body:Dict[str, Any] ,  # elcBillDraftDtlsModifyDraftDtlsRequest,
        accesstoken: Optional[str] = None,
        channeltype: Optional[int] = None,
        co_relationid: Optional[int] = None,
        entity: Optional[str] = None,
        initiatingsystem: Optional[str] = None,
        languagecode: Optional[int] = None,
        referenceid: Optional[str] = None,
        servicemode: Optional[int] = None,
        userid: Optional[int] = None,
        uuidseqno: Optional[int] = None
    ) -> Dict[str, Any]:
        """
        Modify Draft Details
        
        Generated from: POST /tradeFinance/exportLetterOfCredit/bills/modifyMaturityDate
        Source: swagger_2_0
        Operation ID: ELCBT5985ModifyDraftDtls_POSTUsingPOST
        
        
        Authentication: Not required
        
        Parameters:
        - modeFlg: integer (required)
          Mode Flag. Possible values : 1 - Add, 10 - Authorize, 11 - Reject Domain name :  d_ModeFlg_Add,d_ModeFlg_Authorised and d_ModeFlg_Reject 
        - request_body: any (required)
          input
        
        
        
        Headers:
        - Accesstoken: string
          Authorization Token to validation the caller
        - ChannelType: integer
          Channel identifier from where the TXN has originated (Internet, Mobile, ATM, Branch Channel )
        - co-Relationid: integer
          Unique ID for the service invoked, will be set by the TXN system
        - entity: string
          entity
        - initiatingSystem: string
          Indicating the initiated system
        - languageCode: integer
          languageCode
        - referenceId: string
          Place holder for Token based authentication
        - serviceMode: integer
          Used for branch channel to indicate the type of customer
        - userId: integer
          userId
        - uuidSeqNo: integer
          UUID Sequence Number
        
        
        """
        
        
        # Prepare request data
        
        # Single body parameter - send directly
        data = request_body if request_body is not None else {}
        
        
        
        # Prepare query parameters
        params = {}
        if modeflg is not None:
            params["modeFlg"] = modeflg
            
        
        
        # Replace path parameters in URL
        path = "/tradeFinance/exportLetterOfCredit/bills/modifyMaturityDate"
        
        
        # Prepare headers
        headers = {}
        if accesstoken is not None:
            headers["Accesstoken"] = str(accesstoken)
        if channeltype is not None:
            headers["ChannelType"] = str(channeltype)
        if co_relationid is not None:
            headers["co-Relationid"] = str(co_relationid)
        if entity is not None:
            headers["entity"] = str(entity)
        if initiatingsystem is not None:
            headers["initiatingSystem"] = str(initiatingsystem)
        if languagecode is not None:
            headers["languageCode"] = str(languagecode)
        if referenceid is not None:
            headers["referenceId"] = str(referenceid)
        if servicemode is not None:
            headers["serviceMode"] = str(servicemode)
        if userid is not None:
            headers["userId"] = str(userid)
        if uuidseqno is not None:
            headers["uuidSeqNo"] = str(uuidseqno)
        
        
        return await make_api_request(
            "POST", 
            path, 
            data=data, 
            params=params if params else None, 
            headers=headers if headers else None
        )
    
    
    
    @mcp.tool()
    async def elcbt2101_set_up_blprty_dtls_postusing_post(
        request_body:Dict[str, Any] ,  # RegisterExportBillPartyRequest,
        accesstoken: Optional[str] = None,
        channeltype: Optional[int] = None,
        co_relationid: Optional[int] = None,
        entity: Optional[str] = None,
        initiatingsystem: Optional[str] = None,
        languagecode: Optional[int] = None,
        referenceid: Optional[str] = None,
        servicemode: Optional[int] = None,
        userid: Optional[int] = None,
        uuidseqno: Optional[int] = None
    ) -> Dict[str, Any]:
        """
        Party Details under Export Bill Lodgement- Setup
        
        Generated from: POST /tradeFinance/exportLetterOfCredit/bills/partySetup
        Source: swagger_2_0
        Operation ID: ELCBT2101SetUpBLPrtyDtls_POSTUsingPOST
        
        
        Authentication: Not required
        
        Parameters:
        - request_body: any (required)
          input
        
        
        
        Headers:
        - Accesstoken: string
          Authorization Token to validation the caller
        - ChannelType: integer
          Channel identifier from where the TXN has originated (Internet, Mobile, ATM, Branch Channel )
        - co-Relationid: integer
          Unique ID for the service invoked, will be set by the TXN system
        - entity: string
          entity
        - initiatingSystem: string
          Indicating the initiated system
        - languageCode: integer
          languageCode
        - referenceId: string
          Place holder for Token based authentication
        - serviceMode: integer
          Used for branch channel to indicate the type of customer
        - userId: integer
          userId
        - uuidSeqNo: integer
          UUID Sequence Number
        
        
        """
        
        
        # Prepare request data
        
        # Single body parameter - send directly
        data = request_body if request_body is not None else {}
        
        
        
        # Prepare query parameters
        params = {}
        
        
        # Replace path parameters in URL
        path = "/tradeFinance/exportLetterOfCredit/bills/partySetup"
        
        
        # Prepare headers
        headers = {}
        if accesstoken is not None:
            headers["Accesstoken"] = str(accesstoken)
        if channeltype is not None:
            headers["ChannelType"] = str(channeltype)
        if co_relationid is not None:
            headers["co-Relationid"] = str(co_relationid)
        if entity is not None:
            headers["entity"] = str(entity)
        if initiatingsystem is not None:
            headers["initiatingSystem"] = str(initiatingsystem)
        if languagecode is not None:
            headers["languageCode"] = str(languagecode)
        if referenceid is not None:
            headers["referenceId"] = str(referenceid)
        if servicemode is not None:
            headers["serviceMode"] = str(servicemode)
        if userid is not None:
            headers["userId"] = str(userid)
        if uuidseqno is not None:
            headers["uuidSeqNo"] = str(uuidseqno)
        
        
        return await make_api_request(
            "POST", 
            path, 
            data=data, 
            params=params if params else None, 
            headers=headers if headers else None
        )
    
    
    
    @mcp.tool()
    async def elcet2102_get_blprty_dtls_postusing_get(
        entity1: Optional[str] = None,
        transactionid: Optional[int] = None,
        transactiontype: Optional[int] = None,
        pagenum: Optional[int] = None,
        pagesize: Optional[int] = None,
        accesstoken: Optional[str] = None,
        channeltype: Optional[int] = None,
        co_relationid: Optional[int] = None,
        entity: Optional[str] = None,
        initiatingsystem: Optional[str] = None,
        languagecode: Optional[int] = None,
        referenceid: Optional[str] = None,
        servicemode: Optional[int] = None,
        userid: Optional[int] = None,
        uuidseqno: Optional[int] = None
    ) -> Dict[str, Any]:
        """
        Party Details under Export Bill Lodgement- View
        
        Generated from: GET /tradeFinance/exportLetterOfCredit/bills/partyView
        Source: swagger_2_0
        Operation ID: ELCET2102GetBLPrtyDtls_POSTUsingGET
        
        
        Authentication: Not required
        
        Parameters:
        - Entity1: string
          Entity ID
        - TransactionID: integer
          Ebl Transaction ID
        - TransactionType: integer
          Ebl Transaction Type
        - pageNum: integer
          pageNum
        - pageSize: integer
          pageSize
        
        
        
        Headers:
        - Accesstoken: string
          Authorization Token to validation the caller
        - ChannelType: integer
          Channel identifier from where the TXN has originated (Internet, Mobile, ATM, Branch Channel )
        - co-Relationid: integer
          Unique ID for the service invoked, will be set by the TXN system
        - entity: string
          entity
        - initiatingSystem: string
          Indicating the initiated system
        - languageCode: integer
          languageCode
        - referenceId: string
          Place holder for Token based authentication
        - serviceMode: integer
          Used for branch channel to indicate the type of customer
        - userId: integer
          userId
        - uuidSeqNo: integer
          UUID Sequence Number
        
        
        """
        
        
        # Prepare query parameters
        params = {}
        if entity1 is not None:
            params["Entity1"] = entity1
            
        if transactionid is not None:
            params["TransactionID"] = transactionid
            
        if transactiontype is not None:
            params["TransactionType"] = transactiontype
            
        if pagenum is not None:
            params["pageNum"] = pagenum
            
        if pagesize is not None:
            params["pageSize"] = pagesize
            
        
        
        # Replace path parameters in URL
        path = "/tradeFinance/exportLetterOfCredit/bills/partyView"
        
        
        # Prepare headers
        headers = {}
        if accesstoken is not None:
            headers["Accesstoken"] = str(accesstoken)
        if channeltype is not None:
            headers["ChannelType"] = str(channeltype)
        if co_relationid is not None:
            headers["co-Relationid"] = str(co_relationid)
        if entity is not None:
            headers["entity"] = str(entity)
        if initiatingsystem is not None:
            headers["initiatingSystem"] = str(initiatingsystem)
        if languagecode is not None:
            headers["languageCode"] = str(languagecode)
        if referenceid is not None:
            headers["referenceId"] = str(referenceid)
        if servicemode is not None:
            headers["serviceMode"] = str(servicemode)
        if userid is not None:
            headers["userId"] = str(userid)
        if uuidseqno is not None:
            headers["uuidSeqNo"] = str(uuidseqno)
        
        
        return await make_api_request(
            "GET", 
            path, 
            
            params=params if params else None, 
            headers=headers if headers else None
        )
    
    
    
    @mcp.tool()
    async def elcbt2006_blrlsd_to_rjct_postusing_post(
        request_body:Dict[str, Any] ,  # RegisterExportBillRejectRequest,
        accesstoken: Optional[str] = None,
        channeltype: Optional[int] = None,
        co_relationid: Optional[int] = None,
        entity: Optional[str] = None,
        initiatingsystem: Optional[str] = None,
        languagecode: Optional[int] = None,
        referenceid: Optional[str] = None,
        servicemode: Optional[int] = None,
        userid: Optional[int] = None,
        uuidseqno: Optional[int] = None
    ) -> Dict[str, Any]:
        """
        Reject Export Bill Lodgement
        
        Generated from: POST /tradeFinance/exportLetterOfCredit/bills/reject
        Source: swagger_2_0
        Operation ID: ELCBT2006BLRlsdToRjct_POSTUsingPOST
        
        
        Authentication: Not required
        
        Parameters:
        - request_body: any (required)
          input
        
        
        
        Headers:
        - Accesstoken: string
          Authorization Token to validation the caller
        - ChannelType: integer
          Channel identifier from where the TXN has originated (Internet, Mobile, ATM, Branch Channel )
        - co-Relationid: integer
          Unique ID for the service invoked, will be set by the TXN system
        - entity: string
          entity
        - initiatingSystem: string
          Indicating the initiated system
        - languageCode: integer
          languageCode
        - referenceId: string
          Place holder for Token based authentication
        - serviceMode: integer
          Used for branch channel to indicate the type of customer
        - userId: integer
          userId
        - uuidSeqNo: integer
          UUID Sequence Number
        
        
        """
        
        
        # Prepare request data
        
        # Single body parameter - send directly
        data = request_body if request_body is not None else {}
        
        
        
        # Prepare query parameters
        params = {}
        
        
        # Replace path parameters in URL
        path = "/tradeFinance/exportLetterOfCredit/bills/reject"
        
        
        # Prepare headers
        headers = {}
        if accesstoken is not None:
            headers["Accesstoken"] = str(accesstoken)
        if channeltype is not None:
            headers["ChannelType"] = str(channeltype)
        if co_relationid is not None:
            headers["co-Relationid"] = str(co_relationid)
        if entity is not None:
            headers["entity"] = str(entity)
        if initiatingsystem is not None:
            headers["initiatingSystem"] = str(initiatingsystem)
        if languagecode is not None:
            headers["languageCode"] = str(languagecode)
        if referenceid is not None:
            headers["referenceId"] = str(referenceid)
        if servicemode is not None:
            headers["serviceMode"] = str(servicemode)
        if userid is not None:
            headers["userId"] = str(userid)
        if uuidseqno is not None:
            headers["uuidSeqNo"] = str(uuidseqno)
        
        
        return await make_api_request(
            "POST", 
            path, 
            data=data, 
            params=params if params else None, 
            headers=headers if headers else None
        )
    
    
    
    @mcp.tool()
    async def elcet2012_fetch_bldtls_postusing_get(
        customerid: Optional[int] = None,
        customername: Optional[str] = None,
        eblreferenceexternal: Optional[str] = None,
        eblreferenceinternal: Optional[str] = None,
        ebltransactionid: Optional[int] = None,
        elcreferenceexternal: Optional[str] = None,
        elcreferenceinternal: Optional[str] = None,
        pagenum: Optional[int] = None,
        pagesize: Optional[int] = None,
        accesstoken: Optional[str] = None,
        channeltype: Optional[int] = None,
        co_relationid: Optional[int] = None,
        entity: Optional[str] = None,
        initiatingsystem: Optional[str] = None,
        languagecode: Optional[int] = None,
        referenceid: Optional[str] = None,
        servicemode: Optional[int] = None,
        userid: Optional[int] = None,
        uuidseqno: Optional[int] = None
    ) -> Dict[str, Any]:
        """
        Export Bill Lodgement Search
        
        Generated from: GET /tradeFinance/exportLetterOfCredit/bills/search
        Source: swagger_2_0
        Operation ID: ELCET2012FetchBLDtls_POSTUsingGET
        
        
        Authentication: Not required
        
        Parameters:
        - CustomerId: integer
          Customer ID
        - CustomerName: string
          Customer Name
        - EblReferenceExternal: string
          Bill Reference External
        - EblReferenceInternal: string
          Bill Reference Internal
        - EblTransactionId: integer
          TransactionReference
        - ElcReferenceExternal: string
          Export Reference External
        - ElcReferenceInternal: string
          Export Reference Internal
        - pageNum: integer
          pageNum
        - pageSize: integer
          pageSize
        
        
        
        Headers:
        - Accesstoken: string
          Authorization Token to validation the caller
        - ChannelType: integer
          Channel identifier from where the TXN has originated (Internet, Mobile, ATM, Branch Channel )
        - co-Relationid: integer
          Unique ID for the service invoked, will be set by the TXN system
        - entity: string
          entity
        - initiatingSystem: string
          Indicating the initiated system
        - languageCode: integer
          languageCode
        - referenceId: string
          Place holder for Token based authentication
        - serviceMode: integer
          Used for branch channel to indicate the type of customer
        - userId: integer
          userId
        - uuidSeqNo: integer
          UUID Sequence Number
        
        
        """
        
        
        # Prepare query parameters
        params = {}
        if customerid is not None:
            params["CustomerId"] = customerid
            
        if customername is not None:
            params["CustomerName"] = customername
            
        if eblreferenceexternal is not None:
            params["EblReferenceExternal"] = eblreferenceexternal
            
        if eblreferenceinternal is not None:
            params["EblReferenceInternal"] = eblreferenceinternal
            
        if ebltransactionid is not None:
            params["EblTransactionId"] = ebltransactionid
            
        if elcreferenceexternal is not None:
            params["ElcReferenceExternal"] = elcreferenceexternal
            
        if elcreferenceinternal is not None:
            params["ElcReferenceInternal"] = elcreferenceinternal
            
        if pagenum is not None:
            params["pageNum"] = pagenum
            
        if pagesize is not None:
            params["pageSize"] = pagesize
            
        
        
        # Replace path parameters in URL
        path = "/tradeFinance/exportLetterOfCredit/bills/search"
        
        
        # Prepare headers
        headers = {}
        if accesstoken is not None:
            headers["Accesstoken"] = str(accesstoken)
        if channeltype is not None:
            headers["ChannelType"] = str(channeltype)
        if co_relationid is not None:
            headers["co-Relationid"] = str(co_relationid)
        if entity is not None:
            headers["entity"] = str(entity)
        if initiatingsystem is not None:
            headers["initiatingSystem"] = str(initiatingsystem)
        if languagecode is not None:
            headers["languageCode"] = str(languagecode)
        if referenceid is not None:
            headers["referenceId"] = str(referenceid)
        if servicemode is not None:
            headers["serviceMode"] = str(servicemode)
        if userid is not None:
            headers["userId"] = str(userid)
        if uuidseqno is not None:
            headers["uuidSeqNo"] = str(uuidseqno)
        
        
        return await make_api_request(
            "GET", 
            path, 
            
            params=params if params else None, 
            headers=headers if headers else None
        )
    
    
    
    @mcp.tool()
    async def elcbt2007_blrlsd_to_on_hold_postusing_post(
        request_body:Dict[str, Any] ,  # RegisterExportBillSendbackRequest,
        accesstoken: Optional[str] = None,
        channeltype: Optional[int] = None,
        co_relationid: Optional[int] = None,
        entity: Optional[str] = None,
        initiatingsystem: Optional[str] = None,
        languagecode: Optional[int] = None,
        referenceid: Optional[str] = None,
        servicemode: Optional[int] = None,
        userid: Optional[int] = None,
        uuidseqno: Optional[int] = None
    ) -> Dict[str, Any]:
        """
        Sendback Export Bill Lodgement
        
        Generated from: POST /tradeFinance/exportLetterOfCredit/bills/sendback
        Source: swagger_2_0
        Operation ID: ELCBT2007BLRlsdToOnHold_POSTUsingPOST
        
        
        Authentication: Not required
        
        Parameters:
        - request_body: any (required)
          input
        
        
        
        Headers:
        - Accesstoken: string
          Authorization Token to validation the caller
        - ChannelType: integer
          Channel identifier from where the TXN has originated (Internet, Mobile, ATM, Branch Channel )
        - co-Relationid: integer
          Unique ID for the service invoked, will be set by the TXN system
        - entity: string
          entity
        - initiatingSystem: string
          Indicating the initiated system
        - languageCode: integer
          languageCode
        - referenceId: string
          Place holder for Token based authentication
        - serviceMode: integer
          Used for branch channel to indicate the type of customer
        - userId: integer
          userId
        - uuidSeqNo: integer
          UUID Sequence Number
        
        
        """
        
        
        # Prepare request data
        
        # Single body parameter - send directly
        data = request_body if request_body is not None else {}
        
        
        
        # Prepare query parameters
        params = {}
        
        
        # Replace path parameters in URL
        path = "/tradeFinance/exportLetterOfCredit/bills/sendback"
        
        
        # Prepare headers
        headers = {}
        if accesstoken is not None:
            headers["Accesstoken"] = str(accesstoken)
        if channeltype is not None:
            headers["ChannelType"] = str(channeltype)
        if co_relationid is not None:
            headers["co-Relationid"] = str(co_relationid)
        if entity is not None:
            headers["entity"] = str(entity)
        if initiatingsystem is not None:
            headers["initiatingSystem"] = str(initiatingsystem)
        if languagecode is not None:
            headers["languageCode"] = str(languagecode)
        if referenceid is not None:
            headers["referenceId"] = str(referenceid)
        if servicemode is not None:
            headers["serviceMode"] = str(servicemode)
        if userid is not None:
            headers["userId"] = str(userid)
        if uuidseqno is not None:
            headers["uuidSeqNo"] = str(uuidseqno)
        
        
        return await make_api_request(
            "POST", 
            path, 
            data=data, 
            params=params if params else None, 
            headers=headers if headers else None
        )
    
    
    
    @mcp.tool()
    async def elcbt2401_set_up_blshpmnt_dtls_postusing_post(
        request_body:Dict[str, Any] ,  # RegisterExportBillshipRequest,
        accesstoken: Optional[str] = None,
        channeltype: Optional[int] = None,
        co_relationid: Optional[int] = None,
        entity: Optional[str] = None,
        initiatingsystem: Optional[str] = None,
        languagecode: Optional[int] = None,
        referenceid: Optional[str] = None,
        servicemode: Optional[int] = None,
        userid: Optional[int] = None,
        uuidseqno: Optional[int] = None
    ) -> Dict[str, Any]:
        """
        Shipment Details under Export Bill Lodgement- Setup
        
        Generated from: POST /tradeFinance/exportLetterOfCredit/bills/shipmentSetup
        Source: swagger_2_0
        Operation ID: ELCBT2401SetUpBLShpmntDtls_POSTUsingPOST
        
        
        Authentication: Not required
        
        Parameters:
        - request_body: any (required)
          input
        
        
        
        Headers:
        - Accesstoken: string
          Authorization Token to validation the caller
        - ChannelType: integer
          Channel identifier from where the TXN has originated (Internet, Mobile, ATM, Branch Channel )
        - co-Relationid: integer
          Unique ID for the service invoked, will be set by the TXN system
        - entity: string
          entity
        - initiatingSystem: string
          Indicating the initiated system
        - languageCode: integer
          languageCode
        - referenceId: string
          Place holder for Token based authentication
        - serviceMode: integer
          Used for branch channel to indicate the type of customer
        - userId: integer
          userId
        - uuidSeqNo: integer
          UUID Sequence Number
        
        
        """
        
        
        # Prepare request data
        
        # Single body parameter - send directly
        data = request_body if request_body is not None else {}
        
        
        
        # Prepare query parameters
        params = {}
        
        
        # Replace path parameters in URL
        path = "/tradeFinance/exportLetterOfCredit/bills/shipmentSetup"
        
        
        # Prepare headers
        headers = {}
        if accesstoken is not None:
            headers["Accesstoken"] = str(accesstoken)
        if channeltype is not None:
            headers["ChannelType"] = str(channeltype)
        if co_relationid is not None:
            headers["co-Relationid"] = str(co_relationid)
        if entity is not None:
            headers["entity"] = str(entity)
        if initiatingsystem is not None:
            headers["initiatingSystem"] = str(initiatingsystem)
        if languagecode is not None:
            headers["languageCode"] = str(languagecode)
        if referenceid is not None:
            headers["referenceId"] = str(referenceid)
        if servicemode is not None:
            headers["serviceMode"] = str(servicemode)
        if userid is not None:
            headers["userId"] = str(userid)
        if uuidseqno is not None:
            headers["uuidSeqNo"] = str(uuidseqno)
        
        
        return await make_api_request(
            "POST", 
            path, 
            data=data, 
            params=params if params else None, 
            headers=headers if headers else None
        )
    
    
    
    @mcp.tool()
    async def elcet2402_get_blshpmnt_dtls_postusing_get(
        entity1: Optional[str] = None,
        transactionid: Optional[int] = None,
        transactiontype: Optional[int] = None,
        pagenum: Optional[int] = None,
        pagesize: Optional[int] = None,
        accesstoken: Optional[str] = None,
        channeltype: Optional[int] = None,
        co_relationid: Optional[int] = None,
        entity: Optional[str] = None,
        initiatingsystem: Optional[str] = None,
        languagecode: Optional[int] = None,
        referenceid: Optional[str] = None,
        servicemode: Optional[int] = None,
        userid: Optional[int] = None,
        uuidseqno: Optional[int] = None
    ) -> Dict[str, Any]:
        """
        Shipment Details under Export Bill Lodgement-View
        
        Generated from: GET /tradeFinance/exportLetterOfCredit/bills/shipmentView
        Source: swagger_2_0
        Operation ID: ELCET2402GetBLShpmntDtls_POSTUsingGET
        
        
        Authentication: Not required
        
        Parameters:
        - Entity1: string
          Entity ID
        - TransactionID: integer
          Ebl Transaction Id
        - TransactionType: integer
          Ebl Transaction Type
        - pageNum: integer
          pageNum
        - pageSize: integer
          pageSize
        
        
        
        Headers:
        - Accesstoken: string
          Authorization Token to validation the caller
        - ChannelType: integer
          Channel identifier from where the TXN has originated (Internet, Mobile, ATM, Branch Channel )
        - co-Relationid: integer
          Unique ID for the service invoked, will be set by the TXN system
        - entity: string
          entity
        - initiatingSystem: string
          Indicating the initiated system
        - languageCode: integer
          languageCode
        - referenceId: string
          Place holder for Token based authentication
        - serviceMode: integer
          Used for branch channel to indicate the type of customer
        - userId: integer
          userId
        - uuidSeqNo: integer
          UUID Sequence Number
        
        
        """
        
        
        # Prepare query parameters
        params = {}
        if entity1 is not None:
            params["Entity1"] = entity1
            
        if transactionid is not None:
            params["TransactionID"] = transactionid
            
        if transactiontype is not None:
            params["TransactionType"] = transactiontype
            
        if pagenum is not None:
            params["pageNum"] = pagenum
            
        if pagesize is not None:
            params["pageSize"] = pagesize
            
        
        
        # Replace path parameters in URL
        path = "/tradeFinance/exportLetterOfCredit/bills/shipmentView"
        
        
        # Prepare headers
        headers = {}
        if accesstoken is not None:
            headers["Accesstoken"] = str(accesstoken)
        if channeltype is not None:
            headers["ChannelType"] = str(channeltype)
        if co_relationid is not None:
            headers["co-Relationid"] = str(co_relationid)
        if entity is not None:
            headers["entity"] = str(entity)
        if initiatingsystem is not None:
            headers["initiatingSystem"] = str(initiatingsystem)
        if languagecode is not None:
            headers["languageCode"] = str(languagecode)
        if referenceid is not None:
            headers["referenceId"] = str(referenceid)
        if servicemode is not None:
            headers["serviceMode"] = str(servicemode)
        if userid is not None:
            headers["userId"] = str(userid)
        if uuidseqno is not None:
            headers["uuidSeqNo"] = str(uuidseqno)
        
        
        return await make_api_request(
            "GET", 
            path, 
            
            params=params if params else None, 
            headers=headers if headers else None
        )
    
    
    
    @mcp.tool()
    async def elcbt2003_blon_hold_to_released_postusing_post(
        request_body:Dict[str, Any] ,  # RegisterExportConfirmRequest,
        accesstoken: Optional[str] = None,
        channeltype: Optional[int] = None,
        co_relationid: Optional[int] = None,
        entity: Optional[str] = None,
        initiatingsystem: Optional[str] = None,
        languagecode: Optional[int] = None,
        referenceid: Optional[str] = None,
        servicemode: Optional[int] = None,
        userid: Optional[int] = None,
        uuidseqno: Optional[int] = None
    ) -> Dict[str, Any]:
        """
        User Confirmation
        
        Generated from: POST /tradeFinance/exportLetterOfCredit/bills/userConfirmation
        Source: swagger_2_0
        Operation ID: ELCBT2003BLOnHoldToReleased_POSTUsingPOST
        
        
        Authentication: Not required
        
        Parameters:
        - request_body: any (required)
          input
        
        
        
        Headers:
        - Accesstoken: string
          Authorization Token to validation the caller
        - ChannelType: integer
          Channel identifier from where the TXN has originated (Internet, Mobile, ATM, Branch Channel )
        - co-Relationid: integer
          Unique ID for the service invoked, will be set by the TXN system
        - entity: string
          entity
        - initiatingSystem: string
          Indicating the initiated system
        - languageCode: integer
          languageCode
        - referenceId: string
          Place holder for Token based authentication
        - serviceMode: integer
          Used for branch channel to indicate the type of customer
        - userId: integer
          userId
        - uuidSeqNo: integer
          UUID Sequence Number
        
        
        """
        
        
        # Prepare request data
        
        # Single body parameter - send directly
        data = request_body if request_body is not None else {}
        
        
        
        # Prepare query parameters
        params = {}
        
        
        # Replace path parameters in URL
        path = "/tradeFinance/exportLetterOfCredit/bills/userConfirmation"
        
        
        # Prepare headers
        headers = {}
        if accesstoken is not None:
            headers["Accesstoken"] = str(accesstoken)
        if channeltype is not None:
            headers["ChannelType"] = str(channeltype)
        if co_relationid is not None:
            headers["co-Relationid"] = str(co_relationid)
        if entity is not None:
            headers["entity"] = str(entity)
        if initiatingsystem is not None:
            headers["initiatingSystem"] = str(initiatingsystem)
        if languagecode is not None:
            headers["languageCode"] = str(languagecode)
        if referenceid is not None:
            headers["referenceId"] = str(referenceid)
        if servicemode is not None:
            headers["serviceMode"] = str(servicemode)
        if userid is not None:
            headers["userId"] = str(userid)
        if uuidseqno is not None:
            headers["uuidSeqNo"] = str(uuidseqno)
        
        
        return await make_api_request(
            "POST", 
            path, 
            data=data, 
            params=params if params else None, 
            headers=headers if headers else None
        )
    
    
    
    @mcp.tool()
    async def elcet2011_get_bldtls_postusing_get(
        ebltransactionid: Optional[int] = None,
        ebltransactiontype: Optional[int] = None,
        elctransactionid: Optional[int] = None,
        elctransactiontype: Optional[int] = None,
        entityid: Optional[str] = None,
        num1: Optional[int] = None,
        str1: Optional[str] = None,
        pagenum: Optional[int] = None,
        pagesize: Optional[int] = None,
        accesstoken: Optional[str] = None,
        channeltype: Optional[int] = None,
        co_relationid: Optional[int] = None,
        entity: Optional[str] = None,
        initiatingsystem: Optional[str] = None,
        languagecode: Optional[int] = None,
        referenceid: Optional[str] = None,
        servicemode: Optional[int] = None,
        userid: Optional[int] = None,
        uuidseqno: Optional[int] = None
    ) -> Dict[str, Any]:
        """
        Export Bill Lodgement View
        
        Generated from: GET /tradeFinance/exportLetterOfCredit/bills/view
        Source: swagger_2_0
        Operation ID: ELCET2011GetBLDtls_POSTUsingGET
        
        
        Authentication: Not required
        
        Parameters:
        - EblTransactionId: integer
          Export Bill Transaction ID
        - EblTransactionType: integer
          Export Bill Transaction Type
        - ElcTransactionId: integer
          Export letter of Credit Transaction ID
        - ElcTransactionType: integer
          Export letter of Credit Transaction Type
        - EntityID: string
          Entity ID
        - Num1: integer
          Number1
        - STR1: string
          Str1
        - pageNum: integer
          pageNum
        - pageSize: integer
          pageSize
        
        
        
        Headers:
        - Accesstoken: string
          Authorization Token to validation the caller
        - ChannelType: integer
          Channel identifier from where the TXN has originated (Internet, Mobile, ATM, Branch Channel )
        - co-Relationid: integer
          Unique ID for the service invoked, will be set by the TXN system
        - entity: string
          entity
        - initiatingSystem: string
          Indicating the initiated system
        - languageCode: integer
          languageCode
        - referenceId: string
          Place holder for Token based authentication
        - serviceMode: integer
          Used for branch channel to indicate the type of customer
        - userId: integer
          userId
        - uuidSeqNo: integer
          UUID Sequence Number
        
        
        """
        
        
        # Prepare query parameters
        params = {}
        if ebltransactionid is not None:
            params["EblTransactionId"] = ebltransactionid
            
        if ebltransactiontype is not None:
            params["EblTransactionType"] = ebltransactiontype
            
        if elctransactionid is not None:
            params["ElcTransactionId"] = elctransactionid
            
        if elctransactiontype is not None:
            params["ElcTransactionType"] = elctransactiontype
            
        if entityid is not None:
            params["EntityID"] = entityid
            
        if num1 is not None:
            params["Num1"] = num1
            
        if str1 is not None:
            params["STR1"] = str1
            
        if pagenum is not None:
            params["pageNum"] = pagenum
            
        if pagesize is not None:
            params["pageSize"] = pagesize
            
        
        
        # Replace path parameters in URL
        path = "/tradeFinance/exportLetterOfCredit/bills/view"
        
        
        # Prepare headers
        headers = {}
        if accesstoken is not None:
            headers["Accesstoken"] = str(accesstoken)
        if channeltype is not None:
            headers["ChannelType"] = str(channeltype)
        if co_relationid is not None:
            headers["co-Relationid"] = str(co_relationid)
        if entity is not None:
            headers["entity"] = str(entity)
        if initiatingsystem is not None:
            headers["initiatingSystem"] = str(initiatingsystem)
        if languagecode is not None:
            headers["languageCode"] = str(languagecode)
        if referenceid is not None:
            headers["referenceId"] = str(referenceid)
        if servicemode is not None:
            headers["serviceMode"] = str(servicemode)
        if userid is not None:
            headers["userId"] = str(userid)
        if uuidseqno is not None:
            headers["uuidSeqNo"] = str(uuidseqno)
        
        
        return await make_api_request(
            "GET", 
            path, 
            
            params=params if params else None, 
            headers=headers if headers else None
        )
    
    
    
    @mcp.tool()
    async def elcet7026_get_elccls_dtls_postusing_get(
        elcadvisingreference: str,
        accesstoken: Optional[str] = None,
        channeltype: Optional[int] = None,
        co_relationid: Optional[int] = None,
        entity: Optional[str] = None,
        initiatingsystem: Optional[str] = None,
        languagecode: Optional[int] = None,
        referenceid: Optional[str] = None,
        servicemode: Optional[int] = None,
        userid: Optional[int] = None,
        uuidseqno: Optional[int] = None
    ) -> Dict[str, Any]:
        """
        Export LC Closure Details
        
        Generated from: GET /tradeFinance/exportLetterOfCredit/closure/{elcAdvisingReference}
        Source: swagger_2_0
        Operation ID: ELCET7026GetELCClsDtls_POSTUsingGET
        
        
        Authentication: Not required
        
        Parameters:
        - elcAdvisingReference: string (required)
          Export Letter of Credit Advising Reference Number
        
        
        
        Headers:
        - Accesstoken: string
          Authorization Token to validation the caller
        - ChannelType: integer
          Channel identifier from where the TXN has originated (Internet, Mobile, ATM, Branch Channel )
        - co-Relationid: integer
          Unique ID for the service invoked, will be set by the TXN system
        - entity: string
          entity
        - initiatingSystem: string
          Indicating the initiated system
        - languageCode: integer
          languageCode
        - referenceId: string
          Place holder for Token based authentication
        - serviceMode: integer
          Used for branch channel to indicate the type of customer
        - userId: integer
          userId
        - uuidSeqNo: integer
          UUID Sequence Number
        
        
        """
        
        
        # Prepare query parameters
        params = {}
        
        
        # Replace path parameters in URL
        path = "/tradeFinance/exportLetterOfCredit/closure/{elcAdvisingReference}"
        if elcadvisingreference is not None:
            path = path.replace("{elcAdvisingReference}", str(elcadvisingreference))
        
        
        # Prepare headers
        headers = {}
        if accesstoken is not None:
            headers["Accesstoken"] = str(accesstoken)
        if channeltype is not None:
            headers["ChannelType"] = str(channeltype)
        if co_relationid is not None:
            headers["co-Relationid"] = str(co_relationid)
        if entity is not None:
            headers["entity"] = str(entity)
        if initiatingsystem is not None:
            headers["initiatingSystem"] = str(initiatingsystem)
        if languagecode is not None:
            headers["languageCode"] = str(languagecode)
        if referenceid is not None:
            headers["referenceId"] = str(referenceid)
        if servicemode is not None:
            headers["serviceMode"] = str(servicemode)
        if userid is not None:
            headers["userId"] = str(userid)
        if uuidseqno is not None:
            headers["uuidSeqNo"] = str(uuidseqno)
        
        
        return await make_api_request(
            "GET", 
            path, 
            
            params=params if params else None, 
            headers=headers if headers else None
        )
    
    
    
    @mcp.tool()
    async def elcbt7023_cncl_close_auth_postusing_put(
        elcadvisingreference: str,
        authorizationflag: Optional[int] = None,
        verauthremarks: Optional[str] = None,
        accesstoken: Optional[str] = None,
        channeltype: Optional[int] = None,
        co_relationid: Optional[int] = None,
        entity: Optional[str] = None,
        initiatingsystem: Optional[str] = None,
        languagecode: Optional[int] = None,
        referenceid: Optional[str] = None,
        servicemode: Optional[int] = None,
        userid: Optional[int] = None,
        uuidseqno: Optional[int] = None
    ) -> Dict[str, Any]:
        """
        Export LC Closure Authorisation
        
        Generated from: PUT /tradeFinance/exportLetterOfCredit/closure/{elcAdvisingReference}/auth
        Source: swagger_2_0
        Operation ID: ELCBT7023CnclCloseAuth_POSTUsingPUT
        
        
        Authentication: Not required
        
        Parameters:
        - authorizationFlag: integer
          Authorisation Flag
        - elcAdvisingReference: string (required)
          Export Letter of Credit Advising Reference Number
        - verAuthRemarks: string
          Authorisation Remarks
        
        
        
        Headers:
        - Accesstoken: string
          Authorization Token to validation the caller
        - ChannelType: integer
          Channel identifier from where the TXN has originated (Internet, Mobile, ATM, Branch Channel )
        - co-Relationid: integer
          Unique ID for the service invoked, will be set by the TXN system
        - entity: string
          entity
        - initiatingSystem: string
          Indicating the initiated system
        - languageCode: integer
          languageCode
        - referenceId: string
          Place holder for Token based authentication
        - serviceMode: integer
          Used for branch channel to indicate the type of customer
        - userId: integer
          userId
        - uuidSeqNo: integer
          UUID Sequence Number
        
        
        """
        
        
        # Prepare query parameters
        params = {}
        if authorizationflag is not None:
            params["authorizationFlag"] = authorizationflag
            
        if verauthremarks is not None:
            params["verAuthRemarks"] = verauthremarks
            
        
        
        # Replace path parameters in URL
        path = "/tradeFinance/exportLetterOfCredit/closure/{elcAdvisingReference}/auth"
        if elcadvisingreference is not None:
            path = path.replace("{elcAdvisingReference}", str(elcadvisingreference))
        
        
        # Prepare headers
        headers = {}
        if accesstoken is not None:
            headers["Accesstoken"] = str(accesstoken)
        if channeltype is not None:
            headers["ChannelType"] = str(channeltype)
        if co_relationid is not None:
            headers["co-Relationid"] = str(co_relationid)
        if entity is not None:
            headers["entity"] = str(entity)
        if initiatingsystem is not None:
            headers["initiatingSystem"] = str(initiatingsystem)
        if languagecode is not None:
            headers["languageCode"] = str(languagecode)
        if referenceid is not None:
            headers["referenceId"] = str(referenceid)
        if servicemode is not None:
            headers["serviceMode"] = str(servicemode)
        if userid is not None:
            headers["userId"] = str(userid)
        if uuidseqno is not None:
            headers["uuidSeqNo"] = str(uuidseqno)
        
        
        return await make_api_request(
            "PUT", 
            path, 
            
            params=params if params else None, 
            headers=headers if headers else None
        )
    
    
    
    @mcp.tool()
    async def elcbt7020_cncl_close_pndng_postusing_put(
        elcadvisingreference: str,
        request_body:Dict[str, Any] ,  # ExportLcClosureRequest,
        accesstoken: Optional[str] = None,
        channeltype: Optional[int] = None,
        co_relationid: Optional[int] = None,
        entity: Optional[str] = None,
        initiatingsystem: Optional[str] = None,
        languagecode: Optional[int] = None,
        referenceid: Optional[str] = None,
        servicemode: Optional[int] = None,
        userid: Optional[int] = None,
        uuidseqno: Optional[int] = None
    ) -> Dict[str, Any]:
        """
        Export LC Closure On Hold
        
        Generated from: PUT /tradeFinance/exportLetterOfCredit/closure/{elcAdvisingReference}/onHold
        Source: swagger_2_0
        Operation ID: ELCBT7020CnclClosePndng_POSTUsingPUT
        
        
        Authentication: Not required
        
        Parameters:
        - elcAdvisingReference: string (required)
          Export LC Advising Reference
        - request_body: any (required)
          input
        
        
        
        Headers:
        - Accesstoken: string
          Authorization Token to validation the caller
        - ChannelType: integer
          Channel identifier from where the TXN has originated (Internet, Mobile, ATM, Branch Channel )
        - co-Relationid: integer
          Unique ID for the service invoked, will be set by the TXN system
        - entity: string
          entity
        - initiatingSystem: string
          Indicating the initiated system
        - languageCode: integer
          languageCode
        - referenceId: string
          Place holder for Token based authentication
        - serviceMode: integer
          Used for branch channel to indicate the type of customer
        - userId: integer
          userId
        - uuidSeqNo: integer
          UUID Sequence Number
        
        
        """
        
        
        # Prepare request data
        
        # Single body parameter - send directly
        data = request_body if request_body is not None else {}
        
        
        
        # Prepare query parameters
        params = {}
        
        
        # Replace path parameters in URL
        path = "/tradeFinance/exportLetterOfCredit/closure/{elcAdvisingReference}/onHold"
        if elcadvisingreference is not None:
            path = path.replace("{elcAdvisingReference}", str(elcadvisingreference))
        
        
        # Prepare headers
        headers = {}
        if accesstoken is not None:
            headers["Accesstoken"] = str(accesstoken)
        if channeltype is not None:
            headers["ChannelType"] = str(channeltype)
        if co_relationid is not None:
            headers["co-Relationid"] = str(co_relationid)
        if entity is not None:
            headers["entity"] = str(entity)
        if initiatingsystem is not None:
            headers["initiatingSystem"] = str(initiatingsystem)
        if languagecode is not None:
            headers["languageCode"] = str(languagecode)
        if referenceid is not None:
            headers["referenceId"] = str(referenceid)
        if servicemode is not None:
            headers["serviceMode"] = str(servicemode)
        if userid is not None:
            headers["userId"] = str(userid)
        if uuidseqno is not None:
            headers["uuidSeqNo"] = str(uuidseqno)
        
        
        return await make_api_request(
            "PUT", 
            path, 
            data=data, 
            params=params if params else None, 
            headers=headers if headers else None
        )
    
    
    
    @mcp.tool()
    async def elcbt7021_cncl_close_verified_postusing_put(
        elcadvisingreference: str,
        authorizationflag: int,
        accesstoken: Optional[str] = None,
        channeltype: Optional[int] = None,
        co_relationid: Optional[int] = None,
        entity: Optional[str] = None,
        initiatingsystem: Optional[str] = None,
        languagecode: Optional[int] = None,
        referenceid: Optional[str] = None,
        servicemode: Optional[int] = None,
        userid: Optional[int] = None,
        uuidseqno: Optional[int] = None
    ) -> Dict[str, Any]:
        """
        Export LC Closure Verification
        
        Generated from: PUT /tradeFinance/exportLetterOfCredit/closure/{elcAdvisingReference}/verify
        Source: swagger_2_0
        Operation ID: ELCBT7021CnclCloseVerified_POSTUsingPUT
        
        
        Authentication: Not required
        
        Parameters:
        - authorizationFlag: integer (required)
          Authorisation Flag
        - elcAdvisingReference: string (required)
          Export LC Advising Reference
        
        
        
        Headers:
        - Accesstoken: string
          Authorization Token to validation the caller
        - ChannelType: integer
          Channel identifier from where the TXN has originated (Internet, Mobile, ATM, Branch Channel )
        - co-Relationid: integer
          Unique ID for the service invoked, will be set by the TXN system
        - entity: string
          entity
        - initiatingSystem: string
          Indicating the initiated system
        - languageCode: integer
          languageCode
        - referenceId: string
          Place holder for Token based authentication
        - serviceMode: integer
          Used for branch channel to indicate the type of customer
        - userId: integer
          userId
        - uuidSeqNo: integer
          UUID Sequence Number
        
        
        """
        
        
        # Prepare query parameters
        params = {}
        if authorizationflag is not None:
            params["authorizationFlag"] = authorizationflag
            
        
        
        # Replace path parameters in URL
        path = "/tradeFinance/exportLetterOfCredit/closure/{elcAdvisingReference}/verify"
        if elcadvisingreference is not None:
            path = path.replace("{elcAdvisingReference}", str(elcadvisingreference))
        
        
        # Prepare headers
        headers = {}
        if accesstoken is not None:
            headers["Accesstoken"] = str(accesstoken)
        if channeltype is not None:
            headers["ChannelType"] = str(channeltype)
        if co_relationid is not None:
            headers["co-Relationid"] = str(co_relationid)
        if entity is not None:
            headers["entity"] = str(entity)
        if initiatingsystem is not None:
            headers["initiatingSystem"] = str(initiatingsystem)
        if languagecode is not None:
            headers["languageCode"] = str(languagecode)
        if referenceid is not None:
            headers["referenceId"] = str(referenceid)
        if servicemode is not None:
            headers["serviceMode"] = str(servicemode)
        if userid is not None:
            headers["userId"] = str(userid)
        if uuidseqno is not None:
            headers["uuidSeqNo"] = str(uuidseqno)
        
        
        return await make_api_request(
            "PUT", 
            path, 
            
            params=params if params else None, 
            headers=headers if headers else None
        )
    
    
    
    @mcp.tool()
    async def elcbt4558_elcconfirm_postusing_post(
        request_body:Dict[str, Any] ,  # ExportLCRegistrationConfirmationRequest,
        accesstoken: Optional[str] = None,
        channeltype: Optional[int] = None,
        co_relationid: Optional[int] = None,
        entity: Optional[str] = None,
        initiatingsystem: Optional[str] = None,
        languagecode: Optional[int] = None,
        referenceid: Optional[str] = None,
        requesthash: Optional[str] = None,
        servicemode: Optional[int] = None,
        userid: Optional[int] = None,
        uuidseqno: Optional[int] = None
    ) -> Dict[str, Any]:
        """
        Confirm Export LC Registration
        
        Generated from: POST /tradeFinance/exportLetterOfCredit/confirmation
        Source: swagger_2_0
        Operation ID: ELCBT4558ELCConfirm_POSTUsingPOST
        
        
        Authentication: Not required
        
        Parameters:
        - request_body: any (required)
          input
        
        
        
        Headers:
        - Accesstoken: string
          Authorization Token to validation the caller
        - ChannelType: integer
          Channel identifier from where the TXN has originated (Internet, Mobile, ATM, Branch Channel )
        - co-Relationid: integer
          Unique ID for the service invoked, will be set by the TXN system
        - entity: string
          entity
        - initiatingSystem: string
          Indicating the initiated system
        - languageCode: integer
          languageCode
        - referenceId: string
          Place holder for Token based authentication
        - requesthash: string
          Request payload for hash validation
        - serviceMode: integer
          Used for branch channel to indicate the type of customer
        - userId: integer
          userId
        - uuidSeqNo: integer
          UUID Sequence Number
        
        
        """
        
        
        # Prepare request data
        
        # Single body parameter - send directly
        data = request_body if request_body is not None else {}
        
        
        
        # Prepare query parameters
        params = {}
        
        
        # Replace path parameters in URL
        path = "/tradeFinance/exportLetterOfCredit/confirmation"
        
        
        # Prepare headers
        headers = {}
        if accesstoken is not None:
            headers["Accesstoken"] = str(accesstoken)
        if channeltype is not None:
            headers["ChannelType"] = str(channeltype)
        if co_relationid is not None:
            headers["co-Relationid"] = str(co_relationid)
        if entity is not None:
            headers["entity"] = str(entity)
        if initiatingsystem is not None:
            headers["initiatingSystem"] = str(initiatingsystem)
        if languagecode is not None:
            headers["languageCode"] = str(languagecode)
        if referenceid is not None:
            headers["referenceId"] = str(referenceid)
        if requesthash is not None:
            headers["requesthash"] = str(requesthash)
        if servicemode is not None:
            headers["serviceMode"] = str(servicemode)
        if userid is not None:
            headers["userId"] = str(userid)
        if uuidseqno is not None:
            headers["uuidSeqNo"] = str(uuidseqno)
        
        
        return await make_api_request(
            "POST", 
            path, 
            data=data, 
            params=params if params else None, 
            headers=headers if headers else None
        )
    
    
    
    @mcp.tool()
    async def elcbt4558_auth_elcconfirm_postusing_post(
        request_body:Dict[str, Any] ,  # ExportLCRegistrationAuthConfirmationRequest,
        accesstoken: Optional[str] = None,
        channeltype: Optional[int] = None,
        co_relationid: Optional[int] = None,
        entity: Optional[str] = None,
        initiatingsystem: Optional[str] = None,
        languagecode: Optional[int] = None,
        mu_id: Optional[str] = None,
        referenceid: Optional[str] = None,
        servicemode: Optional[int] = None,
        userid: Optional[int] = None,
        uuidseqno: Optional[int] = None
    ) -> Dict[str, Any]:
        """
        Authorize Confirm Export LC Registration
        
        Generated from: POST /tradeFinance/exportLetterOfCredit/confirmation/authorize
        Source: swagger_2_0
        Operation ID: ELCBT4558AuthELCConfirm_POSTUsingPOST
        
        
        Authentication: Not required
        
        Parameters:
        - request_body: any (required)
          input
        
        
        
        Headers:
        - Accesstoken: string
          Authorization Token to validation the caller
        - ChannelType: integer
          Channel identifier from where the TXN has originated (Internet, Mobile, ATM, Branch Channel )
        - co-Relationid: integer
          Unique ID for the service invoked, will be set by the TXN system
        - entity: string
          entity
        - initiatingSystem: string
          Indicating the initiated system
        - languageCode: integer
          languageCode
        - mu_Id: string
          Muid
        - referenceId: string
          Place holder for Token based authentication
        - serviceMode: integer
          Used for branch channel to indicate the type of customer
        - userId: integer
          userId
        - uuidSeqNo: integer
          UUID Sequence Number
        
        
        """
        
        
        # Prepare request data
        
        # Single body parameter - send directly
        data = request_body if request_body is not None else {}
        
        
        
        # Prepare query parameters
        params = {}
        
        
        # Replace path parameters in URL
        path = "/tradeFinance/exportLetterOfCredit/confirmation/authorize"
        
        
        # Prepare headers
        headers = {}
        if accesstoken is not None:
            headers["Accesstoken"] = str(accesstoken)
        if channeltype is not None:
            headers["ChannelType"] = str(channeltype)
        if co_relationid is not None:
            headers["co-Relationid"] = str(co_relationid)
        if entity is not None:
            headers["entity"] = str(entity)
        if initiatingsystem is not None:
            headers["initiatingSystem"] = str(initiatingsystem)
        if languagecode is not None:
            headers["languageCode"] = str(languagecode)
        if mu_id is not None:
            headers["mu_Id"] = str(mu_id)
        if referenceid is not None:
            headers["referenceId"] = str(referenceid)
        if servicemode is not None:
            headers["serviceMode"] = str(servicemode)
        if userid is not None:
            headers["userId"] = str(userid)
        if uuidseqno is not None:
            headers["uuidSeqNo"] = str(uuidseqno)
        
        
        return await make_api_request(
            "POST", 
            path, 
            data=data, 
            params=params if params else None, 
            headers=headers if headers else None
        )
    
    
    
    @mcp.tool()
    async def elcbt7201_set_up_doc_dtls_postusing_post(
        request_body:Dict[str, Any] ,  # SetupDocumentDetailsRequest,
        accesstoken: Optional[str] = None,
        channeltype: Optional[int] = None,
        co_relationid: Optional[int] = None,
        entity: Optional[str] = None,
        initiatingsystem: Optional[str] = None,
        languagecode: Optional[int] = None,
        referenceid: Optional[str] = None,
        servicemode: Optional[int] = None,
        userid: Optional[int] = None,
        uuidseqno: Optional[int] = None
    ) -> Dict[str, Any]:
        """
        Setup Export LC Document Details
        
        Generated from: POST /tradeFinance/exportLetterOfCredit/documentDetails
        Source: swagger_2_0
        Operation ID: ELCBT7201SetUpDocDtls_POSTUsingPOST
        
        
        Authentication: Not required
        
        Parameters:
        - request_body: any (required)
          input
        
        
        
        Headers:
        - Accesstoken: string
          Authorization Token to validation the caller
        - ChannelType: integer
          Channel identifier from where the TXN has originated (Internet, Mobile, ATM, Branch Channel )
        - co-Relationid: integer
          Unique ID for the service invoked, will be set by the TXN system
        - entity: string
          entity
        - initiatingSystem: string
          Indicating the initiated system
        - languageCode: integer
          languageCode
        - referenceId: string
          Place holder for Token based authentication
        - serviceMode: integer
          Used for branch channel to indicate the type of customer
        - userId: integer
          userId
        - uuidSeqNo: integer
          UUID Sequence Number
        
        
        """
        
        
        # Prepare request data
        
        # Single body parameter - send directly
        data = request_body if request_body is not None else {}
        
        
        
        # Prepare query parameters
        params = {}
        
        
        # Replace path parameters in URL
        path = "/tradeFinance/exportLetterOfCredit/documentDetails"
        
        
        # Prepare headers
        headers = {}
        if accesstoken is not None:
            headers["Accesstoken"] = str(accesstoken)
        if channeltype is not None:
            headers["ChannelType"] = str(channeltype)
        if co_relationid is not None:
            headers["co-Relationid"] = str(co_relationid)
        if entity is not None:
            headers["entity"] = str(entity)
        if initiatingsystem is not None:
            headers["initiatingSystem"] = str(initiatingsystem)
        if languagecode is not None:
            headers["languageCode"] = str(languagecode)
        if referenceid is not None:
            headers["referenceId"] = str(referenceid)
        if servicemode is not None:
            headers["serviceMode"] = str(servicemode)
        if userid is not None:
            headers["userId"] = str(userid)
        if uuidseqno is not None:
            headers["uuidSeqNo"] = str(uuidseqno)
        
        
        return await make_api_request(
            "POST", 
            path, 
            data=data, 
            params=params if params else None, 
            headers=headers if headers else None
        )
    
    
    
    @mcp.tool()
    async def elcet7202_fetch_doc_dtls_postusing_get(
        elcadvisingreference: str,
        pagenum: Optional[int] = None,
        pagesize: Optional[int] = None,
        accesstoken: Optional[str] = None,
        channeltype: Optional[int] = None,
        co_relationid: Optional[int] = None,
        entity: Optional[str] = None,
        initiatingsystem: Optional[str] = None,
        languagecode: Optional[int] = None,
        referenceid: Optional[str] = None,
        servicemode: Optional[int] = None,
        userid: Optional[int] = None,
        uuidseqno: Optional[int] = None
    ) -> Dict[str, Any]:
        """
        Fetch ELC Document
        
        Generated from: GET /tradeFinance/exportLetterOfCredit/documentDetails/{elcAdvisingReference}
        Source: swagger_2_0
        Operation ID: ELCET7202FetchDocDtls_POSTUsingGET
        
        
        Authentication: Not required
        
        Parameters:
        - elcAdvisingReference: string (required)
          Elc Advising Reference / LC Internal Reference
        - pageNum: integer
          pageNum
        - pageSize: integer
          pageSize
        
        
        
        Headers:
        - Accesstoken: string
          Authorization Token to validation the caller
        - ChannelType: integer
          Channel identifier from where the TXN has originated (Internet, Mobile, ATM, Branch Channel )
        - co-Relationid: integer
          Unique ID for the service invoked, will be set by the TXN system
        - entity: string
          entity
        - initiatingSystem: string
          Indicating the initiated system
        - languageCode: integer
          languageCode
        - referenceId: string
          Place holder for Token based authentication
        - serviceMode: integer
          Used for branch channel to indicate the type of customer
        - userId: integer
          userId
        - uuidSeqNo: integer
          UUID Sequence Number
        
        
        """
        
        
        # Prepare query parameters
        params = {}
        if pagenum is not None:
            params["pageNum"] = pagenum
            
        if pagesize is not None:
            params["pageSize"] = pagesize
            
        
        
        # Replace path parameters in URL
        path = "/tradeFinance/exportLetterOfCredit/documentDetails/{elcAdvisingReference}"
        if elcadvisingreference is not None:
            path = path.replace("{elcAdvisingReference}", str(elcadvisingreference))
        
        
        # Prepare headers
        headers = {}
        if accesstoken is not None:
            headers["Accesstoken"] = str(accesstoken)
        if channeltype is not None:
            headers["ChannelType"] = str(channeltype)
        if co_relationid is not None:
            headers["co-Relationid"] = str(co_relationid)
        if entity is not None:
            headers["entity"] = str(entity)
        if initiatingsystem is not None:
            headers["initiatingSystem"] = str(initiatingsystem)
        if languagecode is not None:
            headers["languageCode"] = str(languagecode)
        if referenceid is not None:
            headers["referenceId"] = str(referenceid)
        if servicemode is not None:
            headers["serviceMode"] = str(servicemode)
        if userid is not None:
            headers["userId"] = str(userid)
        if uuidseqno is not None:
            headers["uuidSeqNo"] = str(uuidseqno)
        
        
        return await make_api_request(
            "GET", 
            path, 
            
            params=params if params else None, 
            headers=headers if headers else None
        )
    
    
    
    @mcp.tool()
    async def elcbt7501_set_up_draft_dtls_postusing_post(
        request_body:Dict[str, Any] ,  # setupDraftDetailsRequest,
        accesstoken: Optional[str] = None,
        channeltype: Optional[int] = None,
        co_relationid: Optional[int] = None,
        entity: Optional[str] = None,
        initiatingsystem: Optional[str] = None,
        languagecode: Optional[int] = None,
        referenceid: Optional[str] = None,
        requesthash: Optional[str] = None,
        servicemode: Optional[int] = None,
        userid: Optional[int] = None,
        uuidseqno: Optional[int] = None
    ) -> Dict[str, Any]:
        """
        Setup ELC Draft
        
        Generated from: POST /tradeFinance/exportLetterOfCredit/draftDetails
        Source: swagger_2_0
        Operation ID: ELCBT7501SetUpDraftDtls_POSTUsingPOST
        
        
        Authentication: Not required
        
        Parameters:
        - request_body: any (required)
          input
        
        
        
        Headers:
        - Accesstoken: string
          Authorization Token to validation the caller
        - ChannelType: integer
          Channel identifier from where the TXN has originated (Internet, Mobile, ATM, Branch Channel )
        - co-Relationid: integer
          Unique ID for the service invoked, will be set by the TXN system
        - entity: string
          entity
        - initiatingSystem: string
          Indicating the initiated system
        - languageCode: integer
          languageCode
        - referenceId: string
          Place holder for Token based authentication
        - requesthash: string
          Request payload for hash validation
        - serviceMode: integer
          Used for branch channel to indicate the type of customer
        - userId: integer
          userId
        - uuidSeqNo: integer
          UUID Sequence Number
        
        
        """
        
        
        # Prepare request data
        
        # Single body parameter - send directly
        data = request_body if request_body is not None else {}
        
        
        
        # Prepare query parameters
        params = {}
        
        
        # Replace path parameters in URL
        path = "/tradeFinance/exportLetterOfCredit/draftDetails"
        
        
        # Prepare headers
        headers = {}
        if accesstoken is not None:
            headers["Accesstoken"] = str(accesstoken)
        if channeltype is not None:
            headers["ChannelType"] = str(channeltype)
        if co_relationid is not None:
            headers["co-Relationid"] = str(co_relationid)
        if entity is not None:
            headers["entity"] = str(entity)
        if initiatingsystem is not None:
            headers["initiatingSystem"] = str(initiatingsystem)
        if languagecode is not None:
            headers["languageCode"] = str(languagecode)
        if referenceid is not None:
            headers["referenceId"] = str(referenceid)
        if requesthash is not None:
            headers["requesthash"] = str(requesthash)
        if servicemode is not None:
            headers["serviceMode"] = str(servicemode)
        if userid is not None:
            headers["userId"] = str(userid)
        if uuidseqno is not None:
            headers["uuidSeqNo"] = str(uuidseqno)
        
        
        return await make_api_request(
            "POST", 
            path, 
            data=data, 
            params=params if params else None, 
            headers=headers if headers else None
        )
    
    
    
    @mcp.tool()
    async def elcet7502_get_draft_dtls_postusing_get(
        elcadvisingreference: str,
        eventlegid: Optional[int] = None,
        windowidentifier: Optional[int] = None,
        accesstoken: Optional[str] = None,
        channeltype: Optional[int] = None,
        co_relationid: Optional[int] = None,
        entity: Optional[str] = None,
        initiatingsystem: Optional[str] = None,
        languagecode: Optional[int] = None,
        referenceid: Optional[str] = None,
        servicemode: Optional[int] = None,
        userid: Optional[int] = None,
        uuidseqno: Optional[int] = None
    ) -> Dict[str, Any]:
        """
        Fetch ELC Draft
        
        Generated from: GET /tradeFinance/exportLetterOfCredit/draftDetails/{elcAdvisingreference}
        Source: swagger_2_0
        Operation ID: ELCET7502GetDraftDtls_POSTUsingGET
        
        
        Authentication: Not required
        
        Parameters:
        - elcAdvisingreference: string (required)
          Export LC Advising Reference Number
        - eventLegId: integer
          Event Leg ID
        - windowIdentifier: integer
          Window Identifier. 1- To fetch created Data, 3 - Transfer View[Parent ref], 4 - Modify Transfer View[Transferred Ref]
        
        
        
        Headers:
        - Accesstoken: string
          Authorization Token to validation the caller
        - ChannelType: integer
          Channel identifier from where the TXN has originated (Internet, Mobile, ATM, Branch Channel )
        - co-Relationid: integer
          Unique ID for the service invoked, will be set by the TXN system
        - entity: string
          entity
        - initiatingSystem: string
          Indicating the initiated system
        - languageCode: integer
          languageCode
        - referenceId: string
          Place holder for Token based authentication
        - serviceMode: integer
          Used for branch channel to indicate the type of customer
        - userId: integer
          userId
        - uuidSeqNo: integer
          UUID Sequence Number
        
        
        """
        
        
        # Prepare query parameters
        params = {}
        if eventlegid is not None:
            params["eventLegId"] = eventlegid
            
        if windowidentifier is not None:
            params["windowIdentifier"] = windowidentifier
            
        
        
        # Replace path parameters in URL
        path = "/tradeFinance/exportLetterOfCredit/draftDetails/{elcAdvisingreference}"
        if elcadvisingreference is not None:
            path = path.replace("{elcAdvisingreference}", str(elcadvisingreference))
        
        
        # Prepare headers
        headers = {}
        if accesstoken is not None:
            headers["Accesstoken"] = str(accesstoken)
        if channeltype is not None:
            headers["ChannelType"] = str(channeltype)
        if co_relationid is not None:
            headers["co-Relationid"] = str(co_relationid)
        if entity is not None:
            headers["entity"] = str(entity)
        if initiatingsystem is not None:
            headers["initiatingSystem"] = str(initiatingsystem)
        if languagecode is not None:
            headers["languageCode"] = str(languagecode)
        if referenceid is not None:
            headers["referenceId"] = str(referenceid)
        if servicemode is not None:
            headers["serviceMode"] = str(servicemode)
        if userid is not None:
            headers["userId"] = str(userid)
        if uuidseqno is not None:
            headers["uuidSeqNo"] = str(uuidseqno)
        
        
        return await make_api_request(
            "GET", 
            path, 
            
            params=params if params else None, 
            headers=headers if headers else None
        )
    
    
    
    @mcp.tool()
    async def elcbt7001_crt_elcon_hold_postusing_post(
        request_body:Dict[str, Any] ,  # RegisterExportLCOnHoldRequest,
        accesstoken: Optional[str] = None,
        channeltype: Optional[int] = None,
        co_relationid: Optional[int] = None,
        entity: Optional[str] = None,
        initiatingsystem: Optional[str] = None,
        languagecode: Optional[int] = None,
        referenceid: Optional[str] = None,
        requesthash: Optional[str] = None,
        servicemode: Optional[int] = None,
        userid: Optional[int] = None,
        uuidseqno: Optional[int] = None
    ) -> Dict[str, Any]:
        """
        Register Export Letter Of Credit On Hold
        
        Generated from: POST /tradeFinance/exportLetterOfCredit/registration
        Source: swagger_2_0
        Operation ID: ELCBT7001CrtELCOnHold_POSTUsingPOST
        
        
        Authentication: Not required
        
        Parameters:
        - request_body: any (required)
          input
        
        
        
        Headers:
        - Accesstoken: string
          Authorization Token to validation the caller
        - ChannelType: integer
          Channel identifier from where the TXN has originated (Internet, Mobile, ATM, Branch Channel )
        - co-Relationid: integer
          Unique ID for the service invoked, will be set by the TXN system
        - entity: string
          entity
        - initiatingSystem: string
          Indicating the initiated system
        - languageCode: integer
          languageCode
        - referenceId: string
          Place holder for Token based authentication
        - requesthash: string
          Request payload for hash validation
        - serviceMode: integer
          Used for branch channel to indicate the type of customer
        - userId: integer
          userId
        - uuidSeqNo: integer
          UUID Sequence Number
        
        
        """
        
        
        # Prepare request data
        
        # Single body parameter - send directly
        data = request_body if request_body is not None else {}
        
        
        
        # Prepare query parameters
        params = {}
        
        
        # Replace path parameters in URL
        path = "/tradeFinance/exportLetterOfCredit/registration"
        
        
        # Prepare headers
        headers = {}
        if accesstoken is not None:
            headers["Accesstoken"] = str(accesstoken)
        if channeltype is not None:
            headers["ChannelType"] = str(channeltype)
        if co_relationid is not None:
            headers["co-Relationid"] = str(co_relationid)
        if entity is not None:
            headers["entity"] = str(entity)
        if initiatingsystem is not None:
            headers["initiatingSystem"] = str(initiatingsystem)
        if languagecode is not None:
            headers["languageCode"] = str(languagecode)
        if referenceid is not None:
            headers["referenceId"] = str(referenceid)
        if requesthash is not None:
            headers["requesthash"] = str(requesthash)
        if servicemode is not None:
            headers["serviceMode"] = str(servicemode)
        if userid is not None:
            headers["userId"] = str(userid)
        if uuidseqno is not None:
            headers["uuidSeqNo"] = str(uuidseqno)
        
        
        return await make_api_request(
            "POST", 
            path, 
            data=data, 
            params=params if params else None, 
            headers=headers if headers else None
        )
    
    
    
    @mcp.tool()
    async def elcbt7004_lcon_hold_to_rjct_postusing_post(
        request_body:Dict[str, Any] ,  # RegisterExportLCRejectRequest,
        accesstoken: Optional[str] = None,
        channeltype: Optional[int] = None,
        co_relationid: Optional[int] = None,
        entity: Optional[str] = None,
        initiatingsystem: Optional[str] = None,
        languagecode: Optional[int] = None,
        referenceid: Optional[str] = None,
        servicemode: Optional[int] = None,
        userid: Optional[int] = None,
        uuidseqno: Optional[int] = None
    ) -> Dict[str, Any]:
        """
        Export LC Registration Reject
        
        Generated from: POST /tradeFinance/exportLetterOfCredit/registration/Reject
        Source: swagger_2_0
        Operation ID: ELCBT7004LCOnHoldToRjct_POSTUsingPOST
        
        
        Authentication: Not required
        
        Parameters:
        - request_body: any (required)
          input
        
        
        
        Headers:
        - Accesstoken: string
          Authorization Token to validation the caller
        - ChannelType: integer
          Channel identifier from where the TXN has originated (Internet, Mobile, ATM, Branch Channel )
        - co-Relationid: integer
          Unique ID for the service invoked, will be set by the TXN system
        - entity: string
          entity
        - initiatingSystem: string
          Indicating the initiated system
        - languageCode: integer
          languageCode
        - referenceId: string
          Place holder for Token based authentication
        - serviceMode: integer
          Used for branch channel to indicate the type of customer
        - userId: integer
          userId
        - uuidSeqNo: integer
          UUID Sequence Number
        
        
        """
        
        
        # Prepare request data
        
        # Single body parameter - send directly
        data = request_body if request_body is not None else {}
        
        
        
        # Prepare query parameters
        params = {}
        
        
        # Replace path parameters in URL
        path = "/tradeFinance/exportLetterOfCredit/registration/Reject"
        
        
        # Prepare headers
        headers = {}
        if accesstoken is not None:
            headers["Accesstoken"] = str(accesstoken)
        if channeltype is not None:
            headers["ChannelType"] = str(channeltype)
        if co_relationid is not None:
            headers["co-Relationid"] = str(co_relationid)
        if entity is not None:
            headers["entity"] = str(entity)
        if initiatingsystem is not None:
            headers["initiatingSystem"] = str(initiatingsystem)
        if languagecode is not None:
            headers["languageCode"] = str(languagecode)
        if referenceid is not None:
            headers["referenceId"] = str(referenceid)
        if servicemode is not None:
            headers["serviceMode"] = str(servicemode)
        if userid is not None:
            headers["userId"] = str(userid)
        if uuidseqno is not None:
            headers["uuidSeqNo"] = str(uuidseqno)
        
        
        return await make_api_request(
            "POST", 
            path, 
            data=data, 
            params=params if params else None, 
            headers=headers if headers else None
        )
    
    
    
    @mcp.tool()
    async def elcbt5299_elcreleasedto_sentback_postusing_post(
        request_body:Dict[str, Any] ,  # RegisterExportLCSentbackRequest,
        accesstoken: Optional[str] = None,
        channeltype: Optional[int] = None,
        co_relationid: Optional[int] = None,
        entity: Optional[str] = None,
        initiatingsystem: Optional[str] = None,
        languagecode: Optional[int] = None,
        referenceid: Optional[str] = None,
        servicemode: Optional[int] = None,
        userid: Optional[int] = None,
        uuidseqno: Optional[int] = None
    ) -> Dict[str, Any]:
        """
        Export LC Registration Sentback
        
        Generated from: POST /tradeFinance/exportLetterOfCredit/registration/Sentback
        Source: swagger_2_0
        Operation ID: ELCBT5299ELCReleasedtoSentback_POSTUsingPOST
        
        
        Authentication: Not required
        
        Parameters:
        - request_body: any (required)
          input
        
        
        
        Headers:
        - Accesstoken: string
          Authorization Token to validation the caller
        - ChannelType: integer
          Channel identifier from where the TXN has originated (Internet, Mobile, ATM, Branch Channel )
        - co-Relationid: integer
          Unique ID for the service invoked, will be set by the TXN system
        - entity: string
          entity
        - initiatingSystem: string
          Indicating the initiated system
        - languageCode: integer
          languageCode
        - referenceId: string
          Place holder for Token based authentication
        - serviceMode: integer
          Used for branch channel to indicate the type of customer
        - userId: integer
          userId
        - uuidSeqNo: integer
          UUID Sequence Number
        
        
        """
        
        
        # Prepare request data
        
        # Single body parameter - send directly
        data = request_body if request_body is not None else {}
        
        
        
        # Prepare query parameters
        params = {}
        
        
        # Replace path parameters in URL
        path = "/tradeFinance/exportLetterOfCredit/registration/Sentback"
        
        
        # Prepare headers
        headers = {}
        if accesstoken is not None:
            headers["Accesstoken"] = str(accesstoken)
        if channeltype is not None:
            headers["ChannelType"] = str(channeltype)
        if co_relationid is not None:
            headers["co-Relationid"] = str(co_relationid)
        if entity is not None:
            headers["entity"] = str(entity)
        if initiatingsystem is not None:
            headers["initiatingSystem"] = str(initiatingsystem)
        if languagecode is not None:
            headers["languageCode"] = str(languagecode)
        if referenceid is not None:
            headers["referenceId"] = str(referenceid)
        if servicemode is not None:
            headers["serviceMode"] = str(servicemode)
        if userid is not None:
            headers["userId"] = str(userid)
        if uuidseqno is not None:
            headers["uuidSeqNo"] = str(uuidseqno)
        
        
        return await make_api_request(
            "POST", 
            path, 
            data=data, 
            params=params if params else None, 
            headers=headers if headers else None
        )
    
    
    
    @mcp.tool()
    async def elcbt7009_elcverified_to_exec_postusing_post(
        request_body:Dict[str, Any] ,  # RegisterExportLCAuthRequest,
        accesstoken: Optional[str] = None,
        channeltype: Optional[int] = None,
        co_relationid: Optional[int] = None,
        entity: Optional[str] = None,
        initiatingsystem: Optional[str] = None,
        languagecode: Optional[int] = None,
        mu_id: Optional[str] = None,
        referenceid: Optional[str] = None,
        servicemode: Optional[int] = None,
        userid: Optional[int] = None,
        uuidseqno: Optional[int] = None
    ) -> Dict[str, Any]:
        """
        Export LC Registration Authorization
        
        Generated from: POST /tradeFinance/exportLetterOfCredit/registration/authorize
        Source: swagger_2_0
        Operation ID: ELCBT7009ELCVerifiedToExec_POSTUsingPOST
        
        
        Authentication: Not required
        
        Parameters:
        - request_body: any (required)
          input
        
        
        
        Headers:
        - Accesstoken: string
          Authorization Token to validation the caller
        - ChannelType: integer
          Channel identifier from where the TXN has originated (Internet, Mobile, ATM, Branch Channel )
        - co-Relationid: integer
          Unique ID for the service invoked, will be set by the TXN system
        - entity: string
          entity
        - initiatingSystem: string
          Indicating the initiated system
        - languageCode: integer
          languageCode
        - mu_Id: string
          Muid
        - referenceId: string
          Place holder for Token based authentication
        - serviceMode: integer
          Used for branch channel to indicate the type of customer
        - userId: integer
          userId
        - uuidSeqNo: integer
          UUID Sequence Number
        
        
        """
        
        
        # Prepare request data
        
        # Single body parameter - send directly
        data = request_body if request_body is not None else {}
        
        
        
        # Prepare query parameters
        params = {}
        
        
        # Replace path parameters in URL
        path = "/tradeFinance/exportLetterOfCredit/registration/authorize"
        
        
        # Prepare headers
        headers = {}
        if accesstoken is not None:
            headers["Accesstoken"] = str(accesstoken)
        if channeltype is not None:
            headers["ChannelType"] = str(channeltype)
        if co_relationid is not None:
            headers["co-Relationid"] = str(co_relationid)
        if entity is not None:
            headers["entity"] = str(entity)
        if initiatingsystem is not None:
            headers["initiatingSystem"] = str(initiatingsystem)
        if languagecode is not None:
            headers["languageCode"] = str(languagecode)
        if mu_id is not None:
            headers["mu_Id"] = str(mu_id)
        if referenceid is not None:
            headers["referenceId"] = str(referenceid)
        if servicemode is not None:
            headers["serviceMode"] = str(servicemode)
        if userid is not None:
            headers["userId"] = str(userid)
        if uuidseqno is not None:
            headers["uuidSeqNo"] = str(uuidseqno)
        
        
        return await make_api_request(
            "POST", 
            path, 
            data=data, 
            params=params if params else None, 
            headers=headers if headers else None
        )
    
    
    
    @mcp.tool()
    async def elcet7017_fetch_elclist_postusing_get(
        applicantname: Optional[str] = None,
        beneficiaryid: Optional[str] = None,
        dateofexpiry: Optional[str] = None,
        documentarycreditnumber: Optional[str] = None,
        elcadvisingreference: Optional[str] = None,
        elcinstrumentid: Optional[str] = None,
        enddate: Optional[str] = None,
        issuedate: Optional[str] = None,
        modeoftransmission: Optional[str] = None,
        pagenum: Optional[int] = None,
        pagesize: Optional[int] = None,
        startdate: Optional[str] = None,
        status: Optional[str] = None,
        transactionid: Optional[str] = None,
        transferredfrom: Optional[str] = None,
        accesstoken: Optional[str] = None,
        channeltype: Optional[int] = None,
        co_relationid: Optional[int] = None,
        entity: Optional[str] = None,
        initiatingsystem: Optional[str] = None,
        languagecode: Optional[int] = None,
        referenceid: Optional[str] = None,
        servicemode: Optional[int] = None,
        userid: Optional[int] = None,
        uuidseqno: Optional[int] = None
    ) -> Dict[str, Any]:
        """
        Fetch Registered ELC List
        
        Generated from: GET /tradeFinance/exportLetterOfCredit/registration/list
        Source: swagger_2_0
        Operation ID: ELCET7017FetchELCList_POSTUsingGET
        
        
        Authentication: Not required
        
        Parameters:
        - applicantName: string
          Applicant Name
        - beneficiaryId: string
          Customer ID
        - dateOfExpiry: string
          Date Of Expiry
        - documentaryCreditNumber: string
          Documentary Credit Number. This is the LC Reference number of LC Issuing Bank.
        - elcAdvisingReference: string
          ELC Advising Reference. This is the unique system generated Reference for Export LC Advising
        - elcInstrumentId: string
          Instrument ID
        - endDate: string
          End Date
        - issueDate: string
          Issue Date
        - modeOfTransmission: string
          Mode of Transmission 1. Physical 2. Swift
        - pageNum: integer
          pageNum
        - pageSize: integer
          pageSize
        - startDate: string
          Start Date
        - status: string
          LC Status - Available status supported in system: 1 - OnHold,2 - Released,3 - Verified,4 - Executed,5 - Rejected,8 - Expired,11 - Cancelled,12 - Closed. For All Available Status refer d_TFLCStatus
        - transactionId: string
          Unique reference ID
        - transferredFrom: string
          Transferred From LC Reference
        
        
        
        Headers:
        - Accesstoken: string
          Authorization Token to validation the caller
        - ChannelType: integer
          Channel identifier from where the TXN has originated (Internet, Mobile, ATM, Branch Channel )
        - co-Relationid: integer
          Unique ID for the service invoked, will be set by the TXN system
        - entity: string
          entity
        - initiatingSystem: string
          Indicating the initiated system
        - languageCode: integer
          languageCode
        - referenceId: string
          Place holder for Token based authentication
        - serviceMode: integer
          Used for branch channel to indicate the type of customer
        - userId: integer
          userId
        - uuidSeqNo: integer
          UUID Sequence Number
        
        
        """
        
        
        # Prepare query parameters
        params = {}
        if applicantname is not None:
            params["applicantName"] = applicantname
            
        if beneficiaryid is not None:
            params["beneficiaryId"] = beneficiaryid
            
        if dateofexpiry is not None:
            params["dateOfExpiry"] = dateofexpiry
            
        if documentarycreditnumber is not None:
            params["documentaryCreditNumber"] = documentarycreditnumber
            
        if elcadvisingreference is not None:
            params["elcAdvisingReference"] = elcadvisingreference
            
        if elcinstrumentid is not None:
            params["elcInstrumentId"] = elcinstrumentid
            
        if enddate is not None:
            params["endDate"] = enddate
            
        if issuedate is not None:
            params["issueDate"] = issuedate
            
        if modeoftransmission is not None:
            params["modeOfTransmission"] = modeoftransmission
            
        if pagenum is not None:
            params["pageNum"] = pagenum
            
        if pagesize is not None:
            params["pageSize"] = pagesize
            
        if startdate is not None:
            params["startDate"] = startdate
            
        if status is not None:
            params["status"] = status
            
        if transactionid is not None:
            params["transactionId"] = transactionid
            
        if transferredfrom is not None:
            params["transferredFrom"] = transferredfrom
            
        
        
        # Replace path parameters in URL
        path = "/tradeFinance/exportLetterOfCredit/registration/list"
        
        
        # Prepare headers
        headers = {}
        if accesstoken is not None:
            headers["Accesstoken"] = str(accesstoken)
        if channeltype is not None:
            headers["ChannelType"] = str(channeltype)
        if co_relationid is not None:
            headers["co-Relationid"] = str(co_relationid)
        if entity is not None:
            headers["entity"] = str(entity)
        if initiatingsystem is not None:
            headers["initiatingSystem"] = str(initiatingsystem)
        if languagecode is not None:
            headers["languageCode"] = str(languagecode)
        if referenceid is not None:
            headers["referenceId"] = str(referenceid)
        if servicemode is not None:
            headers["serviceMode"] = str(servicemode)
        if userid is not None:
            headers["userId"] = str(userid)
        if uuidseqno is not None:
            headers["uuidSeqNo"] = str(uuidseqno)
        
        
        return await make_api_request(
            "GET", 
            path, 
            
            params=params if params else None, 
            headers=headers if headers else None
        )
    
    
    
    @mcp.tool()
    async def elcbt7002_elcon_hold_to_on_hold_postusing_post(
        request_body:Dict[str, Any] ,  # RegisterExportLCModifyOnHoldRequest,
        accesstoken: Optional[str] = None,
        channeltype: Optional[int] = None,
        co_relationid: Optional[int] = None,
        entity: Optional[str] = None,
        initiatingsystem: Optional[str] = None,
        languagecode: Optional[int] = None,
        referenceid: Optional[str] = None,
        servicemode: Optional[int] = None,
        userid: Optional[int] = None,
        uuidseqno: Optional[int] = None
    ) -> Dict[str, Any]:
        """
        Modify Export Letter Of Credit On Hold
        
        Generated from: POST /tradeFinance/exportLetterOfCredit/registration/modifyOnHold
        Source: swagger_2_0
        Operation ID: ELCBT7002ELCOnHoldToOnHold_POSTUsingPOST
        
        
        Authentication: Not required
        
        Parameters:
        - request_body: any (required)
          input
        
        
        
        Headers:
        - Accesstoken: string
          Authorization Token to validation the caller
        - ChannelType: integer
          Channel identifier from where the TXN has originated (Internet, Mobile, ATM, Branch Channel )
        - co-Relationid: integer
          Unique ID for the service invoked, will be set by the TXN system
        - entity: string
          entity
        - initiatingSystem: string
          Indicating the initiated system
        - languageCode: integer
          languageCode
        - referenceId: string
          Place holder for Token based authentication
        - serviceMode: integer
          Used for branch channel to indicate the type of customer
        - userId: integer
          userId
        - uuidSeqNo: integer
          UUID Sequence Number
        
        
        """
        
        
        # Prepare request data
        
        # Single body parameter - send directly
        data = request_body if request_body is not None else {}
        
        
        
        # Prepare query parameters
        params = {}
        
        
        # Replace path parameters in URL
        path = "/tradeFinance/exportLetterOfCredit/registration/modifyOnHold"
        
        
        # Prepare headers
        headers = {}
        if accesstoken is not None:
            headers["Accesstoken"] = str(accesstoken)
        if channeltype is not None:
            headers["ChannelType"] = str(channeltype)
        if co_relationid is not None:
            headers["co-Relationid"] = str(co_relationid)
        if entity is not None:
            headers["entity"] = str(entity)
        if initiatingsystem is not None:
            headers["initiatingSystem"] = str(initiatingsystem)
        if languagecode is not None:
            headers["languageCode"] = str(languagecode)
        if referenceid is not None:
            headers["referenceId"] = str(referenceid)
        if servicemode is not None:
            headers["serviceMode"] = str(servicemode)
        if userid is not None:
            headers["userId"] = str(userid)
        if uuidseqno is not None:
            headers["uuidSeqNo"] = str(uuidseqno)
        
        
        return await make_api_request(
            "POST", 
            path, 
            data=data, 
            params=params if params else None, 
            headers=headers if headers else None
        )
    
    
    
    @mcp.tool()
    async def elcbt7003_elcon_hold_to_released_postusing_post(
        request_body:Dict[str, Any] ,  # RegisterExportLCReleaseRequest,
        accesstoken: Optional[str] = None,
        channeltype: Optional[int] = None,
        co_relationid: Optional[int] = None,
        entity: Optional[str] = None,
        initiatingsystem: Optional[str] = None,
        languagecode: Optional[int] = None,
        referenceid: Optional[str] = None,
        servicemode: Optional[int] = None,
        userid: Optional[int] = None,
        uuidseqno: Optional[int] = None
    ) -> Dict[str, Any]:
        """
        Release Registration of Export Letter Of Credit
        
        Generated from: POST /tradeFinance/exportLetterOfCredit/registration/release
        Source: swagger_2_0
        Operation ID: ELCBT7003ELCOnHoldToReleased_POSTUsingPOST
        
        
        Authentication: Not required
        
        Parameters:
        - request_body: any (required)
          input
        
        
        
        Headers:
        - Accesstoken: string
          Authorization Token to validation the caller
        - ChannelType: integer
          Channel identifier from where the TXN has originated (Internet, Mobile, ATM, Branch Channel )
        - co-Relationid: integer
          Unique ID for the service invoked, will be set by the TXN system
        - entity: string
          entity
        - initiatingSystem: string
          Indicating the initiated system
        - languageCode: integer
          languageCode
        - referenceId: string
          Place holder for Token based authentication
        - serviceMode: integer
          Used for branch channel to indicate the type of customer
        - userId: integer
          userId
        - uuidSeqNo: integer
          UUID Sequence Number
        
        
        """
        
        
        # Prepare request data
        
        # Single body parameter - send directly
        data = request_body if request_body is not None else {}
        
        
        
        # Prepare query parameters
        params = {}
        
        
        # Replace path parameters in URL
        path = "/tradeFinance/exportLetterOfCredit/registration/release"
        
        
        # Prepare headers
        headers = {}
        if accesstoken is not None:
            headers["Accesstoken"] = str(accesstoken)
        if channeltype is not None:
            headers["ChannelType"] = str(channeltype)
        if co_relationid is not None:
            headers["co-Relationid"] = str(co_relationid)
        if entity is not None:
            headers["entity"] = str(entity)
        if initiatingsystem is not None:
            headers["initiatingSystem"] = str(initiatingsystem)
        if languagecode is not None:
            headers["languageCode"] = str(languagecode)
        if referenceid is not None:
            headers["referenceId"] = str(referenceid)
        if servicemode is not None:
            headers["serviceMode"] = str(servicemode)
        if userid is not None:
            headers["userId"] = str(userid)
        if uuidseqno is not None:
            headers["uuidSeqNo"] = str(uuidseqno)
        
        
        return await make_api_request(
            "POST", 
            path, 
            data=data, 
            params=params if params else None, 
            headers=headers if headers else None
        )
    
    
    
    @mcp.tool()
    async def elcet7013_get_elcdtls_postusing_get(
        elcadvisingreference: str,
        windowflag: Optional[int] = None,
        accesstoken: Optional[str] = None,
        channeltype: Optional[int] = None,
        co_relationid: Optional[int] = None,
        entity: Optional[str] = None,
        initiatingsystem: Optional[str] = None,
        languagecode: Optional[int] = None,
        referenceid: Optional[str] = None,
        servicemode: Optional[int] = None,
        userid: Optional[int] = None,
        uuidseqno: Optional[int] = None
    ) -> Dict[str, Any]:
        """
        ELC Details
        
        Generated from: GET /tradeFinance/exportLetterOfCredit/registration/{elcAdvisingReference}
        Source: swagger_2_0
        Operation ID: ELCET7013GetELCDtls_POSTUsingGET
        
        
        Authentication: Not required
        
        Parameters:
        - elcAdvisingReference: string (required)
          Export LC Advising Reference
        - windowFlag: integer
          Window Identifier. 1 - Modify, 3 - Transfer View[Parent ref], 4 - Modify Transfer View[Transferred Ref]
        
        
        
        Headers:
        - Accesstoken: string
          Authorization Token to validation the caller
        - ChannelType: integer
          Channel identifier from where the TXN has originated (Internet, Mobile, ATM, Branch Channel )
        - co-Relationid: integer
          Unique ID for the service invoked, will be set by the TXN system
        - entity: string
          entity
        - initiatingSystem: string
          Indicating the initiated system
        - languageCode: integer
          languageCode
        - referenceId: string
          Place holder for Token based authentication
        - serviceMode: integer
          Used for branch channel to indicate the type of customer
        - userId: integer
          userId
        - uuidSeqNo: integer
          UUID Sequence Number
        
        
        """
        
        
        # Prepare query parameters
        params = {}
        if windowflag is not None:
            params["windowFlag"] = windowflag
            
        
        
        # Replace path parameters in URL
        path = "/tradeFinance/exportLetterOfCredit/registration/{elcAdvisingReference}"
        if elcadvisingreference is not None:
            path = path.replace("{elcAdvisingReference}", str(elcadvisingreference))
        
        
        # Prepare headers
        headers = {}
        if accesstoken is not None:
            headers["Accesstoken"] = str(accesstoken)
        if channeltype is not None:
            headers["ChannelType"] = str(channeltype)
        if co_relationid is not None:
            headers["co-Relationid"] = str(co_relationid)
        if entity is not None:
            headers["entity"] = str(entity)
        if initiatingsystem is not None:
            headers["initiatingSystem"] = str(initiatingsystem)
        if languagecode is not None:
            headers["languageCode"] = str(languagecode)
        if referenceid is not None:
            headers["referenceId"] = str(referenceid)
        if servicemode is not None:
            headers["serviceMode"] = str(servicemode)
        if userid is not None:
            headers["userId"] = str(userid)
        if uuidseqno is not None:
            headers["uuidSeqNo"] = str(uuidseqno)
        
        
        return await make_api_request(
            "GET", 
            path, 
            
            params=params if params else None, 
            headers=headers if headers else None
        )
    
    
    
    @mcp.tool()
    async def elcbt7401_set_up_shpmnt_dtls_postusing_post(
        request_body:Dict[str, Any] ,  # SetupShipmentDetailsRequest,
        accesstoken: Optional[str] = None,
        channeltype: Optional[int] = None,
        co_relationid: Optional[int] = None,
        entity: Optional[str] = None,
        initiatingsystem: Optional[str] = None,
        languagecode: Optional[int] = None,
        referenceid: Optional[str] = None,
        servicemode: Optional[int] = None,
        userid: Optional[int] = None,
        uuidseqno: Optional[int] = None
    ) -> Dict[str, Any]:
        """
        Setup Export LC Shipment Details
        
        Generated from: POST /tradeFinance/exportLetterOfCredit/shipmentDetails
        Source: swagger_2_0
        Operation ID: ELCBT7401SetUpShpmntDtls_POSTUsingPOST
        
        
        Authentication: Not required
        
        Parameters:
        - request_body: any (required)
          input
        
        
        
        Headers:
        - Accesstoken: string
          Authorization Token to validation the caller
        - ChannelType: integer
          Channel identifier from where the TXN has originated (Internet, Mobile, ATM, Branch Channel )
        - co-Relationid: integer
          Unique ID for the service invoked, will be set by the TXN system
        - entity: string
          entity
        - initiatingSystem: string
          Indicating the initiated system
        - languageCode: integer
          languageCode
        - referenceId: string
          Place holder for Token based authentication
        - serviceMode: integer
          Used for branch channel to indicate the type of customer
        - userId: integer
          userId
        - uuidSeqNo: integer
          UUID Sequence Number
        
        
        """
        
        
        # Prepare request data
        
        # Single body parameter - send directly
        data = request_body if request_body is not None else {}
        
        
        
        # Prepare query parameters
        params = {}
        
        
        # Replace path parameters in URL
        path = "/tradeFinance/exportLetterOfCredit/shipmentDetails"
        
        
        # Prepare headers
        headers = {}
        if accesstoken is not None:
            headers["Accesstoken"] = str(accesstoken)
        if channeltype is not None:
            headers["ChannelType"] = str(channeltype)
        if co_relationid is not None:
            headers["co-Relationid"] = str(co_relationid)
        if entity is not None:
            headers["entity"] = str(entity)
        if initiatingsystem is not None:
            headers["initiatingSystem"] = str(initiatingsystem)
        if languagecode is not None:
            headers["languageCode"] = str(languagecode)
        if referenceid is not None:
            headers["referenceId"] = str(referenceid)
        if servicemode is not None:
            headers["serviceMode"] = str(servicemode)
        if userid is not None:
            headers["userId"] = str(userid)
        if uuidseqno is not None:
            headers["uuidSeqNo"] = str(uuidseqno)
        
        
        return await make_api_request(
            "POST", 
            path, 
            data=data, 
            params=params if params else None, 
            headers=headers if headers else None
        )
    
    
    
    @mcp.tool()
    async def elcet7402_get_shpmnt_dtls_postusing_get(
        elcadvisingreference: str,
        eventlegid: Optional[int] = None,
        windowidentifier: Optional[int] = None,
        accesstoken: Optional[str] = None,
        channeltype: Optional[int] = None,
        co_relationid: Optional[int] = None,
        entity: Optional[str] = None,
        initiatingsystem: Optional[str] = None,
        languagecode: Optional[int] = None,
        referenceid: Optional[str] = None,
        servicemode: Optional[int] = None,
        userid: Optional[int] = None,
        uuidseqno: Optional[int] = None
    ) -> Dict[str, Any]:
        """
        Fetch ELC Shipment
        
        Generated from: GET /tradeFinance/exportLetterOfCredit/shipmentDetails/{elcAdvisingReference}
        Source: swagger_2_0
        Operation ID: ELCET7402GetShpmntDtls_POSTUsingGET
        
        
        Authentication: Not required
        
        Parameters:
        - elcAdvisingReference: string (required)
          Elc Advising Reference / LC Internal Reference
        - eventLegId: integer
          Event Leg Id of Amendment
        - windowIdentifier: integer
          Window Identifier flag. 1- Through view, 2-Modified view
        
        
        
        Headers:
        - Accesstoken: string
          Authorization Token to validation the caller
        - ChannelType: integer
          Channel identifier from where the TXN has originated (Internet, Mobile, ATM, Branch Channel )
        - co-Relationid: integer
          Unique ID for the service invoked, will be set by the TXN system
        - entity: string
          entity
        - initiatingSystem: string
          Indicating the initiated system
        - languageCode: integer
          languageCode
        - referenceId: string
          Place holder for Token based authentication
        - serviceMode: integer
          Used for branch channel to indicate the type of customer
        - userId: integer
          userId
        - uuidSeqNo: integer
          UUID Sequence Number
        
        
        """
        
        
        # Prepare query parameters
        params = {}
        if eventlegid is not None:
            params["eventLegId"] = eventlegid
            
        if windowidentifier is not None:
            params["windowIdentifier"] = windowidentifier
            
        
        
        # Replace path parameters in URL
        path = "/tradeFinance/exportLetterOfCredit/shipmentDetails/{elcAdvisingReference}"
        if elcadvisingreference is not None:
            path = path.replace("{elcAdvisingReference}", str(elcadvisingreference))
        
        
        # Prepare headers
        headers = {}
        if accesstoken is not None:
            headers["Accesstoken"] = str(accesstoken)
        if channeltype is not None:
            headers["ChannelType"] = str(channeltype)
        if co_relationid is not None:
            headers["co-Relationid"] = str(co_relationid)
        if entity is not None:
            headers["entity"] = str(entity)
        if initiatingsystem is not None:
            headers["initiatingSystem"] = str(initiatingsystem)
        if languagecode is not None:
            headers["languageCode"] = str(languagecode)
        if referenceid is not None:
            headers["referenceId"] = str(referenceid)
        if servicemode is not None:
            headers["serviceMode"] = str(servicemode)
        if userid is not None:
            headers["userId"] = str(userid)
        if uuidseqno is not None:
            headers["uuidSeqNo"] = str(uuidseqno)
        
        
        return await make_api_request(
            "GET", 
            path, 
            
            params=params if params else None, 
            headers=headers if headers else None
        )
    
    
    
    @mcp.tool()
    async def elcbt4559_trnsfr_elcauth_postusing_put(
        elcadvisingreference: str,
        authorizationflag: int,
        verauthremarks: Optional[str] = None,
        accesstoken: Optional[str] = None,
        channeltype: Optional[int] = None,
        co_relationid: Optional[int] = None,
        entity: Optional[str] = None,
        initiatingsystem: Optional[str] = None,
        languagecode: Optional[int] = None,
        referenceid: Optional[str] = None,
        servicemode: Optional[int] = None,
        userid: Optional[int] = None,
        uuidseqno: Optional[int] = None
    ) -> Dict[str, Any]:
        """
        Authorisation of Transfer Of Export LC
        
        Generated from: PUT /tradeFinance/exportLetterOfCredit/transfer/{elcAdvisingReference}/auth
        Source: swagger_2_0
        Operation ID: ELCBT4559TrnsfrELCAuth_POSTUsingPUT
        
        
        Authentication: Not required
        
        Parameters:
        - authorizationFlag: integer (required)
          Authorisation Flag
        - elcAdvisingReference: string (required)
          Export LC Advising Reference
        - verAuthRemarks: string
          Authorisation Remarks
        
        
        
        Headers:
        - Accesstoken: string
          Authorization Token to validation the caller
        - ChannelType: integer
          Channel identifier from where the TXN has originated (Internet, Mobile, ATM, Branch Channel )
        - co-Relationid: integer
          Unique ID for the service invoked, will be set by the TXN system
        - entity: string
          entity
        - initiatingSystem: string
          Indicating the initiated system
        - languageCode: integer
          languageCode
        - referenceId: string
          Place holder for Token based authentication
        - serviceMode: integer
          Used for branch channel to indicate the type of customer
        - userId: integer
          userId
        - uuidSeqNo: integer
          UUID Sequence Number
        
        
        """
        
        
        # Prepare query parameters
        params = {}
        if authorizationflag is not None:
            params["authorizationFlag"] = authorizationflag
            
        if verauthremarks is not None:
            params["verAuthRemarks"] = verauthremarks
            
        
        
        # Replace path parameters in URL
        path = "/tradeFinance/exportLetterOfCredit/transfer/{elcAdvisingReference}/auth"
        if elcadvisingreference is not None:
            path = path.replace("{elcAdvisingReference}", str(elcadvisingreference))
        
        
        # Prepare headers
        headers = {}
        if accesstoken is not None:
            headers["Accesstoken"] = str(accesstoken)
        if channeltype is not None:
            headers["ChannelType"] = str(channeltype)
        if co_relationid is not None:
            headers["co-Relationid"] = str(co_relationid)
        if entity is not None:
            headers["entity"] = str(entity)
        if initiatingsystem is not None:
            headers["initiatingSystem"] = str(initiatingsystem)
        if languagecode is not None:
            headers["languageCode"] = str(languagecode)
        if referenceid is not None:
            headers["referenceId"] = str(referenceid)
        if servicemode is not None:
            headers["serviceMode"] = str(servicemode)
        if userid is not None:
            headers["userId"] = str(userid)
        if uuidseqno is not None:
            headers["uuidSeqNo"] = str(uuidseqno)
        
        
        return await make_api_request(
            "PUT", 
            path, 
            
            params=params if params else None, 
            headers=headers if headers else None
        )
    
    
    
    @mcp.tool()
    async def elcbt4559_trnsfr_elcon_hold_postusing_post(
        elcadvisingreference: str,
        request_body:Dict[str, Any] ,  # TransferExportLcRequest,
        accesstoken: Optional[str] = None,
        channeltype: Optional[int] = None,
        co_relationid: Optional[int] = None,
        entity: Optional[str] = None,
        initiatingsystem: Optional[str] = None,
        languagecode: Optional[int] = None,
        referenceid: Optional[str] = None,
        servicemode: Optional[int] = None,
        userid: Optional[int] = None,
        uuidseqno: Optional[int] = None
    ) -> Dict[str, Any]:
        """
        Transfer Export LC On Hold
        
        Generated from: POST /tradeFinance/exportLetterOfCredit/transfer/{elcAdvisingReference}/onHold
        Source: swagger_2_0
        Operation ID: ELCBT4559TrnsfrELCOnHold_POSTUsingPOST
        
        
        Authentication: Not required
        
        Parameters:
        - elcAdvisingReference: string (required)
          Export Letter of Credit Advising Reference
        - request_body: any (required)
          input
        
        
        
        Headers:
        - Accesstoken: string
          Authorization Token to validation the caller
        - ChannelType: integer
          Channel identifier from where the TXN has originated (Internet, Mobile, ATM, Branch Channel )
        - co-Relationid: integer
          Unique ID for the service invoked, will be set by the TXN system
        - entity: string
          entity
        - initiatingSystem: string
          Indicating the initiated system
        - languageCode: integer
          languageCode
        - referenceId: string
          Place holder for Token based authentication
        - serviceMode: integer
          Used for branch channel to indicate the type of customer
        - userId: integer
          userId
        - uuidSeqNo: integer
          UUID Sequence Number
        
        
        """
        
        
        # Prepare request data
        
        # Single body parameter - send directly
        data = request_body if request_body is not None else {}
        
        
        
        # Prepare query parameters
        params = {}
        
        
        # Replace path parameters in URL
        path = "/tradeFinance/exportLetterOfCredit/transfer/{elcAdvisingReference}/onHold"
        if elcadvisingreference is not None:
            path = path.replace("{elcAdvisingReference}", str(elcadvisingreference))
        
        
        # Prepare headers
        headers = {}
        if accesstoken is not None:
            headers["Accesstoken"] = str(accesstoken)
        if channeltype is not None:
            headers["ChannelType"] = str(channeltype)
        if co_relationid is not None:
            headers["co-Relationid"] = str(co_relationid)
        if entity is not None:
            headers["entity"] = str(entity)
        if initiatingsystem is not None:
            headers["initiatingSystem"] = str(initiatingsystem)
        if languagecode is not None:
            headers["languageCode"] = str(languagecode)
        if referenceid is not None:
            headers["referenceId"] = str(referenceid)
        if servicemode is not None:
            headers["serviceMode"] = str(servicemode)
        if userid is not None:
            headers["userId"] = str(userid)
        if uuidseqno is not None:
            headers["uuidSeqNo"] = str(uuidseqno)
        
        
        return await make_api_request(
            "POST", 
            path, 
            data=data, 
            params=params if params else None, 
            headers=headers if headers else None
        )
    
    
    
    @mcp.tool()
    async def elcbt4559_trnsfr_elcrelease_postusing_put(
        elcadvisingreference: str,
        request_body:Dict[str, Any] ,  # TransferExportLcReleaseRequest,
        accesstoken: Optional[str] = None,
        channeltype: Optional[int] = None,
        co_relationid: Optional[int] = None,
        entity: Optional[str] = None,
        initiatingsystem: Optional[str] = None,
        languagecode: Optional[int] = None,
        referenceid: Optional[str] = None,
        servicemode: Optional[int] = None,
        userid: Optional[int] = None,
        uuidseqno: Optional[int] = None
    ) -> Dict[str, Any]:
        """
        Release Transfer of Export LC
        
        Generated from: PUT /tradeFinance/exportLetterOfCredit/transfer/{elcAdvisingReference}/release
        Source: swagger_2_0
        Operation ID: ELCBT4559TrnsfrELCRelease_POSTUsingPUT
        
        
        Authentication: Not required
        
        Parameters:
        - elcAdvisingReference: string (required)
          Export LC Advising Reference
        - request_body: any (required)
          input
        
        
        
        Headers:
        - Accesstoken: string
          Authorization Token to validation the caller
        - ChannelType: integer
          Channel identifier from where the TXN has originated (Internet, Mobile, ATM, Branch Channel )
        - co-Relationid: integer
          Unique ID for the service invoked, will be set by the TXN system
        - entity: string
          entity
        - initiatingSystem: string
          Indicating the initiated system
        - languageCode: integer
          languageCode
        - referenceId: string
          Place holder for Token based authentication
        - serviceMode: integer
          Used for branch channel to indicate the type of customer
        - userId: integer
          userId
        - uuidSeqNo: integer
          UUID Sequence Number
        
        
        """
        
        
        # Prepare request data
        
        # Single body parameter - send directly
        data = request_body if request_body is not None else {}
        
        
        
        # Prepare query parameters
        params = {}
        
        
        # Replace path parameters in URL
        path = "/tradeFinance/exportLetterOfCredit/transfer/{elcAdvisingReference}/release"
        if elcadvisingreference is not None:
            path = path.replace("{elcAdvisingReference}", str(elcadvisingreference))
        
        
        # Prepare headers
        headers = {}
        if accesstoken is not None:
            headers["Accesstoken"] = str(accesstoken)
        if channeltype is not None:
            headers["ChannelType"] = str(channeltype)
        if co_relationid is not None:
            headers["co-Relationid"] = str(co_relationid)
        if entity is not None:
            headers["entity"] = str(entity)
        if initiatingsystem is not None:
            headers["initiatingSystem"] = str(initiatingsystem)
        if languagecode is not None:
            headers["languageCode"] = str(languagecode)
        if referenceid is not None:
            headers["referenceId"] = str(referenceid)
        if servicemode is not None:
            headers["serviceMode"] = str(servicemode)
        if userid is not None:
            headers["userId"] = str(userid)
        if uuidseqno is not None:
            headers["uuidSeqNo"] = str(uuidseqno)
        
        
        return await make_api_request(
            "PUT", 
            path, 
            data=data, 
            params=params if params else None, 
            headers=headers if headers else None
        )
    
    
    
    @mcp.tool()
    async def tfcbt4931_general_corr_auth_postusing_put(
        request_body:Dict[str, Any] ,  # GeneralCorrAuthResource,
        seqnum: Optional[int] = None,
        verauthflg: Optional[int] = None,
        channeltype: Optional[int] = None,
        accesstoken: Optional[str] = None,
        co_relationid: Optional[int] = None,
        entity: Optional[str] = None,
        initiatingsystem: Optional[str] = None,
        languagecode: Optional[int] = None,
        mu_id: Optional[str] = None,
        referenceid: Optional[str] = None,
        servicemode: Optional[int] = None,
        userid: Optional[int] = None,
        uuidseqno: Optional[int] = None
    ) -> Dict[str, Any]:
        """
        General Corr Auth
        
        Generated from: PUT /tradeFinance/generalCorrAuth
        Source: swagger_2_0
        Operation ID: TFCBT4931GeneralCorrAuth_POSTUsingPUT
        
        
        Authentication: Not required
        
        Parameters:
        - seqNum: integer
          Seq Number
        - verAuthFlg: integer
          Ver Auth Flag. Possible values : 1 - Authorise, 2 - Reject
        - request_body: any (required)
          input
        
        
        
        Headers:
        - ChannelType: integer
          Channel identifier from where the TXN has originated (Internet, Mobile, ATM, Branch Channel )
        - accesstoken: string
          Authorization Token to validation the caller
        - co-Relationid: integer
          Unique ID for the service invoked, will be set by the TXN system
        - entity: string
          entity
        - initiatingSystem: string
          Indicating the initiated system
        - languageCode: integer
          languageCode
        - mu_Id: string
          Muid
        - referenceId: string
          Place holder for Token based authentication
        - serviceMode: integer
          Used for branch channel to indicate the type of customer
        - userId: integer
          userId
        - uuidSeqNo: integer
          UUID Sequence Number
        
        
        """
        
        
        # Prepare request data
        
        # Single body parameter - send directly
        data = request_body if request_body is not None else {}
        
        
        
        # Prepare query parameters
        params = {}
        if seqnum is not None:
            params["seqNum"] = seqnum
            
        if verauthflg is not None:
            params["verAuthFlg"] = verauthflg
            
        
        
        # Replace path parameters in URL
        path = "/tradeFinance/generalCorrAuth"
        
        
        # Prepare headers
        headers = {}
        if channeltype is not None:
            headers["ChannelType"] = str(channeltype)
        if accesstoken is not None:
            headers["accesstoken"] = str(accesstoken)
        if co_relationid is not None:
            headers["co-Relationid"] = str(co_relationid)
        if entity is not None:
            headers["entity"] = str(entity)
        if initiatingsystem is not None:
            headers["initiatingSystem"] = str(initiatingsystem)
        if languagecode is not None:
            headers["languageCode"] = str(languagecode)
        if mu_id is not None:
            headers["mu_Id"] = str(mu_id)
        if referenceid is not None:
            headers["referenceId"] = str(referenceid)
        if servicemode is not None:
            headers["serviceMode"] = str(servicemode)
        if userid is not None:
            headers["userId"] = str(userid)
        if uuidseqno is not None:
            headers["uuidSeqNo"] = str(uuidseqno)
        
        
        return await make_api_request(
            "PUT", 
            path, 
            data=data, 
            params=params if params else None, 
            headers=headers if headers else None
        )
    
    
    
    @mcp.tool()
    async def tfet4931_general_corr_list_postusing_get(
        busnessar: Optional[int] = None,
        msgtype: Optional[str] = None,
        pagenum: Optional[int] = None,
        pagesize: Optional[int] = None,
        referenceexternal: Optional[str] = None,
        channeltype: Optional[int] = None,
        co_relationid: Optional[int] = None,
        entity: Optional[str] = None,
        initiatingsystem: Optional[str] = None,
        languagecode: Optional[int] = None,
        servicemode: Optional[int] = None,
        userid: Optional[int] = None,
        uuidseqno: Optional[int] = None
    ) -> Dict[str, Any]:
        """
        General Corr List
        
        Generated from: GET /tradeFinance/generalCorrList
        Source: swagger_2_0
        Operation ID: TFET4931GeneralCorrList_POSTUsingGET
        
        
        Authentication: Not required
        
        Parameters:
        - busnessAr: integer
          BUSNESS AR
        - msgType: string
          MSG TYPE
        - pageNum: integer
          pageNum
        - pageSize: integer
          pageSize
        - referenceExternal: string
          Reference External
        
        
        
        Headers:
        - ChannelType: integer
          Channel identifier from where the TXN has originated (Internet, Mobile, ATM, Branch Channel )
        - co-Relationid: integer
          Unique ID for the service invoked, will be set by the TXN system
        - entity: string
          entity
        - initiatingSystem: string
          Indicating the initiated system
        - languageCode: integer
          languageCode
        - serviceMode: integer
          Used for branch channel to indicate the type of customer
        - userId: integer
          userId
        - uuidSeqNo: integer
          UUID Sequence Number
        
        
        """
        
        
        # Prepare query parameters
        params = {}
        if busnessar is not None:
            params["busnessAr"] = busnessar
            
        if msgtype is not None:
            params["msgType"] = msgtype
            
        if pagenum is not None:
            params["pageNum"] = pagenum
            
        if pagesize is not None:
            params["pageSize"] = pagesize
            
        if referenceexternal is not None:
            params["referenceExternal"] = referenceexternal
            
        
        
        # Replace path parameters in URL
        path = "/tradeFinance/generalCorrList"
        
        
        # Prepare headers
        headers = {}
        if channeltype is not None:
            headers["ChannelType"] = str(channeltype)
        if co_relationid is not None:
            headers["co-Relationid"] = str(co_relationid)
        if entity is not None:
            headers["entity"] = str(entity)
        if initiatingsystem is not None:
            headers["initiatingSystem"] = str(initiatingsystem)
        if languagecode is not None:
            headers["languageCode"] = str(languagecode)
        if servicemode is not None:
            headers["serviceMode"] = str(servicemode)
        if userid is not None:
            headers["userId"] = str(userid)
        if uuidseqno is not None:
            headers["uuidSeqNo"] = str(uuidseqno)
        
        
        return await make_api_request(
            "GET", 
            path, 
            
            params=params if params else None, 
            headers=headers if headers else None
        )
    
    
    
    @mcp.tool()
    async def tfcbt4931_general_corr_release_postusing_put(
        request_body:Dict[str, Any] ,  # GeneralCorrReleaseResource,
        channeltype: Optional[int] = None,
        accesstoken: Optional[str] = None,
        co_relationid: Optional[int] = None,
        entity: Optional[str] = None,
        initiatingsystem: Optional[str] = None,
        languagecode: Optional[int] = None,
        mu_id: Optional[str] = None,
        referenceid: Optional[str] = None,
        servicemode: Optional[int] = None,
        userid: Optional[int] = None,
        uuidseqno: Optional[int] = None
    ) -> Dict[str, Any]:
        """
        General Corr Release
        
        Generated from: PUT /tradeFinance/generalCorrRelease
        Source: swagger_2_0
        Operation ID: TFCBT4931GeneralCorrRelease_POSTUsingPUT
        
        
        Authentication: Not required
        
        Parameters:
        - request_body: any (required)
          input
        
        
        
        Headers:
        - ChannelType: integer
          Channel identifier from where the TXN has originated (Internet, Mobile, ATM, Branch Channel )
        - accesstoken: string
          Authorization Token to validation the caller
        - co-Relationid: integer
          Unique ID for the service invoked, will be set by the TXN system
        - entity: string
          entity
        - initiatingSystem: string
          Indicating the initiated system
        - languageCode: integer
          languageCode
        - mu_Id: string
          Muid
        - referenceId: string
          Place holder for Token based authentication
        - serviceMode: integer
          Used for branch channel to indicate the type of customer
        - userId: integer
          userId
        - uuidSeqNo: integer
          UUID Sequence Number
        
        
        """
        
        
        # Prepare request data
        
        # Single body parameter - send directly
        data = request_body if request_body is not None else {}
        
        
        
        # Prepare query parameters
        params = {}
        
        
        # Replace path parameters in URL
        path = "/tradeFinance/generalCorrRelease"
        
        
        # Prepare headers
        headers = {}
        if channeltype is not None:
            headers["ChannelType"] = str(channeltype)
        if accesstoken is not None:
            headers["accesstoken"] = str(accesstoken)
        if co_relationid is not None:
            headers["co-Relationid"] = str(co_relationid)
        if entity is not None:
            headers["entity"] = str(entity)
        if initiatingsystem is not None:
            headers["initiatingSystem"] = str(initiatingsystem)
        if languagecode is not None:
            headers["languageCode"] = str(languagecode)
        if mu_id is not None:
            headers["mu_Id"] = str(mu_id)
        if referenceid is not None:
            headers["referenceId"] = str(referenceid)
        if servicemode is not None:
            headers["serviceMode"] = str(servicemode)
        if userid is not None:
            headers["userId"] = str(userid)
        if uuidseqno is not None:
            headers["uuidSeqNo"] = str(uuidseqno)
        
        
        return await make_api_request(
            "PUT", 
            path, 
            data=data, 
            params=params if params else None, 
            headers=headers if headers else None
        )
    
    
    
    @mcp.tool()
    async def tfcet4931_general_corr_postusing_get(
        seqnum: int,
        channeltype: Optional[int] = None,
        co_relationid: Optional[int] = None,
        entity: Optional[str] = None,
        initiatingsystem: Optional[str] = None,
        languagecode: Optional[int] = None,
        servicemode: Optional[int] = None,
        userid: Optional[int] = None,
        uuidseqno: Optional[int] = None
    ) -> Dict[str, Any]:
        """
        TFCET4931GeneralCorr
        
        Generated from: GET /tradeFinance/getGeneralCorrespondence/{seqNum}
        Source: swagger_2_0
        Operation ID: TFCET4931GeneralCorr_POSTUsingGET
        
        
        Authentication: Not required
        
        Parameters:
        - seqNum: integer (required)
          SEQ NUM
        
        
        
        Headers:
        - ChannelType: integer
          Channel identifier from where the TXN has originated (Internet, Mobile, ATM, Branch Channel )
        - co-Relationid: integer
          Unique ID for the service invoked, will be set by the TXN system
        - entity: string
          entity
        - initiatingSystem: string
          Indicating the initiated system
        - languageCode: integer
          languageCode
        - serviceMode: integer
          Used for branch channel to indicate the type of customer
        - userId: integer
          userId
        - uuidSeqNo: integer
          UUID Sequence Number
        
        
        """
        
        
        # Prepare query parameters
        params = {}
        
        
        # Replace path parameters in URL
        path = "/tradeFinance/getGeneralCorrespondence/{seqNum}"
        if seqnum is not None:
            path = path.replace("{seqNum}", str(seqnum))
        
        
        # Prepare headers
        headers = {}
        if channeltype is not None:
            headers["ChannelType"] = str(channeltype)
        if co_relationid is not None:
            headers["co-Relationid"] = str(co_relationid)
        if entity is not None:
            headers["entity"] = str(entity)
        if initiatingsystem is not None:
            headers["initiatingSystem"] = str(initiatingsystem)
        if languagecode is not None:
            headers["languageCode"] = str(languagecode)
        if servicemode is not None:
            headers["serviceMode"] = str(servicemode)
        if userid is not None:
            headers["userId"] = str(userid)
        if uuidseqno is not None:
            headers["uuidSeqNo"] = str(uuidseqno)
        
        
        return await make_api_request(
            "GET", 
            path, 
            
            params=params if params else None, 
            headers=headers if headers else None
        )
    
    
    
    @mcp.tool()
    async def tfbt5997_auth_reject_awb_endorsement_postusing_put(
        request_body:Dict[str, Any] ,  # awbEndorsementDcAuthRejectRequest,
        accesstoken: Optional[str] = None,
        channeltype: Optional[int] = None,
        co_relationid: Optional[int] = None,
        entity: Optional[str] = None,
        initiatingsystem: Optional[str] = None,
        languagecode: Optional[int] = None,
        referenceid: Optional[str] = None,
        servicemode: Optional[int] = None,
        userid: Optional[int] = None,
        uuidseqno: Optional[int] = None
    ) -> Dict[str, Any]:
        """
        Authorise Reject Awb Endorsement
        
        Generated from: PUT /tradeFinance/importCollectionBills/awbEndorsement/authReject
        Source: swagger_2_0
        Operation ID: TFBT5997AuthRejectAwbEndorsement_POSTUsingPUT
        
        
        Authentication: Not required
        
        Parameters:
        - request_body: any (required)
          input
        
        
        
        Headers:
        - Accesstoken: string
          Authorization Token to validation the caller
        - ChannelType: integer
          Channel identifier from where the TXN has originated (Internet, Mobile, ATM, Branch Channel )
        - co-Relationid: integer
          Unique ID for the service invoked, will be set by the TXN system
        - entity: string
          entity
        - initiatingSystem: string
          Indicating the initiated system
        - languageCode: integer
          languageCode
        - referenceId: string
          Place holder for Token based authentication
        - serviceMode: integer
          Used for branch channel to indicate the type of customer
        - userId: integer
          userId
        - uuidSeqNo: integer
          UUID Sequence Number
        
        
        """
        
        
        # Prepare request data
        
        # Single body parameter - send directly
        data = request_body if request_body is not None else {}
        
        
        
        # Prepare query parameters
        params = {}
        
        
        # Replace path parameters in URL
        path = "/tradeFinance/importCollectionBills/awbEndorsement/authReject"
        
        
        # Prepare headers
        headers = {}
        if accesstoken is not None:
            headers["Accesstoken"] = str(accesstoken)
        if channeltype is not None:
            headers["ChannelType"] = str(channeltype)
        if co_relationid is not None:
            headers["co-Relationid"] = str(co_relationid)
        if entity is not None:
            headers["entity"] = str(entity)
        if initiatingsystem is not None:
            headers["initiatingSystem"] = str(initiatingsystem)
        if languagecode is not None:
            headers["languageCode"] = str(languagecode)
        if referenceid is not None:
            headers["referenceId"] = str(referenceid)
        if servicemode is not None:
            headers["serviceMode"] = str(servicemode)
        if userid is not None:
            headers["userId"] = str(userid)
        if uuidseqno is not None:
            headers["uuidSeqNo"] = str(uuidseqno)
        
        
        return await make_api_request(
            "PUT", 
            path, 
            data=data, 
            params=params if params else None, 
            headers=headers if headers else None
        )
    
    
    
    @mcp.tool()
    async def tfbt5997_create_awb_endorsement_postusing_post(
        request_body:Dict[str, Any] ,  # awbCreateRequest,
        accesstoken: Optional[str] = None,
        channeltype: Optional[int] = None,
        co_relationid: Optional[int] = None,
        entity: Optional[str] = None,
        initiatingsystem: Optional[str] = None,
        languagecode: Optional[int] = None,
        referenceid: Optional[str] = None,
        servicemode: Optional[int] = None,
        userid: Optional[int] = None,
        uuidseqno: Optional[int] = None
    ) -> Dict[str, Any]:
        """
        Create's Awb Endorsement
        
        Generated from: POST /tradeFinance/importCollectionBills/awbEndorsement/awbcreate
        Source: swagger_2_0
        Operation ID: TFBT5997CreateAwbEndorsement_POSTUsingPOST
        
        
        Authentication: Not required
        
        Parameters:
        - request_body: any (required)
          input
        
        
        
        Headers:
        - Accesstoken: string
          Authorization Token to validation the caller
        - ChannelType: integer
          Channel identifier from where the TXN has originated (Internet, Mobile, ATM, Branch Channel )
        - co-Relationid: integer
          Unique ID for the service invoked,will be set by the TXN system
        - entity: string
          entity
        - initiatingSystem: string
          Indicating the initiated system
        - languageCode: integer
          languageCode
        - referenceId: string
          Place holder for Token based authentication
        - serviceMode: integer
          Used for branch channel to indicate the type of customer
        - userId: integer
          userId
        - uuidSeqNo: integer
          UUID Sequence Number
        
        
        """
        
        
        # Prepare request data
        
        # Single body parameter - send directly
        data = request_body if request_body is not None else {}
        
        
        
        # Prepare query parameters
        params = {}
        
        
        # Replace path parameters in URL
        path = "/tradeFinance/importCollectionBills/awbEndorsement/awbcreate"
        
        
        # Prepare headers
        headers = {}
        if accesstoken is not None:
            headers["Accesstoken"] = str(accesstoken)
        if channeltype is not None:
            headers["ChannelType"] = str(channeltype)
        if co_relationid is not None:
            headers["co-Relationid"] = str(co_relationid)
        if entity is not None:
            headers["entity"] = str(entity)
        if initiatingsystem is not None:
            headers["initiatingSystem"] = str(initiatingsystem)
        if languagecode is not None:
            headers["languageCode"] = str(languagecode)
        if referenceid is not None:
            headers["referenceId"] = str(referenceid)
        if servicemode is not None:
            headers["serviceMode"] = str(servicemode)
        if userid is not None:
            headers["userId"] = str(userid)
        if uuidseqno is not None:
            headers["uuidSeqNo"] = str(uuidseqno)
        
        
        return await make_api_request(
            "POST", 
            path, 
            data=data, 
            params=params if params else None, 
            headers=headers if headers else None
        )
    
    
    
    @mcp.tool()
    async def tfet5997_get_awb_details_postusing_get(
        awbtransactionid: int,
        accesstoken: Optional[str] = None,
        channeltype: Optional[int] = None,
        co_relationid: Optional[int] = None,
        entity: Optional[str] = None,
        initiatingsystem: Optional[str] = None,
        languagecode: Optional[int] = None,
        referenceid: Optional[str] = None,
        servicemode: Optional[int] = None,
        userid: Optional[int] = None,
        uuidseqno: Optional[int] = None
    ) -> Dict[str, Any]:
        """
        Get Awb Details
        
        Generated from: GET /tradeFinance/importCollectionBills/awbEndorsement/{awbTransactionId}/awbdetails
        Source: swagger_2_0
        Operation ID: TFET5997GetAwbDetails_POSTUsingGET
        
        
        Authentication: Not required
        
        Parameters:
        - awbTransactionId: integer (required)
          AWB Transaction ID
        
        
        
        Headers:
        - Accesstoken: string
          Authorization Token to validation the caller
        - ChannelType: integer
          Channel identifier from where the TXN has originated (Internet, Mobile, ATM, Branch Channel )
        - co-Relationid: integer
          Unique ID for the service invoked, will be set by the TXN system
        - entity: string
          entity
        - initiatingSystem: string
          Indicating the initiated system
        - languageCode: integer
          languageCode
        - referenceId: string
          Place holder for Token based authentication
        - serviceMode: integer
          Used for branch channel to indicate the type of customer
        - userId: integer
          userId
        - uuidSeqNo: integer
          UUID Sequence Number
        
        
        """
        
        
        # Prepare query parameters
        params = {}
        
        
        # Replace path parameters in URL
        path = "/tradeFinance/importCollectionBills/awbEndorsement/{awbTransactionId}/awbdetails"
        if awbtransactionid is not None:
            path = path.replace("{awbTransactionId}", str(awbtransactionid))
        
        
        # Prepare headers
        headers = {}
        if accesstoken is not None:
            headers["Accesstoken"] = str(accesstoken)
        if channeltype is not None:
            headers["ChannelType"] = str(channeltype)
        if co_relationid is not None:
            headers["co-Relationid"] = str(co_relationid)
        if entity is not None:
            headers["entity"] = str(entity)
        if initiatingsystem is not None:
            headers["initiatingSystem"] = str(initiatingsystem)
        if languagecode is not None:
            headers["languageCode"] = str(languagecode)
        if referenceid is not None:
            headers["referenceId"] = str(referenceid)
        if servicemode is not None:
            headers["serviceMode"] = str(servicemode)
        if userid is not None:
            headers["userId"] = str(userid)
        if uuidseqno is not None:
            headers["uuidSeqNo"] = str(uuidseqno)
        
        
        return await make_api_request(
            "GET", 
            path, 
            
            params=params if params else None, 
            headers=headers if headers else None
        )
    
    
    
    @mcp.tool()
    async def tfet5997_fetch_awb_list_getusing_get(
        awbtransactionid: Optional[int] = None,
        customerid: Optional[int] = None,
        customername: Optional[str] = None,
        frmdt: Optional[str] = None,
        pagenum: Optional[int] = None,
        pagesize: Optional[int] = None,
        status: Optional[int] = None,
        todt: Optional[str] = None,
        totalawbamount: Optional[float] = None,
        totalawbamountcurrency: Optional[str] = None,
        totalnoofawbendorsed: Optional[int] = None,
        transactiondate: Optional[str] = None,
        accesstoken: Optional[str] = None,
        channeltype: Optional[int] = None,
        co_relationid: Optional[int] = None,
        entity: Optional[str] = None,
        initiatingsystem: Optional[str] = None,
        languagecode: Optional[int] = None,
        referenceid: Optional[str] = None,
        servicemode: Optional[int] = None,
        userid: Optional[int] = None,
        uuidseqno: Optional[int] = None
    ) -> Dict[str, Any]:
        """
        awbFetchList
        
        Generated from: GET /tradeFinance/importCollectionBills/dcawbEndorsement/awbList
        Source: swagger_2_0
        Operation ID: TFET5997FetchAwbList_GETUsingGET
        
        
        Authentication: Not required
        
        Parameters:
        - awbTransactionId: integer
          awbTransactionId
        - customerId: integer
          Customer Reference
        - customerName: string
          Customer Name
        - frmDt: string
          From Date. Date Format :[dd/MM/yyyy]
        - pageNum: integer
          pageNum
        - pageSize: integer
          pageSize
        - status: integer
          STATUS Domain Name: d_AWBStatus Initiated 1 Authorised 2 Rejected 3 Active 4 Inactive 5
        - toDt: string
          To Date. Date Format :[dd/MM/yyyy]
        - totalAwbAmount: number
          Total Awb Amount
        - totalAwbAmountCurrency: string
          Total Awb Amount Currency
        - totalNoOfAwbEndorsed: integer
          Total No Of Awb Endorsed
        - transactionDate: string
          Transaction Date. Date Format :[dd/MM/yyyy]
        
        
        
        Headers:
        - Accesstoken: string
          Authorization Token to validation the caller
        - channelType: integer
          Channel identifier from where the TXN has originated (Internet, Mobile, ATM, Branch Channel )
        - co-Relationid: integer
          Unique ID for the service invoked, will be set by the TXN system
        - entity: string
          entity
        - initiatingSystem: string
          Indicating the initiated system
        - languageCode: integer
          languageCode
        - referenceId: string
          Place holder for Token based authentication
        - serviceMode: integer
          Used for branch channel to indicate the type of customer
        - userId: integer
          userId
        - uuidSeqNo: integer
          UUID Sequence Number
        
        
        """
        
        
        # Prepare query parameters
        params = {}
        if awbtransactionid is not None:
            params["awbTransactionId"] = awbtransactionid
            
        if customerid is not None:
            params["customerId"] = customerid
            
        if customername is not None:
            params["customerName"] = customername
            
        if frmdt is not None:
            params["frmDt"] = frmdt
            
        if pagenum is not None:
            params["pageNum"] = pagenum
            
        if pagesize is not None:
            params["pageSize"] = pagesize
            
        if status is not None:
            params["status"] = status
            
        if todt is not None:
            params["toDt"] = todt
            
        if totalawbamount is not None:
            params["totalAwbAmount"] = totalawbamount
            
        if totalawbamountcurrency is not None:
            params["totalAwbAmountCurrency"] = totalawbamountcurrency
            
        if totalnoofawbendorsed is not None:
            params["totalNoOfAwbEndorsed"] = totalnoofawbendorsed
            
        if transactiondate is not None:
            params["transactionDate"] = transactiondate
            
        
        
        # Replace path parameters in URL
        path = "/tradeFinance/importCollectionBills/dcawbEndorsement/awbList"
        
        
        # Prepare headers
        headers = {}
        if accesstoken is not None:
            headers["Accesstoken"] = str(accesstoken)
        if channeltype is not None:
            headers["channelType"] = str(channeltype)
        if co_relationid is not None:
            headers["co-Relationid"] = str(co_relationid)
        if entity is not None:
            headers["entity"] = str(entity)
        if initiatingsystem is not None:
            headers["initiatingSystem"] = str(initiatingsystem)
        if languagecode is not None:
            headers["languageCode"] = str(languagecode)
        if referenceid is not None:
            headers["referenceId"] = str(referenceid)
        if servicemode is not None:
            headers["serviceMode"] = str(servicemode)
        if userid is not None:
            headers["userId"] = str(userid)
        if uuidseqno is not None:
            headers["uuidSeqNo"] = str(uuidseqno)
        
        
        return await make_api_request(
            "GET", 
            path, 
            
            params=params if params else None, 
            headers=headers if headers else None
        )
    
    
    
    @mcp.tool()
    async def tfet4877_fetch_all_dcevents_postusing_get(
        blexternalreference: str,
        pagenum: Optional[int] = None,
        pagesize: Optional[int] = None,
        channeltype: Optional[int] = None,
        co_relationid: Optional[int] = None,
        entity: Optional[str] = None,
        initiatingsystem: Optional[str] = None,
        languagecode: Optional[int] = None,
        servicemode: Optional[int] = None,
        userid: Optional[int] = None,
        uuidseqno: Optional[int] = None
    ) -> Dict[str, Any]:
        """
        Fetch All DC Events
        
        Generated from: GET /tradeFinance/importCollectionBills/{blExternalReference}/eventList
        Source: swagger_2_0
        Operation ID: TFET4877FetchAllDCEvents_POSTUsingGET
        
        
        Authentication: Not required
        
        Parameters:
        - blExternalReference: string (required)
          BL External Reference
        - pageNum: integer
          pageNum
        - pageSize: integer
          pageSize
        
        
        
        Headers:
        - ChannelType: integer
          Channel identifier from where the TXN has originated (Internet, Mobile, ATM, Branch Channel )
        - co-Relationid: integer
          Unique ID for the service invoked, will be set by the TXN system
        - entity: string
          entity
        - initiatingSystem: string
          Indicating the initiated system
        - languageCode: integer
          languageCode
        - serviceMode: integer
          Used for branch channel to indicate the type of customer
        - userId: integer
          userId
        - uuidSeqNo: integer
          UUID Sequence Number
        
        
        """
        
        
        # Prepare query parameters
        params = {}
        if pagenum is not None:
            params["pageNum"] = pagenum
            
        if pagesize is not None:
            params["pageSize"] = pagesize
            
        
        
        # Replace path parameters in URL
        path = "/tradeFinance/importCollectionBills/{blExternalReference}/eventList"
        if blexternalreference is not None:
            path = path.replace("{blExternalReference}", str(blexternalreference))
        
        
        # Prepare headers
        headers = {}
        if channeltype is not None:
            headers["ChannelType"] = str(channeltype)
        if co_relationid is not None:
            headers["co-Relationid"] = str(co_relationid)
        if entity is not None:
            headers["entity"] = str(entity)
        if initiatingsystem is not None:
            headers["initiatingSystem"] = str(initiatingsystem)
        if languagecode is not None:
            headers["languageCode"] = str(languagecode)
        if servicemode is not None:
            headers["serviceMode"] = str(servicemode)
        if userid is not None:
            headers["userId"] = str(userid)
        if uuidseqno is not None:
            headers["uuidSeqNo"] = str(uuidseqno)
        
        
        return await make_api_request(
            "GET", 
            path, 
            
            params=params if params else None, 
            headers=headers if headers else None
        )
    
    
    
    @mcp.tool()
    async def tfbt1010_dcver_to_on_hold_postusing_put(
        blreferenceexternal: str,
        eventlegid: int,
        blreferenceinternal: Optional[str] = None,
        bltransactionid: Optional[int] = None,
        channeltransactionid: Optional[int] = None,
        channeltype: Optional[int] = None,
        accesstoken: Optional[str] = None,
        co_relationid: Optional[int] = None,
        entity: Optional[str] = None,
        initiatingsystem: Optional[str] = None,
        languagecode: Optional[int] = None,
        referenceid: Optional[str] = None,
        requesthash: Optional[str] = None,
        servicemode: Optional[int] = None,
        userid: Optional[int] = None,
        uuidseqno: Optional[int] = None
    ) -> Dict[str, Any]:
        """
        Import Documentary Collection Sendback
        
        Generated from: PUT /tradeFinance/importCollectionBills/{blReferenceExternal}/{eventLegId}/sendback
        Source: swagger_2_0
        Operation ID: TFBT1010DCVerToOnHold_POSTUsingPUT
        
        
        Authentication: Not required
        
        Parameters:
        - blReferenceExternal: string (required)
          Bill Reference External
        - blReferenceInternal: string
          Bill Reference Internal
        - blTransactionID: integer
          Bill Transaction ID
        - channelTransactionId: integer
          Channel Transaction Id For Send Back
        - eventLegId: integer (required)
          Event Leg ID
        
        
        
        Headers:
        - ChannelType: integer
          Channel identifier from where the TXN has originated (Internet, Mobile, ATM, Branch Channel )
        - accesstoken: string
          Authorization Token to validation the caller
        - co-Relationid: integer
          Unique ID for the service invoked, will be set by the TXN system
        - entity: string
          entity
        - initiatingSystem: string
          Indicating the initiated system
        - languageCode: integer
          languageCode
        - referenceId: string
          Place holder for Token based authentication
        - requesthash: string
          Request payload for hash validation
        - serviceMode: integer
          Used for branch channel to indicate the type of customer
        - userId: integer
          userId
        - uuidSeqNo: integer
          UUID Sequence Number
        
        
        """
        
        
        # Prepare query parameters
        params = {}
        if blreferenceinternal is not None:
            params["blReferenceInternal"] = blreferenceinternal
            
        if bltransactionid is not None:
            params["blTransactionID"] = bltransactionid
            
        if channeltransactionid is not None:
            params["channelTransactionId"] = channeltransactionid
            
        
        
        # Replace path parameters in URL
        path = "/tradeFinance/importCollectionBills/{blReferenceExternal}/{eventLegId}/sendback"
        if blreferenceexternal is not None:
            path = path.replace("{blReferenceExternal}", str(blreferenceexternal))
        if eventlegid is not None:
            path = path.replace("{eventLegId}", str(eventlegid))
        
        
        # Prepare headers
        headers = {}
        if channeltype is not None:
            headers["ChannelType"] = str(channeltype)
        if accesstoken is not None:
            headers["accesstoken"] = str(accesstoken)
        if co_relationid is not None:
            headers["co-Relationid"] = str(co_relationid)
        if entity is not None:
            headers["entity"] = str(entity)
        if initiatingsystem is not None:
            headers["initiatingSystem"] = str(initiatingsystem)
        if languagecode is not None:
            headers["languageCode"] = str(languagecode)
        if referenceid is not None:
            headers["referenceId"] = str(referenceid)
        if requesthash is not None:
            headers["requesthash"] = str(requesthash)
        if servicemode is not None:
            headers["serviceMode"] = str(servicemode)
        if userid is not None:
            headers["userId"] = str(userid)
        if uuidseqno is not None:
            headers["uuidSeqNo"] = str(uuidseqno)
        
        
        return await make_api_request(
            "PUT", 
            path, 
            
            params=params if params else None, 
            headers=headers if headers else None
        )
    
    
    
    @mcp.tool()
    async def tfet5735_fetch_amend_lcmrgn_dtls_postusing_get(
        lcreferenceexternal: str,
        channeltype: Optional[int] = None,
        co_relationid: Optional[int] = None,
        entity: Optional[str] = None,
        initiatingsystem: Optional[str] = None,
        languagecode: Optional[int] = None,
        servicemode: Optional[int] = None,
        userid: Optional[int] = None,
        uuidseqno: Optional[int] = None
    ) -> Dict[str, Any]:
        """
        Fetch Amend LC Margin Details
        
        Generated from: GET /tradeFinance/importLetterOfCredit/amend/{lcReferenceExternal}/marginDetails
        Source: swagger_2_0
        Operation ID: TFET5735FetchAmendLCMrgnDtls_POSTUsingGET
        
        
        Authentication: Not required
        
        Parameters:
        - lcReferenceExternal: string (required)
          LC Reference External
        
        
        
        Headers:
        - ChannelType: integer
          Channel identifier from where the TXN has originated (Internet, Mobile, ATM, Branch Channel )
        - co-Relationid: integer
          Unique ID for the service invoked, will be set by the TXN system
        - entity: string
          entity
        - initiatingSystem: string
          Indicating the initiated system
        - languageCode: integer
          languageCode
        - serviceMode: integer
          Used for branch channel to indicate the type of customer
        - userId: integer
          userId
        - uuidSeqNo: integer
          UUID Sequence Number
        
        
        """
        
        
        # Prepare query parameters
        params = {}
        
        
        # Replace path parameters in URL
        path = "/tradeFinance/importLetterOfCredit/amend/{lcReferenceExternal}/marginDetails"
        if lcreferenceexternal is not None:
            path = path.replace("{lcReferenceExternal}", str(lcreferenceexternal))
        
        
        # Prepare headers
        headers = {}
        if channeltype is not None:
            headers["ChannelType"] = str(channeltype)
        if co_relationid is not None:
            headers["co-Relationid"] = str(co_relationid)
        if entity is not None:
            headers["entity"] = str(entity)
        if initiatingsystem is not None:
            headers["initiatingSystem"] = str(initiatingsystem)
        if languagecode is not None:
            headers["languageCode"] = str(languagecode)
        if servicemode is not None:
            headers["serviceMode"] = str(servicemode)
        if userid is not None:
            headers["userId"] = str(userid)
        if uuidseqno is not None:
            headers["uuidSeqNo"] = str(uuidseqno)
        
        
        return await make_api_request(
            "GET", 
            path, 
            
            params=params if params else None, 
            headers=headers if headers else None
        )
    
    
    
    @mcp.tool()
    async def tfbt5735_set_up_amend_lcmrgn_dtls_postusing_put(
        lcreferenceexternal: str,
        request_body:Dict[str, Any] ,  # SetUpAmendLCMrgnDtlsResource,
        channeltype: Optional[int] = None,
        co_relationid: Optional[int] = None,
        entity: Optional[str] = None,
        initiatingsystem: Optional[str] = None,
        languagecode: Optional[int] = None,
        servicemode: Optional[int] = None,
        userid: Optional[int] = None,
        uuidseqno: Optional[int] = None
    ) -> Dict[str, Any]:
        """
        Set Up Amend LC Margin Details
        
        Generated from: PUT /tradeFinance/importLetterOfCredit/amend/{lcReferenceExternal}/marginDetails
        Source: swagger_2_0
        Operation ID: TFBT5735SetUpAmendLCMrgnDtls_POSTUsingPUT
        
        
        Authentication: Not required
        
        Parameters:
        - lcReferenceExternal: string (required)
          LC Reference External
        - request_body: any (required)
          input
        
        
        
        Headers:
        - ChannelType: integer
          Channel identifier from where the TXN has originated (Internet, Mobile, ATM, Branch Channel )
        - co-Relationid: integer
          Unique ID for the service invoked, will be set by the TXN system
        - entity: string
          entity
        - initiatingSystem: string
          Indicating the initiated system
        - languageCode: integer
          languageCode
        - serviceMode: integer
          Used for branch channel to indicate the type of customer
        - userId: integer
          userId
        - uuidSeqNo: integer
          UUID Sequence Number
        
        
        """
        
        
        # Prepare request data
        
        # Single body parameter - send directly
        data = request_body if request_body is not None else {}
        
        
        
        # Prepare query parameters
        params = {}
        
        
        # Replace path parameters in URL
        path = "/tradeFinance/importLetterOfCredit/amend/{lcReferenceExternal}/marginDetails"
        if lcreferenceexternal is not None:
            path = path.replace("{lcReferenceExternal}", str(lcreferenceexternal))
        
        
        # Prepare headers
        headers = {}
        if channeltype is not None:
            headers["ChannelType"] = str(channeltype)
        if co_relationid is not None:
            headers["co-Relationid"] = str(co_relationid)
        if entity is not None:
            headers["entity"] = str(entity)
        if initiatingsystem is not None:
            headers["initiatingSystem"] = str(initiatingsystem)
        if languagecode is not None:
            headers["languageCode"] = str(languagecode)
        if servicemode is not None:
            headers["serviceMode"] = str(servicemode)
        if userid is not None:
            headers["userId"] = str(userid)
        if uuidseqno is not None:
            headers["uuidSeqNo"] = str(uuidseqno)
        
        
        return await make_api_request(
            "PUT", 
            path, 
            data=data, 
            params=params if params else None, 
            headers=headers if headers else None
        )
    
    
    
    @mcp.tool()
    async def tfbt5592_auth_reject_awb_endorsement_postusing_put(
        request_body:Dict[str, Any] ,  # awbEndorsementLcAuthRejectRequest,
        accesstoken: Optional[str] = None,
        channeltype: Optional[int] = None,
        co_relationid: Optional[int] = None,
        entity: Optional[str] = None,
        initiatingsystem: Optional[str] = None,
        languagecode: Optional[int] = None,
        referenceid: Optional[str] = None,
        servicemode: Optional[int] = None,
        userid: Optional[int] = None,
        uuidseqno: Optional[int] = None
    ) -> Dict[str, Any]:
        """
        Authorise Reject Awb Endorsement
        
        Generated from: PUT /tradeFinance/importLetterOfCredit/awbEndorsement/authReject
        Source: swagger_2_0
        Operation ID: TFBT5592AuthRejectAwbEndorsement_POSTUsingPUT
        
        
        Authentication: Not required
        
        Parameters:
        - request_body: any (required)
          input
        
        
        
        Headers:
        - Accesstoken: string
          Authorization Token to validation the caller
        - ChannelType: integer
          Channel identifier from where the TXN has originated (Internet, Mobile, ATM, Branch Channel )
        - co-Relationid: integer
          Unique ID for the service invoked, will be set by the TXN system
        - entity: string
          entity
        - initiatingSystem: string
          Indicating the initiated system
        - languageCode: integer
          languageCode
        - referenceId: string
          Place holder for Token based authentication
        - serviceMode: integer
          Used for branch channel to indicate the type of customer
        - userId: integer
          userId
        - uuidSeqNo: integer
          UUID Sequence Number
        
        
        """
        
        
        # Prepare request data
        
        # Single body parameter - send directly
        data = request_body if request_body is not None else {}
        
        
        
        # Prepare query parameters
        params = {}
        
        
        # Replace path parameters in URL
        path = "/tradeFinance/importLetterOfCredit/awbEndorsement/authReject"
        
        
        # Prepare headers
        headers = {}
        if accesstoken is not None:
            headers["Accesstoken"] = str(accesstoken)
        if channeltype is not None:
            headers["ChannelType"] = str(channeltype)
        if co_relationid is not None:
            headers["co-Relationid"] = str(co_relationid)
        if entity is not None:
            headers["entity"] = str(entity)
        if initiatingsystem is not None:
            headers["initiatingSystem"] = str(initiatingsystem)
        if languagecode is not None:
            headers["languageCode"] = str(languagecode)
        if referenceid is not None:
            headers["referenceId"] = str(referenceid)
        if servicemode is not None:
            headers["serviceMode"] = str(servicemode)
        if userid is not None:
            headers["userId"] = str(userid)
        if uuidseqno is not None:
            headers["uuidSeqNo"] = str(uuidseqno)
        
        
        return await make_api_request(
            "PUT", 
            path, 
            data=data, 
            params=params if params else None, 
            headers=headers if headers else None
        )
    
    
    
    @mcp.tool()
    async def tfet5592_fetch_awb_list_postusing_get(
        awbtransactionid: Optional[int] = None,
        exprydate: Optional[str] = None,
        frmdt: Optional[str] = None,
        issuedate: Optional[str] = None,
        lcamt: Optional[float] = None,
        lccrncy: Optional[str] = None,
        lcrefextrnl: Optional[str] = None,
        pagenum: Optional[int] = None,
        pagesize: Optional[int] = None,
        status: Optional[int] = None,
        todt: Optional[str] = None,
        totalawbamount: Optional[float] = None,
        totalawbamountcurrency: Optional[str] = None,
        totalnoofawbendorsed: Optional[int] = None,
        transactiondate: Optional[str] = None,
        accesstoken: Optional[str] = None,
        channeltype: Optional[int] = None,
        co_relationid: Optional[int] = None,
        entity: Optional[str] = None,
        initiatingsystem: Optional[str] = None,
        languagecode: Optional[int] = None,
        referenceid: Optional[str] = None,
        servicemode: Optional[int] = None,
        userid: Optional[int] = None,
        uuidseqno: Optional[int] = None
    ) -> Dict[str, Any]:
        """
        Fetch LC Awb List
        
        Generated from: GET /tradeFinance/importLetterOfCredit/awbEndorsement/awbList
        Source: swagger_2_0
        Operation ID: TFET5592FetchAwbList_POSTUsingGET
        
        
        Authentication: Not required
        
        Parameters:
        - awbTransactionId: integer
          awbTransactionId
        - expryDate: string
          LC Expiry Date. Date Format :[yyyyMMdd]
        - frmDt: string
          From Date. Date Format :[yyyyMMdd]
        - issueDate: string
           LC Issue Date. Date Format :[yyyyMMdd]
        - lcAmt: number
          LC Amount
        - lcCrncy: string
          lcCrncy
        - lcRefExtrnl: string
          LC External Reference Number
        - pageNum: integer
          pageNum
        - pageSize: integer
          pageSize
        - status: integer
          STATUS Domain Name: d_AWBStatus Initiated 1 Authorised 2 Rejected 3 Active 4 Inactive 5
        - toDt: string
          To Date. Date Format :[yyyyMMdd]
        - totalAwbAmount: number
          totalAwbAmount
        - totalAwbAmountCurrency: string
          totalAwbAmountCurrency
        - totalNoOfAwbEndorsed: integer
          totalNoOfAwbEndorsed
        - transactionDate: string
          transactionDate
        
        
        
        Headers:
        - Accesstoken: string
          Authorization Token to validation the caller
        - channelType: integer
          Channel identifier from where the TXN has originated (Internet, Mobile, ATM, Branch Channel )
        - co-Relationid: integer
          Unique ID for the service invoked, will be set by the TXN system
        - entity: string
          entity
        - initiatingSystem: string
          Indicating the initiated system
        - languageCode: integer
          languageCode
        - referenceId: string
          Place holder for Token based authentication
        - serviceMode: integer
          Used for branch channel to indicate the type of customer
        - userId: integer
          userId
        - uuidSeqNo: integer
          UUID Sequence Number
        
        
        """
        
        
        # Prepare query parameters
        params = {}
        if awbtransactionid is not None:
            params["awbTransactionId"] = awbtransactionid
            
        if exprydate is not None:
            params["expryDate"] = exprydate
            
        if frmdt is not None:
            params["frmDt"] = frmdt
            
        if issuedate is not None:
            params["issueDate"] = issuedate
            
        if lcamt is not None:
            params["lcAmt"] = lcamt
            
        if lccrncy is not None:
            params["lcCrncy"] = lccrncy
            
        if lcrefextrnl is not None:
            params["lcRefExtrnl"] = lcrefextrnl
            
        if pagenum is not None:
            params["pageNum"] = pagenum
            
        if pagesize is not None:
            params["pageSize"] = pagesize
            
        if status is not None:
            params["status"] = status
            
        if todt is not None:
            params["toDt"] = todt
            
        if totalawbamount is not None:
            params["totalAwbAmount"] = totalawbamount
            
        if totalawbamountcurrency is not None:
            params["totalAwbAmountCurrency"] = totalawbamountcurrency
            
        if totalnoofawbendorsed is not None:
            params["totalNoOfAwbEndorsed"] = totalnoofawbendorsed
            
        if transactiondate is not None:
            params["transactionDate"] = transactiondate
            
        
        
        # Replace path parameters in URL
        path = "/tradeFinance/importLetterOfCredit/awbEndorsement/awbList"
        
        
        # Prepare headers
        headers = {}
        if accesstoken is not None:
            headers["Accesstoken"] = str(accesstoken)
        if channeltype is not None:
            headers["channelType"] = str(channeltype)
        if co_relationid is not None:
            headers["co-Relationid"] = str(co_relationid)
        if entity is not None:
            headers["entity"] = str(entity)
        if initiatingsystem is not None:
            headers["initiatingSystem"] = str(initiatingsystem)
        if languagecode is not None:
            headers["languageCode"] = str(languagecode)
        if referenceid is not None:
            headers["referenceId"] = str(referenceid)
        if servicemode is not None:
            headers["serviceMode"] = str(servicemode)
        if userid is not None:
            headers["userId"] = str(userid)
        if uuidseqno is not None:
            headers["uuidSeqNo"] = str(uuidseqno)
        
        
        return await make_api_request(
            "GET", 
            path, 
            
            params=params if params else None, 
            headers=headers if headers else None
        )
    
    
    
    @mcp.tool()
    async def tfbt5592_create_awb_endorsement_postusing_post(
        request_body:Dict[str, Any] ,  # awbEndorsementRequest,
        accesstoken: Optional[str] = None,
        channeltype: Optional[int] = None,
        co_relationid: Optional[int] = None,
        entity: Optional[str] = None,
        initiatingsystem: Optional[str] = None,
        languagecode: Optional[int] = None,
        referenceid: Optional[str] = None,
        servicemode: Optional[int] = None,
        userid: Optional[int] = None,
        uuidseqno: Optional[int] = None
    ) -> Dict[str, Any]:
        """
        Create LC Awb Endorsement
        
        Generated from: POST /tradeFinance/importLetterOfCredit/awbEndorsement/create
        Source: swagger_2_0
        Operation ID: TFBT5592CreateAwbEndorsement_POSTUsingPOST
        
        
        Authentication: Not required
        
        Parameters:
        - request_body: any (required)
          input
        
        
        
        Headers:
        - Accesstoken: string
          Authorization Token to validation the caller
        - ChannelType: integer
          Channel identifier from where the TXN has originated (Internet, Mobile, ATM, Branch Channel )
        - co-Relationid: integer
          Unique ID for the service invoked, will be set by the TXN system
        - entity: string
          entity
        - initiatingSystem: string
          Indicating the initiated system
        - languageCode: integer
          languageCode
        - referenceId: string
          Place holder for Token based authentication
        - serviceMode: integer
          Used for branch channel to indicate the type of customer
        - userId: integer
          userId
        - uuidSeqNo: integer
          UUID Sequence Number
        
        
        """
        
        
        # Prepare request data
        
        # Single body parameter - send directly
        data = request_body if request_body is not None else {}
        
        
        
        # Prepare query parameters
        params = {}
        
        
        # Replace path parameters in URL
        path = "/tradeFinance/importLetterOfCredit/awbEndorsement/create"
        
        
        # Prepare headers
        headers = {}
        if accesstoken is not None:
            headers["Accesstoken"] = str(accesstoken)
        if channeltype is not None:
            headers["ChannelType"] = str(channeltype)
        if co_relationid is not None:
            headers["co-Relationid"] = str(co_relationid)
        if entity is not None:
            headers["entity"] = str(entity)
        if initiatingsystem is not None:
            headers["initiatingSystem"] = str(initiatingsystem)
        if languagecode is not None:
            headers["languageCode"] = str(languagecode)
        if referenceid is not None:
            headers["referenceId"] = str(referenceid)
        if servicemode is not None:
            headers["serviceMode"] = str(servicemode)
        if userid is not None:
            headers["userId"] = str(userid)
        if uuidseqno is not None:
            headers["uuidSeqNo"] = str(uuidseqno)
        
        
        return await make_api_request(
            "POST", 
            path, 
            data=data, 
            params=params if params else None, 
            headers=headers if headers else None
        )
    
    
    
    @mcp.tool()
    async def tfet5592_get_awb_details_postusing_get(
        awbtransactionid: int,
        accesstoken: Optional[str] = None,
        channeltype: Optional[int] = None,
        co_relationid: Optional[int] = None,
        entity: Optional[str] = None,
        initiatingsystem: Optional[str] = None,
        languagecode: Optional[int] = None,
        referenceid: Optional[str] = None,
        servicemode: Optional[int] = None,
        userid: Optional[int] = None,
        uuidseqno: Optional[int] = None
    ) -> Dict[str, Any]:
        """
        Get Awb Details
        
        Generated from: GET /tradeFinance/importLetterOfCredit/awbEndorsement/{awbTransactionId}/awbdetails
        Source: swagger_2_0
        Operation ID: TFET5592GetAwbDetails_POSTUsingGET
        
        
        Authentication: Not required
        
        Parameters:
        - awbTransactionId: integer (required)
          AWB Transaction ID
        
        
        
        Headers:
        - Accesstoken: string
          Authorization Token to validation the caller
        - ChannelType: integer
          Channel identifier from where the TXN has originated (Internet, Mobile, ATM, Branch Channel )
        - co-Relationid: integer
          Unique ID for the service invoked, will be set by the TXN system
        - entity: string
          entity
        - initiatingSystem: string
          Indicating the initiated system
        - languageCode: integer
          languageCode
        - referenceId: string
          Place holder for Token based authentication
        - serviceMode: integer
          Used for branch channel to indicate the type of customer
        - userId: integer
          userId
        - uuidSeqNo: integer
          UUID Sequence Number
        
        
        """
        
        
        # Prepare query parameters
        params = {}
        
        
        # Replace path parameters in URL
        path = "/tradeFinance/importLetterOfCredit/awbEndorsement/{awbTransactionId}/awbdetails"
        if awbtransactionid is not None:
            path = path.replace("{awbTransactionId}", str(awbtransactionid))
        
        
        # Prepare headers
        headers = {}
        if accesstoken is not None:
            headers["Accesstoken"] = str(accesstoken)
        if channeltype is not None:
            headers["ChannelType"] = str(channeltype)
        if co_relationid is not None:
            headers["co-Relationid"] = str(co_relationid)
        if entity is not None:
            headers["entity"] = str(entity)
        if initiatingsystem is not None:
            headers["initiatingSystem"] = str(initiatingsystem)
        if languagecode is not None:
            headers["languageCode"] = str(languagecode)
        if referenceid is not None:
            headers["referenceId"] = str(referenceid)
        if servicemode is not None:
            headers["serviceMode"] = str(servicemode)
        if userid is not None:
            headers["userId"] = str(userid)
        if uuidseqno is not None:
            headers["uuidSeqNo"] = str(uuidseqno)
        
        
        return await make_api_request(
            "GET", 
            path, 
            
            params=params if params else None, 
            headers=headers if headers else None
        )
    
    
    
    @mcp.tool()
    async def tfbt2010_blverified_to_on_hold_postusing_put(
        billreferenceexternal: str,
        billtransactionid: Optional[int] = None,
        blreferenceinternal: Optional[str] = None,
        channeltransactionid: Optional[int] = None,
        channeltype: Optional[int] = None,
        accesstoken: Optional[str] = None,
        co_relationid: Optional[int] = None,
        entity: Optional[str] = None,
        initiatingsystem: Optional[str] = None,
        languagecode: Optional[int] = None,
        referenceid: Optional[str] = None,
        requesthash: Optional[str] = None,
        servicemode: Optional[int] = None,
        userid: Optional[int] = None,
        uuidseqno: Optional[int] = None
    ) -> Dict[str, Any]:
        """
        BillLodgement Sendback
        
        Generated from: PUT /tradeFinance/importLetterOfCredit/bills/{billReferenceExternal}/sendback
        Source: swagger_2_0
        Operation ID: TFBT2010BLVerifiedToOnHold_POSTUsingPUT
        
        
        Authentication: Not required
        
        Parameters:
        - billReferenceExternal: string (required)
          Bill Reference External
        - billTransactionId: integer
          Bill Transaction ID
        - blReferenceInternal: string
          Bill Reference Internal
        - channelTransactionId: integer
          Channel Transaction Id For Send Back
        
        
        
        Headers:
        - ChannelType: integer
          Channel identifier from where the TXN has originated (Internet, Mobile, ATM, Branch Channel )
        - accesstoken: string
          Authorization Token to validation the caller
        - co-Relationid: integer
          Unique ID for the service invoked, will be set by the TXN system
        - entity: string
          entity
        - initiatingSystem: string
          Indicating the initiated system
        - languageCode: integer
          languageCode
        - referenceId: string
          Place holder for Token based authentication
        - requesthash: string
          Request payload for hash validation
        - serviceMode: integer
          Used for branch channel to indicate the type of customer
        - userId: integer
          userId
        - uuidSeqNo: integer
          UUID Sequence Number
        
        
        """
        
        
        # Prepare query parameters
        params = {}
        if billtransactionid is not None:
            params["billTransactionId"] = billtransactionid
            
        if blreferenceinternal is not None:
            params["blReferenceInternal"] = blreferenceinternal
            
        if channeltransactionid is not None:
            params["channelTransactionId"] = channeltransactionid
            
        
        
        # Replace path parameters in URL
        path = "/tradeFinance/importLetterOfCredit/bills/{billReferenceExternal}/sendback"
        if billreferenceexternal is not None:
            path = path.replace("{billReferenceExternal}", str(billreferenceexternal))
        
        
        # Prepare headers
        headers = {}
        if channeltype is not None:
            headers["ChannelType"] = str(channeltype)
        if accesstoken is not None:
            headers["accesstoken"] = str(accesstoken)
        if co_relationid is not None:
            headers["co-Relationid"] = str(co_relationid)
        if entity is not None:
            headers["entity"] = str(entity)
        if initiatingsystem is not None:
            headers["initiatingSystem"] = str(initiatingsystem)
        if languagecode is not None:
            headers["languageCode"] = str(languagecode)
        if referenceid is not None:
            headers["referenceId"] = str(referenceid)
        if requesthash is not None:
            headers["requesthash"] = str(requesthash)
        if servicemode is not None:
            headers["serviceMode"] = str(servicemode)
        if userid is not None:
            headers["userId"] = str(userid)
        if uuidseqno is not None:
            headers["uuidSeqNo"] = str(uuidseqno)
        
        
        return await make_api_request(
            "PUT", 
            path, 
            
            params=params if params else None, 
            headers=headers if headers else None
        )
    
    
    
    @mcp.tool()
    async def tfcet4581_fetch_elclist_postusing_get(
        amount: Optional[float] = None,
        beneficiaryname: Optional[str] = None,
        beneficiaryreference: Optional[int] = None,
        currency: Optional[str] = None,
        pagenum: Optional[int] = None,
        pagesize: Optional[int] = None,
        sendername: Optional[str] = None,
        senderreferencenumber: Optional[str] = None,
        senderswiftid: Optional[str] = None,
        accesstoken: Optional[str] = None,
        channeltype: Optional[int] = None,
        co_relationid: Optional[int] = None,
        entity: Optional[str] = None,
        initiatingsystem: Optional[str] = None,
        languagecode: Optional[int] = None,
        referenceid: Optional[str] = None,
        servicemode: Optional[int] = None,
        userid: Optional[int] = None,
        uuidseqno: Optional[int] = None
    ) -> Dict[str, Any]:
        """
        This Api Is Used To Fetch All The Export Lc
        
        Generated from: GET /tradeFinance/importLetterOfCredit/exportLcList
        Source: swagger_2_0
        Operation ID: TFCET4581FetchELCList_POSTUsingGET
        
        
        Authentication: Not required
        
        Parameters:
        - amount: number
          Amount
        - beneficiaryName: string
          Beneficiary Name
        - beneficiaryReference: integer
          Beneficiary Reference 
        - currency: string
          Currency
        - pageNum: integer
          pageNum
        - pageSize: integer
          pageSize
        - senderName: string
          Sender Name
        - senderReferenceNumber: string
          Sender Reference Number
        - senderSwiftId: string
          Sender Swift Id
        
        
        
        Headers:
        - Accesstoken: string
          Authorization Token to validation the caller
        - ChannelType: integer
          Channel identifier from where the TXN has originated (Internet, Mobile, ATM, Branch Channel )
        - co-Relationid: integer
          Unique ID for the service invoked, will be set by the TXN system
        - entity: string
          entity
        - initiatingSystem: string
          Indicating the initiated system
        - languageCode: integer
          languageCode
        - referenceId: string
          Place holder for Token based authentication
        - serviceMode: integer
          Used for branch channel to indicate the type of customer
        - userId: integer
          userId
        - uuidSeqNo: integer
          UUID Sequence Number
        
        
        """
        
        
        # Prepare query parameters
        params = {}
        if amount is not None:
            params["amount"] = amount
            
        if beneficiaryname is not None:
            params["beneficiaryName"] = beneficiaryname
            
        if beneficiaryreference is not None:
            params["beneficiaryReference"] = beneficiaryreference
            
        if currency is not None:
            params["currency"] = currency
            
        if pagenum is not None:
            params["pageNum"] = pagenum
            
        if pagesize is not None:
            params["pageSize"] = pagesize
            
        if sendername is not None:
            params["senderName"] = sendername
            
        if senderreferencenumber is not None:
            params["senderReferenceNumber"] = senderreferencenumber
            
        if senderswiftid is not None:
            params["senderSwiftId"] = senderswiftid
            
        
        
        # Replace path parameters in URL
        path = "/tradeFinance/importLetterOfCredit/exportLcList"
        
        
        # Prepare headers
        headers = {}
        if accesstoken is not None:
            headers["Accesstoken"] = str(accesstoken)
        if channeltype is not None:
            headers["ChannelType"] = str(channeltype)
        if co_relationid is not None:
            headers["co-Relationid"] = str(co_relationid)
        if entity is not None:
            headers["entity"] = str(entity)
        if initiatingsystem is not None:
            headers["initiatingSystem"] = str(initiatingsystem)
        if languagecode is not None:
            headers["languageCode"] = str(languagecode)
        if referenceid is not None:
            headers["referenceId"] = str(referenceid)
        if servicemode is not None:
            headers["serviceMode"] = str(servicemode)
        if userid is not None:
            headers["userId"] = str(userid)
        if uuidseqno is not None:
            headers["uuidSeqNo"] = str(uuidseqno)
        
        
        return await make_api_request(
            "GET", 
            path, 
            
            params=params if params else None, 
            headers=headers if headers else None
        )
    
    
    
    @mcp.tool()
    async def tfet7302_get_margin_dtls_postusing_get(
        lcreferenceexternal: str,
        pagenum: Optional[int] = None,
        pagesize: Optional[int] = None,
        channeltype: Optional[int] = None,
        co_relationid: Optional[int] = None,
        entity: Optional[str] = None,
        initiatingsystem: Optional[str] = None,
        languagecode: Optional[int] = None,
        servicemode: Optional[int] = None,
        userid: Optional[int] = None,
        uuidseqno: Optional[int] = None
    ) -> Dict[str, Any]:
        """
        GetMarginDtls
        
        Generated from: GET /tradeFinance/importLetterOfCredit/issue/{lcReferenceExternal}/GetMarginDtls
        Source: swagger_2_0
        Operation ID: TFET7302GetMarginDtls_POSTUsingGET
        
        
        Authentication: Not required
        
        Parameters:
        - lcReferenceExternal: string (required)
          Letter of Credit Reference External
        - pageNum: integer
          pageNum
        - pageSize: integer
          pageSize
        
        
        
        Headers:
        - ChannelType: integer
          Channel identifier from where the TXN has originated (Internet, Mobile, ATM, Branch Channel )
        - co-Relationid: integer
          Unique ID for the service invoked, will be set by the TXN system
        - entity: string
          entity
        - initiatingSystem: string
          Indicating the initiated system
        - languageCode: integer
          languageCode
        - serviceMode: integer
          Used for branch channel to indicate the type of customer
        - userId: integer
          userId
        - uuidSeqNo: integer
          UUID Sequence Number
        
        
        """
        
        
        # Prepare query parameters
        params = {}
        if pagenum is not None:
            params["pageNum"] = pagenum
            
        if pagesize is not None:
            params["pageSize"] = pagesize
            
        
        
        # Replace path parameters in URL
        path = "/tradeFinance/importLetterOfCredit/issue/{lcReferenceExternal}/GetMarginDtls"
        if lcreferenceexternal is not None:
            path = path.replace("{lcReferenceExternal}", str(lcreferenceexternal))
        
        
        # Prepare headers
        headers = {}
        if channeltype is not None:
            headers["ChannelType"] = str(channeltype)
        if co_relationid is not None:
            headers["co-Relationid"] = str(co_relationid)
        if entity is not None:
            headers["entity"] = str(entity)
        if initiatingsystem is not None:
            headers["initiatingSystem"] = str(initiatingsystem)
        if languagecode is not None:
            headers["languageCode"] = str(languagecode)
        if servicemode is not None:
            headers["serviceMode"] = str(servicemode)
        if userid is not None:
            headers["userId"] = str(userid)
        if uuidseqno is not None:
            headers["uuidSeqNo"] = str(uuidseqno)
        
        
        return await make_api_request(
            "GET", 
            path, 
            
            params=params if params else None, 
            headers=headers if headers else None
        )
    
    
    
    @mcp.tool()
    async def tfbt7301_set_up_margin_dtls_postusing_put(
        lcreferenceexternal: str,
        request_body:Dict[str, Any] ,  # SetUpMarginDtlsResource,
        channeltype: Optional[int] = None,
        co_relationid: Optional[int] = None,
        entity: Optional[str] = None,
        initiatingsystem: Optional[str] = None,
        languagecode: Optional[int] = None,
        servicemode: Optional[int] = None,
        userid: Optional[int] = None,
        uuidseqno: Optional[int] = None
    ) -> Dict[str, Any]:
        """
        SetUpMarginDtls
        
        Generated from: PUT /tradeFinance/importLetterOfCredit/issue/{lcReferenceExternal}/SetUpMarginDtls
        Source: swagger_2_0
        Operation ID: TFBT7301SetUpMarginDtls_POSTUsingPUT
        
        
        Authentication: Not required
        
        Parameters:
        - lcReferenceExternal: string (required)
          Letter of Credit Reference External
        - request_body: any (required)
          input
        
        
        
        Headers:
        - ChannelType: integer
          Channel identifier from where the TXN has originated (Internet, Mobile, ATM, Branch Channel )
        - co-Relationid: integer
          Unique ID for the service invoked, will be set by the TXN system
        - entity: string
          entity
        - initiatingSystem: string
          Indicating the initiated system
        - languageCode: integer
          languageCode
        - serviceMode: integer
          Used for branch channel to indicate the type of customer
        - userId: integer
          userId
        - uuidSeqNo: integer
          UUID Sequence Number
        
        
        """
        
        
        # Prepare request data
        
        # Single body parameter - send directly
        data = request_body if request_body is not None else {}
        
        
        
        # Prepare query parameters
        params = {}
        
        
        # Replace path parameters in URL
        path = "/tradeFinance/importLetterOfCredit/issue/{lcReferenceExternal}/SetUpMarginDtls"
        if lcreferenceexternal is not None:
            path = path.replace("{lcReferenceExternal}", str(lcreferenceexternal))
        
        
        # Prepare headers
        headers = {}
        if channeltype is not None:
            headers["ChannelType"] = str(channeltype)
        if co_relationid is not None:
            headers["co-Relationid"] = str(co_relationid)
        if entity is not None:
            headers["entity"] = str(entity)
        if initiatingsystem is not None:
            headers["initiatingSystem"] = str(initiatingsystem)
        if languagecode is not None:
            headers["languageCode"] = str(languagecode)
        if servicemode is not None:
            headers["serviceMode"] = str(servicemode)
        if userid is not None:
            headers["userId"] = str(userid)
        if uuidseqno is not None:
            headers["uuidSeqNo"] = str(uuidseqno)
        
        
        return await make_api_request(
            "PUT", 
            path, 
            data=data, 
            params=params if params else None, 
            headers=headers if headers else None
        )
    
    
    
    @mcp.tool()
    async def tfbt9010_lcamend_verified_to_on_hold_postusing_put(
        request_body:Dict[str, Any] ,  # TFLCAmendVerifiedToOnHoldRequest,
        accesstoken: Optional[str] = None,
        channeltype: Optional[int] = None,
        co_relationid: Optional[int] = None,
        entity: Optional[str] = None,
        initiatingsystem: Optional[str] = None,
        languagecode: Optional[int] = None,
        referenceid: Optional[str] = None,
        requesthash: Optional[str] = None,
        servicemode: Optional[int] = None,
        userid: Optional[int] = None,
        uuidseqno: Optional[int] = None
    ) -> Dict[str, Any]:
        """
        LC Amend Verified To On Hold
        
        Generated from: PUT /tradeFinance/importLetterOfCredit/lcAmendVerifiedToOnHold
        Source: swagger_2_0
        Operation ID: TFBT9010LCAmendVerifiedToOnHold_POSTUsingPUT
        
        
        Authentication: Not required
        
        Parameters:
        - request_body: any (required)
          input
        
        
        
        Headers:
        - Accesstoken: string
          Authorization Token to validation the caller
        - ChannelType: integer
          Channel identifier from where the TXN has originated (Internet, Mobile, ATM, Branch Channel )
        - co-Relationid: integer
          Unique ID for the service invoked, will be set by the TXN system
        - entity: string
          entity
        - initiatingSystem: string
          Indicating the initiated system
        - languageCode: integer
          languageCode
        - referenceId: string
          Place holder for Token based authentication
        - requesthash: string
          Request payload for hash validation
        - serviceMode: integer
          Used for branch channel to indicate the type of customer
        - userId: integer
          userId
        - uuidSeqNo: integer
          UUID Sequence Number
        
        
        """
        
        
        # Prepare request data
        
        # Single body parameter - send directly
        data = request_body if request_body is not None else {}
        
        
        
        # Prepare query parameters
        params = {}
        
        
        # Replace path parameters in URL
        path = "/tradeFinance/importLetterOfCredit/lcAmendVerifiedToOnHold"
        
        
        # Prepare headers
        headers = {}
        if accesstoken is not None:
            headers["Accesstoken"] = str(accesstoken)
        if channeltype is not None:
            headers["ChannelType"] = str(channeltype)
        if co_relationid is not None:
            headers["co-Relationid"] = str(co_relationid)
        if entity is not None:
            headers["entity"] = str(entity)
        if initiatingsystem is not None:
            headers["initiatingSystem"] = str(initiatingsystem)
        if languagecode is not None:
            headers["languageCode"] = str(languagecode)
        if referenceid is not None:
            headers["referenceId"] = str(referenceid)
        if requesthash is not None:
            headers["requesthash"] = str(requesthash)
        if servicemode is not None:
            headers["serviceMode"] = str(servicemode)
        if userid is not None:
            headers["userId"] = str(userid)
        if uuidseqno is not None:
            headers["uuidSeqNo"] = str(uuidseqno)
        
        
        return await make_api_request(
            "PUT", 
            path, 
            data=data, 
            params=params if params else None, 
            headers=headers if headers else None
        )
    
    
    
    @mcp.tool()
    async def tfbt7010_lcverified_to_on_hold_postusing_put(
        request_body:Dict[str, Any] ,  # TFLCVerifiedToOnHoldRequest,
        accesstoken: Optional[str] = None,
        channeltype: Optional[int] = None,
        co_relationid: Optional[int] = None,
        entity: Optional[str] = None,
        initiatingsystem: Optional[str] = None,
        languagecode: Optional[int] = None,
        referenceid: Optional[str] = None,
        requesthash: Optional[str] = None,
        servicemode: Optional[int] = None,
        userid: Optional[int] = None,
        uuidseqno: Optional[int] = None
    ) -> Dict[str, Any]:
        """
        LC Verified To On Hold
        
        Generated from: PUT /tradeFinance/importLetterOfCredit/lcVerifiedToOnHold
        Source: swagger_2_0
        Operation ID: TFBT7010LCVerifiedToOnHold_POSTUsingPUT
        
        
        Authentication: Not required
        
        Parameters:
        - request_body: any (required)
          input
        
        
        
        Headers:
        - Accesstoken: string
          Authorization Token to validation the caller
        - ChannelType: integer
          Channel identifier from where the TXN has originated (Internet, Mobile, ATM, Branch Channel )
        - co-Relationid: integer
          Unique ID for the service invoked, will be set by the TXN system
        - entity: string
          entity
        - initiatingSystem: string
          Indicating the initiated system
        - languageCode: integer
          languageCode
        - referenceId: string
          Place holder for Token based authentication
        - requesthash: string
          Request payload for hash validation
        - serviceMode: integer
          Used for branch channel to indicate the type of customer
        - userId: integer
          userId
        - uuidSeqNo: integer
          UUID Sequence Number
        
        
        """
        
        
        # Prepare request data
        
        # Single body parameter - send directly
        data = request_body if request_body is not None else {}
        
        
        
        # Prepare query parameters
        params = {}
        
        
        # Replace path parameters in URL
        path = "/tradeFinance/importLetterOfCredit/lcVerifiedToOnHold"
        
        
        # Prepare headers
        headers = {}
        if accesstoken is not None:
            headers["Accesstoken"] = str(accesstoken)
        if channeltype is not None:
            headers["ChannelType"] = str(channeltype)
        if co_relationid is not None:
            headers["co-Relationid"] = str(co_relationid)
        if entity is not None:
            headers["entity"] = str(entity)
        if initiatingsystem is not None:
            headers["initiatingSystem"] = str(initiatingsystem)
        if languagecode is not None:
            headers["languageCode"] = str(languagecode)
        if referenceid is not None:
            headers["referenceId"] = str(referenceid)
        if requesthash is not None:
            headers["requesthash"] = str(requesthash)
        if servicemode is not None:
            headers["serviceMode"] = str(servicemode)
        if userid is not None:
            headers["userId"] = str(userid)
        if uuidseqno is not None:
            headers["uuidSeqNo"] = str(uuidseqno)
        
        
        return await make_api_request(
            "PUT", 
            path, 
            data=data, 
            params=params if params else None, 
            headers=headers if headers else None
        )
    
    
    
    @mcp.tool()
    async def tfet5546_get_modified_lcmargin_dtls_postusing_get(
        lcreferenceexternal: str,
        pagenum: Optional[int] = None,
        pagesize: Optional[int] = None,
        channeltype: Optional[int] = None,
        co_relationid: Optional[int] = None,
        entity: Optional[str] = None,
        initiatingsystem: Optional[str] = None,
        languagecode: Optional[int] = None,
        servicemode: Optional[int] = None,
        userid: Optional[int] = None,
        uuidseqno: Optional[int] = None
    ) -> Dict[str, Any]:
        """
        GetModifiedLCMarginDtls
        
        Generated from: GET /tradeFinance/importLetterOfCredit/modify/{lcReferenceExternal}/GetModifiedLCMarginDtls
        Source: swagger_2_0
        Operation ID: TFET5546GetModifiedLCMarginDtls_POSTUsingGET
        
        
        Authentication: Not required
        
        Parameters:
        - lcReferenceExternal: string (required)
          Letter of Credit Reference External
        - pageNum: integer
          pageNum
        - pageSize: integer
          pageSize
        
        
        
        Headers:
        - ChannelType: integer
          Channel identifier from where the TXN has originated (Internet, Mobile, ATM, Branch Channel )
        - co-Relationid: integer
          Unique ID for the service invoked, will be set by the TXN system
        - entity: string
          entity
        - initiatingSystem: string
          Indicating the initiated system
        - languageCode: integer
          languageCode
        - serviceMode: integer
          Used for branch channel to indicate the type of customer
        - userId: integer
          userId
        - uuidSeqNo: integer
          UUID Sequence Number
        
        
        """
        
        
        # Prepare query parameters
        params = {}
        if pagenum is not None:
            params["pageNum"] = pagenum
            
        if pagesize is not None:
            params["pageSize"] = pagesize
            
        
        
        # Replace path parameters in URL
        path = "/tradeFinance/importLetterOfCredit/modify/{lcReferenceExternal}/GetModifiedLCMarginDtls"
        if lcreferenceexternal is not None:
            path = path.replace("{lcReferenceExternal}", str(lcreferenceexternal))
        
        
        # Prepare headers
        headers = {}
        if channeltype is not None:
            headers["ChannelType"] = str(channeltype)
        if co_relationid is not None:
            headers["co-Relationid"] = str(co_relationid)
        if entity is not None:
            headers["entity"] = str(entity)
        if initiatingsystem is not None:
            headers["initiatingSystem"] = str(initiatingsystem)
        if languagecode is not None:
            headers["languageCode"] = str(languagecode)
        if servicemode is not None:
            headers["serviceMode"] = str(servicemode)
        if userid is not None:
            headers["userId"] = str(userid)
        if uuidseqno is not None:
            headers["uuidSeqNo"] = str(uuidseqno)
        
        
        return await make_api_request(
            "GET", 
            path, 
            
            params=params if params else None, 
            headers=headers if headers else None
        )
    
    
    
    @mcp.tool()
    async def tfbt5546_modify_lcwrapper_postusing_put(
        lcreferenceexternal: str,
        authoriseflag: Optional[int] = None,
        authoriseremarks: Optional[str] = None,
        modeflag: Optional[int] = None,
        channeltype: Optional[int] = None,
        co_relationid: Optional[int] = None,
        entity: Optional[str] = None,
        initiatingsystem: Optional[str] = None,
        languagecode: Optional[int] = None,
        servicemode: Optional[int] = None,
        userid: Optional[int] = None,
        uuidseqno: Optional[int] = None
    ) -> Dict[str, Any]:
        """
        ModifyLCWrapper
        
        Generated from: PUT /tradeFinance/importLetterOfCredit/modify/{lcReferenceExternal}/authorise
        Source: swagger_2_0
        Operation ID: TFBT5546ModifyLCWrapper_POSTUsingPUT
        
        
        Authentication: Not required
        
        Parameters:
        - authoriseFlag: integer
          Authorise Flag. Possible values : 1 - Authorise, 2 - Reject, 3 - Sent Back Domain name : d_VerAuthFlg
        - authoriseRemarks: string
          Authorise Remarks
        - lcReferenceExternal: string (required)
          Letter of Credit Reference External
        - modeFlag: integer
          Mode Flag. Possible values : 9 - Release , Default empty for Authorise service. Domain name : d_ModeFlg
        
        
        
        Headers:
        - ChannelType: integer
          Channel identifier from where the TXN has originated (Internet, Mobile, ATM, Branch Channel )
        - co-Relationid: integer
          Unique ID for the service invoked, will be set by the TXN system
        - entity: string
          entity
        - initiatingSystem: string
          Indicating the initiated system
        - languageCode: integer
          languageCode
        - serviceMode: integer
          Used for branch channel to indicate the type of customer
        - userId: integer
          userId
        - uuidSeqNo: integer
          UUID Sequence Number
        
        
        """
        
        
        # Prepare query parameters
        params = {}
        if authoriseflag is not None:
            params["authoriseFlag"] = authoriseflag
            
        if authoriseremarks is not None:
            params["authoriseRemarks"] = authoriseremarks
            
        if modeflag is not None:
            params["modeFlag"] = modeflag
            
        
        
        # Replace path parameters in URL
        path = "/tradeFinance/importLetterOfCredit/modify/{lcReferenceExternal}/authorise"
        if lcreferenceexternal is not None:
            path = path.replace("{lcReferenceExternal}", str(lcreferenceexternal))
        
        
        # Prepare headers
        headers = {}
        if channeltype is not None:
            headers["ChannelType"] = str(channeltype)
        if co_relationid is not None:
            headers["co-Relationid"] = str(co_relationid)
        if entity is not None:
            headers["entity"] = str(entity)
        if initiatingsystem is not None:
            headers["initiatingSystem"] = str(initiatingsystem)
        if languagecode is not None:
            headers["languageCode"] = str(languagecode)
        if servicemode is not None:
            headers["serviceMode"] = str(servicemode)
        if userid is not None:
            headers["userId"] = str(userid)
        if uuidseqno is not None:
            headers["uuidSeqNo"] = str(uuidseqno)
        
        
        return await make_api_request(
            "PUT", 
            path, 
            
            params=params if params else None, 
            headers=headers if headers else None
        )
    
    
    
    @mcp.tool()
    async def tfbt5546_modify_lcmargin_dtls_postusing_put(
        lcreferenceexternal: str,
        request_body:Dict[str, Any] ,  # ModifyLCMarginDtlsResourse,
        channeltype: Optional[int] = None,
        co_relationid: Optional[int] = None,
        entity: Optional[str] = None,
        initiatingsystem: Optional[str] = None,
        languagecode: Optional[int] = None,
        servicemode: Optional[int] = None,
        userid: Optional[int] = None,
        uuidseqno: Optional[int] = None
    ) -> Dict[str, Any]:
        """
        ModifyLCMarginDtls
        
        Generated from: PUT /tradeFinance/importLetterOfCredit/modify/{lcReferenceExternal}/marginDetails
        Source: swagger_2_0
        Operation ID: TFBT5546ModifyLCMarginDtls_POSTUsingPUT
        
        
        Authentication: Not required
        
        Parameters:
        - lcReferenceExternal: string (required)
          LC Reference External
        - request_body: any (required)
          input
        
        
        
        Headers:
        - ChannelType: integer
          Channel identifier from where the TXN has originated (Internet, Mobile, ATM, Branch Channel )
        - co-Relationid: integer
          Unique ID for the service invoked, will be set by the TXN system
        - entity: string
          entity
        - initiatingSystem: string
          Indicating the initiated system
        - languageCode: integer
          languageCode
        - serviceMode: integer
          Used for branch channel to indicate the type of customer
        - userId: integer
          userId
        - uuidSeqNo: integer
          UUID Sequence Number
        
        
        """
        
        
        # Prepare request data
        
        # Single body parameter - send directly
        data = request_body if request_body is not None else {}
        
        
        
        # Prepare query parameters
        params = {}
        
        
        # Replace path parameters in URL
        path = "/tradeFinance/importLetterOfCredit/modify/{lcReferenceExternal}/marginDetails"
        if lcreferenceexternal is not None:
            path = path.replace("{lcReferenceExternal}", str(lcreferenceexternal))
        
        
        # Prepare headers
        headers = {}
        if channeltype is not None:
            headers["ChannelType"] = str(channeltype)
        if co_relationid is not None:
            headers["co-Relationid"] = str(co_relationid)
        if entity is not None:
            headers["entity"] = str(entity)
        if initiatingsystem is not None:
            headers["initiatingSystem"] = str(initiatingsystem)
        if languagecode is not None:
            headers["languageCode"] = str(languagecode)
        if servicemode is not None:
            headers["serviceMode"] = str(servicemode)
        if userid is not None:
            headers["userId"] = str(userid)
        if uuidseqno is not None:
            headers["uuidSeqNo"] = str(uuidseqno)
        
        
        return await make_api_request(
            "PUT", 
            path, 
            data=data, 
            params=params if params else None, 
            headers=headers if headers else None
        )
    
    
    
    @mcp.tool()
    async def tfet5546_fetch_margin_history_postusing_get(
        lcreferenceexternal: str,
        channeltype: Optional[int] = None,
        co_relationid: Optional[int] = None,
        entity: Optional[str] = None,
        initiatingsystem: Optional[str] = None,
        languagecode: Optional[int] = None,
        servicemode: Optional[int] = None,
        userid: Optional[int] = None,
        uuidseqno: Optional[int] = None
    ) -> Dict[str, Any]:
        """
        lcMarginHistory
        
        Generated from: GET /tradeFinance/importLetterOfCredit/modify/{lcReferenceExternal}/marginHistory
        Source: swagger_2_0
        Operation ID: TFET5546FetchMarginHistory_POSTUsingGET
        
        
        Authentication: Not required
        
        Parameters:
        - lcReferenceExternal: string (required)
          Letter of Credit Reference External
        
        
        
        Headers:
        - ChannelType: integer
          Channel identifier from where the TXN has originated (Internet, Mobile, ATM, Branch Channel )
        - co-Relationid: integer
          Unique ID for the service invoked, will be set by the TXN system
        - entity: string
          entity
        - initiatingSystem: string
          Indicating the initiated system
        - languageCode: integer
          languageCode
        - serviceMode: integer
          Used for branch channel to indicate the type of customer
        - userId: integer
          userId
        - uuidSeqNo: integer
          UUID Sequence Number
        
        
        """
        
        
        # Prepare query parameters
        params = {}
        
        
        # Replace path parameters in URL
        path = "/tradeFinance/importLetterOfCredit/modify/{lcReferenceExternal}/marginHistory"
        if lcreferenceexternal is not None:
            path = path.replace("{lcReferenceExternal}", str(lcreferenceexternal))
        
        
        # Prepare headers
        headers = {}
        if channeltype is not None:
            headers["ChannelType"] = str(channeltype)
        if co_relationid is not None:
            headers["co-Relationid"] = str(co_relationid)
        if entity is not None:
            headers["entity"] = str(entity)
        if initiatingsystem is not None:
            headers["initiatingSystem"] = str(initiatingsystem)
        if languagecode is not None:
            headers["languageCode"] = str(languagecode)
        if servicemode is not None:
            headers["serviceMode"] = str(servicemode)
        if userid is not None:
            headers["userId"] = str(userid)
        if uuidseqno is not None:
            headers["uuidSeqNo"] = str(uuidseqno)
        
        
        return await make_api_request(
            "GET", 
            path, 
            
            params=params if params else None, 
            headers=headers if headers else None
        )
    
    
    
    @mcp.tool()
    async def tfet4876_fetch_all_lcevents_postusing_get(
        customerid: str,
        lcreferenceexternal: str,
        pagenum: Optional[int] = None,
        pagesize: Optional[int] = None,
        accesstoken: Optional[str] = None,
        channeltype: Optional[int] = None,
        co_relationid: Optional[int] = None,
        entity: Optional[str] = None,
        initiatingsystem: Optional[str] = None,
        languagecode: Optional[int] = None,
        referenceid: Optional[str] = None,
        servicemode: Optional[int] = None,
        userid: Optional[int] = None,
        uuidseqno: Optional[int] = None
    ) -> Dict[str, Any]:
        """
        Service to fetch all letter of credit events
        
        Generated from: GET /tradeFinance/importLetterOfCredit/{customerId}/{lcReferenceExternal}/eventsList
        Source: swagger_2_0
        Operation ID: TFET4876FetchAllLCEvents_POSTUsingGET
        
        
        Authentication: Not required
        
        Parameters:
        - customerId: string (required)
          Customer ID
        - lcReferenceExternal: string (required)
          LC Reference External
        - pageNum: integer
          pageNum
        - pageSize: integer
          pageSize
        
        
        
        Headers:
        - Accesstoken: string
          Authorization Token to validation the caller
        - ChannelType: integer
          Channel identifier from where the TXN has originated (Internet, Mobile, ATM, Branch Channel )
        - co-Relationid: integer
          Unique ID for the service invoked, will be set by the TXN system
        - entity: string
          entity
        - initiatingSystem: string
          Indicating the initiated system
        - languageCode: integer
          languageCode
        - referenceId: string
          Place holder for Token based authentication
        - serviceMode: integer
          Used for branch channel to indicate the type of customer
        - userId: integer
          userId
        - uuidSeqNo: integer
          UUID Sequence Number
        
        
        """
        
        
        # Prepare query parameters
        params = {}
        if pagenum is not None:
            params["pageNum"] = pagenum
            
        if pagesize is not None:
            params["pageSize"] = pagesize
            
        
        
        # Replace path parameters in URL
        path = "/tradeFinance/importLetterOfCredit/{customerId}/{lcReferenceExternal}/eventsList"
        if customerid is not None:
            path = path.replace("{customerId}", str(customerid))
        if lcreferenceexternal is not None:
            path = path.replace("{lcReferenceExternal}", str(lcreferenceexternal))
        
        
        # Prepare headers
        headers = {}
        if accesstoken is not None:
            headers["Accesstoken"] = str(accesstoken)
        if channeltype is not None:
            headers["ChannelType"] = str(channeltype)
        if co_relationid is not None:
            headers["co-Relationid"] = str(co_relationid)
        if entity is not None:
            headers["entity"] = str(entity)
        if initiatingsystem is not None:
            headers["initiatingSystem"] = str(initiatingsystem)
        if languagecode is not None:
            headers["languageCode"] = str(languagecode)
        if referenceid is not None:
            headers["referenceId"] = str(referenceid)
        if servicemode is not None:
            headers["serviceMode"] = str(servicemode)
        if userid is not None:
            headers["userId"] = str(userid)
        if uuidseqno is not None:
            headers["uuidSeqNo"] = str(uuidseqno)
        
        
        return await make_api_request(
            "GET", 
            path, 
            
            params=params if params else None, 
            headers=headers if headers else None
        )
    
    
    
    @mcp.tool()
    async def tfbt4884_auth_lcreinstatement_postusing_put(
        lcreferenceexternal: str,
        channeltype: Optional[int] = None,
        co_relationid: Optional[int] = None,
        entity: Optional[str] = None,
        initiatingsystem: Optional[str] = None,
        languagecode: Optional[int] = None,
        servicemode: Optional[int] = None,
        userid: Optional[int] = None,
        uuidseqno: Optional[int] = None
    ) -> Dict[str, Any]:
        """
        reinstatementauth
        
        Generated from: PUT /tradeFinance/importLetterOfCredit/{lCReferenceExternal}/authReinstatement
        Source: swagger_2_0
        Operation ID: TFBT4884AuthLCReinstatement_POSTUsingPUT
        
        
        Authentication: Not required
        
        Parameters:
        - lCReferenceExternal: string (required)
          Letter Of Credit External Reference
        
        
        
        Headers:
        - ChannelType: integer
          Channel identifier from where the TXN has originated (Internet, Mobile, ATM, Branch Channel )
        - co-Relationid: integer
          Unique ID for the service invoked, will be set by the TXN system
        - entity: string
          entity
        - initiatingSystem: string
          Indicating the initiated system
        - languageCode: integer
          languageCode
        - serviceMode: integer
          Used for branch channel to indicate the type of customer
        - userId: integer
          userId
        - uuidSeqNo: integer
          UUID Sequence Number
        
        
        """
        
        
        # Prepare query parameters
        params = {}
        
        
        # Replace path parameters in URL
        path = "/tradeFinance/importLetterOfCredit/{lCReferenceExternal}/authReinstatement"
        if lcreferenceexternal is not None:
            path = path.replace("{lCReferenceExternal}", str(lcreferenceexternal))
        
        
        # Prepare headers
        headers = {}
        if channeltype is not None:
            headers["ChannelType"] = str(channeltype)
        if co_relationid is not None:
            headers["co-Relationid"] = str(co_relationid)
        if entity is not None:
            headers["entity"] = str(entity)
        if initiatingsystem is not None:
            headers["initiatingSystem"] = str(initiatingsystem)
        if languagecode is not None:
            headers["languageCode"] = str(languagecode)
        if servicemode is not None:
            headers["serviceMode"] = str(servicemode)
        if userid is not None:
            headers["userId"] = str(userid)
        if uuidseqno is not None:
            headers["uuidSeqNo"] = str(uuidseqno)
        
        
        return await make_api_request(
            "PUT", 
            path, 
            
            params=params if params else None, 
            headers=headers if headers else None
        )
    
    
    
    @mcp.tool()
    async def tfbt5072_lcdraft_postusing_put(
        lcreferenceexternal: str,
        request_body:Dict[str, Any] ,  # lCDraftResource,
        channeltype: Optional[int] = None,
        co_relationid: Optional[int] = None,
        entity: Optional[str] = None,
        initiatingsystem: Optional[str] = None,
        languagecode: Optional[int] = None,
        servicemode: Optional[int] = None,
        userid: Optional[int] = None,
        uuidseqno: Optional[int] = None
    ) -> Dict[str, Any]:
        """
        save draft
        
        Generated from: PUT /tradeFinance/importLetterOfCredit/{lCReferenceExternal}/draft
        Source: swagger_2_0
        Operation ID: TFBT5072LCDraft_POSTUsingPUT
        
        
        Authentication: Not required
        
        Parameters:
        - lCReferenceExternal: string (required)
          LC Reference External
        - request_body: any (required)
          input
        
        
        
        Headers:
        - ChannelType: integer
          Channel identifier from where the TXN has originated (Internet, Mobile, ATM, Branch Channel )
        - co-Relationid: integer
          Unique ID for the service invoked, will be set by the TXN system
        - entity: string
          entity
        - initiatingSystem: string
          Indicating the initiated system
        - languageCode: integer
          languageCode
        - serviceMode: integer
          Used for branch channel to indicate the type of customer
        - userId: integer
          userId
        - uuidSeqNo: integer
          UUID Sequence Number
        
        
        """
        
        
        # Prepare request data
        
        # Single body parameter - send directly
        data = request_body if request_body is not None else {}
        
        
        
        # Prepare query parameters
        params = {}
        
        
        # Replace path parameters in URL
        path = "/tradeFinance/importLetterOfCredit/{lCReferenceExternal}/draft"
        if lcreferenceexternal is not None:
            path = path.replace("{lCReferenceExternal}", str(lcreferenceexternal))
        
        
        # Prepare headers
        headers = {}
        if channeltype is not None:
            headers["ChannelType"] = str(channeltype)
        if co_relationid is not None:
            headers["co-Relationid"] = str(co_relationid)
        if entity is not None:
            headers["entity"] = str(entity)
        if initiatingsystem is not None:
            headers["initiatingSystem"] = str(initiatingsystem)
        if languagecode is not None:
            headers["languageCode"] = str(languagecode)
        if servicemode is not None:
            headers["serviceMode"] = str(servicemode)
        if userid is not None:
            headers["userId"] = str(userid)
        if uuidseqno is not None:
            headers["uuidSeqNo"] = str(uuidseqno)
        
        
        return await make_api_request(
            "PUT", 
            path, 
            data=data, 
            params=params if params else None, 
            headers=headers if headers else None
        )
    
    
    
    @mcp.tool()
    async def tfbt4884_lcreinstatement_postusing_put(
        lcreferenceexternal: str,
        request_body:Dict[str, Any] ,  # reinstatementResource,
        channeltype: Optional[int] = None,
        co_relationid: Optional[int] = None,
        entity: Optional[str] = None,
        initiatingsystem: Optional[str] = None,
        languagecode: Optional[int] = None,
        servicemode: Optional[int] = None,
        userid: Optional[int] = None,
        uuidseqno: Optional[int] = None
    ) -> Dict[str, Any]:
        """
        lcReinstatement
        
        Generated from: PUT /tradeFinance/importLetterOfCredit/{lCReferenceExternal}/reinstatement
        Source: swagger_2_0
        Operation ID: TFBT4884LCReinstatement_POSTUsingPUT
        
        
        Authentication: Not required
        
        Parameters:
        - lCReferenceExternal: string (required)
          LC Reference External
        - request_body: any (required)
          input
        
        
        
        Headers:
        - ChannelType: integer
          Channel identifier from where the TXN has originated (Internet, Mobile, ATM, Branch Channel )
        - co-Relationid: integer
          Unique ID for the service invoked, will be set by the TXN system
        - entity: string
          entity
        - initiatingSystem: string
          Indicating the initiated system
        - languageCode: integer
          languageCode
        - serviceMode: integer
          Used for branch channel to indicate the type of customer
        - userId: integer
          userId
        - uuidSeqNo: integer
          UUID Sequence Number
        
        
        """
        
        
        # Prepare request data
        
        # Single body parameter - send directly
        data = request_body if request_body is not None else {}
        
        
        
        # Prepare query parameters
        params = {}
        
        
        # Replace path parameters in URL
        path = "/tradeFinance/importLetterOfCredit/{lCReferenceExternal}/reinstatement"
        if lcreferenceexternal is not None:
            path = path.replace("{lCReferenceExternal}", str(lcreferenceexternal))
        
        
        # Prepare headers
        headers = {}
        if channeltype is not None:
            headers["ChannelType"] = str(channeltype)
        if co_relationid is not None:
            headers["co-Relationid"] = str(co_relationid)
        if entity is not None:
            headers["entity"] = str(entity)
        if initiatingsystem is not None:
            headers["initiatingSystem"] = str(initiatingsystem)
        if languagecode is not None:
            headers["languageCode"] = str(languagecode)
        if servicemode is not None:
            headers["serviceMode"] = str(servicemode)
        if userid is not None:
            headers["userId"] = str(userid)
        if uuidseqno is not None:
            headers["uuidSeqNo"] = str(uuidseqno)
        
        
        return await make_api_request(
            "PUT", 
            path, 
            data=data, 
            params=params if params else None, 
            headers=headers if headers else None
        )
    
    
    
    @mcp.tool()
    async def tfbt5302_revived_on_hold_postusing_put(
        lcexternalreference: str,
        request_body:Dict[str, Any] ,  # ReviveLCOnHoldResource,
        channeltype: Optional[int] = None,
        co_relationid: Optional[int] = None,
        entity: Optional[str] = None,
        initiatingsystem: Optional[str] = None,
        languagecode: Optional[int] = None,
        servicemode: Optional[int] = None,
        userid: Optional[int] = None,
        uuidseqno: Optional[int] = None
    ) -> Dict[str, Any]:
        """
        ReviveLCOnHold
        
        Generated from: PUT /tradeFinance/importLetterOfCredit/{lcExternalReference}/revive
        Source: swagger_2_0
        Operation ID: TFBT5302RevivedOnHold_POSTUsingPUT
        
        
        Authentication: Not required
        
        Parameters:
        - lcExternalReference: string (required)
          Letter Of Credit External Reference
        - request_body: any (required)
          input
        
        
        
        Headers:
        - ChannelType: integer
          Channel identifier from where the TXN has originated (Internet, Mobile, ATM, Branch Channel )
        - co-Relationid: integer
          Unique ID for the service invoked, will be set by the TXN system
        - entity: string
          entity
        - initiatingSystem: string
          Indicating the initiated system
        - languageCode: integer
          languageCode
        - serviceMode: integer
          Used for branch channel to indicate the type of customer
        - userId: integer
          userId
        - uuidSeqNo: integer
          UUID Sequence Number
        
        
        """
        
        
        # Prepare request data
        
        # Single body parameter - send directly
        data = request_body if request_body is not None else {}
        
        
        
        # Prepare query parameters
        params = {}
        
        
        # Replace path parameters in URL
        path = "/tradeFinance/importLetterOfCredit/{lcExternalReference}/revive"
        if lcexternalreference is not None:
            path = path.replace("{lcExternalReference}", str(lcexternalreference))
        
        
        # Prepare headers
        headers = {}
        if channeltype is not None:
            headers["ChannelType"] = str(channeltype)
        if co_relationid is not None:
            headers["co-Relationid"] = str(co_relationid)
        if entity is not None:
            headers["entity"] = str(entity)
        if initiatingsystem is not None:
            headers["initiatingSystem"] = str(initiatingsystem)
        if languagecode is not None:
            headers["languageCode"] = str(languagecode)
        if servicemode is not None:
            headers["serviceMode"] = str(servicemode)
        if userid is not None:
            headers["userId"] = str(userid)
        if uuidseqno is not None:
            headers["uuidSeqNo"] = str(uuidseqno)
        
        
        return await make_api_request(
            "PUT", 
            path, 
            data=data, 
            params=params if params else None, 
            headers=headers if headers else None
        )
    
    
    
    @mcp.tool()
    async def tfbt5302_revived_wrapper_postusing_put(
        lcexternalreference: str,
        request_body:Dict[str, Any] ,  # RlsdAndAuthRevivedLCResource,
        authflag: Optional[int] = None,
        authoriseremarks: Optional[str] = None,
        modeflag: Optional[int] = None,
        channeltype: Optional[int] = None,
        co_relationid: Optional[int] = None,
        entity: Optional[str] = None,
        initiatingsystem: Optional[str] = None,
        languagecode: Optional[int] = None,
        servicemode: Optional[int] = None,
        userid: Optional[int] = None,
        uuidseqno: Optional[int] = None
    ) -> Dict[str, Any]:
        """
        RlsdAndAuthRevivedLC
        
        Generated from: PUT /tradeFinance/importLetterOfCredit/{lcExternalReference}/revive/authorisation
        Source: swagger_2_0
        Operation ID: TFBT5302RevivedWrapper_POSTUsingPUT
        
        
        Authentication: Not required
        
        Parameters:
        - authFlag: integer
          Authorise Flag. Possible values : 1 - Authorise, 2 - Reject, 3 - Sent Back Domain name : d_VerAuthFlg
        - authoriseRemarks: string
          Authorise Remarks
        - lcExternalReference: string (required)
          Letter Of Credit External Reference
        - modeFlag: integer
          Mode Flag. Possible values : 9 - Release , Default empty for Authorise service. Domain name : d_ModeFlg
        - request_body: any (required)
          input
        
        
        
        Headers:
        - ChannelType: integer
          Channel identifier from where the TXN has originated (Internet, Mobile, ATM, Branch Channel )
        - co-Relationid: integer
          Unique ID for the service invoked, will be set by the TXN system
        - entity: string
          entity
        - initiatingSystem: string
          Indicating the initiated system
        - languageCode: integer
          languageCode
        - serviceMode: integer
          Used for branch channel to indicate the type of customer
        - userId: integer
          userId
        - uuidSeqNo: integer
          UUID Sequence Number
        
        
        """
        
        
        # Prepare request data
        
        # Single body parameter - send directly
        data = request_body if request_body is not None else {}
        
        
        
        # Prepare query parameters
        params = {}
        if authflag is not None:
            params["authFlag"] = authflag
            
        if authoriseremarks is not None:
            params["authoriseRemarks"] = authoriseremarks
            
        if modeflag is not None:
            params["modeFlag"] = modeflag
            
        
        
        # Replace path parameters in URL
        path = "/tradeFinance/importLetterOfCredit/{lcExternalReference}/revive/authorisation"
        if lcexternalreference is not None:
            path = path.replace("{lcExternalReference}", str(lcexternalreference))
        
        
        # Prepare headers
        headers = {}
        if channeltype is not None:
            headers["ChannelType"] = str(channeltype)
        if co_relationid is not None:
            headers["co-Relationid"] = str(co_relationid)
        if entity is not None:
            headers["entity"] = str(entity)
        if initiatingsystem is not None:
            headers["initiatingSystem"] = str(initiatingsystem)
        if languagecode is not None:
            headers["languageCode"] = str(languagecode)
        if servicemode is not None:
            headers["serviceMode"] = str(servicemode)
        if userid is not None:
            headers["userId"] = str(userid)
        if uuidseqno is not None:
            headers["uuidSeqNo"] = str(uuidseqno)
        
        
        return await make_api_request(
            "PUT", 
            path, 
            data=data, 
            params=params if params else None, 
            headers=headers if headers else None
        )
    
    
    
    @mcp.tool()
    async def tfbt5575_incoming_lc_postusing_put(
        letterofcreditexternalreference: str,
        request_body:Dict[str, Any] ,  # incomingSwiftResource,
        channeltype: Optional[int] = None,
        co_relationid: Optional[int] = None,
        entity: Optional[str] = None,
        initiatingsystem: Optional[str] = None,
        languagecode: Optional[int] = None,
        servicemode: Optional[int] = None,
        userid: Optional[int] = None,
        uuidseqno: Optional[int] = None
    ) -> Dict[str, Any]:
        """
        Incoming Swift
        
        Generated from: PUT /tradeFinance/importLetterOfCredit/{letterOfCreditExternalReference}/incomingSwift
        Source: swagger_2_0
        Operation ID: TFBT5575IncomingLC_POSTUsingPUT
        
        
        Authentication: Not required
        
        Parameters:
        - letterOfCreditExternalReference: string (required)
          Letter Of Credit External Reference
        - request_body: any (required)
          input
        
        
        
        Headers:
        - ChannelType: integer
          Channel identifier from where the TXN has originated (Internet, Mobile, ATM, Branch Channel )
        - co-Relationid: integer
          Unique ID for the service invoked, will be set by the TXN system
        - entity: string
          entity
        - initiatingSystem: string
          Indicating the initiated system
        - languageCode: integer
          languageCode
        - serviceMode: integer
          Used for branch channel to indicate the type of customer
        - userId: integer
          userId
        - uuidSeqNo: integer
          UUID Sequence Number
        
        
        """
        
        
        # Prepare request data
        
        # Single body parameter - send directly
        data = request_body if request_body is not None else {}
        
        
        
        # Prepare query parameters
        params = {}
        
        
        # Replace path parameters in URL
        path = "/tradeFinance/importLetterOfCredit/{letterOfCreditExternalReference}/incomingSwift"
        if letterofcreditexternalreference is not None:
            path = path.replace("{letterOfCreditExternalReference}", str(letterofcreditexternalreference))
        
        
        # Prepare headers
        headers = {}
        if channeltype is not None:
            headers["ChannelType"] = str(channeltype)
        if co_relationid is not None:
            headers["co-Relationid"] = str(co_relationid)
        if entity is not None:
            headers["entity"] = str(entity)
        if initiatingsystem is not None:
            headers["initiatingSystem"] = str(initiatingsystem)
        if languagecode is not None:
            headers["languageCode"] = str(languagecode)
        if servicemode is not None:
            headers["serviceMode"] = str(servicemode)
        if userid is not None:
            headers["userId"] = str(userid)
        if uuidseqno is not None:
            headers["uuidSeqNo"] = str(uuidseqno)
        
        
        return await make_api_request(
            "PUT", 
            path, 
            data=data, 
            params=params if params else None, 
            headers=headers if headers else None
        )
    
    
    
    @mcp.tool()
    async def ibgbt4616_user_confirmation_ibg_postusing_post(
        request_body:Dict[str, Any] ,  # ibgBankGuaranteeUserConfirmationRequest,
        accesstoken: Optional[str] = None,
        channeltype: Optional[int] = None,
        co_relationid: Optional[int] = None,
        entity: Optional[str] = None,
        initiatingsystem: Optional[str] = None,
        languagecode: Optional[int] = None,
        referenceid: Optional[str] = None,
        servicemode: Optional[int] = None,
        userid: Optional[int] = None,
        uuidseqno: Optional[int] = None
    ) -> Dict[str, Any]:
        """
        UserConfirmationIBG
        
        Generated from: POST /tradeFinance/incomingBankGuarantee/UserConfirmation
        Source: swagger_2_0
        Operation ID: IBGBT4616UserConfirmationIBG_POSTUsingPOST
        
        
        Authentication: Not required
        
        Parameters:
        - request_body: any (required)
          input
        
        
        
        Headers:
        - Accesstoken: string
          Authorization Token to validation the caller
        - ChannelType: integer
          Channel identifier from where the TXN has originated (Internet, Mobile, ATM, Branch Channel )
        - co-Relationid: integer
          Unique ID for the service invoked, will be set by the TXN system
        - entity: string
          entity
        - initiatingSystem: string
          Indicating the initiated system
        - languageCode: integer
          languageCode
        - referenceId: string
          Place holder for Token based authentication
        - serviceMode: integer
          Used for branch channel to indicate the type of customer
        - userId: integer
          userId
        - uuidSeqNo: integer
          UUID Sequence Number
        
        
        """
        
        
        # Prepare request data
        
        # Single body parameter - send directly
        data = request_body if request_body is not None else {}
        
        
        
        # Prepare query parameters
        params = {}
        
        
        # Replace path parameters in URL
        path = "/tradeFinance/incomingBankGuarantee/UserConfirmation"
        
        
        # Prepare headers
        headers = {}
        if accesstoken is not None:
            headers["Accesstoken"] = str(accesstoken)
        if channeltype is not None:
            headers["ChannelType"] = str(channeltype)
        if co_relationid is not None:
            headers["co-Relationid"] = str(co_relationid)
        if entity is not None:
            headers["entity"] = str(entity)
        if initiatingsystem is not None:
            headers["initiatingSystem"] = str(initiatingsystem)
        if languagecode is not None:
            headers["languageCode"] = str(languagecode)
        if referenceid is not None:
            headers["referenceId"] = str(referenceid)
        if servicemode is not None:
            headers["serviceMode"] = str(servicemode)
        if userid is not None:
            headers["userId"] = str(userid)
        if uuidseqno is not None:
            headers["uuidSeqNo"] = str(uuidseqno)
        
        
        return await make_api_request(
            "POST", 
            path, 
            data=data, 
            params=params if params else None, 
            headers=headers if headers else None
        )
    
    
    
    @mcp.tool()
    async def ibgbt4616_auth_reject_ibgamnd_postusing_put(
        authoriseflag: int,
        evntlegid: int,
        ibgtransactionid: int,
        accesstoken: Optional[str] = None,
        channeltype: Optional[int] = None,
        co_relationid: Optional[int] = None,
        entity: Optional[str] = None,
        initiatingsystem: Optional[str] = None,
        languagecode: Optional[int] = None,
        referenceid: Optional[str] = None,
        servicemode: Optional[int] = None,
        userid: Optional[int] = None,
        uuidseqno: Optional[int] = None
    ) -> Dict[str, Any]:
        """
        Authorise Reject IBG Amend
        
        Generated from: PUT /tradeFinance/incomingBankGuarantee/amend/authreject
        Source: swagger_2_0
        Operation ID: IBGBT4616AuthRejectIBGAmnd_POSTUsingPUT
        
        
        Authentication: Not required
        
        Parameters:
        - authoriseFlag: integer (required)
          Authorise Flag. Possible values : 10 - Authorise, 11 - Reject Domain name :  d_ModeFlg_Authorised and d_ModeFlg_Reject
        - evntLegId: integer (required)
          event Leg Id
        - ibgTransactionId: integer (required)
          IBG Transaction Id
        
        
        
        Headers:
        - Accesstoken: string
          Authorization Token to validation the caller
        - ChannelType: integer
          Channel identifier from where the TXN has originated (Internet, Mobile, ATM, Branch Channel )
        - co-Relationid: integer
          Unique ID for the service invoked, will be set by the TXN system
        - entity: string
          entity
        - initiatingSystem: string
          Indicating the initiated system
        - languageCode: integer
          languageCode
        - referenceId: string
          Place holder for Token based authentication
        - serviceMode: integer
          Used for branch channel to indicate the type of customer
        - userId: integer
          userId
        - uuidSeqNo: integer
          UUID Sequence Number
        
        
        """
        
        
        # Prepare query parameters
        params = {}
        if authoriseflag is not None:
            params["authoriseFlag"] = authoriseflag
            
        if evntlegid is not None:
            params["evntLegId"] = evntlegid
            
        if ibgtransactionid is not None:
            params["ibgTransactionId"] = ibgtransactionid
            
        
        
        # Replace path parameters in URL
        path = "/tradeFinance/incomingBankGuarantee/amend/authreject"
        
        
        # Prepare headers
        headers = {}
        if accesstoken is not None:
            headers["Accesstoken"] = str(accesstoken)
        if channeltype is not None:
            headers["ChannelType"] = str(channeltype)
        if co_relationid is not None:
            headers["co-Relationid"] = str(co_relationid)
        if entity is not None:
            headers["entity"] = str(entity)
        if initiatingsystem is not None:
            headers["initiatingSystem"] = str(initiatingsystem)
        if languagecode is not None:
            headers["languageCode"] = str(languagecode)
        if referenceid is not None:
            headers["referenceId"] = str(referenceid)
        if servicemode is not None:
            headers["serviceMode"] = str(servicemode)
        if userid is not None:
            headers["userId"] = str(userid)
        if uuidseqno is not None:
            headers["uuidSeqNo"] = str(uuidseqno)
        
        
        return await make_api_request(
            "PUT", 
            path, 
            
            params=params if params else None, 
            headers=headers if headers else None
        )
    
    
    
    @mcp.tool()
    async def ibgbt4616_crt_modify_ibgamnd_postusing_post(
        modeflg: int,
        request_body:Dict[str, Any] ,  # ibgBankGuaranteeAmendCreateModifyRequest,
        accesstoken: Optional[str] = None,
        channeltype: Optional[int] = None,
        co_relationid: Optional[int] = None,
        entity: Optional[str] = None,
        initiatingsystem: Optional[str] = None,
        languagecode: Optional[int] = None,
        referenceid: Optional[str] = None,
        servicemode: Optional[int] = None,
        userid: Optional[int] = None,
        uuidseqno: Optional[int] = None
    ) -> Dict[str, Any]:
        """
        Create Modify IBG Amend
        
        Generated from: POST /tradeFinance/incomingBankGuarantee/amend/createModify
        Source: swagger_2_0
        Operation ID: IBGBT4616CrtModifyIBGAmnd_POSTUsingPOST
        
        
        Authentication: Not required
        
        Parameters:
        - modeFlg: integer (required)
          Mode Flag. Possible values : 1 - Add, 2 - Modify Domain name :  d_ModeFlg_Add and d_ModeFlg_Modify 
        - request_body: any (required)
          input
        
        
        
        Headers:
        - Accesstoken: string
          Authorization Token to validation the caller
        - ChannelType: integer
          Channel identifier from where the TXN has originated (Internet, Mobile, ATM, Branch Channel )
        - co-Relationid: integer
          Unique ID for the service invoked, will be set by the TXN system
        - entity: string
          entity
        - initiatingSystem: string
          Indicating the initiated system
        - languageCode: integer
          languageCode
        - referenceId: string
          Place holder for Token based authentication
        - serviceMode: integer
          Used for branch channel to indicate the type of customer
        - userId: integer
          userId
        - uuidSeqNo: integer
          UUID Sequence Number
        
        
        """
        
        
        # Prepare request data
        
        # Single body parameter - send directly
        data = request_body if request_body is not None else {}
        
        
        
        # Prepare query parameters
        params = {}
        if modeflg is not None:
            params["modeFlg"] = modeflg
            
        
        
        # Replace path parameters in URL
        path = "/tradeFinance/incomingBankGuarantee/amend/createModify"
        
        
        # Prepare headers
        headers = {}
        if accesstoken is not None:
            headers["Accesstoken"] = str(accesstoken)
        if channeltype is not None:
            headers["ChannelType"] = str(channeltype)
        if co_relationid is not None:
            headers["co-Relationid"] = str(co_relationid)
        if entity is not None:
            headers["entity"] = str(entity)
        if initiatingsystem is not None:
            headers["initiatingSystem"] = str(initiatingsystem)
        if languagecode is not None:
            headers["languageCode"] = str(languagecode)
        if referenceid is not None:
            headers["referenceId"] = str(referenceid)
        if servicemode is not None:
            headers["serviceMode"] = str(servicemode)
        if userid is not None:
            headers["userId"] = str(userid)
        if uuidseqno is not None:
            headers["uuidSeqNo"] = str(uuidseqno)
        
        
        return await make_api_request(
            "POST", 
            path, 
            data=data, 
            params=params if params else None, 
            headers=headers if headers else None
        )
    
    
    
    @mcp.tool()
    async def ibget4616_get_amnd_ibgdetails_postusing_get(
        evntlegid: int,
        ibgtransactionid: int,
        accesstoken: Optional[str] = None,
        channeltype: Optional[int] = None,
        co_relationid: Optional[int] = None,
        entity: Optional[str] = None,
        initiatingsystem: Optional[str] = None,
        languagecode: Optional[int] = None,
        referenceid: Optional[str] = None,
        servicemode: Optional[int] = None,
        userid: Optional[int] = None,
        uuidseqno: Optional[int] = None
    ) -> Dict[str, Any]:
        """
        Get IBG Amend Details
        
        Generated from: GET /tradeFinance/incomingBankGuarantee/amend/getdetails
        Source: swagger_2_0
        Operation ID: IBGET4616GetAmndIBGDetails_POSTUsingGET
        
        
        Authentication: Not required
        
        Parameters:
        - evntLegId: integer (required)
          event Leg Id
        - ibgTransactionId: integer (required)
          IBG Transaction Id
        
        
        
        Headers:
        - Accesstoken: string
          Authorization Token to validation the caller
        - ChannelType: integer
          Channel identifier from where the TXN has originated (Internet, Mobile, ATM, Branch Channel )
        - co-Relationid: integer
          Unique ID for the service invoked, will be set by the TXN system
        - entity: string
          entity
        - initiatingSystem: string
          Indicating the initiated system
        - languageCode: integer
          languageCode
        - referenceId: string
          Place holder for Token based authentication
        - serviceMode: integer
          Used for branch channel to indicate the type of customer
        - userId: integer
          userId
        - uuidSeqNo: integer
          UUID Sequence Number
        
        
        """
        
        
        # Prepare query parameters
        params = {}
        if evntlegid is not None:
            params["evntLegId"] = evntlegid
            
        if ibgtransactionid is not None:
            params["ibgTransactionId"] = ibgtransactionid
            
        
        
        # Replace path parameters in URL
        path = "/tradeFinance/incomingBankGuarantee/amend/getdetails"
        
        
        # Prepare headers
        headers = {}
        if accesstoken is not None:
            headers["Accesstoken"] = str(accesstoken)
        if channeltype is not None:
            headers["ChannelType"] = str(channeltype)
        if co_relationid is not None:
            headers["co-Relationid"] = str(co_relationid)
        if entity is not None:
            headers["entity"] = str(entity)
        if initiatingsystem is not None:
            headers["initiatingSystem"] = str(initiatingsystem)
        if languagecode is not None:
            headers["languageCode"] = str(languagecode)
        if referenceid is not None:
            headers["referenceId"] = str(referenceid)
        if servicemode is not None:
            headers["serviceMode"] = str(servicemode)
        if userid is not None:
            headers["userId"] = str(userid)
        if uuidseqno is not None:
            headers["uuidSeqNo"] = str(uuidseqno)
        
        
        return await make_api_request(
            "GET", 
            path, 
            
            params=params if params else None, 
            headers=headers if headers else None
        )
    
    
    
    @mcp.tool()
    async def ibget4616_fetch_amnd_ibglist_postusing_get(
        status: Optional[int] = None,
        amendnumber: Optional[int] = None,
        amendrefextrnl: Optional[str] = None,
        amendrefintrnl: Optional[str] = None,
        amnddt: Optional[str] = None,
        aplcntbpid: Optional[int] = None,
        begindt: Optional[str] = None,
        counterpartyname: Optional[str] = None,
        customername: Optional[str] = None,
        enddt: Optional[str] = None,
        exprydt: Optional[str] = None,
        ibgamt: Optional[float] = None,
        ibgcurrency: Optional[str] = None,
        ibgrefextrnl: Optional[str] = None,
        ibgrefintrnl: Optional[str] = None,
        ibgtransactionid: Optional[int] = None,
        ibgtyp: Optional[int] = None,
        pagenum: Optional[int] = None,
        pagesize: Optional[int] = None,
        strtdt: Optional[str] = None,
        accesstoken: Optional[str] = None,
        channeltype: Optional[int] = None,
        co_relationid: Optional[int] = None,
        entity: Optional[str] = None,
        initiatingsystem: Optional[str] = None,
        languagecode: Optional[int] = None,
        referenceid: Optional[str] = None,
        servicemode: Optional[int] = None,
        userid: Optional[int] = None,
        uuidseqno: Optional[int] = None
    ) -> Dict[str, Any]:
        """
        Fetch IBG Amend List
        
        Generated from: GET /tradeFinance/incomingBankGuarantee/amend/list
        Source: swagger_2_0
        Operation ID: IBGET4616FetchAmndIBGList_POSTUsingGET
        
        
        Authentication: Not required
        
        Parameters:
        - STATUS: integer
          Status
        - amendNumber: integer
          Amend Number
        - amendRefExtrnl: string
          AMEND Ref External
        - amendRefIntrnl: string
          Amend Ref Internal
        - amndDt: string
          Amend Date. Date Format : [yyyyMMdd]
        - aplcntBpId: integer
          Customer Reference
        - beginDt: string
          Start Date Date Format : [yyyyMMdd]
        - counterPartyName: string
          Counter Party/ Issuing Party name
        - customerName: string
          Customer Name
        - endDt: string
          IBG End Date. Date Format :[dd/MM/yyyy]
        - expryDt: string
          Expiry Date 31E. Date Format : [yyyyMMdd]
        - ibgAmt: number
          IBG Amount
        - ibgCurrency: string
          Ibg Currency
        - ibgRefExtrnl: string
          IBG Ref External
        - ibgRefIntrnl: string
          IBG Ref Internal
        - ibgTransactionId: integer
          IBG Transaction Id
        - ibgTyp: integer
          IBG Type
        - pageNum: integer
          pageNum
        - pageSize: integer
          pageSize
        - strtDt: string
          IBG Start Date. Date Format :[dd/MM/yyyy]
        
        
        
        Headers:
        - Accesstoken: string
          Authorization Token to validation the caller
        - channelType: integer
          Channel identifier from where the TXN has originated (Internet, Mobile, ATM, Branch Channel )
        - co-Relationid: integer
          Unique ID for the service invoked, will be set by the TXN system
        - entity: string
          entity
        - initiatingSystem: string
          Indicating the initiated system
        - languageCode: integer
          languageCode
        - referenceId: string
          Place holder for Token based authentication
        - serviceMode: integer
          Used for branch channel to indicate the type of customer
        - userId: integer
          userId
        - uuidSeqNo: integer
          UUID Sequence Number
        
        
        """
        
        
        # Prepare query parameters
        params = {}
        if status is not None:
            params["STATUS"] = status
            
        if amendnumber is not None:
            params["amendNumber"] = amendnumber
            
        if amendrefextrnl is not None:
            params["amendRefExtrnl"] = amendrefextrnl
            
        if amendrefintrnl is not None:
            params["amendRefIntrnl"] = amendrefintrnl
            
        if amnddt is not None:
            params["amndDt"] = amnddt
            
        if aplcntbpid is not None:
            params["aplcntBpId"] = aplcntbpid
            
        if begindt is not None:
            params["beginDt"] = begindt
            
        if counterpartyname is not None:
            params["counterPartyName"] = counterpartyname
            
        if customername is not None:
            params["customerName"] = customername
            
        if enddt is not None:
            params["endDt"] = enddt
            
        if exprydt is not None:
            params["expryDt"] = exprydt
            
        if ibgamt is not None:
            params["ibgAmt"] = ibgamt
            
        if ibgcurrency is not None:
            params["ibgCurrency"] = ibgcurrency
            
        if ibgrefextrnl is not None:
            params["ibgRefExtrnl"] = ibgrefextrnl
            
        if ibgrefintrnl is not None:
            params["ibgRefIntrnl"] = ibgrefintrnl
            
        if ibgtransactionid is not None:
            params["ibgTransactionId"] = ibgtransactionid
            
        if ibgtyp is not None:
            params["ibgTyp"] = ibgtyp
            
        if pagenum is not None:
            params["pageNum"] = pagenum
            
        if pagesize is not None:
            params["pageSize"] = pagesize
            
        if strtdt is not None:
            params["strtDt"] = strtdt
            
        
        
        # Replace path parameters in URL
        path = "/tradeFinance/incomingBankGuarantee/amend/list"
        
        
        # Prepare headers
        headers = {}
        if accesstoken is not None:
            headers["Accesstoken"] = str(accesstoken)
        if channeltype is not None:
            headers["channelType"] = str(channeltype)
        if co_relationid is not None:
            headers["co-Relationid"] = str(co_relationid)
        if entity is not None:
            headers["entity"] = str(entity)
        if initiatingsystem is not None:
            headers["initiatingSystem"] = str(initiatingsystem)
        if languagecode is not None:
            headers["languageCode"] = str(languagecode)
        if referenceid is not None:
            headers["referenceId"] = str(referenceid)
        if servicemode is not None:
            headers["serviceMode"] = str(servicemode)
        if userid is not None:
            headers["userId"] = str(userid)
        if uuidseqno is not None:
            headers["uuidSeqNo"] = str(uuidseqno)
        
        
        return await make_api_request(
            "GET", 
            path, 
            
            params=params if params else None, 
            headers=headers if headers else None
        )
    
    
    
    @mcp.tool()
    async def ibgbt4616_ibgamnd_on_hold_to_rjct_postusing_post(
        evntlegid: int,
        ibgtransactionid: int,
        accesstoken: Optional[str] = None,
        channeltype: Optional[int] = None,
        co_relationid: Optional[int] = None,
        entity: Optional[str] = None,
        initiatingsystem: Optional[str] = None,
        languagecode: Optional[int] = None,
        referenceid: Optional[str] = None,
        servicemode: Optional[int] = None,
        userid: Optional[int] = None,
        uuidseqno: Optional[int] = None
    ) -> Dict[str, Any]:
        """
        IBG Amend Cancel
        
        Generated from: POST /tradeFinance/incomingBankGuarantee/amend/onholdtorjct
        Source: swagger_2_0
        Operation ID: IBGBT4616IBGAmndOnHoldToRjct_POSTUsingPOST
        
        
        Authentication: Not required
        
        Parameters:
        - evntLegId: integer (required)
          event Leg Id
        - ibgTransactionId: integer (required)
          IBG Transaction Id
        
        
        
        Headers:
        - Accesstoken: string
          Authorization Token to validation the caller
        - ChannelType: integer
          Channel identifier from where the TXN has originated (Internet, Mobile, ATM, Branch Channel )
        - co-Relationid: integer
          Unique ID for the service invoked, will be set by the TXN system
        - entity: string
          entity
        - initiatingSystem: string
          Indicating the initiated system
        - languageCode: integer
          languageCode
        - referenceId: string
          Place holder for Token based authentication
        - serviceMode: integer
          Used for branch channel to indicate the type of customer
        - userId: integer
          userId
        - uuidSeqNo: integer
          UUID Sequence Number
        
        
        """
        
        
        # Prepare query parameters
        params = {}
        if evntlegid is not None:
            params["evntLegId"] = evntlegid
            
        if ibgtransactionid is not None:
            params["ibgTransactionId"] = ibgtransactionid
            
        
        
        # Replace path parameters in URL
        path = "/tradeFinance/incomingBankGuarantee/amend/onholdtorjct"
        
        
        # Prepare headers
        headers = {}
        if accesstoken is not None:
            headers["Accesstoken"] = str(accesstoken)
        if channeltype is not None:
            headers["ChannelType"] = str(channeltype)
        if co_relationid is not None:
            headers["co-Relationid"] = str(co_relationid)
        if entity is not None:
            headers["entity"] = str(entity)
        if initiatingsystem is not None:
            headers["initiatingSystem"] = str(initiatingsystem)
        if languagecode is not None:
            headers["languageCode"] = str(languagecode)
        if referenceid is not None:
            headers["referenceId"] = str(referenceid)
        if servicemode is not None:
            headers["serviceMode"] = str(servicemode)
        if userid is not None:
            headers["userId"] = str(userid)
        if uuidseqno is not None:
            headers["uuidSeqNo"] = str(uuidseqno)
        
        
        return await make_api_request(
            "POST", 
            path, 
            
            params=params if params else None, 
            headers=headers if headers else None
        )
    
    
    
    @mcp.tool()
    async def ibgbt4616_user_confirmation_ibgamnd_postusing_post(
        request_body:Dict[str, Any] ,  # ibgBankGuaranteeAmendUserConfirmationRequest,
        accesstoken: Optional[str] = None,
        channeltype: Optional[int] = None,
        co_relationid: Optional[int] = None,
        entity: Optional[str] = None,
        initiatingsystem: Optional[str] = None,
        languagecode: Optional[int] = None,
        referenceid: Optional[str] = None,
        servicemode: Optional[int] = None,
        userid: Optional[int] = None,
        uuidseqno: Optional[int] = None
    ) -> Dict[str, Any]:
        """
        User Confirmation IBG Amend
        
        Generated from: POST /tradeFinance/incomingBankGuarantee/amend/userConfirmation
        Source: swagger_2_0
        Operation ID: IBGBT4616UserConfirmationIBGAmnd_POSTUsingPOST
        
        
        Authentication: Not required
        
        Parameters:
        - request_body: any (required)
          input
        
        
        
        Headers:
        - Accesstoken: string
          Authorization Token to validation the caller
        - ChannelType: integer
          Channel identifier from where the TXN has originated (Internet, Mobile, ATM, Branch Channel )
        - co-Relationid: integer
          Unique ID for the service invoked, will be set by the TXN system
        - entity: string
          entity
        - initiatingSystem: string
          Indicating the initiated system
        - languageCode: integer
          languageCode
        - referenceId: string
          Place holder for Token based authentication
        - serviceMode: integer
          Used for branch channel to indicate the type of customer
        - userId: integer
          userId
        - uuidSeqNo: integer
          UUID Sequence Number
        
        
        """
        
        
        # Prepare request data
        
        # Single body parameter - send directly
        data = request_body if request_body is not None else {}
        
        
        
        # Prepare query parameters
        params = {}
        
        
        # Replace path parameters in URL
        path = "/tradeFinance/incomingBankGuarantee/amend/userConfirmation"
        
        
        # Prepare headers
        headers = {}
        if accesstoken is not None:
            headers["Accesstoken"] = str(accesstoken)
        if channeltype is not None:
            headers["ChannelType"] = str(channeltype)
        if co_relationid is not None:
            headers["co-Relationid"] = str(co_relationid)
        if entity is not None:
            headers["entity"] = str(entity)
        if initiatingsystem is not None:
            headers["initiatingSystem"] = str(initiatingsystem)
        if languagecode is not None:
            headers["languageCode"] = str(languagecode)
        if referenceid is not None:
            headers["referenceId"] = str(referenceid)
        if servicemode is not None:
            headers["serviceMode"] = str(servicemode)
        if userid is not None:
            headers["userId"] = str(userid)
        if uuidseqno is not None:
            headers["uuidSeqNo"] = str(uuidseqno)
        
        
        return await make_api_request(
            "POST", 
            path, 
            data=data, 
            params=params if params else None, 
            headers=headers if headers else None
        )
    
    
    
    @mcp.tool()
    async def ibgbt4616_sentback_ibgamnd_postusing_put(
        ibgamendinternalreference: str,
        evntlegid: Optional[int] = None,
        ibgtransactionid: Optional[int] = None,
        accesstoken: Optional[str] = None,
        channeltype: Optional[int] = None,
        co_relationid: Optional[int] = None,
        entity: Optional[str] = None,
        initiatingsystem: Optional[str] = None,
        languagecode: Optional[int] = None,
        referenceid: Optional[str] = None,
        servicemode: Optional[int] = None,
        userid: Optional[int] = None,
        uuidseqno: Optional[int] = None
    ) -> Dict[str, Any]:
        """
        Sentback IBG Amend
        
        Generated from: PUT /tradeFinance/incomingBankGuarantee/amend/{ibgAmendInternalReference}/sentback
        Source: swagger_2_0
        Operation ID: IBGBT4616SentbackIBGAmnd_POSTUsingPUT
        
        
        Authentication: Not required
        
        Parameters:
        - evntLegId: integer
          event Leg Id
        - ibgAmendInternalReference: string (required)
          IBG Amend Reference Internal
        - ibgTransactionId: integer
          IBG Transaction Id
        
        
        
        Headers:
        - Accesstoken: string
          Authorization Token to validation the caller
        - ChannelType: integer
          Channel identifier from where the TXN has originated (Internet, Mobile, ATM, Branch Channel )
        - co-Relationid: integer
          Unique ID for the service invoked, will be set by the TXN system
        - entity: string
          entity
        - initiatingSystem: string
          Indicating the initiated system
        - languageCode: integer
          languageCode
        - referenceId: string
          Place holder for Token based authentication
        - serviceMode: integer
          Used for branch channel to indicate the type of customer
        - userId: integer
          userId
        - uuidSeqNo: integer
          UUID Sequence Number
        
        
        """
        
        
        # Prepare query parameters
        params = {}
        if evntlegid is not None:
            params["evntLegId"] = evntlegid
            
        if ibgtransactionid is not None:
            params["ibgTransactionId"] = ibgtransactionid
            
        
        
        # Replace path parameters in URL
        path = "/tradeFinance/incomingBankGuarantee/amend/{ibgAmendInternalReference}/sentback"
        if ibgamendinternalreference is not None:
            path = path.replace("{ibgAmendInternalReference}", str(ibgamendinternalreference))
        
        
        # Prepare headers
        headers = {}
        if accesstoken is not None:
            headers["Accesstoken"] = str(accesstoken)
        if channeltype is not None:
            headers["ChannelType"] = str(channeltype)
        if co_relationid is not None:
            headers["co-Relationid"] = str(co_relationid)
        if entity is not None:
            headers["entity"] = str(entity)
        if initiatingsystem is not None:
            headers["initiatingSystem"] = str(initiatingsystem)
        if languagecode is not None:
            headers["languageCode"] = str(languagecode)
        if referenceid is not None:
            headers["referenceId"] = str(referenceid)
        if servicemode is not None:
            headers["serviceMode"] = str(servicemode)
        if userid is not None:
            headers["userId"] = str(userid)
        if uuidseqno is not None:
            headers["uuidSeqNo"] = str(uuidseqno)
        
        
        return await make_api_request(
            "PUT", 
            path, 
            
            params=params if params else None, 
            headers=headers if headers else None
        )
    
    
    
    @mcp.tool()
    async def ibgbt4616_crt_modify_ibg_postusing_post(
        modeflg: int,
        request_body:Dict[str, Any] ,  # ibgIncomingBankGuaranteeCrtModifyRequest,
        accesstoken: Optional[str] = None,
        channeltype: Optional[int] = None,
        co_relationid: Optional[int] = None,
        entity: Optional[str] = None,
        initiatingsystem: Optional[str] = None,
        languagecode: Optional[int] = None,
        referenceid: Optional[str] = None,
        servicemode: Optional[int] = None,
        userid: Optional[int] = None,
        uuidseqno: Optional[int] = None
    ) -> Dict[str, Any]:
        """
        Create/Modify IBG
        
        Generated from: POST /tradeFinance/incomingBankGuarantee/issue/createModify
        Source: swagger_2_0
        Operation ID: IBGBT4616CrtModifyIBG_POSTUsingPOST
        
        
        Authentication: Not required
        
        Parameters:
        - modeFlg: integer (required)
          Mode Flag. Possible values : 1 - Add, 2 - Modify Domain name :  d_ModeFlg_Add and d_ModeFlg_Modify 
        - request_body: any (required)
          input
        
        
        
        Headers:
        - Accesstoken: string
          Authorization Token to validation the caller
        - ChannelType: integer
          Channel identifier from where the TXN has originated (Internet, Mobile, ATM, Branch Channel )
        - co-Relationid: integer
          Unique ID for the service invoked, will be set by the TXN system
        - entity: string
          entity
        - initiatingSystem: string
          Indicating the initiated system
        - languageCode: integer
          languageCode
        - referenceId: string
          Place holder for Token based authentication
        - serviceMode: integer
          Used for branch channel to indicate the type of customer
        - userId: integer
          userId
        - uuidSeqNo: integer
          UUID Sequence Number
        
        
        """
        
        
        # Prepare request data
        
        # Single body parameter - send directly
        data = request_body if request_body is not None else {}
        
        
        
        # Prepare query parameters
        params = {}
        if modeflg is not None:
            params["modeFlg"] = modeflg
            
        
        
        # Replace path parameters in URL
        path = "/tradeFinance/incomingBankGuarantee/issue/createModify"
        
        
        # Prepare headers
        headers = {}
        if accesstoken is not None:
            headers["Accesstoken"] = str(accesstoken)
        if channeltype is not None:
            headers["ChannelType"] = str(channeltype)
        if co_relationid is not None:
            headers["co-Relationid"] = str(co_relationid)
        if entity is not None:
            headers["entity"] = str(entity)
        if initiatingsystem is not None:
            headers["initiatingSystem"] = str(initiatingsystem)
        if languagecode is not None:
            headers["languageCode"] = str(languagecode)
        if referenceid is not None:
            headers["referenceId"] = str(referenceid)
        if servicemode is not None:
            headers["serviceMode"] = str(servicemode)
        if userid is not None:
            headers["userId"] = str(userid)
        if uuidseqno is not None:
            headers["uuidSeqNo"] = str(uuidseqno)
        
        
        return await make_api_request(
            "POST", 
            path, 
            data=data, 
            params=params if params else None, 
            headers=headers if headers else None
        )
    
    
    
    @mcp.tool()
    async def ibget4616_fetch_ibglist_postusing_get(
        cntrprtyname: Optional[str] = None,
        customername: Optional[str] = None,
        customerreference: Optional[int] = None,
        enddate: Optional[str] = None,
        exprydate: Optional[str] = None,
        ibgamt: Optional[float] = None,
        ibgexternalreference: Optional[str] = None,
        ibginstrumentid: Optional[int] = None,
        ibginternalreference: Optional[str] = None,
        ibgtransactionid: Optional[int] = None,
        ibgtyp: Optional[int] = None,
        incomingmode: Optional[int] = None,
        pagenum: Optional[int] = None,
        pagesize: Optional[int] = None,
        startdate: Optional[str] = None,
        status: Optional[int] = None,
        accesstoken: Optional[str] = None,
        channeltype: Optional[int] = None,
        co_relationid: Optional[int] = None,
        entity: Optional[str] = None,
        initiatingsystem: Optional[str] = None,
        languagecode: Optional[int] = None,
        referenceid: Optional[str] = None,
        servicemode: Optional[int] = None,
        userid: Optional[int] = None,
        uuidseqno: Optional[int] = None
    ) -> Dict[str, Any]:
        """
        Fetch IBG List
        
        Generated from: GET /tradeFinance/incomingBankGuarantee/issue/ibgList
        Source: swagger_2_0
        Operation ID: IBGET4616FetchIBGList_POSTUsingGET
        
        
        Authentication: Not required
        
        Parameters:
        - cntrPrtyName: string
          Counter Party/ Issuing Party Name
        - customerName: string
          Applicant Name
        - customerReference: integer
          Customer Reference
        - endDate: string
           IBG End Date. Date Format :[dd/MM/yyyy]
        - expryDate: string
          IBG Expiry Date. Date Format : [dd/MM/yyyy]
        - ibgAmt: number
          IBG Amount
        - ibgExternalReference: string
          IBG External Reference Number(IBG Reference External)
        - ibgInstrumentId: integer
          IBG Instrument Id
        - ibgInternalReference: string
          IBG Internal Reference Number(Guarantee Reference(20))
        - ibgTransactionId: integer
          IBG Transaction Id
        - ibgTyp: integer
          IBG Type
        - incomingMode: integer
           BG Incoming Mode
        - pageNum: integer
          pageNum
        - pageSize: integer
          pageSize
        - startDate: string
           IBG Start Date. Date Format :[dd/MM/yyyy]
        - status: integer
          Status.(IBG Status.Possible Values: 1 - OnHold, 2 - Released, 3 - Verified, 4 - PendingClosure, 5 - Closed, 6 - Executed, 7 - Expired, 8 - Rejected, 9 - WaitingForRate, 10 - AmndmntInit, 11 - AcptRefPndng, 13 - Refused, 12 - Final1, 14 - SuspWdrwPndng, 15 - CnclClosePndng, 16 - RevivalPndng, 17 - Cancelled  Domain : d_TFBGStatus)
        
        
        
        Headers:
        - Accesstoken: string
          Authorization Token to validation the caller
        - channelType: integer
          Channel identifier from where the TXN has originated (Internet, Mobile, ATM, Branch Channel )
        - co-Relationid: integer
          Unique ID for the service invoked, will be set by the TXN system
        - entity: string
          entity
        - initiatingSystem: string
          Indicating the initiated system
        - languageCode: integer
          languageCode
        - referenceId: string
          Place holder for Token based authentication
        - serviceMode: integer
          Used for branch channel to indicate the type of customer
        - userId: integer
          userId
        - uuidSeqNo: integer
          UUID Sequence Number
        
        
        """
        
        
        # Prepare query parameters
        params = {}
        if cntrprtyname is not None:
            params["cntrPrtyName"] = cntrprtyname
            
        if customername is not None:
            params["customerName"] = customername
            
        if customerreference is not None:
            params["customerReference"] = customerreference
            
        if enddate is not None:
            params["endDate"] = enddate
            
        if exprydate is not None:
            params["expryDate"] = exprydate
            
        if ibgamt is not None:
            params["ibgAmt"] = ibgamt
            
        if ibgexternalreference is not None:
            params["ibgExternalReference"] = ibgexternalreference
            
        if ibginstrumentid is not None:
            params["ibgInstrumentId"] = ibginstrumentid
            
        if ibginternalreference is not None:
            params["ibgInternalReference"] = ibginternalreference
            
        if ibgtransactionid is not None:
            params["ibgTransactionId"] = ibgtransactionid
            
        if ibgtyp is not None:
            params["ibgTyp"] = ibgtyp
            
        if incomingmode is not None:
            params["incomingMode"] = incomingmode
            
        if pagenum is not None:
            params["pageNum"] = pagenum
            
        if pagesize is not None:
            params["pageSize"] = pagesize
            
        if startdate is not None:
            params["startDate"] = startdate
            
        if status is not None:
            params["status"] = status
            
        
        
        # Replace path parameters in URL
        path = "/tradeFinance/incomingBankGuarantee/issue/ibgList"
        
        
        # Prepare headers
        headers = {}
        if accesstoken is not None:
            headers["Accesstoken"] = str(accesstoken)
        if channeltype is not None:
            headers["channelType"] = str(channeltype)
        if co_relationid is not None:
            headers["co-Relationid"] = str(co_relationid)
        if entity is not None:
            headers["entity"] = str(entity)
        if initiatingsystem is not None:
            headers["initiatingSystem"] = str(initiatingsystem)
        if languagecode is not None:
            headers["languageCode"] = str(languagecode)
        if referenceid is not None:
            headers["referenceId"] = str(referenceid)
        if servicemode is not None:
            headers["serviceMode"] = str(servicemode)
        if userid is not None:
            headers["userId"] = str(userid)
        if uuidseqno is not None:
            headers["uuidSeqNo"] = str(uuidseqno)
        
        
        return await make_api_request(
            "GET", 
            path, 
            
            params=params if params else None, 
            headers=headers if headers else None
        )
    
    
    
    @mcp.tool()
    async def ibgbt4616_auth_reject_ibg_postusing_put(
        ibginternalreference: str,
        authoriseflag: int,
        accesstoken: Optional[str] = None,
        channeltype: Optional[int] = None,
        co_relationid: Optional[int] = None,
        entity: Optional[str] = None,
        initiatingsystem: Optional[str] = None,
        languagecode: Optional[int] = None,
        referenceid: Optional[str] = None,
        servicemode: Optional[int] = None,
        userid: Optional[int] = None,
        uuidseqno: Optional[int] = None
    ) -> Dict[str, Any]:
        """
        Authorise Reject Incoming BG
        
        Generated from: PUT /tradeFinance/incomingBankGuarantee/issue/{ibgInternalReference}/authReject
        Source: swagger_2_0
        Operation ID: IBGBT4616AuthRejectIBG_POSTUsingPUT
        
        
        Authentication: Not required
        
        Parameters:
        - authoriseFlag: integer (required)
          Authorise Flag. Possible values : 10 - Authorise, 11 - Reject Domain name :  d_ModeFlg_Authorised and d_ModeFlg_Reject
        - ibgInternalReference: string (required)
          IBG Reference Internal
        
        
        
        Headers:
        - Accesstoken: string
          Authorization Token to validation the caller
        - ChannelType: integer
          Channel identifier from where the TXN has originated (Internet, Mobile, ATM, Branch Channel )
        - co-Relationid: integer
          Unique ID for the service invoked, will be set by the TXN system
        - entity: string
          entity
        - initiatingSystem: string
          Indicating the initiated system
        - languageCode: integer
          languageCode
        - referenceId: string
          Place holder for Token based authentication
        - serviceMode: integer
          Used for branch channel to indicate the type of customer
        - userId: integer
          userId
        - uuidSeqNo: integer
          UUID Sequence Number
        
        
        """
        
        
        # Prepare query parameters
        params = {}
        if authoriseflag is not None:
            params["authoriseFlag"] = authoriseflag
            
        
        
        # Replace path parameters in URL
        path = "/tradeFinance/incomingBankGuarantee/issue/{ibgInternalReference}/authReject"
        if ibginternalreference is not None:
            path = path.replace("{ibgInternalReference}", str(ibginternalreference))
        
        
        # Prepare headers
        headers = {}
        if accesstoken is not None:
            headers["Accesstoken"] = str(accesstoken)
        if channeltype is not None:
            headers["ChannelType"] = str(channeltype)
        if co_relationid is not None:
            headers["co-Relationid"] = str(co_relationid)
        if entity is not None:
            headers["entity"] = str(entity)
        if initiatingsystem is not None:
            headers["initiatingSystem"] = str(initiatingsystem)
        if languagecode is not None:
            headers["languageCode"] = str(languagecode)
        if referenceid is not None:
            headers["referenceId"] = str(referenceid)
        if servicemode is not None:
            headers["serviceMode"] = str(servicemode)
        if userid is not None:
            headers["userId"] = str(userid)
        if uuidseqno is not None:
            headers["uuidSeqNo"] = str(uuidseqno)
        
        
        return await make_api_request(
            "PUT", 
            path, 
            
            params=params if params else None, 
            headers=headers if headers else None
        )
    
    
    
    @mcp.tool()
    async def ibget4616_get_ibgdetails_postusing_get(
        ibginternalreference: str,
        accesstoken: Optional[str] = None,
        channeltype: Optional[int] = None,
        co_relationid: Optional[int] = None,
        entity: Optional[str] = None,
        initiatingsystem: Optional[str] = None,
        languagecode: Optional[int] = None,
        referenceid: Optional[str] = None,
        servicemode: Optional[int] = None,
        userid: Optional[int] = None,
        uuidseqno: Optional[int] = None
    ) -> Dict[str, Any]:
        """
        Get IBG Details
        
        Generated from: GET /tradeFinance/incomingBankGuarantee/issue/{ibgInternalReference}/ibgDtls
        Source: swagger_2_0
        Operation ID: IBGET4616GetIBGDetails_POSTUsingGET
        
        
        Authentication: Not required
        
        Parameters:
        - ibgInternalReference: string (required)
          IBG Reference Internal
        
        
        
        Headers:
        - Accesstoken: string
          Authorization Token to validation the caller
        - ChannelType: integer
          Channel identifier from where the TXN has originated (Internet, Mobile, ATM, Branch Channel )
        - co-Relationid: integer
          Unique ID for the service invoked, will be set by the TXN system
        - entity: string
          entity
        - initiatingSystem: string
          Indicating the initiated system
        - languageCode: integer
          languageCode
        - referenceId: string
          Place holder for Token based authentication
        - serviceMode: integer
          Used for branch channel to indicate the type of customer
        - userId: integer
          userId
        - uuidSeqNo: integer
          UUID Sequence Number
        
        
        """
        
        
        # Prepare query parameters
        params = {}
        
        
        # Replace path parameters in URL
        path = "/tradeFinance/incomingBankGuarantee/issue/{ibgInternalReference}/ibgDtls"
        if ibginternalreference is not None:
            path = path.replace("{ibgInternalReference}", str(ibginternalreference))
        
        
        # Prepare headers
        headers = {}
        if accesstoken is not None:
            headers["Accesstoken"] = str(accesstoken)
        if channeltype is not None:
            headers["ChannelType"] = str(channeltype)
        if co_relationid is not None:
            headers["co-Relationid"] = str(co_relationid)
        if entity is not None:
            headers["entity"] = str(entity)
        if initiatingsystem is not None:
            headers["initiatingSystem"] = str(initiatingsystem)
        if languagecode is not None:
            headers["languageCode"] = str(languagecode)
        if referenceid is not None:
            headers["referenceId"] = str(referenceid)
        if servicemode is not None:
            headers["serviceMode"] = str(servicemode)
        if userid is not None:
            headers["userId"] = str(userid)
        if uuidseqno is not None:
            headers["uuidSeqNo"] = str(uuidseqno)
        
        
        return await make_api_request(
            "GET", 
            path, 
            
            params=params if params else None, 
            headers=headers if headers else None
        )
    
    
    
    @mcp.tool()
    async def ibgbt4616_ibgreleased_to_sent_back_postusing_put(
        ibginternalreference: str,
        ibgexternalreference: Optional[str] = None,
        ibgtransactionid: Optional[int] = None,
        accesstoken: Optional[str] = None,
        channeltype: Optional[int] = None,
        co_relationid: Optional[int] = None,
        entity: Optional[str] = None,
        initiatingsystem: Optional[str] = None,
        languagecode: Optional[int] = None,
        referenceid: Optional[str] = None,
        servicemode: Optional[int] = None,
        userid: Optional[int] = None,
        uuidseqno: Optional[int] = None
    ) -> Dict[str, Any]:
        """
        Incoming BG SentBack
        
        Generated from: PUT /tradeFinance/incomingBankGuarantee/issue/{ibgInternalReference}/sentback
        Source: swagger_2_0
        Operation ID: IBGBT4616IBGReleasedToSentBack_POSTUsingPUT
        
        
        Authentication: Not required
        
        Parameters:
        - ibgExternalReference: string
          IBG Reference External
        - ibgInternalReference: string (required)
          IBG Reference Internal
        - ibgTransactionId: integer
          IBG Transaction ID
        
        
        
        Headers:
        - Accesstoken: string
          Authorization Token to validation the caller
        - ChannelType: integer
          Channel identifier from where the TXN has originated (Internet, Mobile, ATM, Branch Channel )
        - co-Relationid: integer
          Unique ID for the service invoked, will be set by the TXN system
        - entity: string
          entity
        - initiatingSystem: string
          Indicating the initiated system
        - languageCode: integer
          languageCode
        - referenceId: string
          Place holder for Token based authentication
        - serviceMode: integer
          Used for branch channel to indicate the type of customer
        - userId: integer
          userId
        - uuidSeqNo: integer
          UUID Sequence Number
        
        
        """
        
        
        # Prepare query parameters
        params = {}
        if ibgexternalreference is not None:
            params["ibgExternalReference"] = ibgexternalreference
            
        if ibgtransactionid is not None:
            params["ibgTransactionId"] = ibgtransactionid
            
        
        
        # Replace path parameters in URL
        path = "/tradeFinance/incomingBankGuarantee/issue/{ibgInternalReference}/sentback"
        if ibginternalreference is not None:
            path = path.replace("{ibgInternalReference}", str(ibginternalreference))
        
        
        # Prepare headers
        headers = {}
        if accesstoken is not None:
            headers["Accesstoken"] = str(accesstoken)
        if channeltype is not None:
            headers["ChannelType"] = str(channeltype)
        if co_relationid is not None:
            headers["co-Relationid"] = str(co_relationid)
        if entity is not None:
            headers["entity"] = str(entity)
        if initiatingsystem is not None:
            headers["initiatingSystem"] = str(initiatingsystem)
        if languagecode is not None:
            headers["languageCode"] = str(languagecode)
        if referenceid is not None:
            headers["referenceId"] = str(referenceid)
        if servicemode is not None:
            headers["serviceMode"] = str(servicemode)
        if userid is not None:
            headers["userId"] = str(userid)
        if uuidseqno is not None:
            headers["uuidSeqNo"] = str(uuidseqno)
        
        
        return await make_api_request(
            "PUT", 
            path, 
            
            params=params if params else None, 
            headers=headers if headers else None
        )
    
    
    
    @mcp.tool()
    async def ibgbt4616_ibgon_hold_to_rjct_postusing_post(
        ibginternalreference: str,
        ibgexternalreference: Optional[str] = None,
        ibgtransactionid: Optional[int] = None,
        accesstoken: Optional[str] = None,
        channeltype: Optional[int] = None,
        co_relationid: Optional[int] = None,
        entity: Optional[str] = None,
        initiatingsystem: Optional[str] = None,
        languagecode: Optional[int] = None,
        referenceid: Optional[str] = None,
        servicemode: Optional[int] = None,
        userid: Optional[int] = None,
        uuidseqno: Optional[int] = None
    ) -> Dict[str, Any]:
        """
        Incoming BG Cancel
        
        Generated from: POST /tradeFinance/incomingBankGuarantee/{ibgInternalReference}/Cancel
        Source: swagger_2_0
        Operation ID: IBGBT4616IBGOnHoldToRjct_POSTUsingPOST
        
        
        Authentication: Not required
        
        Parameters:
        - ibgExternalReference: string
          IBG Reference External
        - ibgInternalReference: string (required)
          IBG Reference Internal
        - ibgTransactionId: integer
          IBG Transaction ID
        
        
        
        Headers:
        - Accesstoken: string
          Authorization Token to validation the caller
        - ChannelType: integer
          Channel identifier from where the TXN has originated (Internet, Mobile, ATM, Branch Channel )
        - co-Relationid: integer
          Unique ID for the service invoked, will be set by the TXN system
        - entity: string
          entity
        - initiatingSystem: string
          Indicating the initiated system
        - languageCode: integer
          languageCode
        - referenceId: string
          Place holder for Token based authentication
        - serviceMode: integer
          Used for branch channel to indicate the type of customer
        - userId: integer
          userId
        - uuidSeqNo: integer
          UUID Sequence Number
        
        
        """
        
        
        # Prepare query parameters
        params = {}
        if ibgexternalreference is not None:
            params["ibgExternalReference"] = ibgexternalreference
            
        if ibgtransactionid is not None:
            params["ibgTransactionId"] = ibgtransactionid
            
        
        
        # Replace path parameters in URL
        path = "/tradeFinance/incomingBankGuarantee/{ibgInternalReference}/Cancel"
        if ibginternalreference is not None:
            path = path.replace("{ibgInternalReference}", str(ibginternalreference))
        
        
        # Prepare headers
        headers = {}
        if accesstoken is not None:
            headers["Accesstoken"] = str(accesstoken)
        if channeltype is not None:
            headers["ChannelType"] = str(channeltype)
        if co_relationid is not None:
            headers["co-Relationid"] = str(co_relationid)
        if entity is not None:
            headers["entity"] = str(entity)
        if initiatingsystem is not None:
            headers["initiatingSystem"] = str(initiatingsystem)
        if languagecode is not None:
            headers["languageCode"] = str(languagecode)
        if referenceid is not None:
            headers["referenceId"] = str(referenceid)
        if servicemode is not None:
            headers["serviceMode"] = str(servicemode)
        if userid is not None:
            headers["userId"] = str(userid)
        if uuidseqno is not None:
            headers["uuidSeqNo"] = str(uuidseqno)
        
        
        return await make_api_request(
            "POST", 
            path, 
            
            params=params if params else None, 
            headers=headers if headers else None
        )
    
    
    
    @mcp.tool()
    async def ibget7122_fetch_all_ibgevents_postusing_get(
        ibgrefereneceexternal: str,
        pagenum: Optional[int] = None,
        pagesize: Optional[int] = None,
        accesstoken: Optional[str] = None,
        channeltype: Optional[int] = None,
        co_relationid: Optional[int] = None,
        entity: Optional[str] = None,
        initiatingsystem: Optional[str] = None,
        languagecode: Optional[int] = None,
        referenceid: Optional[str] = None,
        servicemode: Optional[int] = None,
        userid: Optional[int] = None,
        uuidseqno: Optional[int] = None
    ) -> Dict[str, Any]:
        """
        Service to fetch all inward bank guarantee events
        
        Generated from: GET /tradeFinance/incomingBankGuarantee/{ibgRefereneceExternal}/ibgEventsList
        Source: swagger_2_0
        Operation ID: IBGET7122FetchAllIBGEvents_POSTUsingGET
        
        
        Authentication: Not required
        
        Parameters:
        - ibgRefereneceExternal: string (required)
          IBG Reference External
        - pageNum: integer
          pageNum
        - pageSize: integer
          pageSize
        
        
        
        Headers:
        - Accesstoken: string
          Authorization Token to validation the caller
        - channelType: integer
          Channel identifier from where the TXN has originated (Internet, Mobile, ATM, Branch Channel )
        - co-Relationid: integer
          Unique ID for the service invoked, will be set by the TXN system
        - entity: string
          entity
        - initiatingSystem: string
          Indicating the initiated system
        - languageCode: integer
          languageCode
        - referenceId: string
          Place holder for Token based authentication
        - serviceMode: integer
          Used for branch channel to indicate the type of customer
        - userId: integer
          userId
        - uuidSeqNo: integer
          UUID Sequence Number
        
        
        """
        
        
        # Prepare query parameters
        params = {}
        if pagenum is not None:
            params["pageNum"] = pagenum
            
        if pagesize is not None:
            params["pageSize"] = pagesize
            
        
        
        # Replace path parameters in URL
        path = "/tradeFinance/incomingBankGuarantee/{ibgRefereneceExternal}/ibgEventsList"
        if ibgrefereneceexternal is not None:
            path = path.replace("{ibgRefereneceExternal}", str(ibgrefereneceexternal))
        
        
        # Prepare headers
        headers = {}
        if accesstoken is not None:
            headers["Accesstoken"] = str(accesstoken)
        if channeltype is not None:
            headers["channelType"] = str(channeltype)
        if co_relationid is not None:
            headers["co-Relationid"] = str(co_relationid)
        if entity is not None:
            headers["entity"] = str(entity)
        if initiatingsystem is not None:
            headers["initiatingSystem"] = str(initiatingsystem)
        if languagecode is not None:
            headers["languageCode"] = str(languagecode)
        if referenceid is not None:
            headers["referenceId"] = str(referenceid)
        if servicemode is not None:
            headers["serviceMode"] = str(servicemode)
        if userid is not None:
            headers["userId"] = str(userid)
        if uuidseqno is not None:
            headers["uuidSeqNo"] = str(uuidseqno)
        
        
        return await make_api_request(
            "GET", 
            path, 
            
            params=params if params else None, 
            headers=headers if headers else None
        )
    
    
    
    @mcp.tool()
    async def tfcbt6592_message_ack_postusing_post(
        refexternal: str,
        request_body:Dict[str, Any] ,  # MessageAckResource,
        messagetype: Optional[str] = None,
        transactiontype: Optional[int] = None,
        channeltype: Optional[int] = None,
        accesstoken: Optional[str] = None,
        co_relationid: Optional[int] = None,
        entity: Optional[str] = None,
        initiatingsystem: Optional[str] = None,
        languagecode: Optional[int] = None,
        referenceid: Optional[str] = None,
        servicemode: Optional[int] = None,
        userid: Optional[int] = None,
        uuidseqno: Optional[int] = None
    ) -> Dict[str, Any]:
        """
        messageAck
        
        Generated from: POST /tradeFinance/messageAck/{refExternal}/messageAckSubmit
        Source: swagger_2_0
        Operation ID: TFCBT6592MessageAck_POSTUsingPOST
        
        
        Authentication: Not required
        
        Parameters:
        - messageType: string
          Message Type
        - refExternal: string (required)
          Ref External
        - transactionType: integer
          Transaction Type
        - request_body: any (required)
          input
        
        
        
        Headers:
        - ChannelType: integer
          Channel identifier from where the TXN has originated (Internet, Mobile, ATM, Branch Channel )
        - accesstoken: string
          Authorization Token to validation the caller
        - co-Relationid: integer
          Unique ID for the service invoked, will be set by the TXN system
        - entity: string
          entity
        - initiatingSystem: string
          Indicating the initiated system
        - languageCode: integer
          languageCode
        - referenceId: string
          Place holder for Token based authentication
        - serviceMode: integer
          Used for branch channel to indicate the type of customer
        - userId: integer
          userId
        - uuidSeqNo: integer
          UUID Sequence Number
        
        
        """
        
        
        # Prepare request data
        
        # Single body parameter - send directly
        data = request_body if request_body is not None else {}
        
        
        
        # Prepare query parameters
        params = {}
        if messagetype is not None:
            params["messageType"] = messagetype
            
        if transactiontype is not None:
            params["transactionType"] = transactiontype
            
        
        
        # Replace path parameters in URL
        path = "/tradeFinance/messageAck/{refExternal}/messageAckSubmit"
        if refexternal is not None:
            path = path.replace("{refExternal}", str(refexternal))
        
        
        # Prepare headers
        headers = {}
        if channeltype is not None:
            headers["ChannelType"] = str(channeltype)
        if accesstoken is not None:
            headers["accesstoken"] = str(accesstoken)
        if co_relationid is not None:
            headers["co-Relationid"] = str(co_relationid)
        if entity is not None:
            headers["entity"] = str(entity)
        if initiatingsystem is not None:
            headers["initiatingSystem"] = str(initiatingsystem)
        if languagecode is not None:
            headers["languageCode"] = str(languagecode)
        if referenceid is not None:
            headers["referenceId"] = str(referenceid)
        if servicemode is not None:
            headers["serviceMode"] = str(servicemode)
        if userid is not None:
            headers["userId"] = str(userid)
        if uuidseqno is not None:
            headers["uuidSeqNo"] = str(uuidseqno)
        
        
        return await make_api_request(
            "POST", 
            path, 
            data=data, 
            params=params if params else None, 
            headers=headers if headers else None
        )
    
    
    
    @mcp.tool()
    async def tfcbt5584_auth_notes_and_memo_postusing_put(
        notesmemoid: int,
        authoriseflag: int,
        authoriseremarks: Optional[str] = None,
        channeltype: Optional[int] = None,
        co_relationid: Optional[int] = None,
        entity: Optional[str] = None,
        initiatingsystem: Optional[str] = None,
        languagecode: Optional[int] = None,
        servicemode: Optional[int] = None,
        userid: Optional[int] = None,
        uuidseqno: Optional[int] = None
    ) -> Dict[str, Any]:
        """
        Auth Notes and Memo
        
        Generated from: PUT /tradeFinance/notesAndMemo/{notesMemoID}/authorisation
        Source: swagger_2_0
        Operation ID: TFCBT5584AuthNotesAndMemo_POSTUsingPUT
        
        
        Authentication: Not required
        
        Parameters:
        - authoriseFlag: integer (required)
          Authorise Flag. Possible values : 1 - Authorise, 2 - Reject, 3 - Sent Back Domain name : d_VerAuthFlg
        - authoriseRemarks: string
          Authorise Remarks
        - notesMemoID: integer (required)
          Notes Memo ID
        
        
        
        Headers:
        - ChannelType: integer
          Channel identifier from where the TXN has originated (Internet, Mobile, ATM, Branch Channel )
        - co-Relationid: integer
          Unique ID for the service invoked, will be set by the TXN system
        - entity: string
          entity
        - initiatingSystem: string
          Indicating the initiated system
        - languageCode: integer
          languageCode
        - serviceMode: integer
          Used for branch channel to indicate the type of customer
        - userId: integer
          userId
        - uuidSeqNo: integer
          UUID Sequence Number
        
        
        """
        
        
        # Prepare query parameters
        params = {}
        if authoriseflag is not None:
            params["authoriseFlag"] = authoriseflag
            
        if authoriseremarks is not None:
            params["authoriseRemarks"] = authoriseremarks
            
        
        
        # Replace path parameters in URL
        path = "/tradeFinance/notesAndMemo/{notesMemoID}/authorisation"
        if notesmemoid is not None:
            path = path.replace("{notesMemoID}", str(notesmemoid))
        
        
        # Prepare headers
        headers = {}
        if channeltype is not None:
            headers["ChannelType"] = str(channeltype)
        if co_relationid is not None:
            headers["co-Relationid"] = str(co_relationid)
        if entity is not None:
            headers["entity"] = str(entity)
        if initiatingsystem is not None:
            headers["initiatingSystem"] = str(initiatingsystem)
        if languagecode is not None:
            headers["languageCode"] = str(languagecode)
        if servicemode is not None:
            headers["serviceMode"] = str(servicemode)
        if userid is not None:
            headers["userId"] = str(userid)
        if uuidseqno is not None:
            headers["uuidSeqNo"] = str(uuidseqno)
        
        
        return await make_api_request(
            "PUT", 
            path, 
            
            params=params if params else None, 
            headers=headers if headers else None
        )
    
    
    
    @mcp.tool()
    async def tfcbt6106_auth_rjct_sentback_cryst_loan_postusing_put(
        request_body:Dict[str, Any] ,  # AuthRejectSentbackCrystallizationDtlsRequest,
        accesstoken: Optional[str] = None,
        channeltype: Optional[int] = None,
        co_relationid: Optional[int] = None,
        entity: Optional[str] = None,
        initiatingsystem: Optional[str] = None,
        languagecode: Optional[int] = None,
        mu_id: Optional[str] = None,
        referenceid: Optional[str] = None,
        servicemode: Optional[int] = None,
        userid: Optional[int] = None,
        uuidseqno: Optional[int] = None
    ) -> Dict[str, Any]:
        """
        Authorise Reject Sentback Crystallization Details
        
        Generated from: PUT /tradeFinance/prePostShipment/crystallization/authRejectSentback
        Source: swagger_2_0
        Operation ID: TFCBT6106AuthRjctSentbackCrystLoan_POSTUsingPUT
        
        
        Authentication: Not required
        
        Parameters:
        - request_body: any (required)
          input
        
        
        
        Headers:
        - Accesstoken: string
          Authorization Token to validation the caller
        - ChannelType: integer
          Channel identifier from where the TXN has originated (Internet, Mobile, ATM, Branch Channel )
        - co-Relationid: integer
          Unique ID for the service invoked, will be set by the TXN system
        - entity: string
          entity
        - initiatingSystem: string
          Indicating the initiated system
        - languageCode: integer
          languageCode
        - mu_Id: string
          Used to indicate the Branch Id of user
        - referenceId: string
          Place holder for Token based authentication
        - serviceMode: integer
          Used for branch channel to indicate the type of customer
        - userId: integer
          userId
        - uuidSeqNo: integer
          UUID Sequence Number
        
        
        """
        
        
        # Prepare request data
        
        # Single body parameter - send directly
        data = request_body if request_body is not None else {}
        
        
        
        # Prepare query parameters
        params = {}
        
        
        # Replace path parameters in URL
        path = "/tradeFinance/prePostShipment/crystallization/authRejectSentback"
        
        
        # Prepare headers
        headers = {}
        if accesstoken is not None:
            headers["Accesstoken"] = str(accesstoken)
        if channeltype is not None:
            headers["ChannelType"] = str(channeltype)
        if co_relationid is not None:
            headers["co-Relationid"] = str(co_relationid)
        if entity is not None:
            headers["entity"] = str(entity)
        if initiatingsystem is not None:
            headers["initiatingSystem"] = str(initiatingsystem)
        if languagecode is not None:
            headers["languageCode"] = str(languagecode)
        if mu_id is not None:
            headers["mu_Id"] = str(mu_id)
        if referenceid is not None:
            headers["referenceId"] = str(referenceid)
        if servicemode is not None:
            headers["serviceMode"] = str(servicemode)
        if userid is not None:
            headers["userId"] = str(userid)
        if uuidseqno is not None:
            headers["uuidSeqNo"] = str(uuidseqno)
        
        
        return await make_api_request(
            "PUT", 
            path, 
            data=data, 
            params=params if params else None, 
            headers=headers if headers else None
        )
    
    
    
    @mcp.tool()
    async def tfcbt6106_cancel_cryst_loan_postusing_post(
        request_body:Dict[str, Any] ,  # cancelCrystallizationDtlsRequest,
        accesstoken: Optional[str] = None,
        channeltype: Optional[int] = None,
        co_relationid: Optional[int] = None,
        entity: Optional[str] = None,
        initiatingsystem: Optional[str] = None,
        languagecode: Optional[int] = None,
        mu_id: Optional[str] = None,
        referenceid: Optional[str] = None,
        servicemode: Optional[int] = None,
        userid: Optional[int] = None,
        uuidseqno: Optional[int] = None
    ) -> Dict[str, Any]:
        """
        Cancel on hold Crystallization
        
        Generated from: POST /tradeFinance/prePostShipment/crystallization/cancel
        Source: swagger_2_0
        Operation ID: TFCBT6106CancelCrystLoan_POSTUsingPOST
        
        
        Authentication: Not required
        
        Parameters:
        - request_body: any (required)
          input
        
        
        
        Headers:
        - Accesstoken: string
          Authorization Token to validation the caller
        - ChannelType: integer
          Channel identifier from where the TXN has originated (Internet, Mobile, ATM, Branch Channel )
        - co-Relationid: integer
          Unique ID for the service invoked, will be set by the TXN system
        - entity: string
          entity
        - initiatingSystem: string
          Indicating the initiated system
        - languageCode: integer
          languageCode
        - mu_Id: string
          Used to indicate the Branch Id of user
        - referenceId: string
          Place holder for Token based authentication
        - serviceMode: integer
          Used for branch channel to indicate the type of customer
        - userId: integer
          userId
        - uuidSeqNo: integer
          UUID Sequence Number
        
        
        """
        
        
        # Prepare request data
        
        # Single body parameter - send directly
        data = request_body if request_body is not None else {}
        
        
        
        # Prepare query parameters
        params = {}
        
        
        # Replace path parameters in URL
        path = "/tradeFinance/prePostShipment/crystallization/cancel"
        
        
        # Prepare headers
        headers = {}
        if accesstoken is not None:
            headers["Accesstoken"] = str(accesstoken)
        if channeltype is not None:
            headers["ChannelType"] = str(channeltype)
        if co_relationid is not None:
            headers["co-Relationid"] = str(co_relationid)
        if entity is not None:
            headers["entity"] = str(entity)
        if initiatingsystem is not None:
            headers["initiatingSystem"] = str(initiatingsystem)
        if languagecode is not None:
            headers["languageCode"] = str(languagecode)
        if mu_id is not None:
            headers["mu_Id"] = str(mu_id)
        if referenceid is not None:
            headers["referenceId"] = str(referenceid)
        if servicemode is not None:
            headers["serviceMode"] = str(servicemode)
        if userid is not None:
            headers["userId"] = str(userid)
        if uuidseqno is not None:
            headers["uuidSeqNo"] = str(uuidseqno)
        
        
        return await make_api_request(
            "POST", 
            path, 
            data=data, 
            params=params if params else None, 
            headers=headers if headers else None
        )
    
    
    
    @mcp.tool()
    async def tfcbt6106_create_modify_cryst_loan_dtls_postusing_post(
        modeflg: int,
        request_body:Dict[str, Any] ,  # crystallizationDtlsCreateModifyRequest,
        accesstoken: Optional[str] = None,
        channeltype: Optional[int] = None,
        co_relationid: Optional[int] = None,
        entity: Optional[str] = None,
        initiatingsystem: Optional[str] = None,
        languagecode: Optional[int] = None,
        mu_id: Optional[str] = None,
        referenceid: Optional[str] = None,
        servicemode: Optional[int] = None,
        userid: Optional[int] = None,
        uuidseqno: Optional[int] = None
    ) -> Dict[str, Any]:
        """
        Create/Modify Crystallization Details
        
        Generated from: POST /tradeFinance/prePostShipment/crystallization/createModify
        Source: swagger_2_0
        Operation ID: TFCBT6106CreateModifyCrystLoanDtls_POSTUsingPOST
        
        
        Authentication: Not required
        
        Parameters:
        - modeFlg: integer (required)
          Mode Flag. Possible values : 1 - Capture Bill and Crystallization Details 2 - Modify Recovery Details
        - request_body: any (required)
          input
        
        
        
        Headers:
        - Accesstoken: string
          Authorization Token to validation the caller
        - ChannelType: integer
          Channel identifier from where the TXN has originated (Internet, Mobile, ATM, Branch Channel )
        - co-Relationid: integer
          Unique ID for the service invoked, will be set by the TXN system
        - entity: string
          entity
        - initiatingSystem: string
          Indicating the initiated system
        - languageCode: integer
          languageCode
        - mu_Id: string
          Used to indicate the Branch Id of user
        - referenceId: string
          Place holder for Token based authentication
        - serviceMode: integer
          Used for branch channel to indicate the type of customer
        - userId: integer
          userId
        - uuidSeqNo: integer
          UUID Sequence Number
        
        
        """
        
        
        # Prepare request data
        
        # Single body parameter - send directly
        data = request_body if request_body is not None else {}
        
        
        
        # Prepare query parameters
        params = {}
        if modeflg is not None:
            params["modeFlg"] = modeflg
            
        
        
        # Replace path parameters in URL
        path = "/tradeFinance/prePostShipment/crystallization/createModify"
        
        
        # Prepare headers
        headers = {}
        if accesstoken is not None:
            headers["Accesstoken"] = str(accesstoken)
        if channeltype is not None:
            headers["ChannelType"] = str(channeltype)
        if co_relationid is not None:
            headers["co-Relationid"] = str(co_relationid)
        if entity is not None:
            headers["entity"] = str(entity)
        if initiatingsystem is not None:
            headers["initiatingSystem"] = str(initiatingsystem)
        if languagecode is not None:
            headers["languageCode"] = str(languagecode)
        if mu_id is not None:
            headers["mu_Id"] = str(mu_id)
        if referenceid is not None:
            headers["referenceId"] = str(referenceid)
        if servicemode is not None:
            headers["serviceMode"] = str(servicemode)
        if userid is not None:
            headers["userId"] = str(userid)
        if uuidseqno is not None:
            headers["uuidSeqNo"] = str(uuidseqno)
        
        
        return await make_api_request(
            "POST", 
            path, 
            data=data, 
            params=params if params else None, 
            headers=headers if headers else None
        )
    
    
    
    @mcp.tool()
    async def tfcet6106_cryst_loan_dtls_list_postusing_get(
        billamount: Optional[float] = None,
        billamountcurrency: Optional[str] = None,
        billreferenceexternal: Optional[str] = None,
        crysttransactionid: Optional[int] = None,
        crystallizedamount: Optional[float] = None,
        crystallizedamountcurrency: Optional[str] = None,
        draweename: Optional[str] = None,
        drawerid: Optional[int] = None,
        drawername: Optional[str] = None,
        frmdt: Optional[str] = None,
        modeofrecovery: Optional[int] = None,
        module: Optional[str] = None,
        operationtype: Optional[int] = None,
        pagenum: Optional[int] = None,
        pagesize: Optional[int] = None,
        ratestatus: Optional[int] = None,
        status: Optional[int] = None,
        todt: Optional[str] = None,
        transactiondate: Optional[str] = None,
        accesstoken: Optional[str] = None,
        channeltype: Optional[int] = None,
        co_relationid: Optional[int] = None,
        entity: Optional[str] = None,
        initiatingsystem: Optional[str] = None,
        languagecode: Optional[int] = None,
        mu_id: Optional[str] = None,
        referenceid: Optional[str] = None,
        servicemode: Optional[int] = None,
        userid: Optional[int] = None,
        uuidseqno: Optional[int] = None
    ) -> Dict[str, Any]:
        """
        Fetch Crystallization List
        
        Generated from: GET /tradeFinance/prePostShipment/crystallization/list
        Source: swagger_2_0
        Operation ID: TFCET6106CrystLoanDtlsList_POSTUsingGET
        
        
        Authentication: Not required
        
        Parameters:
        - billAmount: number
          Bill Amount
        - billAmountCurrency: string
          Bill Amount Currency Eg.[USD]
        - billReferenceExternal: string
          BL External Reference Number
        - crystTransactionId: integer
          Crsytallization Transaction Id
        - crystallizedAmount: number
          Crystallized Amount
        - crystallizedAmountCurrency: string
          Crystallized Amount Currency Eg.[USD]
        - draweeName: string
          Drawee Name
        - drawerId: integer
          Customer Reference
        - drawerName: string
          Drawer Name
        - frmDt: string
          From Date. Date Format :[dd/MM/yyyy]
        - modeOfRecovery: integer
          Mode Of Recovery
        - module: string
          Module - LC or DC
        - operationType: integer
          operationType
        - pageNum: integer
          pageNum
        - pageSize: integer
          pageSize
        - rateStatus: integer
          Rate Request Status
        - status: integer
          Status.( Status.Possible Values: 1 - OnHold, 2 - Released, 3 - Executed, 4 - Rejected, 5 - sentback, 6 - pendingCancel, 7 - Cancelled, 8 - PendingClose, 9 - Closed, 10 - AmndmntInit, 11 - Expired, 12 - Verified, 13 - WaitingForRate, 14 - RateAvailable, 15 - RateRejected, 16 - RateCancelled, 17 - Disbursed,18 -Settled , 19- Active  Domain :d_TFPrePostLoanStatus )
        - toDt: string
          To Date. Date Format :[dd/MM/yyyy]
        - transactionDate: string
          Transaction Date. Date Format :[dd/MM/yyyy]
        
        
        
        Headers:
        - Accesstoken: string
          Authorization Token to validation the caller
        - channelType: integer
          Channel identifier from where the TXN has originated (Internet, Mobile, ATM, Branch Channel )
        - co-Relationid: integer
          Unique ID for the service invoked, will be set by the TXN system
        - entity: string
          entity
        - initiatingSystem: string
          Indicating the initiated system
        - languageCode: integer
          languageCode
        - mu_Id: string
          Used to indicate the Branch Id of user
        - referenceId: string
          Place holder for Token based authentication
        - serviceMode: integer
          Used for branch channel to indicate the type of customer
        - userId: integer
          userId
        - uuidSeqNo: integer
          UUID Sequence Number
        
        
        """
        
        
        # Prepare query parameters
        params = {}
        if billamount is not None:
            params["billAmount"] = billamount
            
        if billamountcurrency is not None:
            params["billAmountCurrency"] = billamountcurrency
            
        if billreferenceexternal is not None:
            params["billReferenceExternal"] = billreferenceexternal
            
        if crysttransactionid is not None:
            params["crystTransactionId"] = crysttransactionid
            
        if crystallizedamount is not None:
            params["crystallizedAmount"] = crystallizedamount
            
        if crystallizedamountcurrency is not None:
            params["crystallizedAmountCurrency"] = crystallizedamountcurrency
            
        if draweename is not None:
            params["draweeName"] = draweename
            
        if drawerid is not None:
            params["drawerId"] = drawerid
            
        if drawername is not None:
            params["drawerName"] = drawername
            
        if frmdt is not None:
            params["frmDt"] = frmdt
            
        if modeofrecovery is not None:
            params["modeOfRecovery"] = modeofrecovery
            
        if module is not None:
            params["module"] = module
            
        if operationtype is not None:
            params["operationType"] = operationtype
            
        if pagenum is not None:
            params["pageNum"] = pagenum
            
        if pagesize is not None:
            params["pageSize"] = pagesize
            
        if ratestatus is not None:
            params["rateStatus"] = ratestatus
            
        if status is not None:
            params["status"] = status
            
        if todt is not None:
            params["toDt"] = todt
            
        if transactiondate is not None:
            params["transactionDate"] = transactiondate
            
        
        
        # Replace path parameters in URL
        path = "/tradeFinance/prePostShipment/crystallization/list"
        
        
        # Prepare headers
        headers = {}
        if accesstoken is not None:
            headers["Accesstoken"] = str(accesstoken)
        if channeltype is not None:
            headers["channelType"] = str(channeltype)
        if co_relationid is not None:
            headers["co-Relationid"] = str(co_relationid)
        if entity is not None:
            headers["entity"] = str(entity)
        if initiatingsystem is not None:
            headers["initiatingSystem"] = str(initiatingsystem)
        if languagecode is not None:
            headers["languageCode"] = str(languagecode)
        if mu_id is not None:
            headers["mu_Id"] = str(mu_id)
        if referenceid is not None:
            headers["referenceId"] = str(referenceid)
        if servicemode is not None:
            headers["serviceMode"] = str(servicemode)
        if userid is not None:
            headers["userId"] = str(userid)
        if uuidseqno is not None:
            headers["uuidSeqNo"] = str(uuidseqno)
        
        
        return await make_api_request(
            "GET", 
            path, 
            
            params=params if params else None, 
            headers=headers if headers else None
        )
    
    
    
    @mcp.tool()
    async def tfcbt6106_user_confirm_cryst_loan_dtls_postusing_post(
        request_body:Dict[str, Any] ,  # UserConfirmCrystallizationDtlsRequest,
        accesstoken: Optional[str] = None,
        channeltype: Optional[int] = None,
        co_relationid: Optional[int] = None,
        entity: Optional[str] = None,
        initiatingsystem: Optional[str] = None,
        languagecode: Optional[int] = None,
        mu_id: Optional[str] = None,
        referenceid: Optional[str] = None,
        servicemode: Optional[int] = None,
        userid: Optional[int] = None,
        uuidseqno: Optional[int] = None
    ) -> Dict[str, Any]:
        """
        UserConfirmation Crystallization Details
        
        Generated from: POST /tradeFinance/prePostShipment/crystallization/userConfirmation
        Source: swagger_2_0
        Operation ID: TFCBT6106UserConfirmCrystLoanDtls_POSTUsingPOST
        
        
        Authentication: Not required
        
        Parameters:
        - request_body: any (required)
          input
        
        
        
        Headers:
        - Accesstoken: string
          Authorization Token to validation the caller
        - ChannelType: integer
          Channel identifier from where the TXN has originated (Internet, Mobile, ATM, Branch Channel )
        - co-Relationid: integer
          Unique ID for the service invoked, will be set by the TXN system
        - entity: string
          entity
        - initiatingSystem: string
          Indicating the initiated system
        - languageCode: integer
          languageCode
        - mu_Id: string
          Used to indicate the Branch Id of user
        - referenceId: string
          Place holder for Token based authentication
        - serviceMode: integer
          Used for branch channel to indicate the type of customer
        - userId: integer
          userId
        - uuidSeqNo: integer
          UUID Sequence Number
        
        
        """
        
        
        # Prepare request data
        
        # Single body parameter - send directly
        data = request_body if request_body is not None else {}
        
        
        
        # Prepare query parameters
        params = {}
        
        
        # Replace path parameters in URL
        path = "/tradeFinance/prePostShipment/crystallization/userConfirmation"
        
        
        # Prepare headers
        headers = {}
        if accesstoken is not None:
            headers["Accesstoken"] = str(accesstoken)
        if channeltype is not None:
            headers["ChannelType"] = str(channeltype)
        if co_relationid is not None:
            headers["co-Relationid"] = str(co_relationid)
        if entity is not None:
            headers["entity"] = str(entity)
        if initiatingsystem is not None:
            headers["initiatingSystem"] = str(initiatingsystem)
        if languagecode is not None:
            headers["languageCode"] = str(languagecode)
        if mu_id is not None:
            headers["mu_Id"] = str(mu_id)
        if referenceid is not None:
            headers["referenceId"] = str(referenceid)
        if servicemode is not None:
            headers["serviceMode"] = str(servicemode)
        if userid is not None:
            headers["userId"] = str(userid)
        if uuidseqno is not None:
            headers["uuidSeqNo"] = str(uuidseqno)
        
        
        return await make_api_request(
            "POST", 
            path, 
            data=data, 
            params=params if params else None, 
            headers=headers if headers else None
        )
    
    
    
    @mcp.tool()
    async def tfcet6106_view_cryst_loan_dtls_postusing_get(
        crysttransactionid: int,
        accesstoken: Optional[str] = None,
        channeltype: Optional[int] = None,
        co_relationid: Optional[int] = None,
        entity: Optional[str] = None,
        initiatingsystem: Optional[str] = None,
        languagecode: Optional[int] = None,
        mu_id: Optional[str] = None,
        referenceid: Optional[str] = None,
        servicemode: Optional[int] = None,
        userid: Optional[int] = None,
        uuidseqno: Optional[int] = None
    ) -> Dict[str, Any]:
        """
        View Crystallization Details
        
        Generated from: GET /tradeFinance/prePostShipment/crystallization/{crystTransactionId}/view
        Source: swagger_2_0
        Operation ID: TFCET6106ViewCrystLoanDtls_POSTUsingGET
        
        
        Authentication: Not required
        
        Parameters:
        - crystTransactionId: integer (required)
          Cryst Transaction ID
        
        
        
        Headers:
        - Accesstoken: string
          Authorization Token to validation the caller
        - ChannelType: integer
          Channel identifier from where the TXN has originated (Internet, Mobile, ATM, Branch Channel )
        - co-Relationid: integer
          Unique ID for the service invoked, will be set by the TXN system
        - entity: string
          entity
        - initiatingSystem: string
          Indicating the initiated system
        - languageCode: integer
          languageCode
        - mu_Id: string
          Used to indicate the Branch Id of user
        - referenceId: string
          Place holder for Token based authentication
        - serviceMode: integer
          Used for branch channel to indicate the type of customer
        - userId: integer
          userId
        - uuidSeqNo: integer
          UUID Sequence Number
        
        
        """
        
        
        # Prepare query parameters
        params = {}
        
        
        # Replace path parameters in URL
        path = "/tradeFinance/prePostShipment/crystallization/{crystTransactionId}/view"
        if crysttransactionid is not None:
            path = path.replace("{crystTransactionId}", str(crysttransactionid))
        
        
        # Prepare headers
        headers = {}
        if accesstoken is not None:
            headers["Accesstoken"] = str(accesstoken)
        if channeltype is not None:
            headers["ChannelType"] = str(channeltype)
        if co_relationid is not None:
            headers["co-Relationid"] = str(co_relationid)
        if entity is not None:
            headers["entity"] = str(entity)
        if initiatingsystem is not None:
            headers["initiatingSystem"] = str(initiatingsystem)
        if languagecode is not None:
            headers["languageCode"] = str(languagecode)
        if mu_id is not None:
            headers["mu_Id"] = str(mu_id)
        if referenceid is not None:
            headers["referenceId"] = str(referenceid)
        if servicemode is not None:
            headers["serviceMode"] = str(servicemode)
        if userid is not None:
            headers["userId"] = str(userid)
        if uuidseqno is not None:
            headers["uuidSeqNo"] = str(uuidseqno)
        
        
        return await make_api_request(
            "GET", 
            path, 
            
            params=params if params else None, 
            headers=headers if headers else None
        )
    
    
    
    @mcp.tool()
    async def tfcbtauth_rjct_sentback_pre_post_loan_postusing_put(
        request_body:Dict[str, Any] ,  # AuthRejectLoanDtlsRequest,
        accesstoken: Optional[str] = None,
        channeltype: Optional[int] = None,
        co_relationid: Optional[int] = None,
        entity: Optional[str] = None,
        initiatingsystem: Optional[str] = None,
        languagecode: Optional[int] = None,
        mu_id: Optional[str] = None,
        referenceid: Optional[str] = None,
        servicemode: Optional[int] = None,
        userid: Optional[int] = None,
        uuidseqno: Optional[int] = None
    ) -> Dict[str, Any]:
        """
        Authorise Reject Sentback PS Loan Details
        
        Generated from: PUT /tradeFinance/prePostShipment/loan/authRejectSentback
        Source: swagger_2_0
        Operation ID: TFCBTAuthRjctSentbackPrePostLoan_POSTUsingPUT
        
        
        Authentication: Not required
        
        Parameters:
        - request_body: any (required)
          input
        
        
        
        Headers:
        - Accesstoken: string
          Authorization Token to validation the caller
        - ChannelType: integer
          Channel identifier from where the TXN has originated (Internet, Mobile, ATM, Branch Channel )
        - co-Relationid: integer
          Unique ID for the service invoked, will be set by the TXN system
        - entity: string
          entity
        - initiatingSystem: string
          Indicating the initiated system
        - languageCode: integer
          languageCode
        - mu_Id: string
          Muid
        - referenceId: string
          Place holder for Token based authentication
        - serviceMode: integer
          Used for branch channel to indicate the type of customer
        - userId: integer
          userId
        - uuidSeqNo: integer
          UUID Sequence Number
        
        
        """
        
        
        # Prepare request data
        
        # Single body parameter - send directly
        data = request_body if request_body is not None else {}
        
        
        
        # Prepare query parameters
        params = {}
        
        
        # Replace path parameters in URL
        path = "/tradeFinance/prePostShipment/loan/authRejectSentback"
        
        
        # Prepare headers
        headers = {}
        if accesstoken is not None:
            headers["Accesstoken"] = str(accesstoken)
        if channeltype is not None:
            headers["ChannelType"] = str(channeltype)
        if co_relationid is not None:
            headers["co-Relationid"] = str(co_relationid)
        if entity is not None:
            headers["entity"] = str(entity)
        if initiatingsystem is not None:
            headers["initiatingSystem"] = str(initiatingsystem)
        if languagecode is not None:
            headers["languageCode"] = str(languagecode)
        if mu_id is not None:
            headers["mu_Id"] = str(mu_id)
        if referenceid is not None:
            headers["referenceId"] = str(referenceid)
        if servicemode is not None:
            headers["serviceMode"] = str(servicemode)
        if userid is not None:
            headers["userId"] = str(userid)
        if uuidseqno is not None:
            headers["uuidSeqNo"] = str(uuidseqno)
        
        
        return await make_api_request(
            "PUT", 
            path, 
            data=data, 
            params=params if params else None, 
            headers=headers if headers else None
        )
    
    
    
    @mcp.tool()
    async def tfcbtcancel_pre_post_loan_postusing_post(
        request_body:Dict[str, Any] ,  # cancelPrePostShipmentLoanDtlsRequest,
        accesstoken: Optional[str] = None,
        channeltype: Optional[int] = None,
        co_relationid: Optional[int] = None,
        entity: Optional[str] = None,
        initiatingsystem: Optional[str] = None,
        languagecode: Optional[int] = None,
        mu_id: Optional[str] = None,
        referenceid: Optional[str] = None,
        servicemode: Optional[int] = None,
        userid: Optional[int] = None,
        uuidseqno: Optional[int] = None
    ) -> Dict[str, Any]:
        """
        Cancel on hold PS Loan
        
        Generated from: POST /tradeFinance/prePostShipment/loan/cancel
        Source: swagger_2_0
        Operation ID: TFCBTCancelPrePostLoan_POSTUsingPOST
        
        
        Authentication: Not required
        
        Parameters:
        - request_body: any (required)
          input
        
        
        
        Headers:
        - Accesstoken: string
          Authorization Token to validation the caller
        - ChannelType: integer
          Channel identifier from where the TXN has originated (Internet, Mobile, ATM, Branch Channel )
        - co-Relationid: integer
          Unique ID for the service invoked, will be set by the TXN system
        - entity: string
          entity
        - initiatingSystem: string
          Indicating the initiated system
        - languageCode: integer
          languageCode
        - mu_Id: string
          Used to indicate the Branch Id of user
        - referenceId: string
          Place holder for Token based authentication
        - serviceMode: integer
          Used for branch channel to indicate the type of customer
        - userId: integer
          userId
        - uuidSeqNo: integer
          UUID Sequence Number
        
        
        """
        
        
        # Prepare request data
        
        # Single body parameter - send directly
        data = request_body if request_body is not None else {}
        
        
        
        # Prepare query parameters
        params = {}
        
        
        # Replace path parameters in URL
        path = "/tradeFinance/prePostShipment/loan/cancel"
        
        
        # Prepare headers
        headers = {}
        if accesstoken is not None:
            headers["Accesstoken"] = str(accesstoken)
        if channeltype is not None:
            headers["ChannelType"] = str(channeltype)
        if co_relationid is not None:
            headers["co-Relationid"] = str(co_relationid)
        if entity is not None:
            headers["entity"] = str(entity)
        if initiatingsystem is not None:
            headers["initiatingSystem"] = str(initiatingsystem)
        if languagecode is not None:
            headers["languageCode"] = str(languagecode)
        if mu_id is not None:
            headers["mu_Id"] = str(mu_id)
        if referenceid is not None:
            headers["referenceId"] = str(referenceid)
        if servicemode is not None:
            headers["serviceMode"] = str(servicemode)
        if userid is not None:
            headers["userId"] = str(userid)
        if uuidseqno is not None:
            headers["uuidSeqNo"] = str(uuidseqno)
        
        
        return await make_api_request(
            "POST", 
            path, 
            data=data, 
            params=params if params else None, 
            headers=headers if headers else None
        )
    
    
    
    @mcp.tool()
    async def tfcbtcreate_loan_dtls_postusing_post(
        modeflg: int,
        request_body:Dict[str, Any] ,  # prePostShipmentcreatemodifyLoanDtlsRequest,
        accesstoken: Optional[str] = None,
        channeltype: Optional[int] = None,
        co_relationid: Optional[int] = None,
        entity: Optional[str] = None,
        initiatingsystem: Optional[str] = None,
        languagecode: Optional[int] = None,
        mu_id: Optional[str] = None,
        referenceid: Optional[str] = None,
        servicemode: Optional[int] = None,
        userid: Optional[int] = None,
        uuidseqno: Optional[int] = None
    ) -> Dict[str, Any]:
        """
        Create/Modify PS Loan Details 
        
        Generated from: POST /tradeFinance/prePostShipment/loan/createModify
        Source: swagger_2_0
        Operation ID: TFCBTCreateLoanDtls_POSTUsingPOST
        
        
        Authentication: Not required
        
        Parameters:
        - modeFlg: integer (required)
          Mode Flag. Possible values : 1 - Create Settlement Details, 2 - Create Loan Details, 3 - Modify Loan Details
        - request_body: any (required)
          input
        
        
        
        Headers:
        - Accesstoken: string
          Authorization Token to validation the caller
        - ChannelType: integer
          Channel identifier from where the TXN has originated (Internet, Mobile, ATM, Branch Channel )
        - co-Relationid: integer
          Unique ID for the service invoked, will be set by the TXN system
        - entity: string
          entity
        - initiatingSystem: string
          Indicating the initiated system
        - languageCode: integer
          languageCode
        - mu_Id: string
          Used to indicate the Branch Id of user
        - referenceId: string
          Place holder for Token based authentication
        - serviceMode: integer
          Used for branch channel to indicate the type of customer
        - userId: integer
          userId
        - uuidSeqNo: integer
          UUID Sequence Number
        
        
        """
        
        
        # Prepare request data
        
        # Single body parameter - send directly
        data = request_body if request_body is not None else {}
        
        
        
        # Prepare query parameters
        params = {}
        if modeflg is not None:
            params["modeFlg"] = modeflg
            
        
        
        # Replace path parameters in URL
        path = "/tradeFinance/prePostShipment/loan/createModify"
        
        
        # Prepare headers
        headers = {}
        if accesstoken is not None:
            headers["Accesstoken"] = str(accesstoken)
        if channeltype is not None:
            headers["ChannelType"] = str(channeltype)
        if co_relationid is not None:
            headers["co-Relationid"] = str(co_relationid)
        if entity is not None:
            headers["entity"] = str(entity)
        if initiatingsystem is not None:
            headers["initiatingSystem"] = str(initiatingsystem)
        if languagecode is not None:
            headers["languageCode"] = str(languagecode)
        if mu_id is not None:
            headers["mu_Id"] = str(mu_id)
        if referenceid is not None:
            headers["referenceId"] = str(referenceid)
        if servicemode is not None:
            headers["serviceMode"] = str(servicemode)
        if userid is not None:
            headers["userId"] = str(userid)
        if uuidseqno is not None:
            headers["uuidSeqNo"] = str(uuidseqno)
        
        
        return await make_api_request(
            "POST", 
            path, 
            data=data, 
            params=params if params else None, 
            headers=headers if headers else None
        )
    
    
    
    @mcp.tool()
    async def tfcetcrloan_list_postusing_get(
        accounttype: Optional[int] = None,
        billreference: Optional[str] = None,
        crystflag: Optional[int] = None,
        customerreference: Optional[int] = None,
        loanaccountreference: Optional[str] = None,
        loanid: Optional[int] = None,
        loanstatus: Optional[int] = None,
        module: Optional[int] = None,
        pagenum: Optional[int] = None,
        pagesize: Optional[int] = None,
        shipmenttype: Optional[int] = None,
        channeltype: Optional[int] = None,
        co_relationid: Optional[int] = None,
        entity: Optional[str] = None,
        initiatingsystem: Optional[str] = None,
        languagecode: Optional[int] = None,
        servicemode: Optional[int] = None,
        userid: Optional[int] = None,
        uuidseqno: Optional[int] = None
    ) -> Dict[str, Any]:
        """
        Loan Accounts List
        
        Generated from: GET /tradeFinance/prePostShipment/loan/loanAccountsList
        Source: swagger_2_0
        Operation ID: TFCETCRLoanList_POSTUsingGET
        
        
        Authentication: Not required
        
        Parameters:
        - accountType: integer
          Account Type
        - billReference: string
          Bill Reference
        - crystFlag: integer
          Crystallization Flag
        - customerReference: integer
          Customer Reference
        - loanAccountReference: string
          Loan Account Reference
        - loanId: integer
          Loan Application Number
        - loanStatus: integer
          Loan Status
        - module: integer
          Module EDC or ELC
        - pageNum: integer
          pageNum
        - pageSize: integer
          pageSize
        - shipmentType: integer
          Shipment Type - 1- Pre Shipment Loan, 2- Post Shipment Loan
        
        
        
        Headers:
        - ChannelType: integer
          Channel identifier from where the TXN has originated (Internet, Mobile, ATM, Branch Channel )
        - co-Relationid: integer
          Unique ID for the service invoked, will be set by the TXN system
        - entity: string
          entity
        - initiatingSystem: string
          Indicating the initiated system
        - languageCode: integer
          languageCode
        - serviceMode: integer
          Used for branch channel to indicate the type of customer
        - userId: integer
          userId
        - uuidSeqNo: integer
          UUID Sequence Number
        
        
        """
        
        
        # Prepare query parameters
        params = {}
        if accounttype is not None:
            params["accountType"] = accounttype
            
        if billreference is not None:
            params["billReference"] = billreference
            
        if crystflag is not None:
            params["crystFlag"] = crystflag
            
        if customerreference is not None:
            params["customerReference"] = customerreference
            
        if loanaccountreference is not None:
            params["loanAccountReference"] = loanaccountreference
            
        if loanid is not None:
            params["loanId"] = loanid
            
        if loanstatus is not None:
            params["loanStatus"] = loanstatus
            
        if module is not None:
            params["module"] = module
            
        if pagenum is not None:
            params["pageNum"] = pagenum
            
        if pagesize is not None:
            params["pageSize"] = pagesize
            
        if shipmenttype is not None:
            params["shipmentType"] = shipmenttype
            
        
        
        # Replace path parameters in URL
        path = "/tradeFinance/prePostShipment/loan/loanAccountsList"
        
        
        # Prepare headers
        headers = {}
        if channeltype is not None:
            headers["ChannelType"] = str(channeltype)
        if co_relationid is not None:
            headers["co-Relationid"] = str(co_relationid)
        if entity is not None:
            headers["entity"] = str(entity)
        if initiatingsystem is not None:
            headers["initiatingSystem"] = str(initiatingsystem)
        if languagecode is not None:
            headers["languageCode"] = str(languagecode)
        if servicemode is not None:
            headers["serviceMode"] = str(servicemode)
        if userid is not None:
            headers["userId"] = str(userid)
        if uuidseqno is not None:
            headers["uuidSeqNo"] = str(uuidseqno)
        
        
        return await make_api_request(
            "GET", 
            path, 
            
            params=params if params else None, 
            headers=headers if headers else None
        )
    
    
    
    @mcp.tool()
    async def tfcetloan_dtls_list_postusing_get(
        begindate: Optional[str] = None,
        billamount: Optional[float] = None,
        billamountcurrency: Optional[str] = None,
        billreferenceexternal: Optional[str] = None,
        closedate: Optional[str] = None,
        documenttype: Optional[int] = None,
        draweename: Optional[str] = None,
        drawerid: Optional[int] = None,
        drawername: Optional[str] = None,
        loanamount: Optional[float] = None,
        loancurrency: Optional[str] = None,
        loanshipmenttype: Optional[int] = None,
        loantransactionid: Optional[int] = None,
        module: Optional[str] = None,
        operationtype: Optional[int] = None,
        pagenum: Optional[int] = None,
        pagesize: Optional[int] = None,
        ratestatus: Optional[int] = None,
        status: Optional[int] = None,
        transactiondate: Optional[str] = None,
        accesstoken: Optional[str] = None,
        channeltype: Optional[int] = None,
        co_relationid: Optional[int] = None,
        entity: Optional[str] = None,
        initiatingsystem: Optional[str] = None,
        languagecode: Optional[int] = None,
        mu_id: Optional[str] = None,
        referenceid: Optional[str] = None,
        servicemode: Optional[int] = None,
        userid: Optional[int] = None,
        uuidseqno: Optional[int] = None
    ) -> Dict[str, Any]:
        """
        Fetch PS Loan Details List
        
        Generated from: GET /tradeFinance/prePostShipment/loan/loanList
        Source: swagger_2_0
        Operation ID: TFCETLoanDtlsList_POSTUsingGET
        
        
        Authentication: Not required
        
        Parameters:
        - beginDate: string
          Start Date Date. Date Format :[dd/MM/yyyy]
        - billAmount: number
          Bill Amount
        - billAmountCurrency: string
          Bill Amount Currency Eg.[USD]
        - billReferenceExternal: string
          BL External Reference Number
        - closeDate: string
          End Date. Date Format :[dd/MM/yyyy]
        - documentType: integer
          Document Type
        - draweeName: string
          Drawee Name
        - drawerId: integer
          Customer Reference
        - drawerName: string
          Drawer Name
        - loanAmount: number
          Loan Amount
        - loanCurrency: string
          Loan Amount Currency Eg.[USD]
        - loanShipmentType: integer
          LOAN SHIPMENT TYPE
        - loanTransactionId: integer
          Loan Transaction Id
        - module: string
          Module - LC or DC
        - operationType: integer
          operationType
        - pageNum: integer
          pageNum
        - pageSize: integer
          pageSize
        - rateStatus: integer
          Rate Request Status
        - status: integer
          Status.( Status.Possible Values: 1 - OnHold, 2 - Released, 3 - Verified, 4 - PendingClosure, 5 - Closed, 6 - Executed, 7 - Expired, 8 - Rejected, 9 - WaitingForRate, 10 - AmndmntInit, 11 - AcptRefPndng, 13 - Refused, 12 - Final1, 14 - SuspWdrwPndng, 15 - CnclClosePndng, 16 - RevivalPndng, 17 - Cancelled  Domain : d_TFBGStatus)
        - transactionDate: string
          Transaction Date. Date Format :[dd/MM/yyyy]
        
        
        
        Headers:
        - Accesstoken: string
          Authorization Token to validation the caller
        - ChannelType: integer
          Channel identifier from where the TXN has originated (Internet, Mobile, ATM, Branch Channel )
        - co-Relationid: integer
          Unique ID for the service invoked, will be set by the TXN system
        - entity: string
          entity
        - initiatingSystem: string
          Indicating the initiated system
        - languageCode: integer
          languageCode
        - mu_Id: string
          Used to indicate the Branch Id of user
        - referenceId: string
          Place holder for Token based authentication
        - serviceMode: integer
          Used for branch channel to indicate the type of customer
        - userId: integer
          userId
        - uuidSeqNo: integer
          UUID Sequence Number
        
        
        """
        
        
        # Prepare query parameters
        params = {}
        if begindate is not None:
            params["beginDate"] = begindate
            
        if billamount is not None:
            params["billAmount"] = billamount
            
        if billamountcurrency is not None:
            params["billAmountCurrency"] = billamountcurrency
            
        if billreferenceexternal is not None:
            params["billReferenceExternal"] = billreferenceexternal
            
        if closedate is not None:
            params["closeDate"] = closedate
            
        if documenttype is not None:
            params["documentType"] = documenttype
            
        if draweename is not None:
            params["draweeName"] = draweename
            
        if drawerid is not None:
            params["drawerId"] = drawerid
            
        if drawername is not None:
            params["drawerName"] = drawername
            
        if loanamount is not None:
            params["loanAmount"] = loanamount
            
        if loancurrency is not None:
            params["loanCurrency"] = loancurrency
            
        if loanshipmenttype is not None:
            params["loanShipmentType"] = loanshipmenttype
            
        if loantransactionid is not None:
            params["loanTransactionId"] = loantransactionid
            
        if module is not None:
            params["module"] = module
            
        if operationtype is not None:
            params["operationType"] = operationtype
            
        if pagenum is not None:
            params["pageNum"] = pagenum
            
        if pagesize is not None:
            params["pageSize"] = pagesize
            
        if ratestatus is not None:
            params["rateStatus"] = ratestatus
            
        if status is not None:
            params["status"] = status
            
        if transactiondate is not None:
            params["transactionDate"] = transactiondate
            
        
        
        # Replace path parameters in URL
        path = "/tradeFinance/prePostShipment/loan/loanList"
        
        
        # Prepare headers
        headers = {}
        if accesstoken is not None:
            headers["Accesstoken"] = str(accesstoken)
        if channeltype is not None:
            headers["ChannelType"] = str(channeltype)
        if co_relationid is not None:
            headers["co-Relationid"] = str(co_relationid)
        if entity is not None:
            headers["entity"] = str(entity)
        if initiatingsystem is not None:
            headers["initiatingSystem"] = str(initiatingsystem)
        if languagecode is not None:
            headers["languageCode"] = str(languagecode)
        if mu_id is not None:
            headers["mu_Id"] = str(mu_id)
        if referenceid is not None:
            headers["referenceId"] = str(referenceid)
        if servicemode is not None:
            headers["serviceMode"] = str(servicemode)
        if userid is not None:
            headers["userId"] = str(userid)
        if uuidseqno is not None:
            headers["uuidSeqNo"] = str(uuidseqno)
        
        
        return await make_api_request(
            "GET", 
            path, 
            
            params=params if params else None, 
            headers=headers if headers else None
        )
    
    
    
    @mcp.tool()
    async def tfcetsimulate_loan_repayment_postusing_get(
        disbursementdate: Optional[str] = None,
        downpaymentamount: Optional[float] = None,
        gracefrequency: Optional[int] = None,
        graceval: Optional[int] = None,
        installmentdate: Optional[str] = None,
        installmentfrequency: Optional[int] = None,
        installmentid: Optional[int] = None,
        installmenttyp: Optional[int] = None,
        interestrate: Optional[float] = None,
        ismanual: Optional[int] = None,
        loancurrency: Optional[str] = None,
        purchasecost: Optional[float] = None,
        revisedmaturitydate: Optional[str] = None,
        specialholidayapplication: Optional[int] = None,
        todate: Optional[str] = None,
        transactionpurpose: Optional[int] = None,
        transactionsubpurpose: Optional[int] = None,
        channeltype: Optional[int] = None,
        co_relationid: Optional[int] = None,
        entity: Optional[str] = None,
        initiatingsystem: Optional[str] = None,
        languagecode: Optional[int] = None,
        servicemode: Optional[int] = None,
        userid: Optional[int] = None,
        uuidseqno: Optional[int] = None
    ) -> Dict[str, Any]:
        """
        Simulate Loan Repayment
        
        Generated from: GET /tradeFinance/prePostShipment/loan/upFrontProfit
        Source: swagger_2_0
        Operation ID: TFCETSimulateLoanRepayment_POSTUsingGET
        
        
        Authentication: Not required
        
        Parameters:
        - disbursementDate: string
          disbursement Date
        - downPaymentAmount: number
          downPayment Amount
        - graceFrequency: integer
          grace Frequency
        - graceVal: integer
          grace Value
        - installmentDate: string
          installment Date
        - installmentFrequency: integer
          installment Frequency
        - installmentId: integer
          installment Id
        - installmentTyp: integer
          installment Type
        - interestRate: number
          interest Rate
        - isManual: integer
          Manual
        - loanCurrency: string
          loanCurrency
        - purchaseCost: number
          purchase Cost
        - revisedMaturityDate: string
          revised Maturity Date
        - specialHolidayApplication: integer
          special Holiday Application
        - toDate: string
          Today Date
        - transactionPurpose: integer
          transaction Purpose
        - transactionSubPurpose: integer
          transaction Sub Purpose
        
        
        
        Headers:
        - ChannelType: integer
          Channel identifier from where the TXN has originated (Internet, Mobile, ATM, Branch Channel )
        - co-Relationid: integer
          Unique ID for the service invoked, will be set by the TXN system
        - entity: string
          entity
        - initiatingSystem: string
          Indicating the initiated system
        - languageCode: integer
          languageCode
        - serviceMode: integer
          Used for branch channel to indicate the type of customer
        - userId: integer
          userId
        - uuidSeqNo: integer
          UUID Sequence Number
        
        
        """
        
        
        # Prepare query parameters
        params = {}
        if disbursementdate is not None:
            params["disbursementDate"] = disbursementdate
            
        if downpaymentamount is not None:
            params["downPaymentAmount"] = downpaymentamount
            
        if gracefrequency is not None:
            params["graceFrequency"] = gracefrequency
            
        if graceval is not None:
            params["graceVal"] = graceval
            
        if installmentdate is not None:
            params["installmentDate"] = installmentdate
            
        if installmentfrequency is not None:
            params["installmentFrequency"] = installmentfrequency
            
        if installmentid is not None:
            params["installmentId"] = installmentid
            
        if installmenttyp is not None:
            params["installmentTyp"] = installmenttyp
            
        if interestrate is not None:
            params["interestRate"] = interestrate
            
        if ismanual is not None:
            params["isManual"] = ismanual
            
        if loancurrency is not None:
            params["loanCurrency"] = loancurrency
            
        if purchasecost is not None:
            params["purchaseCost"] = purchasecost
            
        if revisedmaturitydate is not None:
            params["revisedMaturityDate"] = revisedmaturitydate
            
        if specialholidayapplication is not None:
            params["specialHolidayApplication"] = specialholidayapplication
            
        if todate is not None:
            params["toDate"] = todate
            
        if transactionpurpose is not None:
            params["transactionPurpose"] = transactionpurpose
            
        if transactionsubpurpose is not None:
            params["transactionSubPurpose"] = transactionsubpurpose
            
        
        
        # Replace path parameters in URL
        path = "/tradeFinance/prePostShipment/loan/upFrontProfit"
        
        
        # Prepare headers
        headers = {}
        if channeltype is not None:
            headers["ChannelType"] = str(channeltype)
        if co_relationid is not None:
            headers["co-Relationid"] = str(co_relationid)
        if entity is not None:
            headers["entity"] = str(entity)
        if initiatingsystem is not None:
            headers["initiatingSystem"] = str(initiatingsystem)
        if languagecode is not None:
            headers["languageCode"] = str(languagecode)
        if servicemode is not None:
            headers["serviceMode"] = str(servicemode)
        if userid is not None:
            headers["userId"] = str(userid)
        if uuidseqno is not None:
            headers["uuidSeqNo"] = str(uuidseqno)
        
        
        return await make_api_request(
            "GET", 
            path, 
            
            params=params if params else None, 
            headers=headers if headers else None
        )
    
    
    
    @mcp.tool()
    async def tfcbtuser_confirmation_pre_post_loan_postusing_post(
        request_body:Dict[str, Any] ,  # prePostShipmentUserConfirmationLoanDtlsRequest,
        accesstoken: Optional[str] = None,
        channeltype: Optional[int] = None,
        co_relationid: Optional[int] = None,
        entity: Optional[str] = None,
        initiatingsystem: Optional[str] = None,
        languagecode: Optional[int] = None,
        mu_id: Optional[str] = None,
        referenceid: Optional[str] = None,
        servicemode: Optional[int] = None,
        userid: Optional[int] = None,
        uuidseqno: Optional[int] = None
    ) -> Dict[str, Any]:
        """
        UserConfirmation PS Loan Dtls
        
        Generated from: POST /tradeFinance/prePostShipment/loan/userConfirmation
        Source: swagger_2_0
        Operation ID: TFCBTUserConfirmationPrePostLoan_POSTUsingPOST
        
        
        Authentication: Not required
        
        Parameters:
        - request_body: any (required)
          input
        
        
        
        Headers:
        - Accesstoken: string
          Authorization Token to validation the caller
        - ChannelType: integer
          Channel identifier from where the TXN has originated (Internet, Mobile, ATM, Branch Channel )
        - co-Relationid: integer
          Unique ID for the service invoked, will be set by the TXN system
        - entity: string
          entity
        - initiatingSystem: string
          Indicating the initiated system
        - languageCode: integer
          languageCode
        - mu_Id: string
          Used to indicate the Branch Id of user
        - referenceId: string
          Place holder for Token based authentication
        - serviceMode: integer
          Used for branch channel to indicate the type of customer
        - userId: integer
          userId
        - uuidSeqNo: integer
          UUID Sequence Number
        
        
        """
        
        
        # Prepare request data
        
        # Single body parameter - send directly
        data = request_body if request_body is not None else {}
        
        
        
        # Prepare query parameters
        params = {}
        
        
        # Replace path parameters in URL
        path = "/tradeFinance/prePostShipment/loan/userConfirmation"
        
        
        # Prepare headers
        headers = {}
        if accesstoken is not None:
            headers["Accesstoken"] = str(accesstoken)
        if channeltype is not None:
            headers["ChannelType"] = str(channeltype)
        if co_relationid is not None:
            headers["co-Relationid"] = str(co_relationid)
        if entity is not None:
            headers["entity"] = str(entity)
        if initiatingsystem is not None:
            headers["initiatingSystem"] = str(initiatingsystem)
        if languagecode is not None:
            headers["languageCode"] = str(languagecode)
        if mu_id is not None:
            headers["mu_Id"] = str(mu_id)
        if referenceid is not None:
            headers["referenceId"] = str(referenceid)
        if servicemode is not None:
            headers["serviceMode"] = str(servicemode)
        if userid is not None:
            headers["userId"] = str(userid)
        if uuidseqno is not None:
            headers["uuidSeqNo"] = str(uuidseqno)
        
        
        return await make_api_request(
            "POST", 
            path, 
            data=data, 
            params=params if params else None, 
            headers=headers if headers else None
        )
    
    
    
    @mcp.tool()
    async def tfcetview_loan_dtls_postusing_get(
        loantransactionid: int,
        accesstoken: Optional[str] = None,
        channeltype: Optional[int] = None,
        co_relationid: Optional[int] = None,
        entity: Optional[str] = None,
        initiatingsystem: Optional[str] = None,
        languagecode: Optional[int] = None,
        mu_id: Optional[str] = None,
        referenceid: Optional[str] = None,
        servicemode: Optional[int] = None,
        userid: Optional[int] = None,
        uuidseqno: Optional[int] = None
    ) -> Dict[str, Any]:
        """
        View PS Loan  Details
        
        Generated from: GET /tradeFinance/prePostShipment/loan/{loanTransactionId}/view
        Source: swagger_2_0
        Operation ID: TFCETViewLoanDtls_POSTUsingGET
        
        
        Authentication: Not required
        
        Parameters:
        - loanTransactionId: integer (required)
          Loan Transaction ID
        
        
        
        Headers:
        - Accesstoken: string
          Authorization Token to validation the caller
        - ChannelType: integer
          Channel identifier from where the TXN has originated (Internet, Mobile, ATM, Branch Channel )
        - co-Relationid: integer
          Unique ID for the service invoked, will be set by the TXN system
        - entity: string
          entity
        - initiatingSystem: string
          Indicating the initiated system
        - languageCode: integer
          languageCode
        - mu_Id: string
          Used to indicate the Branch Id of user
        - referenceId: string
          Place holder for Token based authentication
        - serviceMode: integer
          Used for branch channel to indicate the type of customer
        - userId: integer
          userId
        - uuidSeqNo: integer
          UUID Sequence Number
        
        
        """
        
        
        # Prepare query parameters
        params = {}
        
        
        # Replace path parameters in URL
        path = "/tradeFinance/prePostShipment/loan/{loanTransactionId}/view"
        if loantransactionid is not None:
            path = path.replace("{loanTransactionId}", str(loantransactionid))
        
        
        # Prepare headers
        headers = {}
        if accesstoken is not None:
            headers["Accesstoken"] = str(accesstoken)
        if channeltype is not None:
            headers["ChannelType"] = str(channeltype)
        if co_relationid is not None:
            headers["co-Relationid"] = str(co_relationid)
        if entity is not None:
            headers["entity"] = str(entity)
        if initiatingsystem is not None:
            headers["initiatingSystem"] = str(initiatingsystem)
        if languagecode is not None:
            headers["languageCode"] = str(languagecode)
        if mu_id is not None:
            headers["mu_Id"] = str(mu_id)
        if referenceid is not None:
            headers["referenceId"] = str(referenceid)
        if servicemode is not None:
            headers["serviceMode"] = str(servicemode)
        if userid is not None:
            headers["userId"] = str(userid)
        if uuidseqno is not None:
            headers["uuidSeqNo"] = str(uuidseqno)
        
        
        return await make_api_request(
            "GET", 
            path, 
            
            params=params if params else None, 
            headers=headers if headers else None
        )
    
    
    
    @mcp.tool()
    async def tfet5282_fetch_sglist_postusing_get(
        referenceexternal: Optional[str] = None,
        channeltype: Optional[int] = None,
        accesstoken: Optional[str] = None,
        co_relationid: Optional[int] = None,
        entity: Optional[str] = None,
        initiatingsystem: Optional[str] = None,
        languagecode: Optional[int] = None,
        referenceid: Optional[str] = None,
        servicemode: Optional[int] = None,
        userid: Optional[int] = None,
        uuidseqno: Optional[int] = None
    ) -> Dict[str, Any]:
        """
        Service to fetch SG Details
        
        Generated from: GET /tradeFinance/shippingGuaranteeList
        Source: swagger_2_0
        Operation ID: TFET5282FetchSGList_POSTUsingGET
        
        
        Authentication: Not required
        
        Parameters:
        - referenceExternal: string
          Reference External
        
        
        
        Headers:
        - ChannelType: integer
          Channel identifier from where the TXN has originated (Internet, Mobile, ATM, Branch Channel )
        - accesstoken: string
          Authorization Token to validation the caller
        - co-Relationid: integer
          Unique ID for the service invoked, will be set by the TXN system
        - entity: string
          entity
        - initiatingSystem: string
          Indicating the initiated system
        - languageCode: integer
          languageCode
        - referenceId: string
          Place holder for Token based authentication
        - serviceMode: integer
          Used for branch channel to indicate the type of customer
        - userId: integer
          userId
        - uuidSeqNo: integer
          UUID Sequence Number
        
        
        """
        
        
        # Prepare query parameters
        params = {}
        if referenceexternal is not None:
            params["referenceExternal"] = referenceexternal
            
        
        
        # Replace path parameters in URL
        path = "/tradeFinance/shippingGuaranteeList"
        
        
        # Prepare headers
        headers = {}
        if channeltype is not None:
            headers["ChannelType"] = str(channeltype)
        if accesstoken is not None:
            headers["accesstoken"] = str(accesstoken)
        if co_relationid is not None:
            headers["co-Relationid"] = str(co_relationid)
        if entity is not None:
            headers["entity"] = str(entity)
        if initiatingsystem is not None:
            headers["initiatingSystem"] = str(initiatingsystem)
        if languagecode is not None:
            headers["languageCode"] = str(languagecode)
        if referenceid is not None:
            headers["referenceId"] = str(referenceid)
        if servicemode is not None:
            headers["serviceMode"] = str(servicemode)
        if userid is not None:
            headers["userId"] = str(userid)
        if uuidseqno is not None:
            headers["uuidSeqNo"] = str(uuidseqno)
        
        
        return await make_api_request(
            "GET", 
            path, 
            
            params=params if params else None, 
            headers=headers if headers else None
        )
    
    
    
    @mcp.tool()
    async def tfet3011_get_shipping_master_postusing_get(
        companyname: Optional[str] = None,
        pagenum: Optional[int] = None,
        pagesize: Optional[int] = None,
        channeltype: Optional[int] = None,
        co_relationid: Optional[int] = None,
        entity: Optional[str] = None,
        initiatingsystem: Optional[str] = None,
        languagecode: Optional[int] = None,
        servicemode: Optional[int] = None,
        userid: Optional[int] = None,
        uuidseqno: Optional[int] = None
    ) -> Dict[str, Any]:
        """
        TFET3011GetShippingMaster
        
        Generated from: GET /tradeFinance/tfShippingMaster/shipping
        Source: swagger_2_0
        Operation ID: TFET3011GetShippingMaster_POSTUsingGET
        
        
        Authentication: Not required
        
        Parameters:
        - companyName: string
          Company Name
        - pageNum: integer
          pageNum
        - pageSize: integer
          pageSize
        
        
        
        Headers:
        - ChannelType: integer
          Channel identifier from where the TXN has originated (Internet, Mobile, ATM, Branch Channel )
        - co-Relationid: integer
          Unique ID for the service invoked, will be set by the TXN system
        - entity: string
          entity
        - initiatingSystem: string
          Indicating the initiated system
        - languageCode: integer
          languageCode
        - serviceMode: integer
          Used for branch channel to indicate the type of customer
        - userId: integer
          userId
        - uuidSeqNo: integer
          UUID Sequence Number
        
        
        """
        
        
        # Prepare query parameters
        params = {}
        if companyname is not None:
            params["companyName"] = companyname
            
        if pagenum is not None:
            params["pageNum"] = pagenum
            
        if pagesize is not None:
            params["pageSize"] = pagesize
            
        
        
        # Replace path parameters in URL
        path = "/tradeFinance/tfShippingMaster/shipping"
        
        
        # Prepare headers
        headers = {}
        if channeltype is not None:
            headers["ChannelType"] = str(channeltype)
        if co_relationid is not None:
            headers["co-Relationid"] = str(co_relationid)
        if entity is not None:
            headers["entity"] = str(entity)
        if initiatingsystem is not None:
            headers["initiatingSystem"] = str(initiatingsystem)
        if languagecode is not None:
            headers["languageCode"] = str(languagecode)
        if servicemode is not None:
            headers["serviceMode"] = str(servicemode)
        if userid is not None:
            headers["userId"] = str(userid)
        if uuidseqno is not None:
            headers["uuidSeqNo"] = str(uuidseqno)
        
        
        return await make_api_request(
            "GET", 
            path, 
            
            params=params if params else None, 
            headers=headers if headers else None
        )
    
    
    
    @mcp.tool()
    async def tfcetfetch_tfevents_list_postusing_get(
        externalreference: str,
        pagenum: Optional[int] = None,
        pagesize: Optional[int] = None,
        channeltype: Optional[int] = None,
        co_relationid: Optional[int] = None,
        entity: Optional[str] = None,
        initiatingsystem: Optional[str] = None,
        languagecode: Optional[int] = None,
        servicemode: Optional[int] = None,
        userid: Optional[int] = None,
        uuidseqno: Optional[int] = None
    ) -> Dict[str, Any]:
        """
        Fetch TF Events
        
        Generated from: GET /tradeFinance/{externalReference}/events
        Source: swagger_2_0
        Operation ID: TFCETFetchTFEventsList_POSTUsingGET
        
        
        Authentication: Not required
        
        Parameters:
        - externalReference: string (required)
          externalReference
        - pageNum: integer
          pageNum
        - pageSize: integer
          pageSize
        
        
        
        Headers:
        - ChannelType: integer
          Channel identifier from where the TXN has originated (Internet, Mobile, ATM, Branch Channel )
        - co-Relationid: integer
          Unique ID for the service invoked, will be set by the TXN system
        - entity: string
          entity
        - initiatingSystem: string
          Indicating the initiated system
        - languageCode: integer
          languageCode
        - serviceMode: integer
          Used for branch channel to indicate the type of customer
        - userId: integer
          userId
        - uuidSeqNo: integer
          UUID Sequence Number
        
        
        """
        
        
        # Prepare query parameters
        params = {}
        if pagenum is not None:
            params["pageNum"] = pagenum
            
        if pagesize is not None:
            params["pageSize"] = pagesize
            
        
        
        # Replace path parameters in URL
        path = "/tradeFinance/{externalReference}/events"
        if externalreference is not None:
            path = path.replace("{externalReference}", str(externalreference))
        
        
        # Prepare headers
        headers = {}
        if channeltype is not None:
            headers["ChannelType"] = str(channeltype)
        if co_relationid is not None:
            headers["co-Relationid"] = str(co_relationid)
        if entity is not None:
            headers["entity"] = str(entity)
        if initiatingsystem is not None:
            headers["initiatingSystem"] = str(initiatingsystem)
        if languagecode is not None:
            headers["languageCode"] = str(languagecode)
        if servicemode is not None:
            headers["serviceMode"] = str(servicemode)
        if userid is not None:
            headers["userId"] = str(userid)
        if uuidseqno is not None:
            headers["uuidSeqNo"] = str(uuidseqno)
        
        
        return await make_api_request(
            "GET", 
            path, 
            
            params=params if params else None, 
            headers=headers if headers else None
        )
    
    
    
    @mcp.tool()
    async def tfcet5584_fetch_notes_and_memo_postusing_get(
        referenceexternal: str,
        transactiontype: int,
        eventlegid: Optional[int] = None,
        notesmemoid: Optional[int] = None,
        pagenum: Optional[int] = None,
        pagesize: Optional[int] = None,
        channeltype: Optional[int] = None,
        co_relationid: Optional[int] = None,
        entity: Optional[str] = None,
        initiatingsystem: Optional[str] = None,
        languagecode: Optional[int] = None,
        servicemode: Optional[int] = None,
        userid: Optional[int] = None,
        uuidseqno: Optional[int] = None
    ) -> Dict[str, Any]:
        """
        Fetch Notes and Memo
        
        Generated from: GET /tradeFinance/{referenceExternal}/notesAndMemo
        Source: swagger_2_0
        Operation ID: TFCET5584FetchNotesAndMemo_POSTUsingGET
        
        
        Authentication: Not required
        
        Parameters:
        - eventLegID: integer
          Event leg ID  Possible values: > 0 (only for lc amend, bg amend) 
        - notesMemoID: integer
          Notes Memo ID
        - pageNum: integer
          pageNum
        - pageSize: integer
          pageSize
        - referenceExternal: string (required)
          Account Reference
        - transactionType: integer (required)
          Transaction type   Possible values : 1119 - TF LC Issue, 1122 - TF LC Bill Lodgement, 1123 - TF LC Bill Payment, 1111 - TF BG Issue,1310 - TF Bg Claim, 1311 - TF BG Claim Settlement, 1131 - TF DC Bill Lodgement, 1305 - TF DC Bill Payment, 1112 - ELC issue, 1113 - ELC Bill Lodgement, 1115 - ELC Bill Payment, 1117 - EDC Bill Lodgement, 1118 - EDC Bill Payment. Domain name : d_PosTyp
        
        
        
        Headers:
        - ChannelType: integer
          Channel identifier from where the TXN has originated (Internet, Mobile, ATM, Branch Channel )
        - co-Relationid: integer
          Unique ID for the service invoked, will be set by the TXN system
        - entity: string
          entity
        - initiatingSystem: string
          Indicating the initiated system
        - languageCode: integer
          languageCode
        - serviceMode: integer
          Used for branch channel to indicate the type of customer
        - userId: integer
          userId
        - uuidSeqNo: integer
          UUID Sequence Number
        
        
        """
        
        
        # Prepare query parameters
        params = {}
        if eventlegid is not None:
            params["eventLegID"] = eventlegid
            
        if notesmemoid is not None:
            params["notesMemoID"] = notesmemoid
            
        if pagenum is not None:
            params["pageNum"] = pagenum
            
        if pagesize is not None:
            params["pageSize"] = pagesize
            
        if transactiontype is not None:
            params["transactionType"] = transactiontype
            
        
        
        # Replace path parameters in URL
        path = "/tradeFinance/{referenceExternal}/notesAndMemo"
        if referenceexternal is not None:
            path = path.replace("{referenceExternal}", str(referenceexternal))
        
        
        # Prepare headers
        headers = {}
        if channeltype is not None:
            headers["ChannelType"] = str(channeltype)
        if co_relationid is not None:
            headers["co-Relationid"] = str(co_relationid)
        if entity is not None:
            headers["entity"] = str(entity)
        if initiatingsystem is not None:
            headers["initiatingSystem"] = str(initiatingsystem)
        if languagecode is not None:
            headers["languageCode"] = str(languagecode)
        if servicemode is not None:
            headers["serviceMode"] = str(servicemode)
        if userid is not None:
            headers["userId"] = str(userid)
        if uuidseqno is not None:
            headers["uuidSeqNo"] = str(uuidseqno)
        
        
        return await make_api_request(
            "GET", 
            path, 
            
            params=params if params else None, 
            headers=headers if headers else None
        )
    
    
    
    @mcp.tool()
    async def tfcbt5584_create_notes_and_memo_postusing_post(
        referenceexternal: str,
        transactiontype: int,
        request_body:Dict[str, Any] ,  # CreateNotesAndMemoRequest,
        eventlegid: Optional[int] = None,
        channeltype: Optional[int] = None,
        co_relationid: Optional[int] = None,
        entity: Optional[str] = None,
        initiatingsystem: Optional[str] = None,
        languagecode: Optional[int] = None,
        referenceid: Optional[str] = None,
        requesthash: Optional[str] = None,
        servicemode: Optional[int] = None,
        userid: Optional[int] = None,
        uuidseqno: Optional[int] = None
    ) -> Dict[str, Any]:
        """
        Create Notes and Memo
        
        Generated from: POST /tradeFinance/{referenceExternal}/notesAndMemo
        Source: swagger_2_0
        Operation ID: TFCBT5584CreateNotesAndMemo_POSTUsingPOST
        
        
        Authentication: Not required
        
        Parameters:
        - eventLegID: integer
          Event leg ID  Possible values: > 0 (only for lc amend, bg amend) 
        - referenceExternal: string (required)
          Account Reference
        - transactionType: integer (required)
          Transaction type   Possible values : 1119 - TF LC Issue, 1122 - TF LC Bill Lodgement, 1123 - TF LC Bill Payment, 1111 - TF BG Issue,1310 - TF Bg Claim, 1311 - TF BG Claim Settlement, 1131 - TF DC Bill Lodgement, 1305 - TF DC Bill Payment, 1112 - ELC issue, 1113 - ELC Bill Lodgement, 1115 - ELC Bill Payment, 1117 - EDC Bill Lodgement, 1118 - EDC Bill Payment. Domain name : d_PosTyp
        - request_body: any (required)
          input
        
        
        
        Headers:
        - ChannelType: integer
          Channel identifier from where the TXN has originated (Internet, Mobile, ATM, Branch Channel )
        - co-Relationid: integer
          Unique ID for the service invoked, will be set by the TXN system
        - entity: string
          entity
        - initiatingSystem: string
          Indicating the initiated system
        - languageCode: integer
          languageCode
        - referenceId: string
          Place holder for Token based authentication
        - requesthash: string
          Request payload for hash validation
        - serviceMode: integer
          Used for branch channel to indicate the type of customer
        - userId: integer
          userId
        - uuidSeqNo: integer
          UUID Sequence Number
        
        
        """
        
        
        # Prepare request data
        
        # Single body parameter - send directly
        data = request_body if request_body is not None else {}
        
        
        
        # Prepare query parameters
        params = {}
        if eventlegid is not None:
            params["eventLegID"] = eventlegid
            
        if transactiontype is not None:
            params["transactionType"] = transactiontype
            
        
        
        # Replace path parameters in URL
        path = "/tradeFinance/{referenceExternal}/notesAndMemo"
        if referenceexternal is not None:
            path = path.replace("{referenceExternal}", str(referenceexternal))
        
        
        # Prepare headers
        headers = {}
        if channeltype is not None:
            headers["ChannelType"] = str(channeltype)
        if co_relationid is not None:
            headers["co-Relationid"] = str(co_relationid)
        if entity is not None:
            headers["entity"] = str(entity)
        if initiatingsystem is not None:
            headers["initiatingSystem"] = str(initiatingsystem)
        if languagecode is not None:
            headers["languageCode"] = str(languagecode)
        if referenceid is not None:
            headers["referenceId"] = str(referenceid)
        if requesthash is not None:
            headers["requesthash"] = str(requesthash)
        if servicemode is not None:
            headers["serviceMode"] = str(servicemode)
        if userid is not None:
            headers["userId"] = str(userid)
        if uuidseqno is not None:
            headers["uuidSeqNo"] = str(uuidseqno)
        
        
        return await make_api_request(
            "POST", 
            path, 
            data=data, 
            params=params if params else None, 
            headers=headers if headers else None
        )
    
    
    
    @mcp.tool()
    async def vabt0063_onhld_bulk_acnt_postusing_post(
        request_body:Dict[str, Any] ,  # bulkAccountCreationRequest,
        accesstoken: Optional[str] = None,
        channeltype: Optional[int] = None,
        co_relationid: Optional[int] = None,
        initiatingsystem: Optional[str] = None,
        servicemode: Optional[int] = None,
        uuidseqno: Optional[int] = None,
        entity: Optional[str] = None,
        languagecode: Optional[int] = None,
        referenceid: Optional[str] = None,
        requesthash: Optional[str] = None,
        userid: Optional[int] = None
    ) -> Dict[str, Any]:
        """
        Create Bulk Account
        
        Generated from: POST /virtualAccountManagement/bulkAccount
        Source: swagger_2_0
        Operation ID: VABT0063OnhldBulkAcnt_POSTUsingPOST
        
        
        Authentication: Not required
        
        Parameters:
        - request_body: any (required)
          input
        
        
        
        Headers:
        - Accesstoken: string
          Authorization token for identification of the caller
        - ChannelType: integer
          Channel identifier from where the TXN has originated (Internet, Mobile, ATM, Branch Channel )
        - Co-Relationid: integer
          Unique ID for the service invoked, will be set by the TXN system
        - InitiatingSystem: string
          Indicating the initiated system
        - ServiceMode: integer
          Used for branch channel to indicate the type of customer
        - UUIDSeqNo: integer
          UUID Sequence Number
        - entity: string
          entity
        - languageCode: integer
          languageCode
        - referenceId: string
          Place holder for Token based authentication
        - requesthash: string
          Request payload for hash validation
        - userId: integer
          userId
        
        
        """
        
        
        # Prepare request data
        
        # Single body parameter - send directly
        data = request_body if request_body is not None else {}
        
        
        
        # Prepare query parameters
        params = {}
        
        
        # Replace path parameters in URL
        path = "/virtualAccountManagement/bulkAccount"
        
        
        # Prepare headers
        headers = {}
        if accesstoken is not None:
            headers["Accesstoken"] = str(accesstoken)
        if channeltype is not None:
            headers["ChannelType"] = str(channeltype)
        if co_relationid is not None:
            headers["Co-Relationid"] = str(co_relationid)
        if initiatingsystem is not None:
            headers["InitiatingSystem"] = str(initiatingsystem)
        if servicemode is not None:
            headers["ServiceMode"] = str(servicemode)
        if uuidseqno is not None:
            headers["UUIDSeqNo"] = str(uuidseqno)
        if entity is not None:
            headers["entity"] = str(entity)
        if languagecode is not None:
            headers["languageCode"] = str(languagecode)
        if referenceid is not None:
            headers["referenceId"] = str(referenceid)
        if requesthash is not None:
            headers["requesthash"] = str(requesthash)
        if userid is not None:
            headers["userId"] = str(userid)
        
        
        return await make_api_request(
            "POST", 
            path, 
            data=data, 
            params=params if params else None, 
            headers=headers if headers else None
        )
    
    
    
    @mcp.tool()
    async def vabt0067_auth_bulk_acnt_postusing_post(
        requestreference: int,
        request_body:Dict[str, Any] ,  # authorizeBulkAccountResource,
        accesstoken: Optional[str] = None,
        channeltype: Optional[int] = None,
        co_relationid: Optional[int] = None,
        initiatingsystem: Optional[str] = None,
        servicemode: Optional[int] = None,
        uuidseqno: Optional[int] = None,
        entity: Optional[str] = None,
        languagecode: Optional[int] = None,
        referenceid: Optional[str] = None,
        requesthash: Optional[str] = None,
        userid: Optional[int] = None
    ) -> Dict[str, Any]:
        """
        Authorize Bulk Account
        
        Generated from: POST /virtualAccountManagement/bulkAccount/authorize/{requestReference}
        Source: swagger_2_0
        Operation ID: VABT0067AuthBulkAcnt_POSTUsingPOST
        
        
        Authentication: Not required
        
        Parameters:
        - requestReference: integer (required)
          Unique Identification reference for each Bulk account creation Request
        - request_body: any (required)
          input
        
        
        
        Headers:
        - Accesstoken: string
          Authorization token for identification of the caller
        - ChannelType: integer
          Channel identifier from where the TXN has originated (Internet, Mobile, ATM, Branch Channel )
        - Co-Relationid: integer
          Unique ID for the service invoked, will be set by the TXN system
        - InitiatingSystem: string
          Indicating the initiated system
        - ServiceMode: integer
          Used for branch channel to indicate the type of customer
        - UUIDSeqNo: integer
          UUID Sequence Number
        - entity: string
          entity
        - languageCode: integer
          languageCode
        - referenceId: string
          Place holder for Token based authentication
        - requesthash: string
          Request payload for hash validation
        - userId: integer
          userId
        
        
        """
        
        
        # Prepare request data
        
        # Single body parameter - send directly
        data = request_body if request_body is not None else {}
        
        
        
        # Prepare query parameters
        params = {}
        
        
        # Replace path parameters in URL
        path = "/virtualAccountManagement/bulkAccount/authorize/{requestReference}"
        if requestreference is not None:
            path = path.replace("{requestReference}", str(requestreference))
        
        
        # Prepare headers
        headers = {}
        if accesstoken is not None:
            headers["Accesstoken"] = str(accesstoken)
        if channeltype is not None:
            headers["ChannelType"] = str(channeltype)
        if co_relationid is not None:
            headers["Co-Relationid"] = str(co_relationid)
        if initiatingsystem is not None:
            headers["InitiatingSystem"] = str(initiatingsystem)
        if servicemode is not None:
            headers["ServiceMode"] = str(servicemode)
        if uuidseqno is not None:
            headers["UUIDSeqNo"] = str(uuidseqno)
        if entity is not None:
            headers["entity"] = str(entity)
        if languagecode is not None:
            headers["languageCode"] = str(languagecode)
        if referenceid is not None:
            headers["referenceId"] = str(referenceid)
        if requesthash is not None:
            headers["requesthash"] = str(requesthash)
        if userid is not None:
            headers["userId"] = str(userid)
        
        
        return await make_api_request(
            "POST", 
            path, 
            data=data, 
            params=params if params else None, 
            headers=headers if headers else None
        )
    
    
    
    @mcp.tool()
    async def vabt0065_cncl_bulk_acnt_postusing_delete(
        corporateschemecode: str,
        requestreference: int,
        requesteddate: str,
        accesstoken: Optional[str] = None,
        channeltype: Optional[int] = None,
        co_relationid: Optional[int] = None,
        initiatingsystem: Optional[str] = None,
        servicemode: Optional[int] = None,
        uuidseqno: Optional[int] = None,
        entity: Optional[str] = None,
        languagecode: Optional[int] = None,
        referenceid: Optional[str] = None,
        requesthash: Optional[str] = None,
        userid: Optional[int] = None
    ) -> Dict[str, Any]:
        """
        Delete Bulk Account
        
        Generated from: DELETE /virtualAccountManagement/bulkAccount/cancel/{requestReference}/{corporateSchemeCode}/{requestedDate}
        Source: swagger_2_0
        Operation ID: VABT0065CnclBulkAcnt_POSTUsingDELETE
        
        
        Authentication: Not required
        
        Parameters:
        - corporateSchemeCode: string (required)
          Unique reference for each Customer Scheme Registration
        - requestReference: integer (required)
          Unique Identification reference for each Bulk account creation Request
        - requestedDate: string (required)
          Date on which Bulk account creation Request  is initiated(Format : YYYYMMDD)
        
        
        
        Headers:
        - Accesstoken: string
          Authorization token for identification of the caller
        - ChannelType: integer
          Channel identifier from where the TXN has originated (Internet, Mobile, ATM, Branch Channel )
        - Co-Relationid: integer
          Unique ID for the service invoked, will be set by the TXN system
        - InitiatingSystem: string
          Indicating the initiated system
        - ServiceMode: integer
          Used for branch channel to indicate the type of customer
        - UUIDSeqNo: integer
          UUID Sequence Number
        - entity: string
          entity
        - languageCode: integer
          languageCode
        - referenceId: string
          Place holder for Token based authentication
        - requesthash: string
          Request payload for hash validation
        - userId: integer
          userId
        
        
        """
        
        
        # Prepare query parameters
        params = {}
        
        
        # Replace path parameters in URL
        path = "/virtualAccountManagement/bulkAccount/cancel/{requestReference}/{corporateSchemeCode}/{requestedDate}"
        if corporateschemecode is not None:
            path = path.replace("{corporateSchemeCode}", str(corporateschemecode))
        if requestreference is not None:
            path = path.replace("{requestReference}", str(requestreference))
        if requesteddate is not None:
            path = path.replace("{requestedDate}", str(requesteddate))
        
        
        # Prepare headers
        headers = {}
        if accesstoken is not None:
            headers["Accesstoken"] = str(accesstoken)
        if channeltype is not None:
            headers["ChannelType"] = str(channeltype)
        if co_relationid is not None:
            headers["Co-Relationid"] = str(co_relationid)
        if initiatingsystem is not None:
            headers["InitiatingSystem"] = str(initiatingsystem)
        if servicemode is not None:
            headers["ServiceMode"] = str(servicemode)
        if uuidseqno is not None:
            headers["UUIDSeqNo"] = str(uuidseqno)
        if entity is not None:
            headers["entity"] = str(entity)
        if languagecode is not None:
            headers["languageCode"] = str(languagecode)
        if referenceid is not None:
            headers["referenceId"] = str(referenceid)
        if requesthash is not None:
            headers["requesthash"] = str(requesthash)
        if userid is not None:
            headers["userId"] = str(userid)
        
        
        return await make_api_request(
            "DELETE", 
            path, 
            
            params=params if params else None, 
            headers=headers if headers else None
        )
    
    
    
    @mcp.tool()
    async def vaet0069_get_bulk_acnt_using_get(
        requestreference: int,
        corporateschemecode: str,
        requesteddate: str,
        channeltype: Optional[int] = None,
        co_relationid: Optional[int] = None,
        initiatingsystem: Optional[str] = None,
        servicemode: Optional[int] = None,
        uuidseqno: Optional[int] = None,
        authorization: Optional[str] = None,
        entity: Optional[str] = None,
        languagecode: Optional[int] = None,
        referenceid: Optional[str] = None,
        userid: Optional[int] = None
    ) -> Dict[str, Any]:
        """
        View Bulk Account
        
        Generated from: GET /virtualAccountManagement/bulkAccount/details/{requestReference}
        Source: swagger_2_0
        Operation ID: VAET0069GetBulkAcntUsingGET
        
        
        Authentication: Not required
        
        Parameters:
        - corporateSchemeCode: string (required)
          Unique reference for each Customer Scheme Registration
        - requestReference: integer (required)
          Reference generated by the system for the request provided.
        - requestedDate: string (required)
          Unique reference to identify the customer
        
        
        
        Headers:
        - ChannelType: integer
          Channel identifier from where the TXN has originated (Internet, Mobile, ATM, Branch Channel )
        - Co-Relationid: integer
          Unique ID for the service invoked, will be set by the TXN system
        - InitiatingSystem: string
          Indicating the initiated system
        - ServiceMode: integer
          Used for branch channel to indicate the type of customer
        - UUIDSeqNo: integer
          UUID Sequence Number
        - authorization: string
          Authorization Token to validation the caller
        - entity: string
          entity
        - languageCode: integer
          languageCode
        - referenceId: string
          Identified reference field for authorization
        - userId: integer
          userId
        
        
        """
        
        
        # Prepare query parameters
        params = {}
        if corporateschemecode is not None:
            params["corporateSchemeCode"] = corporateschemecode
            
        if requesteddate is not None:
            params["requestedDate"] = requesteddate
            
        
        
        # Replace path parameters in URL
        path = "/virtualAccountManagement/bulkAccount/details/{requestReference}"
        if requestreference is not None:
            path = path.replace("{requestReference}", str(requestreference))
        
        
        # Prepare headers
        headers = {}
        if channeltype is not None:
            headers["ChannelType"] = str(channeltype)
        if co_relationid is not None:
            headers["Co-Relationid"] = str(co_relationid)
        if initiatingsystem is not None:
            headers["InitiatingSystem"] = str(initiatingsystem)
        if servicemode is not None:
            headers["ServiceMode"] = str(servicemode)
        if uuidseqno is not None:
            headers["UUIDSeqNo"] = str(uuidseqno)
        if authorization is not None:
            headers["authorization"] = str(authorization)
        if entity is not None:
            headers["entity"] = str(entity)
        if languagecode is not None:
            headers["languageCode"] = str(languagecode)
        if referenceid is not None:
            headers["referenceId"] = str(referenceid)
        if userid is not None:
            headers["userId"] = str(userid)
        
        
        return await make_api_request(
            "GET", 
            path, 
            
            params=params if params else None, 
            headers=headers if headers else None
        )
    
    
    
    @mcp.tool()
    async def vaet0068_ftch_bulk_acnt_postusing_get(
        corporateschemecode: Optional[str] = None,
        customerreference: Optional[str] = None,
        pagenum: Optional[int] = None,
        pagesize: Optional[int] = None,
        requestreference: Optional[int] = None,
        requesteddate: Optional[str] = None,
        status: Optional[int] = None,
        accesstoken: Optional[str] = None,
        channeltype: Optional[int] = None,
        co_relationid: Optional[int] = None,
        initiatingsystem: Optional[str] = None,
        servicemode: Optional[int] = None,
        uuidseqno: Optional[int] = None,
        entity: Optional[str] = None,
        languagecode: Optional[int] = None,
        referenceid: Optional[str] = None,
        userid: Optional[int] = None
    ) -> Dict[str, Any]:
        """
        Fetch Bulk Account Request List
        
        Generated from: GET /virtualAccountManagement/bulkAccount/list
        Source: swagger_2_0
        Operation ID: VAET0068FtchBulkAcnt_POSTUsingGET
        
        
        Authentication: Not required
        
        Parameters:
        - corporateSchemeCode: string
          Unique reference for each Customer Scheme Registration
        - customerReference: string
          Business Partner Reference or equivalent identifier uniquely assigned to the customer
        - pageNum: integer
          pageNum
        - pageSize: integer
          pageSize
        - requestReference: integer
          Unique Identification reference for each Bulk account creation Request
        - requestedDate: string
          Date on which Bulk account creation Request  is initiated(Format : YYYYMMDD)
        - status: integer
          Status of Bulk account creation Request
        
        
        
        Headers:
        - Accesstoken: string
          Authorization token for identification of the caller
        - ChannelType: integer
          Channel identifier from where the TXN has originated (Internet, Mobile, ATM, Branch Channel )
        - Co-Relationid: integer
          Unique ID for the service invoked, will be set by the TXN system
        - InitiatingSystem: string
          Indicating the initiated system
        - ServiceMode: integer
          Used for branch channel to indicate the type of customer
        - UUIDSeqNo: integer
          UUID Sequence Number
        - entity: string
          entity
        - languageCode: integer
          languageCode
        - referenceId: string
          Place holder for Token based authentication
        - userId: integer
          userId
        
        
        """
        
        
        # Prepare query parameters
        params = {}
        if corporateschemecode is not None:
            params["corporateSchemeCode"] = corporateschemecode
            
        if customerreference is not None:
            params["customerReference"] = customerreference
            
        if pagenum is not None:
            params["pageNum"] = pagenum
            
        if pagesize is not None:
            params["pageSize"] = pagesize
            
        if requestreference is not None:
            params["requestReference"] = requestreference
            
        if requesteddate is not None:
            params["requestedDate"] = requesteddate
            
        if status is not None:
            params["status"] = status
            
        
        
        # Replace path parameters in URL
        path = "/virtualAccountManagement/bulkAccount/list"
        
        
        # Prepare headers
        headers = {}
        if accesstoken is not None:
            headers["Accesstoken"] = str(accesstoken)
        if channeltype is not None:
            headers["ChannelType"] = str(channeltype)
        if co_relationid is not None:
            headers["Co-Relationid"] = str(co_relationid)
        if initiatingsystem is not None:
            headers["InitiatingSystem"] = str(initiatingsystem)
        if servicemode is not None:
            headers["ServiceMode"] = str(servicemode)
        if uuidseqno is not None:
            headers["UUIDSeqNo"] = str(uuidseqno)
        if entity is not None:
            headers["entity"] = str(entity)
        if languagecode is not None:
            headers["languageCode"] = str(languagecode)
        if referenceid is not None:
            headers["referenceId"] = str(referenceid)
        if userid is not None:
            headers["userId"] = str(userid)
        
        
        return await make_api_request(
            "GET", 
            path, 
            
            params=params if params else None, 
            headers=headers if headers else None
        )
    
    
    
    @mcp.tool()
    async def vabt0077_rej_bulk_acnt_postusing_post(
        requestreference: int,
        request_body:Dict[str, Any] ,  # rejectBulkAccountResource,
        accesstoken: Optional[str] = None,
        channeltype: Optional[int] = None,
        co_relationid: Optional[int] = None,
        initiatingsystem: Optional[str] = None,
        servicemode: Optional[int] = None,
        uuidseqno: Optional[int] = None,
        entity: Optional[str] = None,
        languagecode: Optional[int] = None,
        referenceid: Optional[str] = None,
        requesthash: Optional[str] = None,
        userid: Optional[int] = None
    ) -> Dict[str, Any]:
        """
        Reject Bulk Account
        
        Generated from: POST /virtualAccountManagement/bulkAccount/reject/{requestReference}
        Source: swagger_2_0
        Operation ID: VABT0077RejBulkAcnt_POSTUsingPOST
        
        
        Authentication: Not required
        
        Parameters:
        - requestReference: integer (required)
          Unique Identification reference for each Bulk account creation Request
        - request_body: any (required)
          input
        
        
        
        Headers:
        - Accesstoken: string
          Authorization token for identification of the caller
        - ChannelType: integer
          Channel identifier from where the TXN has originated (Internet, Mobile, ATM, Branch Channel )
        - Co-Relationid: integer
          Unique ID for the service invoked, will be set by the TXN system
        - InitiatingSystem: string
          Indicating the initiated system
        - ServiceMode: integer
          Used for branch channel to indicate the type of customer
        - UUIDSeqNo: integer
          UUID Sequence Number
        - entity: string
          entity
        - languageCode: integer
          languageCode
        - referenceId: string
          Place holder for Token based authentication
        - requesthash: string
          Request payload for hash validation
        - userId: integer
          userId
        
        
        """
        
        
        # Prepare request data
        
        # Single body parameter - send directly
        data = request_body if request_body is not None else {}
        
        
        
        # Prepare query parameters
        params = {}
        
        
        # Replace path parameters in URL
        path = "/virtualAccountManagement/bulkAccount/reject/{requestReference}"
        if requestreference is not None:
            path = path.replace("{requestReference}", str(requestreference))
        
        
        # Prepare headers
        headers = {}
        if accesstoken is not None:
            headers["Accesstoken"] = str(accesstoken)
        if channeltype is not None:
            headers["ChannelType"] = str(channeltype)
        if co_relationid is not None:
            headers["Co-Relationid"] = str(co_relationid)
        if initiatingsystem is not None:
            headers["InitiatingSystem"] = str(initiatingsystem)
        if servicemode is not None:
            headers["ServiceMode"] = str(servicemode)
        if uuidseqno is not None:
            headers["UUIDSeqNo"] = str(uuidseqno)
        if entity is not None:
            headers["entity"] = str(entity)
        if languagecode is not None:
            headers["languageCode"] = str(languagecode)
        if referenceid is not None:
            headers["referenceId"] = str(referenceid)
        if requesthash is not None:
            headers["requesthash"] = str(requesthash)
        if userid is not None:
            headers["userId"] = str(userid)
        
        
        return await make_api_request(
            "POST", 
            path, 
            data=data, 
            params=params if params else None, 
            headers=headers if headers else None
        )
    
    
    
    @mcp.tool()
    async def vabt0064_rls_bulk_acnt_postusing_post(
        request_body:Dict[str, Any] ,  # releaseBulkAccountResource,
        accesstoken: Optional[str] = None,
        channeltype: Optional[int] = None,
        co_relationid: Optional[int] = None,
        initiatingsystem: Optional[str] = None,
        servicemode: Optional[int] = None,
        uuidseqno: Optional[int] = None,
        entity: Optional[str] = None,
        languagecode: Optional[int] = None,
        referenceid: Optional[str] = None,
        requesthash: Optional[str] = None,
        userid: Optional[int] = None
    ) -> Dict[str, Any]:
        """
        Release Bulk Account
        
        Generated from: POST /virtualAccountManagement/bulkAccount/release
        Source: swagger_2_0
        Operation ID: VABT0064RlsBulkAcnt_POSTUsingPOST
        
        
        Authentication: Not required
        
        Parameters:
        - request_body: any (required)
          input
        
        
        
        Headers:
        - Accesstoken: string
          Authorization token for identification of the caller
        - ChannelType: integer
          Channel identifier from where the TXN has originated (Internet, Mobile, ATM, Branch Channel )
        - Co-Relationid: integer
          Unique ID for the service invoked, will be set by the TXN system
        - InitiatingSystem: string
          Indicating the initiated system
        - ServiceMode: integer
          Used for branch channel to indicate the type of customer
        - UUIDSeqNo: integer
          UUID Sequence Number
        - entity: string
          entity
        - languageCode: integer
          languageCode
        - referenceId: string
          Place holder for Token based authentication
        - requesthash: string
          Request payload for hash validation
        - userId: integer
          userId
        
        
        """
        
        
        # Prepare request data
        
        # Single body parameter - send directly
        data = request_body if request_body is not None else {}
        
        
        
        # Prepare query parameters
        params = {}
        
        
        # Replace path parameters in URL
        path = "/virtualAccountManagement/bulkAccount/release"
        
        
        # Prepare headers
        headers = {}
        if accesstoken is not None:
            headers["Accesstoken"] = str(accesstoken)
        if channeltype is not None:
            headers["ChannelType"] = str(channeltype)
        if co_relationid is not None:
            headers["Co-Relationid"] = str(co_relationid)
        if initiatingsystem is not None:
            headers["InitiatingSystem"] = str(initiatingsystem)
        if servicemode is not None:
            headers["ServiceMode"] = str(servicemode)
        if uuidseqno is not None:
            headers["UUIDSeqNo"] = str(uuidseqno)
        if entity is not None:
            headers["entity"] = str(entity)
        if languagecode is not None:
            headers["languageCode"] = str(languagecode)
        if referenceid is not None:
            headers["referenceId"] = str(referenceid)
        if requesthash is not None:
            headers["requesthash"] = str(requesthash)
        if userid is not None:
            headers["userId"] = str(userid)
        
        
        return await make_api_request(
            "POST", 
            path, 
            data=data, 
            params=params if params else None, 
            headers=headers if headers else None
        )
    
    
    
    @mcp.tool()
    async def vabt0066_sndbck_bulk_acnt_postusing_post(
        requestreference: int,
        request_body:Dict[str, Any] ,  # sendBackBulkAccountResource,
        accesstoken: Optional[str] = None,
        channeltype: Optional[int] = None,
        co_relationid: Optional[int] = None,
        initiatingsystem: Optional[str] = None,
        servicemode: Optional[int] = None,
        uuidseqno: Optional[int] = None,
        entity: Optional[str] = None,
        languagecode: Optional[int] = None,
        referenceid: Optional[str] = None,
        requesthash: Optional[str] = None,
        userid: Optional[int] = None
    ) -> Dict[str, Any]:
        """
        Sendback Bulk Account
        
        Generated from: POST /virtualAccountManagement/bulkAccount/sendback/{requestReference}
        Source: swagger_2_0
        Operation ID: VABT0066SndbckBulkAcnt_POSTUsingPOST
        
        
        Authentication: Not required
        
        Parameters:
        - requestReference: integer (required)
          Unique Identification reference for each Bulk account creation Request
        - request_body: any (required)
          input
        
        
        
        Headers:
        - Accesstoken: string
          Authorization token for identification of the caller
        - ChannelType: integer
          Channel identifier from where the TXN has originated (Internet, Mobile, ATM, Branch Channel )
        - Co-Relationid: integer
          Unique ID for the service invoked, will be set by the TXN system
        - InitiatingSystem: string
          Indicating the initiated system
        - ServiceMode: integer
          Used for branch channel to indicate the type of customer
        - UUIDSeqNo: integer
          UUID Sequence Number
        - entity: string
          entity
        - languageCode: integer
          languageCode
        - referenceId: string
          Place holder for Token based authentication
        - requesthash: string
          Request payload for hash validation
        - userId: integer
          userId
        
        
        """
        
        
        # Prepare request data
        
        # Single body parameter - send directly
        data = request_body if request_body is not None else {}
        
        
        
        # Prepare query parameters
        params = {}
        
        
        # Replace path parameters in URL
        path = "/virtualAccountManagement/bulkAccount/sendback/{requestReference}"
        if requestreference is not None:
            path = path.replace("{requestReference}", str(requestreference))
        
        
        # Prepare headers
        headers = {}
        if accesstoken is not None:
            headers["Accesstoken"] = str(accesstoken)
        if channeltype is not None:
            headers["ChannelType"] = str(channeltype)
        if co_relationid is not None:
            headers["Co-Relationid"] = str(co_relationid)
        if initiatingsystem is not None:
            headers["InitiatingSystem"] = str(initiatingsystem)
        if servicemode is not None:
            headers["ServiceMode"] = str(servicemode)
        if uuidseqno is not None:
            headers["UUIDSeqNo"] = str(uuidseqno)
        if entity is not None:
            headers["entity"] = str(entity)
        if languagecode is not None:
            headers["languageCode"] = str(languagecode)
        if referenceid is not None:
            headers["referenceId"] = str(referenceid)
        if requesthash is not None:
            headers["requesthash"] = str(requesthash)
        if userid is not None:
            headers["userId"] = str(userid)
        
        
        return await make_api_request(
            "POST", 
            path, 
            data=data, 
            params=params if params else None, 
            headers=headers if headers else None
        )
    
    
    
    @mcp.tool()
    async def vabt0077_bulk_vrt_acnt_multi_crtn_postusing_post(
        request_body:Dict[str, Any] ,  # bulkVirtualAccountMultiCreationResource,
        accesstoken: Optional[str] = None,
        channeltype: Optional[int] = None,
        co_relationid: Optional[int] = None,
        initiatingsystem: Optional[str] = None,
        servicemode: Optional[int] = None,
        uuidseqno: Optional[int] = None,
        entity: Optional[str] = None,
        languagecode: Optional[int] = None,
        referenceid: Optional[str] = None,
        requesthash: Optional[str] = None,
        userid: Optional[int] = None
    ) -> Dict[str, Any]:
        """
        Bulk Virtual Account Multi Creation
        
        Generated from: POST /virtualAccountManagement/bulkAccount/unitary
        Source: swagger_2_0
        Operation ID: VABT0077BulkVrtAcntMultiCrtn_POSTUsingPOST
        
        
        Authentication: Not required
        
        Parameters:
        - request_body: any (required)
          input
        
        
        
        Headers:
        - Accesstoken: string
          Authorization token for identification of the caller
        - ChannelType: integer
          Channel identifier from where the TXN has originated (Internet, Mobile, ATM, Branch Channel )
        - Co-Relationid: integer
          Unique ID for the service invoked, will be set by the TXN system
        - InitiatingSystem: string
          Indicating the initiated system
        - ServiceMode: integer
          Used for branch channel to indicate the type of customer
        - UUIDSeqNo: integer
          UUID Sequence Number
        - entity: string
          entity
        - languageCode: integer
          languageCode
        - referenceId: string
          Place holder for Token based authentication
        - requesthash: string
          Request payload for hash validation
        - userId: integer
          userId
        
        
        """
        
        
        # Prepare request data
        
        # Single body parameter - send directly
        data = request_body if request_body is not None else {}
        
        
        
        # Prepare query parameters
        params = {}
        
        
        # Replace path parameters in URL
        path = "/virtualAccountManagement/bulkAccount/unitary"
        
        
        # Prepare headers
        headers = {}
        if accesstoken is not None:
            headers["Accesstoken"] = str(accesstoken)
        if channeltype is not None:
            headers["ChannelType"] = str(channeltype)
        if co_relationid is not None:
            headers["Co-Relationid"] = str(co_relationid)
        if initiatingsystem is not None:
            headers["InitiatingSystem"] = str(initiatingsystem)
        if servicemode is not None:
            headers["ServiceMode"] = str(servicemode)
        if uuidseqno is not None:
            headers["UUIDSeqNo"] = str(uuidseqno)
        if entity is not None:
            headers["entity"] = str(entity)
        if languagecode is not None:
            headers["languageCode"] = str(languagecode)
        if referenceid is not None:
            headers["referenceId"] = str(referenceid)
        if requesthash is not None:
            headers["requesthash"] = str(requesthash)
        if userid is not None:
            headers["userId"] = str(userid)
        
        
        return await make_api_request(
            "POST", 
            path, 
            data=data, 
            params=params if params else None, 
            headers=headers if headers else None
        )
    
    
    
    @mcp.tool()
    async def vabt0001_register_customer_using_post(
        request_body:Dict[str, Any] ,  # registerCustomerResource,
        channeltype: Optional[int] = None,
        co_relationid: Optional[int] = None,
        initiatingsystem: Optional[str] = None,
        servicemode: Optional[int] = None,
        uuidseqno: Optional[int] = None,
        authorization: Optional[str] = None,
        entity: Optional[str] = None,
        referenceid: Optional[str] = None,
        requesthash: Optional[str] = None,
        userid: Optional[int] = None
    ) -> Dict[str, Any]:
        """
        This Service will register a Corporate Customer for a unique Corporate Scheme Code.
        
        Generated from: POST /virtualAccountManagement/customer
        Source: swagger_2_0
        Operation ID: VABT0001RegisterCustomerUsingPOST
        
        
        Authentication: Not required
        
        Parameters:
        - request_body: any (required)
          input
        
        
        
        Headers:
        - ChannelType: integer
          Channel identifier from where the TXN has originated (Internet, Mobile, ATM, Branch Channel )
        - Co-Relationid: integer
          Unique ID for the service invoked, will be set by the TXN system
        - InitiatingSystem: string
          Indicating the initiated system
        - ServiceMode: integer
          Used for branch channel to indicate the type of customer
        - UUIDSeqNo: integer
          UUID Sequence Number
        - authorization: string
          Authorization Token to validation the caller
        - entity: string
          entity
        - referenceId: string
          Identified reference field for authorization
        - requesthash: string
          Request payload for hash validation
        - userId: integer
          userId
        
        
        """
        
        
        # Prepare request data
        
        # Single body parameter - send directly
        data = request_body if request_body is not None else {}
        
        
        
        # Prepare query parameters
        params = {}
        
        
        # Replace path parameters in URL
        path = "/virtualAccountManagement/customer"
        
        
        # Prepare headers
        headers = {}
        if channeltype is not None:
            headers["ChannelType"] = str(channeltype)
        if co_relationid is not None:
            headers["Co-Relationid"] = str(co_relationid)
        if initiatingsystem is not None:
            headers["InitiatingSystem"] = str(initiatingsystem)
        if servicemode is not None:
            headers["ServiceMode"] = str(servicemode)
        if uuidseqno is not None:
            headers["UUIDSeqNo"] = str(uuidseqno)
        if authorization is not None:
            headers["authorization"] = str(authorization)
        if entity is not None:
            headers["entity"] = str(entity)
        if referenceid is not None:
            headers["referenceId"] = str(referenceid)
        if requesthash is not None:
            headers["requesthash"] = str(requesthash)
        if userid is not None:
            headers["userId"] = str(userid)
        
        
        return await make_api_request(
            "POST", 
            path, 
            data=data, 
            params=params if params else None, 
            headers=headers if headers else None
        )
    
    
    
    @mcp.tool()
    async def cbcet1003_fetch_account_list_qbeusing_get(
        accountcurrency: Optional[str] = None,
        accountreference1: Optional[str] = None,
        accounttype: Optional[str] = None,
        bban: Optional[str] = None,
        customerid: Optional[str] = None,
        entityid: Optional[str] = None,
        iban: Optional[str] = None,
        pagenum: Optional[int] = None,
        pagesize: Optional[int] = None,
        status: Optional[str] = None,
        accesstoken: Optional[str] = None,
        channeltype: Optional[int] = None,
        co_relationid: Optional[int] = None,
        initiatingsystem: Optional[str] = None,
        servicemode: Optional[int] = None,
        uuidseqno: Optional[int] = None,
        entity: Optional[str] = None,
        referenceid: Optional[str] = None,
        requesthash: Optional[str] = None,
        userid: Optional[int] = None
    ) -> Dict[str, Any]:
        """
        This Service is used to Fetch Account List
        
        Generated from: GET /virtualAccountManagement/customer/accounts/list
        Source: swagger_2_0
        Operation ID: CBCET1003FetchAccountListQBEUsingGET
        
        
        Authentication: Not required
        
        Parameters:
        - accountCurrency: string
          Currency of Account which is used in Account List for Search
        - accountReference1: string
          This Field denotes the External Reference of the Account
        - accountType: string
          This Field denotes the Account Type of the Account which is used in Account List for Search
        - bban: string
          This Field denote the BBAN Sequence Number of Account
        - customerId: string
          Unique Reference for the Customer which exists in Core System
        - entityId: string
          Operation Unit Reference in Which numbering schema is getting issued/delivered
        - iban: string
          This Field denotes the IBAN Number of the Account
        - pageNum: integer
          pageNum
        - pageSize: integer
          pageSize
        - status: string
          This Field denotes the Account Status which is used in Account List for Search
        
        
        
        Headers:
        - Accesstoken: string
          Authorization Token to validation the caller
        - ChannelType: integer
          Channel identifier from where the TXN has originated (Internet, Mobile, ATM, Branch Channel )
        - Co-Relationid: integer
          Unique ID for the service invoked, will be set by the TXN system
        - InitiatingSystem: string
          Indicating the initiated system
        - ServiceMode: integer
          Used for branch channel to indicate the type of customer
        - UUIDSeqNo: integer
          UUID Sequence Number
        - entity: string
          entity
        - referenceId: string
          Place holder for Token based authentication
        - requesthash: string
          Request payload for hash validation
        - userId: integer
          userId
        
        
        """
        
        
        # Prepare query parameters
        params = {}
        if accountcurrency is not None:
            params["accountCurrency"] = accountcurrency
            
        if accountreference1 is not None:
            params["accountReference1"] = accountreference1
            
        if accounttype is not None:
            params["accountType"] = accounttype
            
        if bban is not None:
            params["bban"] = bban
            
        if customerid is not None:
            params["customerId"] = customerid
            
        if entityid is not None:
            params["entityId"] = entityid
            
        if iban is not None:
            params["iban"] = iban
            
        if pagenum is not None:
            params["pageNum"] = pagenum
            
        if pagesize is not None:
            params["pageSize"] = pagesize
            
        if status is not None:
            params["status"] = status
            
        
        
        # Replace path parameters in URL
        path = "/virtualAccountManagement/customer/accounts/list"
        
        
        # Prepare headers
        headers = {}
        if accesstoken is not None:
            headers["Accesstoken"] = str(accesstoken)
        if channeltype is not None:
            headers["ChannelType"] = str(channeltype)
        if co_relationid is not None:
            headers["Co-Relationid"] = str(co_relationid)
        if initiatingsystem is not None:
            headers["InitiatingSystem"] = str(initiatingsystem)
        if servicemode is not None:
            headers["ServiceMode"] = str(servicemode)
        if uuidseqno is not None:
            headers["UUIDSeqNo"] = str(uuidseqno)
        if entity is not None:
            headers["entity"] = str(entity)
        if referenceid is not None:
            headers["referenceId"] = str(referenceid)
        if requesthash is not None:
            headers["requesthash"] = str(requesthash)
        if userid is not None:
            headers["userId"] = str(userid)
        
        
        return await make_api_request(
            "GET", 
            path, 
            
            params=params if params else None, 
            headers=headers if headers else None
        )
    
    
    
    @mcp.tool()
    async def vabt0079_create_contact_dtls_postusing_post(
        request_body:Dict[str, Any] ,  # createContactDetailResource,
        accesstoken: Optional[str] = None,
        channeltype: Optional[int] = None,
        co_relationid: Optional[int] = None,
        initiatingsystem: Optional[str] = None,
        servicemode: Optional[int] = None,
        uuidseqno: Optional[int] = None,
        entity: Optional[str] = None,
        languagecode: Optional[int] = None,
        referenceid: Optional[str] = None,
        requesthash: Optional[str] = None,
        userid: Optional[int] = None
    ) -> Dict[str, Any]:
        """
        This API creates Contact Details
        
        Generated from: POST /virtualAccountManagement/customer/contactDetails
        Source: swagger_2_0
        Operation ID: VABT0079CreateContactDtls_POSTUsingPOST
        
        
        Authentication: Not required
        
        Parameters:
        - request_body: any (required)
          input
        
        
        
        Headers:
        - Accesstoken: string
          Authorization token for identification of the caller
        - ChannelType: integer
          Channel identifier from where the TXN has originated (Internet, Mobile, ATM, Branch Channel )
        - Co-Relationid: integer
          Unique ID for the service invoked, will be set by the TXN system
        - InitiatingSystem: string
          Indicating the initiated system
        - ServiceMode: integer
          Used for branch channel to indicate the type of customer
        - UUIDSeqNo: integer
          UUID Sequence Number
        - entity: string
          entity
        - languageCode: integer
          languageCode
        - referenceId: string
          Place holder for Token based authentication
        - requesthash: string
          Request payload for hash validation
        - userId: integer
          userId
        
        
        """
        
        
        # Prepare request data
        
        # Single body parameter - send directly
        data = request_body if request_body is not None else {}
        
        
        
        # Prepare query parameters
        params = {}
        
        
        # Replace path parameters in URL
        path = "/virtualAccountManagement/customer/contactDetails"
        
        
        # Prepare headers
        headers = {}
        if accesstoken is not None:
            headers["Accesstoken"] = str(accesstoken)
        if channeltype is not None:
            headers["ChannelType"] = str(channeltype)
        if co_relationid is not None:
            headers["Co-Relationid"] = str(co_relationid)
        if initiatingsystem is not None:
            headers["InitiatingSystem"] = str(initiatingsystem)
        if servicemode is not None:
            headers["ServiceMode"] = str(servicemode)
        if uuidseqno is not None:
            headers["UUIDSeqNo"] = str(uuidseqno)
        if entity is not None:
            headers["entity"] = str(entity)
        if languagecode is not None:
            headers["languageCode"] = str(languagecode)
        if referenceid is not None:
            headers["referenceId"] = str(referenceid)
        if requesthash is not None:
            headers["requesthash"] = str(requesthash)
        if userid is not None:
            headers["userId"] = str(userid)
        
        
        return await make_api_request(
            "POST", 
            path, 
            data=data, 
            params=params if params else None, 
            headers=headers if headers else None
        )
    
    
    
    @mcp.tool()
    async def vabt0081_delete_contact_dtls_postusing_delete(
        contactdetailsreference: int,
        schemeid: int,
        accesstoken: Optional[str] = None,
        channeltype: Optional[int] = None,
        co_relationid: Optional[int] = None,
        initiatingsystem: Optional[str] = None,
        servicemode: Optional[int] = None,
        uuidseqno: Optional[int] = None,
        entity: Optional[str] = None,
        languagecode: Optional[int] = None,
        referenceid: Optional[str] = None,
        requesthash: Optional[str] = None,
        userid: Optional[int] = None
    ) -> Dict[str, Any]:
        """
        This API will delete Contact details of Customer
        
        Generated from: DELETE /virtualAccountManagement/customer/contactDetails/delete/{schemeId}/{contactDetailsReference}
        Source: swagger_2_0
        Operation ID: VABT0081DeleteContactDtls_POSTUsingDELETE
        
        
        Authentication: Not required
        
        Parameters:
        - contactDetailsReference: integer (required)
          Unique Reference for each contact created
        - schemeId: integer (required)
          Reference for the Customer Registration which will be created for unique Scheme Code and Customer Combination
        
        
        
        Headers:
        - Accesstoken: string
          Authorization token for identification of the caller
        - ChannelType: integer
          Channel identifier from where the TXN has originated (Internet, Mobile, ATM, Branch Channel )
        - Co-Relationid: integer
          Unique ID for the service invoked, will be set by the TXN system
        - InitiatingSystem: string
          Indicating the initiated system
        - ServiceMode: integer
          Used for branch channel to indicate the type of customer
        - UUIDSeqNo: integer
          UUID Sequence Number
        - entity: string
          entity
        - languageCode: integer
          languageCode
        - referenceId: string
          Place holder for Token based authentication
        - requesthash: string
          Request payload for hash validation
        - userId: integer
          userId
        
        
        """
        
        
        # Prepare query parameters
        params = {}
        
        
        # Replace path parameters in URL
        path = "/virtualAccountManagement/customer/contactDetails/delete/{schemeId}/{contactDetailsReference}"
        if contactdetailsreference is not None:
            path = path.replace("{contactDetailsReference}", str(contactdetailsreference))
        if schemeid is not None:
            path = path.replace("{schemeId}", str(schemeid))
        
        
        # Prepare headers
        headers = {}
        if accesstoken is not None:
            headers["Accesstoken"] = str(accesstoken)
        if channeltype is not None:
            headers["ChannelType"] = str(channeltype)
        if co_relationid is not None:
            headers["Co-Relationid"] = str(co_relationid)
        if initiatingsystem is not None:
            headers["InitiatingSystem"] = str(initiatingsystem)
        if servicemode is not None:
            headers["ServiceMode"] = str(servicemode)
        if uuidseqno is not None:
            headers["UUIDSeqNo"] = str(uuidseqno)
        if entity is not None:
            headers["entity"] = str(entity)
        if languagecode is not None:
            headers["languageCode"] = str(languagecode)
        if referenceid is not None:
            headers["referenceId"] = str(referenceid)
        if requesthash is not None:
            headers["requesthash"] = str(requesthash)
        if userid is not None:
            headers["userId"] = str(userid)
        
        
        return await make_api_request(
            "DELETE", 
            path, 
            
            params=params if params else None, 
            headers=headers if headers else None
        )
    
    
    
    @mcp.tool()
    async def vaet0083_view_contact_dtls_postusing_get(
        contactdetailsreference: int,
        schemeid: int,
        accesstoken: Optional[str] = None,
        channeltype: Optional[int] = None,
        co_relationid: Optional[int] = None,
        initiatingsystem: Optional[str] = None,
        servicemode: Optional[int] = None,
        uuidseqno: Optional[int] = None,
        entity: Optional[str] = None,
        languagecode: Optional[int] = None,
        referenceid: Optional[str] = None,
        userid: Optional[int] = None
    ) -> Dict[str, Any]:
        """
        This API will get contact details of contact details
        
        Generated from: GET /virtualAccountManagement/customer/contactDetails/details/{schemeId}/{contactDetailsReference}
        Source: swagger_2_0
        Operation ID: VAET0083ViewContactDtls_POSTUsingGET
        
        
        Authentication: Not required
        
        Parameters:
        - contactDetailsReference: integer (required)
          Unique Reference for each contact created
        - schemeId: integer (required)
          Reference for the Customer Registration which will be created for unique Scheme Code and Customer Combination
        
        
        
        Headers:
        - Accesstoken: string
          Authorization token for identification of the caller
        - ChannelType: integer
          Channel identifier from where the TXN has originated (Internet, Mobile, ATM, Branch Channel )
        - Co-Relationid: integer
          Unique ID for the service invoked, will be set by the TXN system
        - InitiatingSystem: string
          Indicating the initiated system
        - ServiceMode: integer
          Used for branch channel to indicate the type of customer
        - UUIDSeqNo: integer
          UUID Sequence Number
        - entity: string
          entity
        - languageCode: integer
          languageCode
        - referenceId: string
          Place holder for Token based authentication
        - userId: integer
          userId
        
        
        """
        
        
        # Prepare query parameters
        params = {}
        
        
        # Replace path parameters in URL
        path = "/virtualAccountManagement/customer/contactDetails/details/{schemeId}/{contactDetailsReference}"
        if contactdetailsreference is not None:
            path = path.replace("{contactDetailsReference}", str(contactdetailsreference))
        if schemeid is not None:
            path = path.replace("{schemeId}", str(schemeid))
        
        
        # Prepare headers
        headers = {}
        if accesstoken is not None:
            headers["Accesstoken"] = str(accesstoken)
        if channeltype is not None:
            headers["ChannelType"] = str(channeltype)
        if co_relationid is not None:
            headers["Co-Relationid"] = str(co_relationid)
        if initiatingsystem is not None:
            headers["InitiatingSystem"] = str(initiatingsystem)
        if servicemode is not None:
            headers["ServiceMode"] = str(servicemode)
        if uuidseqno is not None:
            headers["UUIDSeqNo"] = str(uuidseqno)
        if entity is not None:
            headers["entity"] = str(entity)
        if languagecode is not None:
            headers["languageCode"] = str(languagecode)
        if referenceid is not None:
            headers["referenceId"] = str(referenceid)
        if userid is not None:
            headers["userId"] = str(userid)
        
        
        return await make_api_request(
            "GET", 
            path, 
            
            params=params if params else None, 
            headers=headers if headers else None
        )
    
    
    
    @mcp.tool()
    async def vaet0077_fetch_contact_dtls_getusing_get(
        schemeid: int,
        contactdetailsreference: Optional[int] = None,
        corporateschemecode: Optional[str] = None,
        pagenum: Optional[int] = None,
        pagesize: Optional[int] = None,
        accesstoken: Optional[str] = None,
        channeltype: Optional[int] = None,
        co_relationid: Optional[int] = None,
        initiatingsystem: Optional[str] = None,
        servicemode: Optional[int] = None,
        uuidseqno: Optional[int] = None,
        entity: Optional[str] = None,
        languagecode: Optional[int] = None,
        referenceid: Optional[str] = None,
        userid: Optional[int] = None
    ) -> Dict[str, Any]:
        """
        This API will fetch Contact Details
        
        Generated from: GET /virtualAccountManagement/customer/contactDetails/list/{schemeId}
        Source: swagger_2_0
        Operation ID: VAET0077FetchContactDtls_GETUsingGET
        
        
        Authentication: Not required
        
        Parameters:
        - contactDetailsReference: integer
          Unique Reference for each contact created
        - corporateSchemeCode: string
          Unique code reference for each Customer Scheme Registration
        - pageNum: integer
          pageNum
        - pageSize: integer
          pageSize
        - schemeId: integer (required)
          Reference for the Customer Registration which will be created for unique Scheme Code and Customer Combination
        
        
        
        Headers:
        - Accesstoken: string
          Authorization token for identification of the caller
        - ChannelType: integer
          Channel identifier from where the TXN has originated (Internet, Mobile, ATM, Branch Channel )
        - Co-Relationid: integer
          Unique ID for the service invoked, will be set by the TXN system
        - InitiatingSystem: string
          Indicating the initiated system
        - ServiceMode: integer
          Used for branch channel to indicate the type of customer
        - UUIDSeqNo: integer
          UUID Sequence Number
        - entity: string
          entity
        - languageCode: integer
          languageCode
        - referenceId: string
          Place holder for Token based authentication
        - userId: integer
          userId
        
        
        """
        
        
        # Prepare query parameters
        params = {}
        if contactdetailsreference is not None:
            params["contactDetailsReference"] = contactdetailsreference
            
        if corporateschemecode is not None:
            params["corporateSchemeCode"] = corporateschemecode
            
        if pagenum is not None:
            params["pageNum"] = pagenum
            
        if pagesize is not None:
            params["pageSize"] = pagesize
            
        
        
        # Replace path parameters in URL
        path = "/virtualAccountManagement/customer/contactDetails/list/{schemeId}"
        if schemeid is not None:
            path = path.replace("{schemeId}", str(schemeid))
        
        
        # Prepare headers
        headers = {}
        if accesstoken is not None:
            headers["Accesstoken"] = str(accesstoken)
        if channeltype is not None:
            headers["ChannelType"] = str(channeltype)
        if co_relationid is not None:
            headers["Co-Relationid"] = str(co_relationid)
        if initiatingsystem is not None:
            headers["InitiatingSystem"] = str(initiatingsystem)
        if servicemode is not None:
            headers["ServiceMode"] = str(servicemode)
        if uuidseqno is not None:
            headers["UUIDSeqNo"] = str(uuidseqno)
        if entity is not None:
            headers["entity"] = str(entity)
        if languagecode is not None:
            headers["languageCode"] = str(languagecode)
        if referenceid is not None:
            headers["referenceId"] = str(referenceid)
        if userid is not None:
            headers["userId"] = str(userid)
        
        
        return await make_api_request(
            "GET", 
            path, 
            
            params=params if params else None, 
            headers=headers if headers else None
        )
    
    
    
    @mcp.tool()
    async def vabt0080_modify_contact_dtls_postusing_put(
        schemeid: int,
        request_body:Dict[str, Any] ,  # modifyContactDetailResource,
        accesstoken: Optional[str] = None,
        channeltype: Optional[int] = None,
        co_relationid: Optional[int] = None,
        initiatingsystem: Optional[str] = None,
        servicemode: Optional[int] = None,
        uuidseqno: Optional[int] = None,
        entity: Optional[str] = None,
        languagecode: Optional[int] = None,
        referenceid: Optional[str] = None,
        requesthash: Optional[str] = None,
        userid: Optional[int] = None
    ) -> Dict[str, Any]:
        """
        This API will modify Contact Details
        
        Generated from: PUT /virtualAccountManagement/customer/contactDetails/update/{schemeId}
        Source: swagger_2_0
        Operation ID: VABT0080ModifyContactDtls_POSTUsingPUT
        
        
        Authentication: Not required
        
        Parameters:
        - schemeId: integer (required)
          Reference for the Customer Registration which will be created for unique Scheme Code and Customer Combination
        - request_body: any (required)
          input
        
        
        
        Headers:
        - Accesstoken: string
          Authorization token for identification of the caller
        - ChannelType: integer
          Channel identifier from where the TXN has originated (Internet, Mobile, ATM, Branch Channel )
        - Co-Relationid: integer
          Unique ID for the service invoked, will be set by the TXN system
        - InitiatingSystem: string
          Indicating the initiated system
        - ServiceMode: integer
          Used for branch channel to indicate the type of customer
        - UUIDSeqNo: integer
          UUID Sequence Number
        - entity: string
          entity
        - languageCode: integer
          languageCode
        - referenceId: string
          Place holder for Token based authentication
        - requesthash: string
          Request payload for hash validation
        - userId: integer
          userId
        
        
        """
        
        
        # Prepare request data
        
        # Single body parameter - send directly
        data = request_body if request_body is not None else {}
        
        
        
        # Prepare query parameters
        params = {}
        
        
        # Replace path parameters in URL
        path = "/virtualAccountManagement/customer/contactDetails/update/{schemeId}"
        if schemeid is not None:
            path = path.replace("{schemeId}", str(schemeid))
        
        
        # Prepare headers
        headers = {}
        if accesstoken is not None:
            headers["Accesstoken"] = str(accesstoken)
        if channeltype is not None:
            headers["ChannelType"] = str(channeltype)
        if co_relationid is not None:
            headers["Co-Relationid"] = str(co_relationid)
        if initiatingsystem is not None:
            headers["InitiatingSystem"] = str(initiatingsystem)
        if servicemode is not None:
            headers["ServiceMode"] = str(servicemode)
        if uuidseqno is not None:
            headers["UUIDSeqNo"] = str(uuidseqno)
        if entity is not None:
            headers["entity"] = str(entity)
        if languagecode is not None:
            headers["languageCode"] = str(languagecode)
        if referenceid is not None:
            headers["referenceId"] = str(referenceid)
        if requesthash is not None:
            headers["requesthash"] = str(requesthash)
        if userid is not None:
            headers["userId"] = str(userid)
        
        
        return await make_api_request(
            "PUT", 
            path, 
            data=data, 
            params=params if params else None, 
            headers=headers if headers else None
        )
    
    
    
    @mcp.tool()
    async def cbcet1000_validate_corporate_scheme_using_get(
        corporateschemecode: str,
        pagenum: Optional[int] = None,
        pagesize: Optional[int] = None,
        accesstoken: Optional[str] = None,
        channeltype: Optional[int] = None,
        co_relationid: Optional[int] = None,
        initiatingsystem: Optional[str] = None,
        servicemode: Optional[int] = None,
        uuidseqno: Optional[int] = None,
        entity: Optional[str] = None,
        referenceid: Optional[str] = None,
        requesthash: Optional[str] = None,
        userid: Optional[int] = None
    ) -> Dict[str, Any]:
        """
        This service will be used to validate corporate scheme code entered.
        
        Generated from: GET /virtualAccountManagement/customer/corporateSchemeCode/tabout
        Source: swagger_2_0
        Operation ID: CBCET1000ValidateCorporateSchemeUsingGET
        
        
        Authentication: Not required
        
        Parameters:
        - corporateSchemeCode: string (required)
          Corporate Scheme Code uniquely identifies a registration for Virtual Account Management Service.Each of the Customer Registration will be with unique Corporate Scheme Code
        - pageNum: integer
          pageNum
        - pageSize: integer
          pageSize
        
        
        
        Headers:
        - Accesstoken: string
          Authorization Token to validation the caller
        - ChannelType: integer
          Channel identifier from where the TXN has originated (Internet, Mobile, ATM, Branch Channel )
        - Co-Relationid: integer
          Unique ID for the service invoked, will be set by the TXN system
        - InitiatingSystem: string
          Indicating the initiated system
        - ServiceMode: integer
          Used for branch channel to indicate the type of customer
        - UUIDSeqNo: integer
          UUID Sequence Number
        - entity: string
          entity
        - referenceId: string
          Place holder for Token based authentication
        - requesthash: string
          Request payload for hash validation
        - userId: integer
          userId
        
        
        """
        
        
        # Prepare query parameters
        params = {}
        if corporateschemecode is not None:
            params["corporateSchemeCode"] = corporateschemecode
            
        if pagenum is not None:
            params["pageNum"] = pagenum
            
        if pagesize is not None:
            params["pageSize"] = pagesize
            
        
        
        # Replace path parameters in URL
        path = "/virtualAccountManagement/customer/corporateSchemeCode/tabout"
        
        
        # Prepare headers
        headers = {}
        if accesstoken is not None:
            headers["Accesstoken"] = str(accesstoken)
        if channeltype is not None:
            headers["ChannelType"] = str(channeltype)
        if co_relationid is not None:
            headers["Co-Relationid"] = str(co_relationid)
        if initiatingsystem is not None:
            headers["InitiatingSystem"] = str(initiatingsystem)
        if servicemode is not None:
            headers["ServiceMode"] = str(servicemode)
        if uuidseqno is not None:
            headers["UUIDSeqNo"] = str(uuidseqno)
        if entity is not None:
            headers["entity"] = str(entity)
        if referenceid is not None:
            headers["referenceId"] = str(referenceid)
        if requesthash is not None:
            headers["requesthash"] = str(requesthash)
        if userid is not None:
            headers["userId"] = str(userid)
        
        
        return await make_api_request(
            "GET", 
            path, 
            
            params=params if params else None, 
            headers=headers if headers else None
        )
    
    
    
    @mcp.tool()
    async def vabt0008_create_level_detail_using_post(
        request_body:Dict[str, Any] ,  # CreateLevelDetail_Resource,
        accesstoken: Optional[str] = None,
        channeltype: Optional[int] = None,
        co_relationid: Optional[int] = None,
        initiatingsystem: Optional[str] = None,
        servicemode: Optional[int] = None,
        uuidseqno: Optional[int] = None,
        entity: Optional[str] = None,
        referenceid: Optional[str] = None,
        requesthash: Optional[str] = None,
        userid: Optional[int] = None
    ) -> Dict[str, Any]:
        """
        With the aid of this service, Level Data that defines the different levels within the schema of virtual account number for the Corporate Scheme Code will be captured.
        
        Generated from: POST /virtualAccountManagement/customer/levelData/create
        Source: swagger_2_0
        Operation ID: VABT0008CreateLevelDetailUsingPOST
        
        
        Authentication: Not required
        
        Parameters:
        - request_body: any (required)
          input
        
        
        
        Headers:
        - Accesstoken: string
          Authorization Token to validation the caller
        - ChannelType: integer
          Channel identifier from where the TXN has originated (Internet, Mobile, ATM, Branch Channel )
        - Co-Relationid: integer
          Unique ID for the service invoked, will be set by the TXN system
        - InitiatingSystem: string
          Indicating the initiated system
        - ServiceMode: integer
          Used for branch channel to indicate the type of customer
        - UUIDSeqNo: integer
          UUID Sequence Number
        - entity: string
          entity
        - referenceId: string
          Place holder for Token based authentication
        - requesthash: string
          Request payload for hash validation
        - userId: integer
          userId
        
        
        """
        
        
        # Prepare request data
        
        # Single body parameter - send directly
        data = request_body if request_body is not None else {}
        
        
        
        # Prepare query parameters
        params = {}
        
        
        # Replace path parameters in URL
        path = "/virtualAccountManagement/customer/levelData/create"
        
        
        # Prepare headers
        headers = {}
        if accesstoken is not None:
            headers["Accesstoken"] = str(accesstoken)
        if channeltype is not None:
            headers["ChannelType"] = str(channeltype)
        if co_relationid is not None:
            headers["Co-Relationid"] = str(co_relationid)
        if initiatingsystem is not None:
            headers["InitiatingSystem"] = str(initiatingsystem)
        if servicemode is not None:
            headers["ServiceMode"] = str(servicemode)
        if uuidseqno is not None:
            headers["UUIDSeqNo"] = str(uuidseqno)
        if entity is not None:
            headers["entity"] = str(entity)
        if referenceid is not None:
            headers["referenceId"] = str(referenceid)
        if requesthash is not None:
            headers["requesthash"] = str(requesthash)
        if userid is not None:
            headers["userId"] = str(userid)
        
        
        return await make_api_request(
            "POST", 
            path, 
            data=data, 
            params=params if params else None, 
            headers=headers if headers else None
        )
    
    
    
    @mcp.tool()
    async def vabt0010_delete_level_detail_using_post(
        request_body:Dict[str, Any] ,  # DeleteLevelDetail_Resource,
        accesstoken: Optional[str] = None,
        channeltype: Optional[int] = None,
        co_relationid: Optional[int] = None,
        initiatingsystem: Optional[str] = None,
        servicemode: Optional[int] = None,
        uuidseqno: Optional[int] = None,
        entity: Optional[str] = None,
        referenceid: Optional[str] = None,
        requesthash: Optional[str] = None,
        userid: Optional[int] = None
    ) -> Dict[str, Any]:
        """
        This service will delete the  Level Data defined.
        
        Generated from: POST /virtualAccountManagement/customer/levelData/delete
        Source: swagger_2_0
        Operation ID: VABT0010DeleteLevelDetailUsingPOST
        
        
        Authentication: Not required
        
        Parameters:
        - request_body: any (required)
          input
        
        
        
        Headers:
        - Accesstoken: string
          Authorization Token to validation the caller
        - ChannelType: integer
          Channel identifier from where the TXN has originated (Internet, Mobile, ATM, Branch Channel )
        - Co-Relationid: integer
          Unique ID for the service invoked, will be set by the TXN system
        - InitiatingSystem: string
          Indicating the initiated system
        - ServiceMode: integer
          Used for branch channel to indicate the type of customer
        - UUIDSeqNo: integer
          UUID Sequence Number
        - entity: string
          entity
        - referenceId: string
          Place holder for Token based authentication
        - requesthash: string
          Request payload for hash validation
        - userId: integer
          userId
        
        
        """
        
        
        # Prepare request data
        
        # Single body parameter - send directly
        data = request_body if request_body is not None else {}
        
        
        
        # Prepare query parameters
        params = {}
        
        
        # Replace path parameters in URL
        path = "/virtualAccountManagement/customer/levelData/delete"
        
        
        # Prepare headers
        headers = {}
        if accesstoken is not None:
            headers["Accesstoken"] = str(accesstoken)
        if channeltype is not None:
            headers["ChannelType"] = str(channeltype)
        if co_relationid is not None:
            headers["Co-Relationid"] = str(co_relationid)
        if initiatingsystem is not None:
            headers["InitiatingSystem"] = str(initiatingsystem)
        if servicemode is not None:
            headers["ServiceMode"] = str(servicemode)
        if uuidseqno is not None:
            headers["UUIDSeqNo"] = str(uuidseqno)
        if entity is not None:
            headers["entity"] = str(entity)
        if referenceid is not None:
            headers["referenceId"] = str(referenceid)
        if requesthash is not None:
            headers["requesthash"] = str(requesthash)
        if userid is not None:
            headers["userId"] = str(userid)
        
        
        return await make_api_request(
            "POST", 
            path, 
            data=data, 
            params=params if params else None, 
            headers=headers if headers else None
        )
    
    
    
    @mcp.tool()
    async def vaet0004_get_level_detail_using_get(
        corporateschemecode: str,
        fieldreference: int,
        schemeid: int,
        pagenum: Optional[int] = None,
        pagesize: Optional[int] = None,
        accesstoken: Optional[str] = None,
        channeltype: Optional[int] = None,
        co_relationid: Optional[int] = None,
        initiatingsystem: Optional[str] = None,
        servicemode: Optional[int] = None,
        uuidseqno: Optional[int] = None,
        entity: Optional[str] = None,
        referenceid: Optional[str] = None,
        requesthash: Optional[str] = None,
        userid: Optional[int] = None
    ) -> Dict[str, Any]:
        """
        This API is used to display Level Data Details
        
        Generated from: GET /virtualAccountManagement/customer/levelData/details
        Source: swagger_2_0
        Operation ID: VAET0004GetLevelDetailUsingGET
        
        
        Authentication: Not required
        
        Parameters:
        - corporateSchemeCode: string (required)
          Corporate Scheme Code for which the Levels in Virtual Account Schema are being defined
        - fieldReference: integer (required)
          Field Reference denotes the different Factors on which Virtual Account Schema will be defined. It will be part of Virtual Account Number Generated based on Schema Defined.(1 - Level 1,2 - Level 2,3 - Level 3,4 - Level 4,5 - Level 5,6 - Level 6,7 - Level 7,8 - Country Code,9 - Check Digit,10 - Bank Code,11 - Branch Code,12 - BIC,13 - Sort Code,14 - Corporate Scheme Code,15 - National Check Digit,16 - Currency,17 - Account Type,18 - Account Number Sequence)
        - pageNum: integer
          pageNum
        - pageSize: integer
          pageSize
        - schemeId: integer (required)
          Unique Reference for the Scheme Registration which will happen for unique Scheme Code and Customer Combination
        
        
        
        Headers:
        - Accesstoken: string
          Authorization Token to validation the caller
        - ChannelType: integer
          Channel identifier from where the TXN has originated (Internet, Mobile, ATM, Branch Channel )
        - Co-Relationid: integer
          Unique ID for the service invoked, will be set by the TXN system
        - InitiatingSystem: string
          Indicating the initiated system
        - ServiceMode: integer
          Used for branch channel to indicate the type of customer
        - UUIDSeqNo: integer
          UUID Sequence Number
        - entity: string
          entity
        - referenceId: string
          Place holder for Token based authentication
        - requesthash: string
          Request payload for hash validation
        - userId: integer
          userId
        
        
        """
        
        
        # Prepare query parameters
        params = {}
        if corporateschemecode is not None:
            params["corporateSchemeCode"] = corporateschemecode
            
        if fieldreference is not None:
            params["fieldReference"] = fieldreference
            
        if pagenum is not None:
            params["pageNum"] = pagenum
            
        if pagesize is not None:
            params["pageSize"] = pagesize
            
        if schemeid is not None:
            params["schemeId"] = schemeid
            
        
        
        # Replace path parameters in URL
        path = "/virtualAccountManagement/customer/levelData/details"
        
        
        # Prepare headers
        headers = {}
        if accesstoken is not None:
            headers["Accesstoken"] = str(accesstoken)
        if channeltype is not None:
            headers["ChannelType"] = str(channeltype)
        if co_relationid is not None:
            headers["Co-Relationid"] = str(co_relationid)
        if initiatingsystem is not None:
            headers["InitiatingSystem"] = str(initiatingsystem)
        if servicemode is not None:
            headers["ServiceMode"] = str(servicemode)
        if uuidseqno is not None:
            headers["UUIDSeqNo"] = str(uuidseqno)
        if entity is not None:
            headers["entity"] = str(entity)
        if referenceid is not None:
            headers["referenceId"] = str(referenceid)
        if requesthash is not None:
            headers["requesthash"] = str(requesthash)
        if userid is not None:
            headers["userId"] = str(userid)
        
        
        return await make_api_request(
            "GET", 
            path, 
            
            params=params if params else None, 
            headers=headers if headers else None
        )
    
    
    
    @mcp.tool()
    async def vabt0009_modify_level_detail_using_post(
        request_body:Dict[str, Any] ,  # ModifyLevelDetail_Resource,
        accesstoken: Optional[str] = None,
        channeltype: Optional[int] = None,
        co_relationid: Optional[int] = None,
        initiatingsystem: Optional[str] = None,
        servicemode: Optional[int] = None,
        uuidseqno: Optional[int] = None,
        entity: Optional[str] = None,
        referenceid: Optional[str] = None,
        requesthash: Optional[str] = None,
        userid: Optional[int] = None
    ) -> Dict[str, Any]:
        """
        This service modifies the Level Data that defines the different levels within the schema of virtual account number for the Corporate Scheme Code.
        
        Generated from: POST /virtualAccountManagement/customer/levelData/modify
        Source: swagger_2_0
        Operation ID: VABT0009ModifyLevelDetailUsingPOST
        
        
        Authentication: Not required
        
        Parameters:
        - request_body: any (required)
          input
        
        
        
        Headers:
        - Accesstoken: string
          Authorization Token to validation the caller
        - ChannelType: integer
          Channel identifier from where the TXN has originated (Internet, Mobile, ATM, Branch Channel )
        - Co-Relationid: integer
          Unique ID for the service invoked, will be set by the TXN system
        - InitiatingSystem: string
          Indicating the initiated system
        - ServiceMode: integer
          Used for branch channel to indicate the type of customer
        - UUIDSeqNo: integer
          UUID Sequence Number
        - entity: string
          entity
        - referenceId: string
          Place holder for Token based authentication
        - requesthash: string
          Request payload for hash validation
        - userId: integer
          userId
        
        
        """
        
        
        # Prepare request data
        
        # Single body parameter - send directly
        data = request_body if request_body is not None else {}
        
        
        
        # Prepare query parameters
        params = {}
        
        
        # Replace path parameters in URL
        path = "/virtualAccountManagement/customer/levelData/modify"
        
        
        # Prepare headers
        headers = {}
        if accesstoken is not None:
            headers["Accesstoken"] = str(accesstoken)
        if channeltype is not None:
            headers["ChannelType"] = str(channeltype)
        if co_relationid is not None:
            headers["Co-Relationid"] = str(co_relationid)
        if initiatingsystem is not None:
            headers["InitiatingSystem"] = str(initiatingsystem)
        if servicemode is not None:
            headers["ServiceMode"] = str(servicemode)
        if uuidseqno is not None:
            headers["UUIDSeqNo"] = str(uuidseqno)
        if entity is not None:
            headers["entity"] = str(entity)
        if referenceid is not None:
            headers["referenceId"] = str(referenceid)
        if requesthash is not None:
            headers["requesthash"] = str(requesthash)
        if userid is not None:
            headers["userId"] = str(userid)
        
        
        return await make_api_request(
            "POST", 
            path, 
            data=data, 
            params=params if params else None, 
            headers=headers if headers else None
        )
    
    
    
    @mcp.tool()
    async def vaet0003_fetch_level_detail_using_get(
        schemeid: int,
        pagenum: Optional[int] = None,
        pagesize: Optional[int] = None,
        accesstoken: Optional[str] = None,
        channeltype: Optional[int] = None,
        co_relationid: Optional[int] = None,
        initiatingsystem: Optional[str] = None,
        servicemode: Optional[int] = None,
        uuidseqno: Optional[int] = None,
        entity: Optional[str] = None,
        referenceid: Optional[str] = None,
        requesthash: Optional[str] = None,
        userid: Optional[int] = None
    ) -> Dict[str, Any]:
        """
        This Service will list all Level Data records defined for  Customer registered in the system
        
        Generated from: GET /virtualAccountManagement/customer/levelData/{schemeId}/list
        Source: swagger_2_0
        Operation ID: VAET0003FetchLevelDetailUsingGET
        
        
        Authentication: Not required
        
        Parameters:
        - pageNum: integer
          pageNum
        - pageSize: integer
          pageSize
        - schemeId: integer (required)
          Unique Reference for the Scheme Registration which will happen for unique Scheme Code and Customer Combination
        
        
        
        Headers:
        - Accesstoken: string
          Authorization Token to validation the caller
        - ChannelType: integer
          Channel identifier from where the TXN has originated (Internet, Mobile, ATM, Branch Channel )
        - Co-Relationid: integer
          Unique ID for the service invoked, will be set by the TXN system
        - InitiatingSystem: string
          Indicating the initiated system
        - ServiceMode: integer
          Used for branch channel to indicate the type of customer
        - UUIDSeqNo: integer
          UUID Sequence Number
        - entity: string
          entity
        - referenceId: string
          Place holder for Token based authentication
        - requesthash: string
          Request payload for hash validation
        - userId: integer
          userId
        
        
        """
        
        
        # Prepare query parameters
        params = {}
        if pagenum is not None:
            params["pageNum"] = pagenum
            
        if pagesize is not None:
            params["pageSize"] = pagesize
            
        
        
        # Replace path parameters in URL
        path = "/virtualAccountManagement/customer/levelData/{schemeId}/list"
        if schemeid is not None:
            path = path.replace("{schemeId}", str(schemeid))
        
        
        # Prepare headers
        headers = {}
        if accesstoken is not None:
            headers["Accesstoken"] = str(accesstoken)
        if channeltype is not None:
            headers["ChannelType"] = str(channeltype)
        if co_relationid is not None:
            headers["Co-Relationid"] = str(co_relationid)
        if initiatingsystem is not None:
            headers["InitiatingSystem"] = str(initiatingsystem)
        if servicemode is not None:
            headers["ServiceMode"] = str(servicemode)
        if uuidseqno is not None:
            headers["UUIDSeqNo"] = str(uuidseqno)
        if entity is not None:
            headers["entity"] = str(entity)
        if referenceid is not None:
            headers["referenceId"] = str(referenceid)
        if requesthash is not None:
            headers["requesthash"] = str(requesthash)
        if userid is not None:
            headers["userId"] = str(userid)
        
        
        return await make_api_request(
            "GET", 
            path, 
            
            params=params if params else None, 
            headers=headers if headers else None
        )
    
    
    
    @mcp.tool()
    async def vaet0006_fetch_registered_customers_using_get(
        corporateschemecode: Optional[str] = None,
        corporateschemename: Optional[str] = None,
        creditaccountcategory: Optional[str] = None,
        creditaccountreference: Optional[str] = None,
        customername: Optional[str] = None,
        customerreference: Optional[str] = None,
        pagenum: Optional[int] = None,
        pagesize: Optional[int] = None,
        status: Optional[str] = None,
        accesstoken: Optional[str] = None,
        channeltype: Optional[int] = None,
        co_relationid: Optional[int] = None,
        initiatingsystem: Optional[str] = None,
        servicemode: Optional[int] = None,
        uuidseqno: Optional[int] = None,
        entity: Optional[str] = None,
        referenceid: Optional[str] = None,
        requesthash: Optional[str] = None,
        userid: Optional[int] = None
    ) -> Dict[str, Any]:
        """
        This service will fetch the list of Registered Customers in the system.
        
        Generated from: GET /virtualAccountManagement/customer/list
        Source: swagger_2_0
        Operation ID: VAET0006FetchRegisteredCustomersUsingGET
        
        
        Authentication: Not required
        
        Parameters:
        - corporateSchemeCode: string
          Corporate Scheme Code uniquely identifies a registration for Virtual Account Management Service.Each of the Customer Registration will be with unique Corporate Scheme Code
        - corporateSchemeName: string
          Name of the Scheme Code which denotes the Purpose for which Virtual Account Management registration is done
        - creditAccountCategory: string
          Indicator to denote the type of Credit Account Reference.If User selects (1-Real), Credit Account Reference will be fetched from Physical Account Database.If User selects (2-Virtual), Credit Account Reference will be fetched from Virtual Account Database
        - creditAccountReference: string
          Physical Bank Account or Virtual Account that will be eventually credited when an incoming payment is recieved on a virtual Account created under the Corporate Scheme with the registered Corporate Scheme Code
        - customerName: string
          Name of the Customer which is going to be registered. This will be derived from Customer Reference selected
        - customerReference: string
          Business Partner Reference or equivalent identifier uniquely assigned to the customer
        - pageNum: integer
          pageNum
        - pageSize: integer
          pageSize
        - status: string
          This Field denotes the WorkFlow Status of the Customer Registration created by User(1-Active,2-OnHold,3-ActivePndngAuth,4-Released,5-PndngCancelAuth,6-PendingCancel,7-Cancelled,8-Rejected,9-MOnHold)
        
        
        
        Headers:
        - Accesstoken: string
          Authorization Token to validation the caller
        - ChannelType: integer
          Channel identifier from where the TXN has originated (Internet, Mobile, ATM, Branch Channel )
        - Co-Relationid: integer
          Unique ID for the service invoked, will be set by the TXN system
        - InitiatingSystem: string
          Indicating the initiated system
        - ServiceMode: integer
          Used for branch channel to indicate the type of customer
        - UUIDSeqNo: integer
          UUID Sequence Number
        - entity: string
          entity
        - referenceId: string
          Place holder for Token based authentication
        - requesthash: string
          Request payload for hash validation
        - userId: integer
          userId
        
        
        """
        
        
        # Prepare query parameters
        params = {}
        if corporateschemecode is not None:
            params["corporateSchemeCode"] = corporateschemecode
            
        if corporateschemename is not None:
            params["corporateSchemeName"] = corporateschemename
            
        if creditaccountcategory is not None:
            params["creditAccountCategory"] = creditaccountcategory
            
        if creditaccountreference is not None:
            params["creditAccountReference"] = creditaccountreference
            
        if customername is not None:
            params["customerName"] = customername
            
        if customerreference is not None:
            params["customerReference"] = customerreference
            
        if pagenum is not None:
            params["pageNum"] = pagenum
            
        if pagesize is not None:
            params["pageSize"] = pagesize
            
        if status is not None:
            params["status"] = status
            
        
        
        # Replace path parameters in URL
        path = "/virtualAccountManagement/customer/list"
        
        
        # Prepare headers
        headers = {}
        if accesstoken is not None:
            headers["Accesstoken"] = str(accesstoken)
        if channeltype is not None:
            headers["ChannelType"] = str(channeltype)
        if co_relationid is not None:
            headers["Co-Relationid"] = str(co_relationid)
        if initiatingsystem is not None:
            headers["InitiatingSystem"] = str(initiatingsystem)
        if servicemode is not None:
            headers["ServiceMode"] = str(servicemode)
        if uuidseqno is not None:
            headers["UUIDSeqNo"] = str(uuidseqno)
        if entity is not None:
            headers["entity"] = str(entity)
        if referenceid is not None:
            headers["referenceId"] = str(referenceid)
        if requesthash is not None:
            headers["requesthash"] = str(requesthash)
        if userid is not None:
            headers["userId"] = str(userid)
        
        
        return await make_api_request(
            "GET", 
            path, 
            
            params=params if params else None, 
            headers=headers if headers else None
        )
    
    
    
    @mcp.tool()
    async def vabt0002_modify_registered_customer_using_post(
        request_body:Dict[str, Any] ,  # modifyRegisteredCustomerResource,
        channeltype: Optional[int] = None,
        co_relationid: Optional[int] = None,
        initiatingsystem: Optional[str] = None,
        servicemode: Optional[int] = None,
        uuidseqno: Optional[int] = None,
        authorization: Optional[str] = None,
        entity: Optional[str] = None,
        referenceid: Optional[str] = None,
        requesthash: Optional[str] = None,
        userid: Optional[int] = None
    ) -> Dict[str, Any]:
        """
        This Service will modify a customer scheme in 'On Hold' Status.
        
        Generated from: POST /virtualAccountManagement/customer/modify
        Source: swagger_2_0
        Operation ID: VABT0002ModifyRegisteredCustomerUsingPOST
        
        
        Authentication: Not required
        
        Parameters:
        - request_body: any (required)
          input
        
        
        
        Headers:
        - ChannelType: integer
          Channel identifier from where the TXN has originated (Internet, Mobile, ATM, Branch Channel )
        - Co-Relationid: integer
          Unique ID for the service invoked, will be set by the TXN system
        - InitiatingSystem: string
          Indicating the initiated system
        - ServiceMode: integer
          Used for branch channel to indicate the type of customer
        - UUIDSeqNo: integer
          UUID Sequence Number
        - authorization: string
          Authorization Token to validation the caller
        - entity: string
          entity
        - referenceId: string
          Identified reference field for authorization
        - requesthash: string
          Request payload for hash validation
        - userId: integer
          userId
        
        
        """
        
        
        # Prepare request data
        
        # Single body parameter - send directly
        data = request_body if request_body is not None else {}
        
        
        
        # Prepare query parameters
        params = {}
        
        
        # Replace path parameters in URL
        path = "/virtualAccountManagement/customer/modify"
        
        
        # Prepare headers
        headers = {}
        if channeltype is not None:
            headers["ChannelType"] = str(channeltype)
        if co_relationid is not None:
            headers["Co-Relationid"] = str(co_relationid)
        if initiatingsystem is not None:
            headers["InitiatingSystem"] = str(initiatingsystem)
        if servicemode is not None:
            headers["ServiceMode"] = str(servicemode)
        if uuidseqno is not None:
            headers["UUIDSeqNo"] = str(uuidseqno)
        if authorization is not None:
            headers["authorization"] = str(authorization)
        if entity is not None:
            headers["entity"] = str(entity)
        if referenceid is not None:
            headers["referenceId"] = str(referenceid)
        if requesthash is not None:
            headers["requesthash"] = str(requesthash)
        if userid is not None:
            headers["userId"] = str(userid)
        
        
        return await make_api_request(
            "POST", 
            path, 
            data=data, 
            params=params if params else None, 
            headers=headers if headers else None
        )
    
    
    
    @mcp.tool()
    async def vabt0004_modify_active_registered_customer_using_post(
        request_body:Dict[str, Any] ,  # modifyActiveRegisteredCustomerResource,
        channeltype: Optional[int] = None,
        co_relationid: Optional[int] = None,
        initiatingsystem: Optional[str] = None,
        servicemode: Optional[int] = None,
        uuidseqno: Optional[int] = None,
        authorization: Optional[str] = None,
        entity: Optional[str] = None,
        referenceid: Optional[str] = None,
        requesthash: Optional[str] = None,
        userid: Optional[int] = None
    ) -> Dict[str, Any]:
        """
        This Service will modify a customer scheme in 'Active' Status.
        
        Generated from: POST /virtualAccountManagement/customer/modifyActive
        Source: swagger_2_0
        Operation ID: VABT0004ModifyActiveRegisteredCustomerUsingPOST
        
        
        Authentication: Not required
        
        Parameters:
        - request_body: any (required)
          input
        
        
        
        Headers:
        - ChannelType: integer
          Channel identifier from where the TXN has originated (Internet, Mobile, ATM, Branch Channel )
        - Co-Relationid: integer
          Unique ID for the service invoked, will be set by the TXN system
        - InitiatingSystem: string
          Indicating the initiated system
        - ServiceMode: integer
          Used for branch channel to indicate the type of customer
        - UUIDSeqNo: integer
          UUID Sequence Number
        - authorization: string
          Authorization Token to validation the caller
        - entity: string
          entity
        - referenceId: string
          Identified reference field for authorization
        - requesthash: string
          Request payload for hash validation
        - userId: integer
          userId
        
        
        """
        
        
        # Prepare request data
        
        # Single body parameter - send directly
        data = request_body if request_body is not None else {}
        
        
        
        # Prepare query parameters
        params = {}
        
        
        # Replace path parameters in URL
        path = "/virtualAccountManagement/customer/modifyActive"
        
        
        # Prepare headers
        headers = {}
        if channeltype is not None:
            headers["ChannelType"] = str(channeltype)
        if co_relationid is not None:
            headers["Co-Relationid"] = str(co_relationid)
        if initiatingsystem is not None:
            headers["InitiatingSystem"] = str(initiatingsystem)
        if servicemode is not None:
            headers["ServiceMode"] = str(servicemode)
        if uuidseqno is not None:
            headers["UUIDSeqNo"] = str(uuidseqno)
        if authorization is not None:
            headers["authorization"] = str(authorization)
        if entity is not None:
            headers["entity"] = str(entity)
        if referenceid is not None:
            headers["referenceId"] = str(referenceid)
        if requesthash is not None:
            headers["requesthash"] = str(requesthash)
        if userid is not None:
            headers["userId"] = str(userid)
        
        
        return await make_api_request(
            "POST", 
            path, 
            data=data, 
            params=params if params else None, 
            headers=headers if headers else None
        )
    
    
    
    @mcp.tool()
    async def cbcet1001_fetch_customer_list_qbeusing_get(
        category: Optional[int] = None,
        customerid: Optional[int] = None,
        customername: Optional[str] = None,
        pagenum: Optional[int] = None,
        pagesize: Optional[int] = None,
        status: Optional[int] = None,
        accesstoken: Optional[str] = None,
        channeltype: Optional[int] = None,
        co_relationid: Optional[int] = None,
        initiatingsystem: Optional[str] = None,
        servicemode: Optional[int] = None,
        uuidseqno: Optional[int] = None,
        entity: Optional[str] = None,
        referenceid: Optional[str] = None,
        requesthash: Optional[str] = None,
        userid: Optional[int] = None
    ) -> Dict[str, Any]:
        """
        This service is used to  Fetch Customer List
        
        Generated from: GET /virtualAccountManagement/customer/name/list
        Source: swagger_2_0
        Operation ID: CBCET1001FetchCustomerListQBEUsingGET
        
        
        Authentication: Not required
        
        Parameters:
        - category: integer
          This Field denotes the Category of the Customer. For, Virtual Account, It will ways be Corporate Customer (1 - Individual ,2 - Company,3 - Bank)
        - customerId: integer
          Unique Reference for the Customer which exists in Core System
        - customerName: string
          This Field denotes the Customer Name for a Unique Customer Reference existing in Core System
        - pageNum: integer
          pageNum
        - pageSize: integer
          pageSize
        - status: integer
          This Field denotes the WorkFlow Status of the Customer Registration created by User(1-Active,2-OnHold,3-ActivePndngAuth,4-Released,5-PndngCancelAuth,6-PendingCancel,7-Cancelled,8-Rejected,9-MOnHold)
        
        
        
        Headers:
        - Accesstoken: string
          Authorization Token to validation the caller
        - ChannelType: integer
          Channel identifier from where the TXN has originated (Internet, Mobile, ATM, Branch Channel )
        - Co-Relationid: integer
          Unique ID for the service invoked, will be set by the TXN system
        - InitiatingSystem: string
          Indicating the initiated system
        - ServiceMode: integer
          Used for branch channel to indicate the type of customer
        - UUIDSeqNo: integer
          UUID Sequence Number
        - entity: string
          entity
        - referenceId: string
          Place holder for Token based authentication
        - requesthash: string
          Request payload for hash validation
        - userId: integer
          userId
        
        
        """
        
        
        # Prepare query parameters
        params = {}
        if category is not None:
            params["category"] = category
            
        if customerid is not None:
            params["customerId"] = customerid
            
        if customername is not None:
            params["customerName"] = customername
            
        if pagenum is not None:
            params["pageNum"] = pagenum
            
        if pagesize is not None:
            params["pageSize"] = pagesize
            
        if status is not None:
            params["status"] = status
            
        
        
        # Replace path parameters in URL
        path = "/virtualAccountManagement/customer/name/list"
        
        
        # Prepare headers
        headers = {}
        if accesstoken is not None:
            headers["Accesstoken"] = str(accesstoken)
        if channeltype is not None:
            headers["ChannelType"] = str(channeltype)
        if co_relationid is not None:
            headers["Co-Relationid"] = str(co_relationid)
        if initiatingsystem is not None:
            headers["InitiatingSystem"] = str(initiatingsystem)
        if servicemode is not None:
            headers["ServiceMode"] = str(servicemode)
        if uuidseqno is not None:
            headers["UUIDSeqNo"] = str(uuidseqno)
        if entity is not None:
            headers["entity"] = str(entity)
        if referenceid is not None:
            headers["referenceId"] = str(referenceid)
        if requesthash is not None:
            headers["requesthash"] = str(requesthash)
        if userid is not None:
            headers["userId"] = str(userid)
        
        
        return await make_api_request(
            "GET", 
            path, 
            
            params=params if params else None, 
            headers=headers if headers else None
        )
    
    
    
    @mcp.tool()
    async def cbcet100_fetch_bpname_using_get(
        customerid: int,
        pagenum: Optional[int] = None,
        pagesize: Optional[int] = None,
        accesstoken: Optional[str] = None,
        channeltype: Optional[int] = None,
        co_relationid: Optional[int] = None,
        initiatingsystem: Optional[str] = None,
        servicemode: Optional[int] = None,
        uuidseqno: Optional[int] = None,
        entity: Optional[str] = None,
        referenceid: Optional[str] = None,
        requesthash: Optional[str] = None,
        userid: Optional[int] = None
    ) -> Dict[str, Any]:
        """
        This service is used to Fetch Customer Name
        
        Generated from: GET /virtualAccountManagement/customer/name/{customerId}
        Source: swagger_2_0
        Operation ID: CBCET100FetchBPNameUsingGET
        
        
        Authentication: Not required
        
        Parameters:
        - customerId: integer (required)
          Unique reference for the Customer which exists in Core System
        - pageNum: integer
          pageNum
        - pageSize: integer
          pageSize
        
        
        
        Headers:
        - Accesstoken: string
          Authorization Token to validation the caller
        - ChannelType: integer
          Channel identifier from where the TXN has originated (Internet, Mobile, ATM, Branch Channel )
        - Co-Relationid: integer
          Unique ID for the service invoked, will be set by the TXN system
        - InitiatingSystem: string
          Indicating the initiated system
        - ServiceMode: integer
          Used for branch channel to indicate the type of customer
        - UUIDSeqNo: integer
          UUID Sequence Number
        - entity: string
          entity
        - referenceId: string
          Place holder for Token based authentication
        - requesthash: string
          Request payload for hash validation
        - userId: integer
          userId
        
        
        """
        
        
        # Prepare query parameters
        params = {}
        if pagenum is not None:
            params["pageNum"] = pagenum
            
        if pagesize is not None:
            params["pageSize"] = pagesize
            
        
        
        # Replace path parameters in URL
        path = "/virtualAccountManagement/customer/name/{customerId}"
        if customerid is not None:
            path = path.replace("{customerId}", str(customerid))
        
        
        # Prepare headers
        headers = {}
        if accesstoken is not None:
            headers["Accesstoken"] = str(accesstoken)
        if channeltype is not None:
            headers["ChannelType"] = str(channeltype)
        if co_relationid is not None:
            headers["Co-Relationid"] = str(co_relationid)
        if initiatingsystem is not None:
            headers["InitiatingSystem"] = str(initiatingsystem)
        if servicemode is not None:
            headers["ServiceMode"] = str(servicemode)
        if uuidseqno is not None:
            headers["UUIDSeqNo"] = str(uuidseqno)
        if entity is not None:
            headers["entity"] = str(entity)
        if referenceid is not None:
            headers["referenceId"] = str(referenceid)
        if requesthash is not None:
            headers["requesthash"] = str(requesthash)
        if userid is not None:
            headers["userId"] = str(userid)
        
        
        return await make_api_request(
            "GET", 
            path, 
            
            params=params if params else None, 
            headers=headers if headers else None
        )
    
    
    
    @mcp.tool()
    async def vabt0097_cust_narrtn_crt_postusing_post(
        request_body:Dict[str, Any] ,  # customNarrationCreateResource,
        accesstoken: Optional[str] = None,
        channeltype: Optional[int] = None,
        co_relationid: Optional[int] = None,
        initiatingsystem: Optional[str] = None,
        servicemode: Optional[int] = None,
        uuidseqno: Optional[int] = None,
        entity: Optional[str] = None,
        languagecode: Optional[int] = None,
        referenceid: Optional[str] = None,
        userid: Optional[int] = None
    ) -> Dict[str, Any]:
        """
        Customer Narration Create
        
        Generated from: POST /virtualAccountManagement/customer/narration
        Source: swagger_2_0
        Operation ID: VABT0097CustNarrtnCrt_POSTUsingPOST
        
        
        Authentication: Not required
        
        Parameters:
        - request_body: any (required)
          input
        
        
        
        Headers:
        - Accesstoken: string
          Authorization token for identification of the caller
        - ChannelType: integer
          Channel from where the transaction has originated (Internet, Mobile, ATM, Branch Channel )
        - Co-Relationid: integer
          Unique ID for the service invoked, will be set by the TXN system
        - InitiatingSystem: string
          Indicating the initiated system
        - ServiceMode: integer
          Used for branch channel to indicate the type of customer
        - UUIDSeqNo: integer
          UUID Sequence Number
        - entity: string
          entity
        - languageCode: integer
          languageCode
        - referenceId: string
          Place holder for Token based authentication
        - userId: integer
          userId
        
        
        """
        
        
        # Prepare request data
        
        # Single body parameter - send directly
        data = request_body if request_body is not None else {}
        
        
        
        # Prepare query parameters
        params = {}
        
        
        # Replace path parameters in URL
        path = "/virtualAccountManagement/customer/narration"
        
        
        # Prepare headers
        headers = {}
        if accesstoken is not None:
            headers["Accesstoken"] = str(accesstoken)
        if channeltype is not None:
            headers["ChannelType"] = str(channeltype)
        if co_relationid is not None:
            headers["Co-Relationid"] = str(co_relationid)
        if initiatingsystem is not None:
            headers["InitiatingSystem"] = str(initiatingsystem)
        if servicemode is not None:
            headers["ServiceMode"] = str(servicemode)
        if uuidseqno is not None:
            headers["UUIDSeqNo"] = str(uuidseqno)
        if entity is not None:
            headers["entity"] = str(entity)
        if languagecode is not None:
            headers["languageCode"] = str(languagecode)
        if referenceid is not None:
            headers["referenceId"] = str(referenceid)
        if userid is not None:
            headers["userId"] = str(userid)
        
        
        return await make_api_request(
            "POST", 
            path, 
            data=data, 
            params=params if params else None, 
            headers=headers if headers else None
        )
    
    
    
    @mcp.tool()
    async def vaet0099_cust_narrtn_lst_postusing_get(
        schemeid: int,
        pagenum: Optional[int] = None,
        pagesize: Optional[int] = None,
        accesstoken: Optional[str] = None,
        channeltype: Optional[int] = None,
        co_relationid: Optional[int] = None,
        initiatingsystem: Optional[str] = None,
        servicemode: Optional[int] = None,
        uuidseqno: Optional[int] = None,
        entity: Optional[str] = None,
        languagecode: Optional[int] = None,
        referenceid: Optional[str] = None,
        userid: Optional[int] = None
    ) -> Dict[str, Any]:
        """
        Customer Narration List
        
        Generated from: GET /virtualAccountManagement/customer/narration/list/{schemeId}
        Source: swagger_2_0
        Operation ID: VAET0099CustNarrtnLst_POSTUsingGET
        
        
        Authentication: Not required
        
        Parameters:
        - pageNum: integer
          pageNum
        - pageSize: integer
          pageSize
        - schemeId: integer (required)
          the field gives detials of scheme ID
        
        
        
        Headers:
        - Accesstoken: string
          Authorization token for identification of the caller
        - ChannelType: integer
          Channel from where the transaction has originated (Internet, Mobile, ATM, Branch Channel )
        - Co-Relationid: integer
          Unique ID for the service invoked, will be set by the TXN system
        - InitiatingSystem: string
          Indicating the initiated system
        - ServiceMode: integer
          Used for branch channel to indicate the type of customer
        - UUIDSeqNo: integer
          UUID Sequence Number
        - entity: string
          entity
        - languageCode: integer
          languageCode
        - referenceId: string
          Place holder for Token based authentication
        - userId: integer
          userId
        
        
        """
        
        
        # Prepare query parameters
        params = {}
        if pagenum is not None:
            params["pageNum"] = pagenum
            
        if pagesize is not None:
            params["pageSize"] = pagesize
            
        
        
        # Replace path parameters in URL
        path = "/virtualAccountManagement/customer/narration/list/{schemeId}"
        if schemeid is not None:
            path = path.replace("{schemeId}", str(schemeid))
        
        
        # Prepare headers
        headers = {}
        if accesstoken is not None:
            headers["Accesstoken"] = str(accesstoken)
        if channeltype is not None:
            headers["ChannelType"] = str(channeltype)
        if co_relationid is not None:
            headers["Co-Relationid"] = str(co_relationid)
        if initiatingsystem is not None:
            headers["InitiatingSystem"] = str(initiatingsystem)
        if servicemode is not None:
            headers["ServiceMode"] = str(servicemode)
        if uuidseqno is not None:
            headers["UUIDSeqNo"] = str(uuidseqno)
        if entity is not None:
            headers["entity"] = str(entity)
        if languagecode is not None:
            headers["languageCode"] = str(languagecode)
        if referenceid is not None:
            headers["referenceId"] = str(referenceid)
        if userid is not None:
            headers["userId"] = str(userid)
        
        
        return await make_api_request(
            "GET", 
            path, 
            
            params=params if params else None, 
            headers=headers if headers else None
        )
    
    
    
    @mcp.tool()
    async def vabt0098_cust_narrtn_mdfy_postusing_put(
        schemeid: int,
        placeholdername: int,
        placeholderrequired: int,
        schemecode: str,
        accesstoken: Optional[str] = None,
        channeltype: Optional[int] = None,
        co_relationid: Optional[int] = None,
        initiatingsystem: Optional[str] = None,
        servicemode: Optional[int] = None,
        uuidseqno: Optional[int] = None,
        entity: Optional[str] = None,
        languagecode: Optional[int] = None,
        referenceid: Optional[str] = None,
        userid: Optional[int] = None
    ) -> Dict[str, Any]:
        """
        Customer Narration Modify
        
        Generated from: PUT /virtualAccountManagement/customer/narration/modify/{schemeId}
        Source: swagger_2_0
        Operation ID: VABT0098CustNarrtnMdfy_POSTUsingPUT
        
        
        Authentication: Not required
        
        Parameters:
        - placeholderName: integer (required)
          the field will give detials of place holder name
        - placeholderRequired: integer (required)
          the field will give detials of place holder value
        - schemeCode: string (required)
          the field gives scheme code
        - schemeId: integer (required)
          the field gives detials of scheme ID
        
        
        
        Headers:
        - Accesstoken: string
          Authorization token for identification of the caller
        - ChannelType: integer
          Channel from where the transaction has originated (Internet, Mobile, ATM, Branch Channel )
        - Co-Relationid: integer
          Unique ID for the service invoked, will be set by the TXN system
        - InitiatingSystem: string
          Indicating the initiated system
        - ServiceMode: integer
          Used for branch channel to indicate the type of customer
        - UUIDSeqNo: integer
          UUID Sequence Number
        - entity: string
          entity
        - languageCode: integer
          languageCode
        - referenceId: string
          Place holder for Token based authentication
        - userId: integer
          userId
        
        
        """
        
        
        # Prepare query parameters
        params = {}
        if placeholdername is not None:
            params["placeholderName"] = placeholdername
            
        if placeholderrequired is not None:
            params["placeholderRequired"] = placeholderrequired
            
        if schemecode is not None:
            params["schemeCode"] = schemecode
            
        
        
        # Replace path parameters in URL
        path = "/virtualAccountManagement/customer/narration/modify/{schemeId}"
        if schemeid is not None:
            path = path.replace("{schemeId}", str(schemeid))
        
        
        # Prepare headers
        headers = {}
        if accesstoken is not None:
            headers["Accesstoken"] = str(accesstoken)
        if channeltype is not None:
            headers["ChannelType"] = str(channeltype)
        if co_relationid is not None:
            headers["Co-Relationid"] = str(co_relationid)
        if initiatingsystem is not None:
            headers["InitiatingSystem"] = str(initiatingsystem)
        if servicemode is not None:
            headers["ServiceMode"] = str(servicemode)
        if uuidseqno is not None:
            headers["UUIDSeqNo"] = str(uuidseqno)
        if entity is not None:
            headers["entity"] = str(entity)
        if languagecode is not None:
            headers["languageCode"] = str(languagecode)
        if referenceid is not None:
            headers["referenceId"] = str(referenceid)
        if userid is not None:
            headers["userId"] = str(userid)
        
        
        return await make_api_request(
            "PUT", 
            path, 
            
            params=params if params else None, 
            headers=headers if headers else None
        )
    
    
    
    @mcp.tool()
    async def vaet0100_cust_narrtn_view_postusing_get(
        schemeid: int,
        placeholdername: int,
        schemecode: str,
        accesstoken: Optional[str] = None,
        channeltype: Optional[int] = None,
        co_relationid: Optional[int] = None,
        initiatingsystem: Optional[str] = None,
        servicemode: Optional[int] = None,
        uuidseqno: Optional[int] = None,
        entity: Optional[str] = None,
        languagecode: Optional[int] = None,
        referenceid: Optional[str] = None,
        userid: Optional[int] = None
    ) -> Dict[str, Any]:
        """
        Customer Narration View
        
        Generated from: GET /virtualAccountManagement/customer/narration/view/{schemeId}
        Source: swagger_2_0
        Operation ID: VAET0100CustNarrtnView_POSTUsingGET
        
        
        Authentication: Not required
        
        Parameters:
        - placeholderName: integer (required)
          the field gives detials of place holder name
        - schemeCode: string (required)
          the field gives scheme code
        - schemeId: integer (required)
          the field gives detials of scheme ID
        
        
        
        Headers:
        - Accesstoken: string
          Authorization token for identification of the caller
        - ChannelType: integer
          Channel from where the transaction has originated (Internet, Mobile, ATM, Branch Channel )
        - Co-Relationid: integer
          Unique ID for the service invoked, will be set by the TXN system
        - InitiatingSystem: string
          Indicating the initiated system
        - ServiceMode: integer
          Used for branch channel to indicate the type of customer
        - UUIDSeqNo: integer
          UUID Sequence Number
        - entity: string
          entity
        - languageCode: integer
          languageCode
        - referenceId: string
          Place holder for Token based authentication
        - userId: integer
          userId
        
        
        """
        
        
        # Prepare query parameters
        params = {}
        if placeholdername is not None:
            params["placeholderName"] = placeholdername
            
        if schemecode is not None:
            params["schemeCode"] = schemecode
            
        
        
        # Replace path parameters in URL
        path = "/virtualAccountManagement/customer/narration/view/{schemeId}"
        if schemeid is not None:
            path = path.replace("{schemeId}", str(schemeid))
        
        
        # Prepare headers
        headers = {}
        if accesstoken is not None:
            headers["Accesstoken"] = str(accesstoken)
        if channeltype is not None:
            headers["ChannelType"] = str(channeltype)
        if co_relationid is not None:
            headers["Co-Relationid"] = str(co_relationid)
        if initiatingsystem is not None:
            headers["InitiatingSystem"] = str(initiatingsystem)
        if servicemode is not None:
            headers["ServiceMode"] = str(servicemode)
        if uuidseqno is not None:
            headers["UUIDSeqNo"] = str(uuidseqno)
        if entity is not None:
            headers["entity"] = str(entity)
        if languagecode is not None:
            headers["languageCode"] = str(languagecode)
        if referenceid is not None:
            headers["referenceId"] = str(referenceid)
        if userid is not None:
            headers["userId"] = str(userid)
        
        
        return await make_api_request(
            "GET", 
            path, 
            
            params=params if params else None, 
            headers=headers if headers else None
        )
    
    
    
    @mcp.tool()
    async def vabt0057_create_permissible_currencies_postusing_post(
        request_body:Dict[str, Any] ,  # createPermissibleCurrenciesResource,
        accesstoken: Optional[str] = None,
        channeltype: Optional[int] = None,
        co_relationid: Optional[int] = None,
        initiatingsystem: Optional[str] = None,
        servicemode: Optional[int] = None,
        uuidseqno: Optional[int] = None,
        entity: Optional[str] = None,
        languagecode: Optional[int] = None,
        referenceid: Optional[str] = None,
        requesthash: Optional[str] = None,
        userid: Optional[int] = None
    ) -> Dict[str, Any]:
        """
        Create Permissible Currency
        
        Generated from: POST /virtualAccountManagement/customer/permissibleCurrencies
        Source: swagger_2_0
        Operation ID: VABT0057CreatePermissibleCurrencies_POSTUsingPOST
        
        
        Authentication: Not required
        
        Parameters:
        - request_body: any (required)
          input
        
        
        
        Headers:
        - Accesstoken: string
          Authorization token for identification of the caller
        - ChannelType: integer
          Channel identifier from where the TXN has originated (Internet, Mobile, ATM, Branch Channel )
        - Co-Relationid: integer
          Unique ID for the service invoked, will be set by the TXN system
        - InitiatingSystem: string
          Indicating the initiated system
        - ServiceMode: integer
          Used for branch channel to indicate the type of customer
        - UUIDSeqNo: integer
          UUID Sequence Number
        - entity: string
          entity
        - languageCode: integer
          languageCode
        - referenceId: string
          Place holder for Token based authentication
        - requesthash: string
          Request payload for hash validation
        - userId: integer
          userId
        
        
        """
        
        
        # Prepare request data
        
        # Single body parameter - send directly
        data = request_body if request_body is not None else {}
        
        
        
        # Prepare query parameters
        params = {}
        
        
        # Replace path parameters in URL
        path = "/virtualAccountManagement/customer/permissibleCurrencies"
        
        
        # Prepare headers
        headers = {}
        if accesstoken is not None:
            headers["Accesstoken"] = str(accesstoken)
        if channeltype is not None:
            headers["ChannelType"] = str(channeltype)
        if co_relationid is not None:
            headers["Co-Relationid"] = str(co_relationid)
        if initiatingsystem is not None:
            headers["InitiatingSystem"] = str(initiatingsystem)
        if servicemode is not None:
            headers["ServiceMode"] = str(servicemode)
        if uuidseqno is not None:
            headers["UUIDSeqNo"] = str(uuidseqno)
        if entity is not None:
            headers["entity"] = str(entity)
        if languagecode is not None:
            headers["languageCode"] = str(languagecode)
        if referenceid is not None:
            headers["referenceId"] = str(referenceid)
        if requesthash is not None:
            headers["requesthash"] = str(requesthash)
        if userid is not None:
            headers["userId"] = str(userid)
        
        
        return await make_api_request(
            "POST", 
            path, 
            data=data, 
            params=params if params else None, 
            headers=headers if headers else None
        )
    
    
    
    @mcp.tool()
    async def vabt0059_delete_permissible_currencies_postusing_delete(
        permissiblecurrencyid: int,
        schemeid: int,
        accesstoken: Optional[str] = None,
        channeltype: Optional[int] = None,
        co_relationid: Optional[int] = None,
        initiatingsystem: Optional[str] = None,
        servicemode: Optional[int] = None,
        uuidseqno: Optional[int] = None,
        entity: Optional[str] = None,
        languagecode: Optional[int] = None,
        referenceid: Optional[str] = None,
        requesthash: Optional[str] = None,
        userid: Optional[int] = None
    ) -> Dict[str, Any]:
        """
        Delete Permissible Currency
        
        Generated from: DELETE /virtualAccountManagement/customer/permissibleCurrencies/cancel/{schemeId}/{permissibleCurrencyId}
        Source: swagger_2_0
        Operation ID: VABT0059DeletePermissibleCurrencies_POSTUsingDELETE
        
        
        Authentication: Not required
        
        Parameters:
        - permissibleCurrencyId: integer (required)
          Unique reference id for each permissible currency
        - schemeId: integer (required)
          Reference for the Customer Registration which will be created for unique Scheme Code and Customer Combination
        
        
        
        Headers:
        - Accesstoken: string
          Authorization token for identification of the caller
        - ChannelType: integer
          Channel identifier from where the TXN has originated (Internet, Mobile, ATM, Branch Channel )
        - Co-Relationid: integer
          Unique ID for the service invoked, will be set by the TXN system
        - InitiatingSystem: string
          Indicating the initiated system
        - ServiceMode: integer
          Used for branch channel to indicate the type of customer
        - UUIDSeqNo: integer
          UUID Sequence Number
        - entity: string
          entity
        - languageCode: integer
          languageCode
        - referenceId: string
          Place holder for Token based authentication
        - requesthash: string
          Request payload for hash validation
        - userId: integer
          userId
        
        
        """
        
        
        # Prepare query parameters
        params = {}
        
        
        # Replace path parameters in URL
        path = "/virtualAccountManagement/customer/permissibleCurrencies/cancel/{schemeId}/{permissibleCurrencyId}"
        if permissiblecurrencyid is not None:
            path = path.replace("{permissibleCurrencyId}", str(permissiblecurrencyid))
        if schemeid is not None:
            path = path.replace("{schemeId}", str(schemeid))
        
        
        # Prepare headers
        headers = {}
        if accesstoken is not None:
            headers["Accesstoken"] = str(accesstoken)
        if channeltype is not None:
            headers["ChannelType"] = str(channeltype)
        if co_relationid is not None:
            headers["Co-Relationid"] = str(co_relationid)
        if initiatingsystem is not None:
            headers["InitiatingSystem"] = str(initiatingsystem)
        if servicemode is not None:
            headers["ServiceMode"] = str(servicemode)
        if uuidseqno is not None:
            headers["UUIDSeqNo"] = str(uuidseqno)
        if entity is not None:
            headers["entity"] = str(entity)
        if languagecode is not None:
            headers["languageCode"] = str(languagecode)
        if referenceid is not None:
            headers["referenceId"] = str(referenceid)
        if requesthash is not None:
            headers["requesthash"] = str(requesthash)
        if userid is not None:
            headers["userId"] = str(userid)
        
        
        return await make_api_request(
            "DELETE", 
            path, 
            
            params=params if params else None, 
            headers=headers if headers else None
        )
    
    
    
    @mcp.tool()
    async def vaet0060_fetch_permissible_currencies_postusing_get(
        schemeid: int,
        pagenum: Optional[int] = None,
        pagesize: Optional[int] = None,
        accesstoken: Optional[str] = None,
        channeltype: Optional[int] = None,
        co_relationid: Optional[int] = None,
        initiatingsystem: Optional[str] = None,
        servicemode: Optional[int] = None,
        uuidseqno: Optional[int] = None,
        entity: Optional[str] = None,
        languagecode: Optional[int] = None,
        referenceid: Optional[str] = None,
        requesthash: Optional[str] = None,
        userid: Optional[int] = None
    ) -> Dict[str, Any]:
        """
        Fetch Permissible Currency List
        
        Generated from: GET /virtualAccountManagement/customer/permissibleCurrencies/list/{schemeId}
        Source: swagger_2_0
        Operation ID: VAET0060FetchPermissibleCurrencies_POSTUsingGET
        
        
        Authentication: Not required
        
        Parameters:
        - pageNum: integer
          pageNum
        - pageSize: integer
          pageSize
        - schemeId: integer (required)
          Reference for the Customer Registration which will be created for unique Scheme Code and Customer Combination
        
        
        
        Headers:
        - Accesstoken: string
          Authorization token for identification of the caller
        - ChannelType: integer
          Channel identifier from where the TXN has originated (Internet, Mobile, ATM, Branch Channel )
        - Co-Relationid: integer
          Unique ID for the service invoked, will be set by the TXN system
        - InitiatingSystem: string
          Indicating the initiated system
        - ServiceMode: integer
          Used for branch channel to indicate the type of customer
        - UUIDSeqNo: integer
          UUID Sequence Number
        - entity: string
          entity
        - languageCode: integer
          languageCode
        - referenceId: string
          Place holder for Token based authentication
        - requesthash: string
          Request payload for hash validation
        - userId: integer
          userId
        
        
        """
        
        
        # Prepare query parameters
        params = {}
        if pagenum is not None:
            params["pageNum"] = pagenum
            
        if pagesize is not None:
            params["pageSize"] = pagesize
            
        
        
        # Replace path parameters in URL
        path = "/virtualAccountManagement/customer/permissibleCurrencies/list/{schemeId}"
        if schemeid is not None:
            path = path.replace("{schemeId}", str(schemeid))
        
        
        # Prepare headers
        headers = {}
        if accesstoken is not None:
            headers["Accesstoken"] = str(accesstoken)
        if channeltype is not None:
            headers["ChannelType"] = str(channeltype)
        if co_relationid is not None:
            headers["Co-Relationid"] = str(co_relationid)
        if initiatingsystem is not None:
            headers["InitiatingSystem"] = str(initiatingsystem)
        if servicemode is not None:
            headers["ServiceMode"] = str(servicemode)
        if uuidseqno is not None:
            headers["UUIDSeqNo"] = str(uuidseqno)
        if entity is not None:
            headers["entity"] = str(entity)
        if languagecode is not None:
            headers["languageCode"] = str(languagecode)
        if referenceid is not None:
            headers["referenceId"] = str(referenceid)
        if requesthash is not None:
            headers["requesthash"] = str(requesthash)
        if userid is not None:
            headers["userId"] = str(userid)
        
        
        return await make_api_request(
            "GET", 
            path, 
            
            params=params if params else None, 
            headers=headers if headers else None
        )
    
    
    
    @mcp.tool()
    async def vabt0058_modify_permissible_currencies_postusing_put(
        schemeid: int,
        request_body:Dict[str, Any] ,  # modifyPermissibleCurrenciesResource,
        accesstoken: Optional[str] = None,
        channeltype: Optional[int] = None,
        co_relationid: Optional[int] = None,
        initiatingsystem: Optional[str] = None,
        servicemode: Optional[int] = None,
        uuidseqno: Optional[int] = None,
        entity: Optional[str] = None,
        languagecode: Optional[int] = None,
        referenceid: Optional[str] = None,
        requesthash: Optional[str] = None,
        userid: Optional[int] = None
    ) -> Dict[str, Any]:
        """
        Update Permissible Currency
        
        Generated from: PUT /virtualAccountManagement/customer/permissibleCurrencies/update/{schemeId}
        Source: swagger_2_0
        Operation ID: VABT0058ModifyPermissibleCurrencies_POSTUsingPUT
        
        
        Authentication: Not required
        
        Parameters:
        - schemeId: integer (required)
          Reference for the Customer Registration which will be created for unique Scheme Code and Customer Combination
        - request_body: any (required)
          input
        
        
        
        Headers:
        - Accesstoken: string
          Authorization token for identification of the caller
        - ChannelType: integer
          Channel identifier from where the TXN has originated (Internet, Mobile, ATM, Branch Channel )
        - Co-Relationid: integer
          Unique ID for the service invoked, will be set by the TXN system
        - InitiatingSystem: string
          Indicating the initiated system
        - ServiceMode: integer
          Used for branch channel to indicate the type of customer
        - UUIDSeqNo: integer
          UUID Sequence Number
        - entity: string
          entity
        - languageCode: integer
          languageCode
        - referenceId: string
          Place holder for Token based authentication
        - requesthash: string
          Request payload for hash validation
        - userId: integer
          userId
        
        
        """
        
        
        # Prepare request data
        
        # Single body parameter - send directly
        data = request_body if request_body is not None else {}
        
        
        
        # Prepare query parameters
        params = {}
        
        
        # Replace path parameters in URL
        path = "/virtualAccountManagement/customer/permissibleCurrencies/update/{schemeId}"
        if schemeid is not None:
            path = path.replace("{schemeId}", str(schemeid))
        
        
        # Prepare headers
        headers = {}
        if accesstoken is not None:
            headers["Accesstoken"] = str(accesstoken)
        if channeltype is not None:
            headers["ChannelType"] = str(channeltype)
        if co_relationid is not None:
            headers["Co-Relationid"] = str(co_relationid)
        if initiatingsystem is not None:
            headers["InitiatingSystem"] = str(initiatingsystem)
        if servicemode is not None:
            headers["ServiceMode"] = str(servicemode)
        if uuidseqno is not None:
            headers["UUIDSeqNo"] = str(uuidseqno)
        if entity is not None:
            headers["entity"] = str(entity)
        if languagecode is not None:
            headers["languageCode"] = str(languagecode)
        if referenceid is not None:
            headers["referenceId"] = str(referenceid)
        if requesthash is not None:
            headers["requesthash"] = str(requesthash)
        if userid is not None:
            headers["userId"] = str(userid)
        
        
        return await make_api_request(
            "PUT", 
            path, 
            data=data, 
            params=params if params else None, 
            headers=headers if headers else None
        )
    
    
    
    @mcp.tool()
    async def vaet0062_get_permissible_currencies_postusing_get(
        schemeid: int,
        corporateschemecode: str,
        permissiblecurrencyid: int,
        accesstoken: Optional[str] = None,
        channeltype: Optional[int] = None,
        co_relationid: Optional[int] = None,
        initiatingsystem: Optional[str] = None,
        servicemode: Optional[int] = None,
        uuidseqno: Optional[int] = None,
        entity: Optional[str] = None,
        languagecode: Optional[int] = None,
        referenceid: Optional[str] = None,
        userid: Optional[int] = None
    ) -> Dict[str, Any]:
        """
        View Permissible Currency
        
        Generated from: GET /virtualAccountManagement/customer/permissibleCurrencies/view/{schemeId}
        Source: swagger_2_0
        Operation ID: VAET0062GetPermissibleCurrencies_POSTUsingGET
        
        
        Authentication: Not required
        
        Parameters:
        - corporateSchemeCode: string (required)
          Unique reference for each Customer Scheme Registration
        - permissibleCurrencyId: integer (required)
          Unique reference id for each permissible currency
        - schemeId: integer (required)
          Reference for the Customer Registration which will be created for unique Scheme Code and Customer Combination
        
        
        
        Headers:
        - Accesstoken: string
          Authorization token for identification of the caller
        - ChannelType: integer
          Channel identifier from where the TXN has originated (Internet, Mobile, ATM, Branch Channel )
        - Co-Relationid: integer
          Unique ID for the service invoked, will be set by the TXN system
        - InitiatingSystem: string
          Indicating the initiated system
        - ServiceMode: integer
          Used for branch channel to indicate the type of customer
        - UUIDSeqNo: integer
          UUID Sequence Number
        - entity: string
          entity
        - languageCode: integer
          languageCode
        - referenceId: string
          Place holder for Token based authentication
        - userId: integer
          userId
        
        
        """
        
        
        # Prepare query parameters
        params = {}
        if corporateschemecode is not None:
            params["corporateSchemeCode"] = corporateschemecode
            
        if permissiblecurrencyid is not None:
            params["permissibleCurrencyId"] = permissiblecurrencyid
            
        
        
        # Replace path parameters in URL
        path = "/virtualAccountManagement/customer/permissibleCurrencies/view/{schemeId}"
        if schemeid is not None:
            path = path.replace("{schemeId}", str(schemeid))
        
        
        # Prepare headers
        headers = {}
        if accesstoken is not None:
            headers["Accesstoken"] = str(accesstoken)
        if channeltype is not None:
            headers["ChannelType"] = str(channeltype)
        if co_relationid is not None:
            headers["Co-Relationid"] = str(co_relationid)
        if initiatingsystem is not None:
            headers["InitiatingSystem"] = str(initiatingsystem)
        if servicemode is not None:
            headers["ServiceMode"] = str(servicemode)
        if uuidseqno is not None:
            headers["UUIDSeqNo"] = str(uuidseqno)
        if entity is not None:
            headers["entity"] = str(entity)
        if languagecode is not None:
            headers["languageCode"] = str(languagecode)
        if referenceid is not None:
            headers["referenceId"] = str(referenceid)
        if userid is not None:
            headers["userId"] = str(userid)
        
        
        return await make_api_request(
            "GET", 
            path, 
            
            params=params if params else None, 
            headers=headers if headers else None
        )
    
    
    
    @mcp.tool()
    async def vabt0054_create_settlement_account_using_post(
        request_body:Dict[str, Any] ,  # createSettlementAccntResource,
        channeltype: Optional[int] = None,
        co_relationid: Optional[int] = None,
        initiatingsystem: Optional[str] = None,
        servicemode: Optional[int] = None,
        uuidseqno: Optional[int] = None,
        authorization: Optional[str] = None,
        entity: Optional[str] = None,
        languagecode: Optional[int] = None,
        referenceid: Optional[str] = None,
        requesthash: Optional[str] = None,
        userid: Optional[int] = None
    ) -> Dict[str, Any]:
        """
        Create Settlement Account
        
        Generated from: POST /virtualAccountManagement/customer/settlementAccount
        Source: swagger_2_0
        Operation ID: VABT0054CreateSettlementAccountUsingPOST
        
        
        Authentication: Not required
        
        Parameters:
        - request_body: any (required)
          input
        
        
        
        Headers:
        - ChannelType: integer
          Channel identifier from where the TXN has originated (Internet, Mobile, ATM, Branch Channel )
        - Co-Relationid: integer
          Unique ID for the service invoked, will be set by the TXN system
        - InitiatingSystem: string
          Indicating the initiated system
        - ServiceMode: integer
          Used for branch channel to indicate the type of customer
        - UUIDSeqNo: integer
          UUID Sequence Number
        - authorization: string
          Authorization Token to validation the caller
        - entity: string
          entity
        - languageCode: integer
          languageCode
        - referenceId: string
          Identified reference field for authorization
        - requesthash: string
          Request payload for hash validation
        - userId: integer
          userId
        
        
        """
        
        
        # Prepare request data
        
        # Single body parameter - send directly
        data = request_body if request_body is not None else {}
        
        
        
        # Prepare query parameters
        params = {}
        
        
        # Replace path parameters in URL
        path = "/virtualAccountManagement/customer/settlementAccount"
        
        
        # Prepare headers
        headers = {}
        if channeltype is not None:
            headers["ChannelType"] = str(channeltype)
        if co_relationid is not None:
            headers["Co-Relationid"] = str(co_relationid)
        if initiatingsystem is not None:
            headers["InitiatingSystem"] = str(initiatingsystem)
        if servicemode is not None:
            headers["ServiceMode"] = str(servicemode)
        if uuidseqno is not None:
            headers["UUIDSeqNo"] = str(uuidseqno)
        if authorization is not None:
            headers["authorization"] = str(authorization)
        if entity is not None:
            headers["entity"] = str(entity)
        if languagecode is not None:
            headers["languageCode"] = str(languagecode)
        if referenceid is not None:
            headers["referenceId"] = str(referenceid)
        if requesthash is not None:
            headers["requesthash"] = str(requesthash)
        if userid is not None:
            headers["userId"] = str(userid)
        
        
        return await make_api_request(
            "POST", 
            path, 
            data=data, 
            params=params if params else None, 
            headers=headers if headers else None
        )
    
    
    
    @mcp.tool()
    async def vabt0055_delete_settlement_account_using_delete(
        schemeid: int,
        settlementtransitid: int,
        channeltype: Optional[int] = None,
        co_relationid: Optional[int] = None,
        initiatingsystem: Optional[str] = None,
        servicemode: Optional[int] = None,
        uuidseqno: Optional[int] = None,
        authorization: Optional[str] = None,
        entity: Optional[str] = None,
        languagecode: Optional[int] = None,
        referenceid: Optional[str] = None,
        requesthash: Optional[str] = None,
        userid: Optional[int] = None
    ) -> Dict[str, Any]:
        """
        Delete Settlement Account
        
        Generated from: DELETE /virtualAccountManagement/customer/settlementAccount/cancel/{schemeId}/{settlementTransitId}
        Source: swagger_2_0
        Operation ID: VABT0055DeleteSettlementAccountUsingDELETE
        
        
        Authentication: Not required
        
        Parameters:
        - schemeId: integer (required)
          Reference for the Customer Registration which will be created for unique Scheme Code and Customer Combination
        - settlementTransitId: integer (required)
          Unique Reference for the Accounts created
        
        
        
        Headers:
        - ChannelType: integer
          Channel identifier from where the TXN has originated (Internet, Mobile, ATM, Branch Channel )
        - Co-Relationid: integer
          Unique ID for the service invoked, will be set by the TXN system
        - InitiatingSystem: string
          Indicating the initiated system
        - ServiceMode: integer
          Used for branch channel to indicate the type of customer
        - UUIDSeqNo: integer
          UUID Sequence Number
        - authorization: string
          Authorization Token to validation the caller
        - entity: string
          entity
        - languageCode: integer
          languageCode
        - referenceId: string
          Identified reference field for authorization
        - requesthash: string
          Request payload for hash validation
        - userId: integer
          userId
        
        
        """
        
        
        # Prepare query parameters
        params = {}
        
        
        # Replace path parameters in URL
        path = "/virtualAccountManagement/customer/settlementAccount/cancel/{schemeId}/{settlementTransitId}"
        if schemeid is not None:
            path = path.replace("{schemeId}", str(schemeid))
        if settlementtransitid is not None:
            path = path.replace("{settlementTransitId}", str(settlementtransitid))
        
        
        # Prepare headers
        headers = {}
        if channeltype is not None:
            headers["ChannelType"] = str(channeltype)
        if co_relationid is not None:
            headers["Co-Relationid"] = str(co_relationid)
        if initiatingsystem is not None:
            headers["InitiatingSystem"] = str(initiatingsystem)
        if servicemode is not None:
            headers["ServiceMode"] = str(servicemode)
        if uuidseqno is not None:
            headers["UUIDSeqNo"] = str(uuidseqno)
        if authorization is not None:
            headers["authorization"] = str(authorization)
        if entity is not None:
            headers["entity"] = str(entity)
        if languagecode is not None:
            headers["languageCode"] = str(languagecode)
        if referenceid is not None:
            headers["referenceId"] = str(referenceid)
        if requesthash is not None:
            headers["requesthash"] = str(requesthash)
        if userid is not None:
            headers["userId"] = str(userid)
        
        
        return await make_api_request(
            "DELETE", 
            path, 
            
            params=params if params else None, 
            headers=headers if headers else None
        )
    
    
    
    @mcp.tool()
    async def vaet0061_get_settlement_account_using_get(
        schemeid: int,
        corporateschemecode: str,
        settlementtransitid: int,
        channeltype: Optional[int] = None,
        co_relationid: Optional[int] = None,
        initiatingsystem: Optional[str] = None,
        servicemode: Optional[int] = None,
        uuidseqno: Optional[int] = None,
        authorization: Optional[str] = None,
        entity: Optional[str] = None,
        languagecode: Optional[int] = None,
        referenceid: Optional[str] = None,
        userid: Optional[int] = None
    ) -> Dict[str, Any]:
        """
        View Settlement Account
        
        Generated from: GET /virtualAccountManagement/customer/settlementAccount/details/{schemeId}
        Source: swagger_2_0
        Operation ID: VAET0061GetSettlementAccountUsingGET
        
        
        Authentication: Not required
        
        Parameters:
        - corporateSchemeCode: string (required)
          Unique reference for each Customer Scheme Registration
        - schemeId: integer (required)
          Reference for the Customer Registration which will be created for unique Scheme Code and Customer Combination
        - settlementTransitId: integer (required)
          Unique Reference for the Accounts created
        
        
        
        Headers:
        - ChannelType: integer
          Channel identifier from where the TXN has originated (Internet, Mobile, ATM, Branch Channel )
        - Co-Relationid: integer
          Unique ID for the service invoked, will be set by the TXN system
        - InitiatingSystem: string
          Indicating the initiated system
        - ServiceMode: integer
          Used for branch channel to indicate the type of customer
        - UUIDSeqNo: integer
          UUID Sequence Number
        - authorization: string
          Authorization Token to validation the caller
        - entity: string
          entity
        - languageCode: integer
          languageCode
        - referenceId: string
          Identified reference field for authorization
        - userId: integer
          userId
        
        
        """
        
        
        # Prepare query parameters
        params = {}
        if corporateschemecode is not None:
            params["corporateSchemeCode"] = corporateschemecode
            
        if settlementtransitid is not None:
            params["settlementTransitId"] = settlementtransitid
            
        
        
        # Replace path parameters in URL
        path = "/virtualAccountManagement/customer/settlementAccount/details/{schemeId}"
        if schemeid is not None:
            path = path.replace("{schemeId}", str(schemeid))
        
        
        # Prepare headers
        headers = {}
        if channeltype is not None:
            headers["ChannelType"] = str(channeltype)
        if co_relationid is not None:
            headers["Co-Relationid"] = str(co_relationid)
        if initiatingsystem is not None:
            headers["InitiatingSystem"] = str(initiatingsystem)
        if servicemode is not None:
            headers["ServiceMode"] = str(servicemode)
        if uuidseqno is not None:
            headers["UUIDSeqNo"] = str(uuidseqno)
        if authorization is not None:
            headers["authorization"] = str(authorization)
        if entity is not None:
            headers["entity"] = str(entity)
        if languagecode is not None:
            headers["languageCode"] = str(languagecode)
        if referenceid is not None:
            headers["referenceId"] = str(referenceid)
        if userid is not None:
            headers["userId"] = str(userid)
        
        
        return await make_api_request(
            "GET", 
            path, 
            
            params=params if params else None, 
            headers=headers if headers else None
        )
    
    
    
    @mcp.tool()
    async def vaet0056_fetch_settlement_account_using_get(
        schemeid: int,
        currency: Optional[str] = None,
        purpose: Optional[int] = None,
        settlementaccountreference: Optional[str] = None,
        channeltype: Optional[int] = None,
        co_relationid: Optional[int] = None,
        initiatingsystem: Optional[str] = None,
        servicemode: Optional[int] = None,
        uuidseqno: Optional[int] = None,
        authorization: Optional[str] = None,
        entity: Optional[str] = None,
        languagecode: Optional[int] = None,
        referenceid: Optional[str] = None,
        userid: Optional[int] = None
    ) -> Dict[str, Any]:
        """
        Fetch Settlement Account List
        
        Generated from: GET /virtualAccountManagement/customer/settlementAccount/list/{schemeId}
        Source: swagger_2_0
        Operation ID: VAET0056FetchSettlementAccountUsingGET
        
        
        Authentication: Not required
        
        Parameters:
        - currency: string
          Currency for which the Settlement account is permitted to be linked to that Corporate Scheme(SAR, USD, EUR,INR)
        - purpose: integer
          Purpose for which the account is captured.(Settlement-1,TransitBooking-2,Code Name:d_VA_Purpose)
        - schemeId: integer (required)
          Reference for the Customer Registration which will be created for unique Scheme Code and Customer Combination
        - settlementAccountReference: string
          Settlement Account Reference
        
        
        
        Headers:
        - ChannelType: integer
          Channel identifier from where the TXN has originated (Internet, Mobile, ATM, Branch Channel )
        - Co-Relationid: integer
          Unique ID for the service invoked, will be set by the TXN system
        - InitiatingSystem: string
          Indicating the initiated system
        - ServiceMode: integer
          Used for branch channel to indicate the type of customer
        - UUIDSeqNo: integer
          UUID Sequence Number
        - authorization: string
          Authorization Token to validation the caller
        - entity: string
          entity
        - languageCode: integer
          languageCode
        - referenceId: string
          Identified reference field for authorization
        - userId: integer
          userId
        
        
        """
        
        
        # Prepare query parameters
        params = {}
        if currency is not None:
            params["currency"] = currency
            
        if purpose is not None:
            params["purpose"] = purpose
            
        if settlementaccountreference is not None:
            params["settlementAccountReference"] = settlementaccountreference
            
        
        
        # Replace path parameters in URL
        path = "/virtualAccountManagement/customer/settlementAccount/list/{schemeId}"
        if schemeid is not None:
            path = path.replace("{schemeId}", str(schemeid))
        
        
        # Prepare headers
        headers = {}
        if channeltype is not None:
            headers["ChannelType"] = str(channeltype)
        if co_relationid is not None:
            headers["Co-Relationid"] = str(co_relationid)
        if initiatingsystem is not None:
            headers["InitiatingSystem"] = str(initiatingsystem)
        if servicemode is not None:
            headers["ServiceMode"] = str(servicemode)
        if uuidseqno is not None:
            headers["UUIDSeqNo"] = str(uuidseqno)
        if authorization is not None:
            headers["authorization"] = str(authorization)
        if entity is not None:
            headers["entity"] = str(entity)
        if languagecode is not None:
            headers["languageCode"] = str(languagecode)
        if referenceid is not None:
            headers["referenceId"] = str(referenceid)
        if userid is not None:
            headers["userId"] = str(userid)
        
        
        return await make_api_request(
            "GET", 
            path, 
            
            params=params if params else None, 
            headers=headers if headers else None
        )
    
    
    
    @mcp.tool()
    async def vabt0055_modify_settlement_account_using_put(
        schemeid: int,
        request_body:Dict[str, Any] ,  # updateSettlementAccntResource,
        channeltype: Optional[int] = None,
        co_relationid: Optional[int] = None,
        initiatingsystem: Optional[str] = None,
        servicemode: Optional[int] = None,
        uuidseqno: Optional[int] = None,
        authorization: Optional[str] = None,
        entity: Optional[str] = None,
        languagecode: Optional[int] = None,
        referenceid: Optional[str] = None,
        requesthash: Optional[str] = None,
        userid: Optional[int] = None
    ) -> Dict[str, Any]:
        """
        Updation of Settlement Account
        
        Generated from: PUT /virtualAccountManagement/customer/settlementAccount/update/{schemeId}
        Source: swagger_2_0
        Operation ID: VABT0055ModifySettlementAccountUsingPUT
        
        
        Authentication: Not required
        
        Parameters:
        - schemeId: integer (required)
          Reference for the Customer Registration which will be created for unique Scheme Code and Customer Combination
        - request_body: any (required)
          input
        
        
        
        Headers:
        - ChannelType: integer
          Channel identifier from where the TXN has originated (Internet, Mobile, ATM, Branch Channel )
        - Co-Relationid: integer
          Unique ID for the service invoked, will be set by the TXN system
        - InitiatingSystem: string
          Indicating the initiated system
        - ServiceMode: integer
          Used for branch channel to indicate the type of customer
        - UUIDSeqNo: integer
          UUID Sequence Number
        - authorization: string
          Authorization Token to validation the caller
        - entity: string
          entity
        - languageCode: integer
          languageCode
        - referenceId: string
          Identified reference field for authorization
        - requesthash: string
          Request payload for hash validation
        - userId: integer
          userId
        
        
        """
        
        
        # Prepare request data
        
        # Single body parameter - send directly
        data = request_body if request_body is not None else {}
        
        
        
        # Prepare query parameters
        params = {}
        
        
        # Replace path parameters in URL
        path = "/virtualAccountManagement/customer/settlementAccount/update/{schemeId}"
        if schemeid is not None:
            path = path.replace("{schemeId}", str(schemeid))
        
        
        # Prepare headers
        headers = {}
        if channeltype is not None:
            headers["ChannelType"] = str(channeltype)
        if co_relationid is not None:
            headers["Co-Relationid"] = str(co_relationid)
        if initiatingsystem is not None:
            headers["InitiatingSystem"] = str(initiatingsystem)
        if servicemode is not None:
            headers["ServiceMode"] = str(servicemode)
        if uuidseqno is not None:
            headers["UUIDSeqNo"] = str(uuidseqno)
        if authorization is not None:
            headers["authorization"] = str(authorization)
        if entity is not None:
            headers["entity"] = str(entity)
        if languagecode is not None:
            headers["languageCode"] = str(languagecode)
        if referenceid is not None:
            headers["referenceId"] = str(referenceid)
        if requesthash is not None:
            headers["requesthash"] = str(requesthash)
        if userid is not None:
            headers["userId"] = str(userid)
        
        
        return await make_api_request(
            "PUT", 
            path, 
            data=data, 
            params=params if params else None, 
            headers=headers if headers else None
        )
    
    
    
    @mcp.tool()
    async def vabt0003_authorise_registered_customer_using_post(
        schemeid: str,
        request_body:Dict[str, Any] ,  # AuthoriseRegisterCustomer_Resource,
        accesstoken: Optional[str] = None,
        channeltype: Optional[int] = None,
        co_relationid: Optional[int] = None,
        initiatingsystem: Optional[str] = None,
        servicemode: Optional[int] = None,
        uuidseqno: Optional[int] = None,
        entity: Optional[str] = None,
        referenceid: Optional[str] = None,
        requesthash: Optional[str] = None,
        userid: Optional[int] = None
    ) -> Dict[str, Any]:
        """
        This Service will Authorise a Registered Customer to become an Active Registered Customer in TCS BANCS
        
        Generated from: POST /virtualAccountManagement/customer/{schemeId}/authorise
        Source: swagger_2_0
        Operation ID: VABT0003AuthoriseRegisteredCustomerUsingPOST
        
        
        Authentication: Not required
        
        Parameters:
        - schemeId: string (required)
          Path parameter schemeId
        - request_body: any (required)
          input
        
        
        
        Headers:
        - Accesstoken: string
          Authorization Token to validation the caller
        - ChannelType: integer
          Channel identifier from where the TXN has originated (Internet, Mobile, ATM, Branch Channel )
        - Co-Relationid: integer
          Unique ID for the service invoked, will be set by the TXN system
        - InitiatingSystem: string
          Indicating the initiated system
        - ServiceMode: integer
          Used for branch channel to indicate the type of customer
        - UUIDSeqNo: integer
          UUID Sequence Number
        - entity: string
          entity
        - referenceId: string
          Place holder for Token based authentication
        - requesthash: string
          Request payload for hash validation
        - userId: integer
          userId
        
        
        """
        
        
        # Prepare request data
        
        # Single body parameter - send directly
        data = request_body if request_body is not None else {}
        
        
        
        # Prepare query parameters
        params = {}
        
        
        # Replace path parameters in URL
        path = "/virtualAccountManagement/customer/{schemeId}/authorise"
        if schemeid is not None:
            path = path.replace("{schemeId}", str(schemeid))
        
        
        # Prepare headers
        headers = {}
        if accesstoken is not None:
            headers["Accesstoken"] = str(accesstoken)
        if channeltype is not None:
            headers["ChannelType"] = str(channeltype)
        if co_relationid is not None:
            headers["Co-Relationid"] = str(co_relationid)
        if initiatingsystem is not None:
            headers["InitiatingSystem"] = str(initiatingsystem)
        if servicemode is not None:
            headers["ServiceMode"] = str(servicemode)
        if uuidseqno is not None:
            headers["UUIDSeqNo"] = str(uuidseqno)
        if entity is not None:
            headers["entity"] = str(entity)
        if referenceid is not None:
            headers["referenceId"] = str(referenceid)
        if requesthash is not None:
            headers["requesthash"] = str(requesthash)
        if userid is not None:
            headers["userId"] = str(userid)
        
        
        return await make_api_request(
            "POST", 
            path, 
            data=data, 
            params=params if params else None, 
            headers=headers if headers else None
        )
    
    
    
    @mcp.tool()
    async def vabt0008_cancel_registration_using_post(
        schemeid: str,
        request_body:Dict[str, Any] ,  # CancelRegistration_Resource,
        accesstoken: Optional[str] = None,
        channeltype: Optional[int] = None,
        co_relationid: Optional[int] = None,
        initiatingsystem: Optional[str] = None,
        servicemode: Optional[int] = None,
        uuidseqno: Optional[int] = None,
        entity: Optional[str] = None,
        referenceid: Optional[str] = None,
        requesthash: Optional[str] = None,
        userid: Optional[int] = None
    ) -> Dict[str, Any]:
        """
        This API will be used to Cancel/Close the Registered Customer.
        
        Generated from: POST /virtualAccountManagement/customer/{schemeId}/cancel
        Source: swagger_2_0
        Operation ID: VABT0008CancelRegistrationUsingPOST
        
        
        Authentication: Not required
        
        Parameters:
        - schemeId: string (required)
          Path parameter schemeId
        - request_body: any (required)
          input
        
        
        
        Headers:
        - Accesstoken: string
          Authorization Token to validation the caller
        - ChannelType: integer
          Channel identifier from where the TXN has originated (Internet, Mobile, ATM, Branch Channel )
        - Co-Relationid: integer
          Unique ID for the service invoked, will be set by the TXN system
        - InitiatingSystem: string
          Indicating the initiated system
        - ServiceMode: integer
          Used for branch channel to indicate the type of customer
        - UUIDSeqNo: integer
          UUID Sequence Number
        - entity: string
          entity
        - referenceId: string
          Place holder for Token based authentication
        - requesthash: string
          Request payload for hash validation
        - userId: integer
          userId
        
        
        """
        
        
        # Prepare request data
        
        # Single body parameter - send directly
        data = request_body if request_body is not None else {}
        
        
        
        # Prepare query parameters
        params = {}
        
        
        # Replace path parameters in URL
        path = "/virtualAccountManagement/customer/{schemeId}/cancel"
        if schemeid is not None:
            path = path.replace("{schemeId}", str(schemeid))
        
        
        # Prepare headers
        headers = {}
        if accesstoken is not None:
            headers["Accesstoken"] = str(accesstoken)
        if channeltype is not None:
            headers["ChannelType"] = str(channeltype)
        if co_relationid is not None:
            headers["Co-Relationid"] = str(co_relationid)
        if initiatingsystem is not None:
            headers["InitiatingSystem"] = str(initiatingsystem)
        if servicemode is not None:
            headers["ServiceMode"] = str(servicemode)
        if uuidseqno is not None:
            headers["UUIDSeqNo"] = str(uuidseqno)
        if entity is not None:
            headers["entity"] = str(entity)
        if referenceid is not None:
            headers["referenceId"] = str(referenceid)
        if requesthash is not None:
            headers["requesthash"] = str(requesthash)
        if userid is not None:
            headers["userId"] = str(userid)
        
        
        return await make_api_request(
            "POST", 
            path, 
            data=data, 
            params=params if params else None, 
            headers=headers if headers else None
        )
    
    
    
    @mcp.tool()
    async def vaet0007_viewregistered_customers_using_get(
        schemeid: int,
        pagenum: Optional[int] = None,
        pagesize: Optional[int] = None,
        channeltype: Optional[int] = None,
        co_relationid: Optional[int] = None,
        initiatingsystem: Optional[str] = None,
        servicemode: Optional[int] = None,
        uuidseqno: Optional[int] = None,
        authorization: Optional[str] = None,
        entity: Optional[str] = None,
        referenceid: Optional[str] = None,
        userid: Optional[int] = None
    ) -> Dict[str, Any]:
        """
        This service will be used to display details of the registered customers
        
        Generated from: GET /virtualAccountManagement/customer/{schemeId}/details
        Source: swagger_2_0
        Operation ID: VAET0007ViewregisteredCustomersUsingGET
        
        
        Authentication: Not required
        
        Parameters:
        - pageNum: integer
          pageNum
        - pageSize: integer
          pageSize
        - schemeId: integer (required)
          Unique Reference for the Customer Registration which will happen for unique Scheme Code and Customer Combination
        
        
        
        Headers:
        - ChannelType: integer
          Channel identifier from where the TXN has originated (Internet, Mobile, ATM, Branch Channel )
        - Co-Relationid: integer
          Unique ID for the service invoked, will be set by the TXN system
        - InitiatingSystem: string
          Indicating the initiated system
        - ServiceMode: integer
          Used for branch channel to indicate the type of customer
        - UUIDSeqNo: integer
          UUID Sequence Number
        - authorization: string
          Authorization Token to validation the caller
        - entity: string
          entity
        - referenceId: string
          Identified reference field for authorization
        - userId: integer
          userId
        
        
        """
        
        
        # Prepare query parameters
        params = {}
        if pagenum is not None:
            params["pageNum"] = pagenum
            
        if pagesize is not None:
            params["pageSize"] = pagesize
            
        
        
        # Replace path parameters in URL
        path = "/virtualAccountManagement/customer/{schemeId}/details"
        if schemeid is not None:
            path = path.replace("{schemeId}", str(schemeid))
        
        
        # Prepare headers
        headers = {}
        if channeltype is not None:
            headers["ChannelType"] = str(channeltype)
        if co_relationid is not None:
            headers["Co-Relationid"] = str(co_relationid)
        if initiatingsystem is not None:
            headers["InitiatingSystem"] = str(initiatingsystem)
        if servicemode is not None:
            headers["ServiceMode"] = str(servicemode)
        if uuidseqno is not None:
            headers["UUIDSeqNo"] = str(uuidseqno)
        if authorization is not None:
            headers["authorization"] = str(authorization)
        if entity is not None:
            headers["entity"] = str(entity)
        if referenceid is not None:
            headers["referenceId"] = str(referenceid)
        if userid is not None:
            headers["userId"] = str(userid)
        
        
        return await make_api_request(
            "GET", 
            path, 
            
            params=params if params else None, 
            headers=headers if headers else None
        )
    
    
    
    @mcp.tool()
    async def vabt0005_reject_registration_using_post(
        schemeid: str,
        request_body:Dict[str, Any] ,  # RejectRegistration_Resource,
        accesstoken: Optional[str] = None,
        channeltype: Optional[int] = None,
        co_relationid: Optional[int] = None,
        initiatingsystem: Optional[str] = None,
        servicemode: Optional[int] = None,
        uuidseqno: Optional[int] = None,
        entity: Optional[str] = None,
        referenceid: Optional[str] = None,
        requesthash: Optional[str] = None,
        userid: Optional[int] = None
    ) -> Dict[str, Any]:
        """
        This Service will Reject Registered Customer in the system.
        
        Generated from: POST /virtualAccountManagement/customer/{schemeId}/reject
        Source: swagger_2_0
        Operation ID: VABT0005RejectRegistrationUsingPOST
        
        
        Authentication: Not required
        
        Parameters:
        - schemeId: string (required)
          Path parameter schemeId
        - request_body: any (required)
          input
        
        
        
        Headers:
        - Accesstoken: string
          Authorization Token to validation the caller
        - ChannelType: integer
          Channel identifier from where the TXN has originated (Internet, Mobile, ATM, Branch Channel )
        - Co-Relationid: integer
          Unique ID for the service invoked, will be set by the TXN system
        - InitiatingSystem: string
          Indicating the initiated system
        - ServiceMode: integer
          Used for branch channel to indicate the type of customer
        - UUIDSeqNo: integer
          UUID Sequence Number
        - entity: string
          entity
        - referenceId: string
          Place holder for Token based authentication
        - requesthash: string
          Request payload for hash validation
        - userId: integer
          userId
        
        
        """
        
        
        # Prepare request data
        
        # Single body parameter - send directly
        data = request_body if request_body is not None else {}
        
        
        
        # Prepare query parameters
        params = {}
        
        
        # Replace path parameters in URL
        path = "/virtualAccountManagement/customer/{schemeId}/reject"
        if schemeid is not None:
            path = path.replace("{schemeId}", str(schemeid))
        
        
        # Prepare headers
        headers = {}
        if accesstoken is not None:
            headers["Accesstoken"] = str(accesstoken)
        if channeltype is not None:
            headers["ChannelType"] = str(channeltype)
        if co_relationid is not None:
            headers["Co-Relationid"] = str(co_relationid)
        if initiatingsystem is not None:
            headers["InitiatingSystem"] = str(initiatingsystem)
        if servicemode is not None:
            headers["ServiceMode"] = str(servicemode)
        if uuidseqno is not None:
            headers["UUIDSeqNo"] = str(uuidseqno)
        if entity is not None:
            headers["entity"] = str(entity)
        if referenceid is not None:
            headers["referenceId"] = str(referenceid)
        if requesthash is not None:
            headers["requesthash"] = str(requesthash)
        if userid is not None:
            headers["userId"] = str(userid)
        
        
        return await make_api_request(
            "POST", 
            path, 
            data=data, 
            params=params if params else None, 
            headers=headers if headers else None
        )
    
    
    
    @mcp.tool()
    async def vabt0007_sendback_registration_using_post(
        schemeid: str,
        request_body:Dict[str, Any] ,  # SendbackRegistration_Resource,
        accesstoken: Optional[str] = None,
        channeltype: Optional[int] = None,
        co_relationid: Optional[int] = None,
        initiatingsystem: Optional[str] = None,
        servicemode: Optional[int] = None,
        uuidseqno: Optional[int] = None,
        entity: Optional[str] = None,
        referenceid: Optional[str] = None,
        requesthash: Optional[str] = None,
        userid: Optional[int] = None
    ) -> Dict[str, Any]:
        """
        This Service will Send Back a Registered Customer to its previous Status.
        
        Generated from: POST /virtualAccountManagement/customer/{schemeId}/sendback
        Source: swagger_2_0
        Operation ID: VABT0007SendbackRegistrationUsingPOST
        
        
        Authentication: Not required
        
        Parameters:
        - schemeId: string (required)
          Path parameter schemeId
        - request_body: any (required)
          input
        
        
        
        Headers:
        - Accesstoken: string
          Authorization Token to validation the caller
        - ChannelType: integer
          Channel identifier from where the TXN has originated (Internet, Mobile, ATM, Branch Channel )
        - Co-Relationid: integer
          Unique ID for the service invoked, will be set by the TXN system
        - InitiatingSystem: string
          Indicating the initiated system
        - ServiceMode: integer
          Used for branch channel to indicate the type of customer
        - UUIDSeqNo: integer
          UUID Sequence Number
        - entity: string
          entity
        - referenceId: string
          Place holder for Token based authentication
        - requesthash: string
          Request payload for hash validation
        - userId: integer
          userId
        
        
        """
        
        
        # Prepare request data
        
        # Single body parameter - send directly
        data = request_body if request_body is not None else {}
        
        
        
        # Prepare query parameters
        params = {}
        
        
        # Replace path parameters in URL
        path = "/virtualAccountManagement/customer/{schemeId}/sendback"
        if schemeid is not None:
            path = path.replace("{schemeId}", str(schemeid))
        
        
        # Prepare headers
        headers = {}
        if accesstoken is not None:
            headers["Accesstoken"] = str(accesstoken)
        if channeltype is not None:
            headers["ChannelType"] = str(channeltype)
        if co_relationid is not None:
            headers["Co-Relationid"] = str(co_relationid)
        if initiatingsystem is not None:
            headers["InitiatingSystem"] = str(initiatingsystem)
        if servicemode is not None:
            headers["ServiceMode"] = str(servicemode)
        if uuidseqno is not None:
            headers["UUIDSeqNo"] = str(uuidseqno)
        if entity is not None:
            headers["entity"] = str(entity)
        if referenceid is not None:
            headers["referenceId"] = str(referenceid)
        if requesthash is not None:
            headers["requesthash"] = str(requesthash)
        if userid is not None:
            headers["userId"] = str(userid)
        
        
        return await make_api_request(
            "POST", 
            path, 
            data=data, 
            params=params if params else None, 
            headers=headers if headers else None
        )
    
    
    
    @mcp.tool()
    async def cbcet101_validate_fee_package_using_get(
        feepackageid: int,
        pagenum: Optional[int] = None,
        pagesize: Optional[int] = None,
        accesstoken: Optional[str] = None,
        channeltype: Optional[int] = None,
        co_relationid: Optional[int] = None,
        initiatingsystem: Optional[str] = None,
        servicemode: Optional[int] = None,
        uuidseqno: Optional[int] = None,
        entity: Optional[str] = None,
        referenceid: Optional[str] = None,
        requesthash: Optional[str] = None,
        userid: Optional[int] = None
    ) -> Dict[str, Any]:
        """
        This service is used to Validate Fee Package added during the registration of customer scheme
        
        Generated from: GET /virtualAccountManagement/feePackage/{feePackageId}
        Source: swagger_2_0
        Operation ID: CBCET101ValidateFeePackageUsingGET
        
        
        Authentication: Not required
        
        Parameters:
        - feePackageId: integer (required)
          Unique Reference of the Fee Package used for calculating prices at Customer Level
        - pageNum: integer
          pageNum
        - pageSize: integer
          pageSize
        
        
        
        Headers:
        - Accesstoken: string
          Authorization Token to validation the caller
        - ChannelType: integer
          Channel identifier from where the TXN has originated (Internet, Mobile, ATM, Branch Channel )
        - Co-Relationid: integer
          Unique ID for the service invoked, will be set by the TXN system
        - InitiatingSystem: string
          Indicating the initiated system
        - ServiceMode: integer
          Used for branch channel to indicate the type of customer
        - UUIDSeqNo: integer
          UUID Sequence Number
        - entity: string
          entity
        - referenceId: string
          Place holder for Token based authentication
        - requesthash: string
          Request payload for hash validation
        - userId: integer
          userId
        
        
        """
        
        
        # Prepare query parameters
        params = {}
        if pagenum is not None:
            params["pageNum"] = pagenum
            
        if pagesize is not None:
            params["pageSize"] = pagesize
            
        
        
        # Replace path parameters in URL
        path = "/virtualAccountManagement/feePackage/{feePackageId}"
        if feepackageid is not None:
            path = path.replace("{feePackageId}", str(feepackageid))
        
        
        # Prepare headers
        headers = {}
        if accesstoken is not None:
            headers["Accesstoken"] = str(accesstoken)
        if channeltype is not None:
            headers["ChannelType"] = str(channeltype)
        if co_relationid is not None:
            headers["Co-Relationid"] = str(co_relationid)
        if initiatingsystem is not None:
            headers["InitiatingSystem"] = str(initiatingsystem)
        if servicemode is not None:
            headers["ServiceMode"] = str(servicemode)
        if uuidseqno is not None:
            headers["UUIDSeqNo"] = str(uuidseqno)
        if entity is not None:
            headers["entity"] = str(entity)
        if referenceid is not None:
            headers["referenceId"] = str(referenceid)
        if requesthash is not None:
            headers["requesthash"] = str(requesthash)
        if userid is not None:
            headers["userId"] = str(userid)
        
        
        return await make_api_request(
            "GET", 
            path, 
            
            params=params if params else None, 
            headers=headers if headers else None
        )
    
    
    
    @mcp.tool()
    async def vaet0078_fetch_invoice_dtls_getusing_get(
        accountnumber: Optional[str] = None,
        corporateschemecode: Optional[str] = None,
        customerreference: Optional[str] = None,
        duedatetill: Optional[str] = None,
        invoicedate: Optional[str] = None,
        invoicedatetill: Optional[str] = None,
        invoiceduedate: Optional[str] = None,
        invoicefilereference: Optional[str] = None,
        invoicenumber: Optional[str] = None,
        pagenum: Optional[int] = None,
        pagesize: Optional[int] = None,
        status: Optional[int] = None,
        virtualaccountnumber: Optional[str] = None,
        virtualaccountnumberformat: Optional[int] = None,
        accesstoken: Optional[str] = None,
        channeltype: Optional[int] = None,
        co_relationid: Optional[int] = None,
        initiatingsystem: Optional[str] = None,
        servicemode: Optional[int] = None,
        uuidseqno: Optional[int] = None,
        entity: Optional[str] = None,
        languagecode: Optional[int] = None,
        referenceid: Optional[str] = None,
        userid: Optional[int] = None
    ) -> Dict[str, Any]:
        """
        This API will fetch invoice Details
        
        Generated from: GET /virtualAccountManagement/invoiceDetails/list
        Source: swagger_2_0
        Operation ID: VAET0078FetchInvoiceDtls_GETUsingGET
        
        
        Authentication: Not required
        
        Parameters:
        - accountNumber: string
          Unique Reference generated for each Virtual Account
        - corporateSchemeCode: string
          Unique reference for each Customer Scheme Registration
        - customerReference: string
          Business Partner Reference or equivalent identifier uniquely assigned to the customer
        - dueDateTill: string
          The date on which the invoice payment is due till
        - invoiceDate: string
          Invoice Date as received for the invoice
        - invoiceDateTill: string
          Invoice Date as received for the invoice till
        - invoiceDueDate: string
          The date on which the invoice payment is due.
        - invoiceFileReference: string
          Invoice File Ref which is expected to be unique for each uploaded invoice file
        - invoiceNumber: string
          Invoice Number as received for the invoice
        - pageNum: integer
          pageNum
        - pageSize: integer
          pageSize
        - status: integer
          Status of invoice.(1-Unpaid,2-PartiallyPaid,3-Cancelled,4-Paid,5-ActiveInvoice,6-CompletedInvoice,7-AllInvoice,codeName:d_VA_InvoiceStatus)
        - virtualAccountNumber: string
          Virtual Account Number on which the invoice is raised. Payment for the invoice is expected on this virtual account.
        - virtualAccountNumberFormat: integer
          Format Type of VirtualAccount (1-IBAN,2-BBAN,3-AccountReference1,4-AccountReference2)
        
        
        
        Headers:
        - Accesstoken: string
          Authorization token for identification of the caller
        - ChannelType: integer
          Channel identifier from where the TXN has originated (Internet, Mobile, ATM, Branch Channel )
        - Co-Relationid: integer
          Unique ID for the service invoked, will be set by the TXN system
        - InitiatingSystem: string
          Indicating the initiated system
        - ServiceMode: integer
          Used for branch channel to indicate the type of customer
        - UUIDSeqNo: integer
          UUID Sequence Number
        - entity: string
          entity
        - languageCode: integer
          languageCode
        - referenceId: string
          Place holder for Token based authentication
        - userId: integer
          userId
        
        
        """
        
        
        # Prepare query parameters
        params = {}
        if accountnumber is not None:
            params["accountNumber"] = accountnumber
            
        if corporateschemecode is not None:
            params["corporateSchemeCode"] = corporateschemecode
            
        if customerreference is not None:
            params["customerReference"] = customerreference
            
        if duedatetill is not None:
            params["dueDateTill"] = duedatetill
            
        if invoicedate is not None:
            params["invoiceDate"] = invoicedate
            
        if invoicedatetill is not None:
            params["invoiceDateTill"] = invoicedatetill
            
        if invoiceduedate is not None:
            params["invoiceDueDate"] = invoiceduedate
            
        if invoicefilereference is not None:
            params["invoiceFileReference"] = invoicefilereference
            
        if invoicenumber is not None:
            params["invoiceNumber"] = invoicenumber
            
        if pagenum is not None:
            params["pageNum"] = pagenum
            
        if pagesize is not None:
            params["pageSize"] = pagesize
            
        if status is not None:
            params["status"] = status
            
        if virtualaccountnumber is not None:
            params["virtualAccountNumber"] = virtualaccountnumber
            
        if virtualaccountnumberformat is not None:
            params["virtualAccountNumberFormat"] = virtualaccountnumberformat
            
        
        
        # Replace path parameters in URL
        path = "/virtualAccountManagement/invoiceDetails/list"
        
        
        # Prepare headers
        headers = {}
        if accesstoken is not None:
            headers["Accesstoken"] = str(accesstoken)
        if channeltype is not None:
            headers["ChannelType"] = str(channeltype)
        if co_relationid is not None:
            headers["Co-Relationid"] = str(co_relationid)
        if initiatingsystem is not None:
            headers["InitiatingSystem"] = str(initiatingsystem)
        if servicemode is not None:
            headers["ServiceMode"] = str(servicemode)
        if uuidseqno is not None:
            headers["UUIDSeqNo"] = str(uuidseqno)
        if entity is not None:
            headers["entity"] = str(entity)
        if languagecode is not None:
            headers["languageCode"] = str(languagecode)
        if referenceid is not None:
            headers["referenceId"] = str(referenceid)
        if userid is not None:
            headers["userId"] = str(userid)
        
        
        return await make_api_request(
            "GET", 
            path, 
            
            params=params if params else None, 
            headers=headers if headers else None
        )
    
    
    
    @mcp.tool()
    async def vabt0082_mantn_vainvoice_dtls_postusing_post(
        request_body:Dict[str, Any] ,  # manitainInvoiceDetailsResource,
        accesstoken: Optional[str] = None,
        channeltype: Optional[int] = None,
        co_relationid: Optional[int] = None,
        initiatingsystem: Optional[str] = None,
        servicemode: Optional[int] = None,
        uuidseqno: Optional[int] = None,
        entity: Optional[str] = None,
        languagecode: Optional[int] = None,
        referenceid: Optional[str] = None,
        requesthash: Optional[str] = None,
        userid: Optional[int] = None
    ) -> Dict[str, Any]:
        """
        This API Validate and create the Invoice details
        
        Generated from: POST /virtualAccountManagement/invoiceDetails/maintain
        Source: swagger_2_0
        Operation ID: VABT0082MantnVAInvoiceDtls_POSTUsingPOST
        
        
        Authentication: Not required
        
        Parameters:
        - request_body: any (required)
          input
        
        
        
        Headers:
        - Accesstoken: string
          Authorization token for identification of the caller
        - ChannelType: integer
          Channel identifier from where the TXN has originated (Internet, Mobile, ATM, Branch Channel )
        - Co-Relationid: integer
          Unique ID for the service invoked, will be set by the TXN system
        - InitiatingSystem: string
          Indicating the initiated system
        - ServiceMode: integer
          Used for branch channel to indicate the type of customer
        - UUIDSeqNo: integer
          UUID Sequence Number
        - entity: string
          entity
        - languageCode: integer
          languageCode
        - referenceId: string
          Place holder for Token based authentication
        - requesthash: string
          Request payload for hash validation
        - userId: integer
          userId
        
        
        """
        
        
        # Prepare request data
        
        # Single body parameter - send directly
        data = request_body if request_body is not None else {}
        
        
        
        # Prepare query parameters
        params = {}
        
        
        # Replace path parameters in URL
        path = "/virtualAccountManagement/invoiceDetails/maintain"
        
        
        # Prepare headers
        headers = {}
        if accesstoken is not None:
            headers["Accesstoken"] = str(accesstoken)
        if channeltype is not None:
            headers["ChannelType"] = str(channeltype)
        if co_relationid is not None:
            headers["Co-Relationid"] = str(co_relationid)
        if initiatingsystem is not None:
            headers["InitiatingSystem"] = str(initiatingsystem)
        if servicemode is not None:
            headers["ServiceMode"] = str(servicemode)
        if uuidseqno is not None:
            headers["UUIDSeqNo"] = str(uuidseqno)
        if entity is not None:
            headers["entity"] = str(entity)
        if languagecode is not None:
            headers["languageCode"] = str(languagecode)
        if referenceid is not None:
            headers["referenceId"] = str(referenceid)
        if requesthash is not None:
            headers["requesthash"] = str(requesthash)
        if userid is not None:
            headers["userId"] = str(userid)
        
        
        return await make_api_request(
            "POST", 
            path, 
            data=data, 
            params=params if params else None, 
            headers=headers if headers else None
        )
    
    
    
    @mcp.tool()
    async def vabt0084_crt_vapymt_dtls_postusing_post(
        request_body:Dict[str, Any] ,  # createPaymentDetailsResource,
        accesstoken: Optional[str] = None,
        channeltype: Optional[int] = None,
        co_relationid: Optional[int] = None,
        initiatingsystem: Optional[str] = None,
        servicemode: Optional[int] = None,
        uuidseqno: Optional[int] = None,
        entity: Optional[str] = None,
        languagecode: Optional[int] = None,
        referenceid: Optional[str] = None,
        requesthash: Optional[str] = None,
        userid: Optional[int] = None
    ) -> Dict[str, Any]:
        """
        This API will create payment details
        
        Generated from: POST /virtualAccountManagement/paymentDetails
        Source: swagger_2_0
        Operation ID: VABT0084CrtVAPymtDtls_POSTUsingPOST
        
        
        Authentication: Not required
        
        Parameters:
        - request_body: any (required)
          input
        
        
        
        Headers:
        - Accesstoken: string
          Authorization token for identification of the caller
        - ChannelType: integer
          Channel identifier from where the TXN has originated (Internet, Mobile, ATM, Branch Channel )
        - Co-Relationid: integer
          Unique ID for the service invoked, will be set by the TXN system
        - InitiatingSystem: string
          Indicating the initiated system
        - ServiceMode: integer
          Used for branch channel to indicate the type of customer
        - UUIDSeqNo: integer
          UUID Sequence Number
        - entity: string
          entity
        - languageCode: integer
          languageCode
        - referenceId: string
          Place holder for Token based authentication
        - requesthash: string
          Request payload for hash validation
        - userId: integer
          userId
        
        
        """
        
        
        # Prepare request data
        
        # Single body parameter - send directly
        data = request_body if request_body is not None else {}
        
        
        
        # Prepare query parameters
        params = {}
        
        
        # Replace path parameters in URL
        path = "/virtualAccountManagement/paymentDetails"
        
        
        # Prepare headers
        headers = {}
        if accesstoken is not None:
            headers["Accesstoken"] = str(accesstoken)
        if channeltype is not None:
            headers["ChannelType"] = str(channeltype)
        if co_relationid is not None:
            headers["Co-Relationid"] = str(co_relationid)
        if initiatingsystem is not None:
            headers["InitiatingSystem"] = str(initiatingsystem)
        if servicemode is not None:
            headers["ServiceMode"] = str(servicemode)
        if uuidseqno is not None:
            headers["UUIDSeqNo"] = str(uuidseqno)
        if entity is not None:
            headers["entity"] = str(entity)
        if languagecode is not None:
            headers["languageCode"] = str(languagecode)
        if referenceid is not None:
            headers["referenceId"] = str(referenceid)
        if requesthash is not None:
            headers["requesthash"] = str(requesthash)
        if userid is not None:
            headers["userId"] = str(userid)
        
        
        return await make_api_request(
            "POST", 
            path, 
            data=data, 
            params=params if params else None, 
            headers=headers if headers else None
        )
    
    
    
    @mcp.tool()
    async def vabt0095_vacor_cust_pymt_ack_nack_postusing_post(
        request_body:Dict[str, Any] ,  # corporateCustomerAckNackRequest,
        channeltype: Optional[int] = None,
        co_relationid: Optional[int] = None,
        initiatingsystem: Optional[str] = None,
        servicemode: Optional[int] = None,
        uuidseqno: Optional[int] = None,
        entity: Optional[str] = None,
        languagecode: Optional[int] = None,
        userid: Optional[int] = None
    ) -> Dict[str, Any]:
        """
        This API will receive Ack or Nack from Customer
        
        Generated from: POST /virtualAccountManagement/paymentDetails/ackNackApi
        Source: swagger_2_0
        Operation ID: VABT0095VACorCustPymtAckNack_POSTUsingPOST
        
        
        Authentication: Not required
        
        Parameters:
        - request_body: any (required)
          input
        
        
        
        Headers:
        - ChannelType: integer
          Channel identifier from where the TXN has originated (Internet, Mobile, ATM, Branch Channel
        - Co-Relationid: integer
          Unique ID for the service invoked, will be set by the TXN system
        - InitiatingSystem: string
          Indicating the initiated system
        - ServiceMode: integer
          Used for branch channel to indicate the type of customer
        - UUIDSeqNo: integer
          UUID Sequence Number
        - entity: string
          entity
        - languageCode: integer
          languageCode
        - userId: integer
          userId
        
        
        """
        
        
        # Prepare request data
        
        # Single body parameter - send directly
        data = request_body if request_body is not None else {}
        
        
        
        # Prepare query parameters
        params = {}
        
        
        # Replace path parameters in URL
        path = "/virtualAccountManagement/paymentDetails/ackNackApi"
        
        
        # Prepare headers
        headers = {}
        if channeltype is not None:
            headers["ChannelType"] = str(channeltype)
        if co_relationid is not None:
            headers["Co-Relationid"] = str(co_relationid)
        if initiatingsystem is not None:
            headers["InitiatingSystem"] = str(initiatingsystem)
        if servicemode is not None:
            headers["ServiceMode"] = str(servicemode)
        if uuidseqno is not None:
            headers["UUIDSeqNo"] = str(uuidseqno)
        if entity is not None:
            headers["entity"] = str(entity)
        if languagecode is not None:
            headers["languageCode"] = str(languagecode)
        if userid is not None:
            headers["userId"] = str(userid)
        
        
        return await make_api_request(
            "POST", 
            path, 
            data=data, 
            params=params if params else None, 
            headers=headers if headers else None
        )
    
    
    
    @mcp.tool()
    async def vaet0085_ftch_vapymt_list_getusing_get(
        accountnumber: Optional[int] = None,
        acknumber: Optional[str] = None,
        bookingstatus: Optional[int] = None,
        collectionaccount: Optional[str] = None,
        corporateschemecode: Optional[str] = None,
        customerreference: Optional[str] = None,
        eventstatus: Optional[int] = None,
        invoicenumber: Optional[str] = None,
        orderingcustomeraccount: Optional[str] = None,
        pagenum: Optional[int] = None,
        pagesize: Optional[int] = None,
        status: Optional[int] = None,
        transactionamount: Optional[float] = None,
        transactionamountto: Optional[float] = None,
        transactioncurrency: Optional[str] = None,
        transactiondate: Optional[str] = None,
        transactiondatetill: Optional[str] = None,
        transactionid: Optional[str] = None,
        transactionreference: Optional[str] = None,
        vapaymentreference: Optional[int] = None,
        virtualaccountnumber: Optional[str] = None,
        virtualaccountnumberformat: Optional[int] = None,
        accesstoken: Optional[str] = None,
        channeltype: Optional[int] = None,
        co_relationid: Optional[int] = None,
        initiatingsystem: Optional[str] = None,
        servicemode: Optional[int] = None,
        uuidseqno: Optional[int] = None,
        entity: Optional[str] = None,
        languagecode: Optional[int] = None,
        referenceid: Optional[str] = None,
        userid: Optional[int] = None
    ) -> Dict[str, Any]:
        """
        This API will fetch Payment List
        
        Generated from: GET /virtualAccountManagement/paymentDetails/list
        Source: swagger_2_0
        Operation ID: VAET0085FtchVAPymtList_GETUsingGET
        
        
        Authentication: Not required
        
        Parameters:
        - accountNumber: integer
          Unique Reference number generated for the virtual account.
        - ackNumber: string
          ACK Number or an equivalent reference generated and shared by corporate customer for payments ACKed
        - bookingStatus: integer
          Status of the Booking (Processed- 1 ,TobeGenerated-2 ,Generated -3 ,ACKReceived - 4 ,NACKReceived-5 , Code Name: d_VA_EventStatus)
        - collectionAccount: string
          The physical bank account number that is linked to the virtual account on which the transaction will be eventually posted.
        - corporateSchemeCode: string
          Corporate Scheme Code uniquely identifies a registration for Virtual Account Management Service.Each of the Customer Registration will be with unique Corporate Scheme Code.
        - customerReference: string
          Unique reference to identify the customer for which the Corporate Scheme Code is provided
        - eventStatus: integer
          Event status of the Virtual account payment (Processed-1 ,TobeGenerated-2 ,Generated -3 ,ACKReceived -4 ,NACKReceived 5 ,CodeName:d_VA_EventStatus )
        - invoiceNumber: string
          Invoice Number as received for the invoice
        - orderingCustomerAccount: string
          The ordering customer account reference as received in the payment initiated from channel
        - pageNum: integer
          pageNum
        - pageSize: integer
          pageSize
        - status: integer
          Status of the Virtual account payment (Processed-1 ,PendingProcessed -2 ,Rejected-3 ,All Payments-4 ,Confirmation Pending-5 ,Success-6 ,CodeName:d_VA_PymntStatus)
        - transactionAmount: number
          The amount of payment on the virtual account
        - transactionAmountTo: number
          The amount to payment on the virtual account
        - transactionCurrency: string
          The currency in which the payment is initiated(e.g. USD,INR,JPY,GBP etc)
        - transactionDate: string
          Date on which the payment is initiated (Date Format:YYYYMMDD)
        - transactionDatetill: string
          Date on which the payment is due till (Date Format:YYYYMMDD)
        - transactionId: string
          The unique transaction identifier generated by the channel from which the virtual account payment is captured and initiated.
        - transactionReference: string
          It is the unique identifier of the incoming virtual account payment as generated by that system which receives the payment from the initiating channel and is responsible for maintaining the entire lifecycle of the payment.
        - vaPaymentReference: integer
          Unique Reference of payment created
        - virtualAccountNumber: string
          Virtual Account Number on which Payment for the invoice is expected.
        - virtualAccountNumberFormat: integer
          format of the virtual account number(1-IBAN,2-BBAN,3-AccountReference1,4-AccountReference2)
        
        
        
        Headers:
        - Accesstoken: string
          Authorization token for identification of the caller
        - ChannelType: integer
          Channel identifier from where the TXN has originated (Internet, Mobile, ATM, Branch Channel )
        - Co-Relationid: integer
          Unique ID for the service invoked, will be set by the TXN system
        - InitiatingSystem: string
          Indicating the initiated system
        - ServiceMode: integer
          Used for branch channel to indicate the type of customer
        - UUIDSeqNo: integer
          UUID Sequence Number
        - entity: string
          entity
        - languageCode: integer
          languageCode
        - referenceId: string
          Place holder for Token based authentication
        - userId: integer
          userId
        
        
        """
        
        
        # Prepare query parameters
        params = {}
        if accountnumber is not None:
            params["accountNumber"] = accountnumber
            
        if acknumber is not None:
            params["ackNumber"] = acknumber
            
        if bookingstatus is not None:
            params["bookingStatus"] = bookingstatus
            
        if collectionaccount is not None:
            params["collectionAccount"] = collectionaccount
            
        if corporateschemecode is not None:
            params["corporateSchemeCode"] = corporateschemecode
            
        if customerreference is not None:
            params["customerReference"] = customerreference
            
        if eventstatus is not None:
            params["eventStatus"] = eventstatus
            
        if invoicenumber is not None:
            params["invoiceNumber"] = invoicenumber
            
        if orderingcustomeraccount is not None:
            params["orderingCustomerAccount"] = orderingcustomeraccount
            
        if pagenum is not None:
            params["pageNum"] = pagenum
            
        if pagesize is not None:
            params["pageSize"] = pagesize
            
        if status is not None:
            params["status"] = status
            
        if transactionamount is not None:
            params["transactionAmount"] = transactionamount
            
        if transactionamountto is not None:
            params["transactionAmountTo"] = transactionamountto
            
        if transactioncurrency is not None:
            params["transactionCurrency"] = transactioncurrency
            
        if transactiondate is not None:
            params["transactionDate"] = transactiondate
            
        if transactiondatetill is not None:
            params["transactionDatetill"] = transactiondatetill
            
        if transactionid is not None:
            params["transactionId"] = transactionid
            
        if transactionreference is not None:
            params["transactionReference"] = transactionreference
            
        if vapaymentreference is not None:
            params["vaPaymentReference"] = vapaymentreference
            
        if virtualaccountnumber is not None:
            params["virtualAccountNumber"] = virtualaccountnumber
            
        if virtualaccountnumberformat is not None:
            params["virtualAccountNumberFormat"] = virtualaccountnumberformat
            
        
        
        # Replace path parameters in URL
        path = "/virtualAccountManagement/paymentDetails/list"
        
        
        # Prepare headers
        headers = {}
        if accesstoken is not None:
            headers["Accesstoken"] = str(accesstoken)
        if channeltype is not None:
            headers["ChannelType"] = str(channeltype)
        if co_relationid is not None:
            headers["Co-Relationid"] = str(co_relationid)
        if initiatingsystem is not None:
            headers["InitiatingSystem"] = str(initiatingsystem)
        if servicemode is not None:
            headers["ServiceMode"] = str(servicemode)
        if uuidseqno is not None:
            headers["UUIDSeqNo"] = str(uuidseqno)
        if entity is not None:
            headers["entity"] = str(entity)
        if languagecode is not None:
            headers["languageCode"] = str(languagecode)
        if referenceid is not None:
            headers["referenceId"] = str(referenceid)
        if userid is not None:
            headers["userId"] = str(userid)
        
        
        return await make_api_request(
            "GET", 
            path, 
            
            params=params if params else None, 
            headers=headers if headers else None
        )
    
    
    
    @mcp.tool()
    async def vabt0040_create_virtual_account_using_post(
        request_body:Dict[str, Any] ,  # CreateVirtualAccount_Resource,
        channeltype: Optional[int] = None,
        co_relationid: Optional[int] = None,
        initiatingsystem: Optional[str] = None,
        servicemode: Optional[int] = None,
        uuidseqno: Optional[int] = None,
        authorization: Optional[str] = None,
        entity: Optional[str] = None,
        referenceid: Optional[str] = None,
        requesthash: Optional[str] = None,
        userid: Optional[int] = None
    ) -> Dict[str, Any]:
        """
        Create Virtual Account
        
        Generated from: POST /virtualAccountManagement/virtualAccount
        Source: swagger_2_0
        Operation ID: VABT0040CreateVirtualAccountUsingPOST
        
        
        Authentication: Not required
        
        Parameters:
        - request_body: any (required)
          input
        
        
        
        Headers:
        - ChannelType: integer
          Channel identifier from where the TXN has originated (Internet, Mobile, ATM, Branch Channel )
        - Co-Relationid: integer
          Unique ID for the service invoked, will be set by the TXN system
        - InitiatingSystem: string
          Indicating the initiated system
        - ServiceMode: integer
          Used for branch channel to indicate the type of customer
        - UUIDSeqNo: integer
          UUID Sequence Number
        - authorization: string
          Authorization Token to validation the caller
        - entity: string
          entity
        - referenceId: string
          Identified reference field for authorization
        - requesthash: string
          Request payload for hash validation
        - userId: integer
          userId
        
        
        """
        
        
        # Prepare request data
        
        # Single body parameter - send directly
        data = request_body if request_body is not None else {}
        
        
        
        # Prepare query parameters
        params = {}
        
        
        # Replace path parameters in URL
        path = "/virtualAccountManagement/virtualAccount"
        
        
        # Prepare headers
        headers = {}
        if channeltype is not None:
            headers["ChannelType"] = str(channeltype)
        if co_relationid is not None:
            headers["Co-Relationid"] = str(co_relationid)
        if initiatingsystem is not None:
            headers["InitiatingSystem"] = str(initiatingsystem)
        if servicemode is not None:
            headers["ServiceMode"] = str(servicemode)
        if uuidseqno is not None:
            headers["UUIDSeqNo"] = str(uuidseqno)
        if authorization is not None:
            headers["authorization"] = str(authorization)
        if entity is not None:
            headers["entity"] = str(entity)
        if referenceid is not None:
            headers["referenceId"] = str(referenceid)
        if requesthash is not None:
            headers["requesthash"] = str(requesthash)
        if userid is not None:
            headers["userId"] = str(userid)
        
        
        return await make_api_request(
            "POST", 
            path, 
            data=data, 
            params=params if params else None, 
            headers=headers if headers else None
        )
    
    
    
    @mcp.tool()
    async def vaet0053_fetch_virtual_account_qbeusing_get(
        accountbban: Optional[str] = None,
        accountcurrency: Optional[int] = None,
        accountiban: Optional[str] = None,
        accountname: Optional[str] = None,
        accountreference1: Optional[str] = None,
        accountreference2: Optional[str] = None,
        accountusage: Optional[int] = None,
        corporateschemecode: Optional[str] = None,
        customerreference: Optional[str] = None,
        pagenum: Optional[int] = None,
        pagesize: Optional[int] = None,
        status: Optional[int] = None,
        accesstoken: Optional[str] = None,
        channeltype: Optional[int] = None,
        co_relationid: Optional[int] = None,
        initiatingsystem: Optional[str] = None,
        servicemode: Optional[int] = None,
        uuidseqno: Optional[int] = None,
        entity: Optional[str] = None,
        referenceid: Optional[str] = None,
        requesthash: Optional[str] = None,
        userid: Optional[int] = None
    ) -> Dict[str, Any]:
        """
        Fetch Virtual Account Details List
        
        Generated from: GET /virtualAccountManagement/virtualAccount/accounts/list
        Source: swagger_2_0
        Operation ID: VAET0053FetchVirtualAccountQBEUsingGET
        
        
        Authentication: Not required
        
        Parameters:
        - accountBban: string
          Enter Account BBAN
        - accountCurrency: integer
          Enter Account Currency
        - accountIban: string
          Enter Account IBAN
        - accountName: string
          Enter Account Name
        - accountReference1: string
          Enter Account Reference 1
        - accountReference2: string
          Enter Account Reference 2
        - accountUsage: integer
          Enter Account Usage
        - corporateSchemeCode: string
          Enter Corporate Scheme Code
        - customerReference: string
          Enter Customer Reference
        - pageNum: integer
          pageNum
        - pageSize: integer
          pageSize
        - status: integer
          Enter Status
        
        
        
        Headers:
        - Accesstoken: string
          Authorization Token to validation the caller
        - ChannelType: integer
          Channel identifier from where the TXN has originated (Internet, Mobile, ATM, Branch Channel )
        - Co-Relationid: integer
          Unique ID for the service invoked, will be set by the TXN system
        - InitiatingSystem: string
          Indicating the initiated system
        - ServiceMode: integer
          Used for branch channel to indicate the type of customer
        - UUIDSeqNo: integer
          UUID Sequence Number
        - entity: string
          entity
        - referenceId: string
          Place holder for Token based authentication
        - requesthash: string
          Request payload for hash validation
        - userId: integer
          userId
        
        
        """
        
        
        # Prepare query parameters
        params = {}
        if accountbban is not None:
            params["accountBban"] = accountbban
            
        if accountcurrency is not None:
            params["accountCurrency"] = accountcurrency
            
        if accountiban is not None:
            params["accountIban"] = accountiban
            
        if accountname is not None:
            params["accountName"] = accountname
            
        if accountreference1 is not None:
            params["accountReference1"] = accountreference1
            
        if accountreference2 is not None:
            params["accountReference2"] = accountreference2
            
        if accountusage is not None:
            params["accountUsage"] = accountusage
            
        if corporateschemecode is not None:
            params["corporateSchemeCode"] = corporateschemecode
            
        if customerreference is not None:
            params["customerReference"] = customerreference
            
        if pagenum is not None:
            params["pageNum"] = pagenum
            
        if pagesize is not None:
            params["pageSize"] = pagesize
            
        if status is not None:
            params["status"] = status
            
        
        
        # Replace path parameters in URL
        path = "/virtualAccountManagement/virtualAccount/accounts/list"
        
        
        # Prepare headers
        headers = {}
        if accesstoken is not None:
            headers["Accesstoken"] = str(accesstoken)
        if channeltype is not None:
            headers["ChannelType"] = str(channeltype)
        if co_relationid is not None:
            headers["Co-Relationid"] = str(co_relationid)
        if initiatingsystem is not None:
            headers["InitiatingSystem"] = str(initiatingsystem)
        if servicemode is not None:
            headers["ServiceMode"] = str(servicemode)
        if uuidseqno is not None:
            headers["UUIDSeqNo"] = str(uuidseqno)
        if entity is not None:
            headers["entity"] = str(entity)
        if referenceid is not None:
            headers["referenceId"] = str(referenceid)
        if requesthash is not None:
            headers["requesthash"] = str(requesthash)
        if userid is not None:
            headers["userId"] = str(userid)
        
        
        return await make_api_request(
            "GET", 
            path, 
            
            params=params if params else None, 
            headers=headers if headers else None
        )
    
    
    
    @mcp.tool()
    async def vabt0078_close_virtual_acnt_postusing_post(
        request_body:Dict[str, Any] ,  # closeVirtualAccountResource,
        accesstoken: Optional[str] = None,
        channeltype: Optional[int] = None,
        co_relationid: Optional[int] = None,
        initiatingsystem: Optional[str] = None,
        servicemode: Optional[int] = None,
        uuidseqno: Optional[int] = None,
        entity: Optional[str] = None,
        languagecode: Optional[int] = None,
        referenceid: Optional[str] = None,
        requesthash: Optional[str] = None,
        userid: Optional[int] = None
    ) -> Dict[str, Any]:
        """
        Close Virtual Account
        
        Generated from: POST /virtualAccountManagement/virtualAccount/close
        Source: swagger_2_0
        Operation ID: VABT0078CloseVirtualAcnt_POSTUsingPOST
        
        
        Authentication: Not required
        
        Parameters:
        - request_body: any (required)
          input
        
        
        
        Headers:
        - Accesstoken: string
          Authorization token for identification of the caller
        - ChannelType: integer
          Channel identifier from where the TXN has originated (Internet, Mobile, ATM, Branch Channel )
        - Co-Relationid: integer
          Unique ID for the service invoked, will be set by the TXN system
        - InitiatingSystem: string
          Indicating the initiated system
        - ServiceMode: integer
          Used for branch channel to indicate the type of customer
        - UUIDSeqNo: integer
          UUID Sequence Number
        - entity: string
          entity
        - languageCode: integer
          languageCode
        - referenceId: string
          Place holder for Token based authentication
        - requesthash: string
          Request payload for hash validation
        - userId: integer
          userId
        
        
        """
        
        
        # Prepare request data
        
        # Single body parameter - send directly
        data = request_body if request_body is not None else {}
        
        
        
        # Prepare query parameters
        params = {}
        
        
        # Replace path parameters in URL
        path = "/virtualAccountManagement/virtualAccount/close"
        
        
        # Prepare headers
        headers = {}
        if accesstoken is not None:
            headers["Accesstoken"] = str(accesstoken)
        if channeltype is not None:
            headers["ChannelType"] = str(channeltype)
        if co_relationid is not None:
            headers["Co-Relationid"] = str(co_relationid)
        if initiatingsystem is not None:
            headers["InitiatingSystem"] = str(initiatingsystem)
        if servicemode is not None:
            headers["ServiceMode"] = str(servicemode)
        if uuidseqno is not None:
            headers["UUIDSeqNo"] = str(uuidseqno)
        if entity is not None:
            headers["entity"] = str(entity)
        if languagecode is not None:
            headers["languageCode"] = str(languagecode)
        if referenceid is not None:
            headers["referenceId"] = str(referenceid)
        if requesthash is not None:
            headers["requesthash"] = str(requesthash)
        if userid is not None:
            headers["userId"] = str(userid)
        
        
        return await make_api_request(
            "POST", 
            path, 
            data=data, 
            params=params if params else None, 
            headers=headers if headers else None
        )
    
    
    
    @mcp.tool()
    async def vabt0048_create_level_values_using_post(
        request_body:Dict[str, Any] ,  # CreateLevelValues_Resource,
        accesstoken: Optional[str] = None,
        channeltype: Optional[int] = None,
        co_relationid: Optional[int] = None,
        initiatingsystem: Optional[str] = None,
        servicemode: Optional[int] = None,
        uuidseqno: Optional[int] = None,
        entity: Optional[str] = None,
        referenceid: Optional[str] = None,
        requesthash: Optional[str] = None,
        userid: Optional[int] = None
    ) -> Dict[str, Any]:
        """
        Create Level Values
        
        Generated from: POST /virtualAccountManagement/virtualAccount/levelValues
        Source: swagger_2_0
        Operation ID: VABT0048CreateLevelValuesUsingPOST
        
        
        Authentication: Not required
        
        Parameters:
        - request_body: any (required)
          input
        
        
        
        Headers:
        - Accesstoken: string
          Authorization Token to validation the caller
        - ChannelType: integer
          Channel identifier from where the TXN has originated (Internet, Mobile, ATM, Branch Channel )
        - Co-Relationid: integer
          Unique ID for the service invoked, will be set by the TXN system
        - InitiatingSystem: string
          Indicating the initiated system
        - ServiceMode: integer
          Used for branch channel to indicate the type of customer
        - UUIDSeqNo: integer
          UUID Sequence Number
        - entity: string
          entity
        - referenceId: string
          Place holder for Token based authentication
        - requesthash: string
          Request payload for hash validation
        - userId: integer
          userId
        
        
        """
        
        
        # Prepare request data
        
        # Single body parameter - send directly
        data = request_body if request_body is not None else {}
        
        
        
        # Prepare query parameters
        params = {}
        
        
        # Replace path parameters in URL
        path = "/virtualAccountManagement/virtualAccount/levelValues"
        
        
        # Prepare headers
        headers = {}
        if accesstoken is not None:
            headers["Accesstoken"] = str(accesstoken)
        if channeltype is not None:
            headers["ChannelType"] = str(channeltype)
        if co_relationid is not None:
            headers["Co-Relationid"] = str(co_relationid)
        if initiatingsystem is not None:
            headers["InitiatingSystem"] = str(initiatingsystem)
        if servicemode is not None:
            headers["ServiceMode"] = str(servicemode)
        if uuidseqno is not None:
            headers["UUIDSeqNo"] = str(uuidseqno)
        if entity is not None:
            headers["entity"] = str(entity)
        if referenceid is not None:
            headers["referenceId"] = str(referenceid)
        if requesthash is not None:
            headers["requesthash"] = str(requesthash)
        if userid is not None:
            headers["userId"] = str(userid)
        
        
        return await make_api_request(
            "POST", 
            path, 
            data=data, 
            params=params if params else None, 
            headers=headers if headers else None
        )
    
    
    
    @mcp.tool()
    async def vabt0050_delete_level_values_using_post(
        request_body:Dict[str, Any] ,  # DeleteLevelValues_Resource,
        accesstoken: Optional[str] = None,
        channeltype: Optional[int] = None,
        co_relationid: Optional[int] = None,
        initiatingsystem: Optional[str] = None,
        servicemode: Optional[int] = None,
        uuidseqno: Optional[int] = None,
        entity: Optional[str] = None,
        referenceid: Optional[str] = None,
        requesthash: Optional[str] = None,
        userid: Optional[int] = None
    ) -> Dict[str, Any]:
        """
        Delete Level Values
        
        Generated from: POST /virtualAccountManagement/virtualAccount/levelValues/delete
        Source: swagger_2_0
        Operation ID: VABT0050DeleteLevelValuesUsingPOST
        
        
        Authentication: Not required
        
        Parameters:
        - request_body: any (required)
          input
        
        
        
        Headers:
        - Accesstoken: string
          Authorization Token to validation the caller
        - ChannelType: integer
          Channel identifier from where the TXN has originated (Internet, Mobile, ATM, Branch Channel )
        - Co-Relationid: integer
          Unique ID for the service invoked, will be set by the TXN system
        - InitiatingSystem: string
          Indicating the initiated system
        - ServiceMode: integer
          Used for branch channel to indicate the type of customer
        - UUIDSeqNo: integer
          UUID Sequence Number
        - entity: string
          entity
        - referenceId: string
          Place holder for Token based authentication
        - requesthash: string
          Request payload for hash validation
        - userId: integer
          userId
        
        
        """
        
        
        # Prepare request data
        
        # Single body parameter - send directly
        data = request_body if request_body is not None else {}
        
        
        
        # Prepare query parameters
        params = {}
        
        
        # Replace path parameters in URL
        path = "/virtualAccountManagement/virtualAccount/levelValues/delete"
        
        
        # Prepare headers
        headers = {}
        if accesstoken is not None:
            headers["Accesstoken"] = str(accesstoken)
        if channeltype is not None:
            headers["ChannelType"] = str(channeltype)
        if co_relationid is not None:
            headers["Co-Relationid"] = str(co_relationid)
        if initiatingsystem is not None:
            headers["InitiatingSystem"] = str(initiatingsystem)
        if servicemode is not None:
            headers["ServiceMode"] = str(servicemode)
        if uuidseqno is not None:
            headers["UUIDSeqNo"] = str(uuidseqno)
        if entity is not None:
            headers["entity"] = str(entity)
        if referenceid is not None:
            headers["referenceId"] = str(referenceid)
        if requesthash is not None:
            headers["requesthash"] = str(requesthash)
        if userid is not None:
            headers["userId"] = str(userid)
        
        
        return await make_api_request(
            "POST", 
            path, 
            data=data, 
            params=params if params else None, 
            headers=headers if headers else None
        )
    
    
    
    @mcp.tool()
    async def vaet0052_get_level_values_using_get(
        virtualaccountnumber: int,
        virtualaccountlevelid: int,
        pagenum: Optional[int] = None,
        pagesize: Optional[int] = None,
        accesstoken: Optional[str] = None,
        channeltype: Optional[int] = None,
        co_relationid: Optional[int] = None,
        initiatingsystem: Optional[str] = None,
        servicemode: Optional[int] = None,
        uuidseqno: Optional[int] = None,
        entity: Optional[str] = None,
        referenceid: Optional[str] = None,
        requesthash: Optional[str] = None,
        userid: Optional[int] = None
    ) -> Dict[str, Any]:
        """
        Get Level Values
        
        Generated from: GET /virtualAccountManagement/virtualAccount/levelValues/details
        Source: swagger_2_0
        Operation ID: VAET0052GetLevelValuesUsingGET
        
        
        Authentication: Not required
        
        Parameters:
        - pageNum: integer
          pageNum
        - pageSize: integer
          pageSize
        - virtualAccountNumber: integer (required)
          Enter Virtual Account Number
        - virtualAccountlevelId: integer (required)
          Enter Virtual Account Level ID
        
        
        
        Headers:
        - Accesstoken: string
          Authorization Token to validation the caller
        - ChannelType: integer
          Channel identifier from where the TXN has originated (Internet, Mobile, ATM, Branch Channel )
        - Co-Relationid: integer
          Unique ID for the service invoked, will be set by the TXN system
        - InitiatingSystem: string
          Indicating the initiated system
        - ServiceMode: integer
          Used for branch channel to indicate the type of customer
        - UUIDSeqNo: integer
          UUID Sequence Number
        - entity: string
          entity
        - referenceId: string
          Place holder for Token based authentication
        - requesthash: string
          Request payload for hash validation
        - userId: integer
          userId
        
        
        """
        
        
        # Prepare query parameters
        params = {}
        if pagenum is not None:
            params["pageNum"] = pagenum
            
        if pagesize is not None:
            params["pageSize"] = pagesize
            
        if virtualaccountnumber is not None:
            params["virtualAccountNumber"] = virtualaccountnumber
            
        if virtualaccountlevelid is not None:
            params["virtualAccountlevelId"] = virtualaccountlevelid
            
        
        
        # Replace path parameters in URL
        path = "/virtualAccountManagement/virtualAccount/levelValues/details"
        
        
        # Prepare headers
        headers = {}
        if accesstoken is not None:
            headers["Accesstoken"] = str(accesstoken)
        if channeltype is not None:
            headers["ChannelType"] = str(channeltype)
        if co_relationid is not None:
            headers["Co-Relationid"] = str(co_relationid)
        if initiatingsystem is not None:
            headers["InitiatingSystem"] = str(initiatingsystem)
        if servicemode is not None:
            headers["ServiceMode"] = str(servicemode)
        if uuidseqno is not None:
            headers["UUIDSeqNo"] = str(uuidseqno)
        if entity is not None:
            headers["entity"] = str(entity)
        if referenceid is not None:
            headers["referenceId"] = str(referenceid)
        if requesthash is not None:
            headers["requesthash"] = str(requesthash)
        if userid is not None:
            headers["userId"] = str(userid)
        
        
        return await make_api_request(
            "GET", 
            path, 
            
            params=params if params else None, 
            headers=headers if headers else None
        )
    
    
    
    @mcp.tool()
    async def vaetfetch_level_id_using_get(
        accountusage: Optional[int] = None,
        corporateschemecode: Optional[str] = None,
        pagenum: Optional[int] = None,
        pagesize: Optional[int] = None,
        accesstoken: Optional[str] = None,
        channeltype: Optional[int] = None,
        co_relationid: Optional[int] = None,
        initiatingsystem: Optional[str] = None,
        servicemode: Optional[int] = None,
        uuidseqno: Optional[int] = None,
        entity: Optional[str] = None,
        referenceid: Optional[str] = None,
        requesthash: Optional[str] = None,
        userid: Optional[int] = None
    ) -> Dict[str, Any]:
        """
        Fetch Level References
        
        Generated from: GET /virtualAccountManagement/virtualAccount/levelValues/levelId/fetch
        Source: swagger_2_0
        Operation ID: VAETFetchLevelIdUsingGET
        
        
        Authentication: Not required
        
        Parameters:
        - accountUsage: integer
          Enter Account Usage
        - corporateSchemeCode: string
          Enter Corporate Scheme Code
        - pageNum: integer
          pageNum
        - pageSize: integer
          pageSize
        
        
        
        Headers:
        - Accesstoken: string
          Authorization Token to validation the caller
        - ChannelType: integer
          Channel identifier from where the TXN has originated (Internet, Mobile, ATM, Branch Channel )
        - Co-Relationid: integer
          Unique ID for the service invoked, will be set by the TXN system
        - InitiatingSystem: string
          Indicating the initiated system
        - ServiceMode: integer
          Used for branch channel to indicate the type of customer
        - UUIDSeqNo: integer
          UUID Sequence Number
        - entity: string
          entity
        - referenceId: string
          Place holder for Token based authentication
        - requesthash: string
          Request payload for hash validation
        - userId: integer
          userId
        
        
        """
        
        
        # Prepare query parameters
        params = {}
        if accountusage is not None:
            params["accountUsage"] = accountusage
            
        if corporateschemecode is not None:
            params["corporateSchemeCode"] = corporateschemecode
            
        if pagenum is not None:
            params["pageNum"] = pagenum
            
        if pagesize is not None:
            params["pageSize"] = pagesize
            
        
        
        # Replace path parameters in URL
        path = "/virtualAccountManagement/virtualAccount/levelValues/levelId/fetch"
        
        
        # Prepare headers
        headers = {}
        if accesstoken is not None:
            headers["Accesstoken"] = str(accesstoken)
        if channeltype is not None:
            headers["ChannelType"] = str(channeltype)
        if co_relationid is not None:
            headers["Co-Relationid"] = str(co_relationid)
        if initiatingsystem is not None:
            headers["InitiatingSystem"] = str(initiatingsystem)
        if servicemode is not None:
            headers["ServiceMode"] = str(servicemode)
        if uuidseqno is not None:
            headers["UUIDSeqNo"] = str(uuidseqno)
        if entity is not None:
            headers["entity"] = str(entity)
        if referenceid is not None:
            headers["referenceId"] = str(referenceid)
        if requesthash is not None:
            headers["requesthash"] = str(requesthash)
        if userid is not None:
            headers["userId"] = str(userid)
        
        
        return await make_api_request(
            "GET", 
            path, 
            
            params=params if params else None, 
            headers=headers if headers else None
        )
    
    
    
    @mcp.tool()
    async def vaetvalidate_level_value_using_get(
        levelid: int,
        numberschemeid: int,
        pagenum: Optional[int] = None,
        pagesize: Optional[int] = None,
        accesstoken: Optional[str] = None,
        channeltype: Optional[int] = None,
        co_relationid: Optional[int] = None,
        initiatingsystem: Optional[str] = None,
        servicemode: Optional[int] = None,
        uuidseqno: Optional[int] = None,
        entity: Optional[str] = None,
        referenceid: Optional[str] = None,
        requesthash: Optional[str] = None,
        userid: Optional[int] = None
    ) -> Dict[str, Any]:
        """
        Validate Level Values
        
        Generated from: GET /virtualAccountManagement/virtualAccount/levelValues/levelId/tabout
        Source: swagger_2_0
        Operation ID: VAETValidateLevelValueUsingGET
        
        
        Authentication: Not required
        
        Parameters:
        - levelId: integer (required)
          Enter the Level ID
        - numberSchemeId: integer (required)
          Enter the Number Scheme ID
        - pageNum: integer
          pageNum
        - pageSize: integer
          pageSize
        
        
        
        Headers:
        - Accesstoken: string
          Authorization Token to validation the caller
        - ChannelType: integer
          Channel identifier from where the TXN has originated (Internet, Mobile, ATM, Branch Channel )
        - Co-Relationid: integer
          Unique ID for the service invoked, will be set by the TXN system
        - InitiatingSystem: string
          Indicating the initiated system
        - ServiceMode: integer
          Used for branch channel to indicate the type of customer
        - UUIDSeqNo: integer
          UUID Sequence Number
        - entity: string
          entity
        - referenceId: string
          Place holder for Token based authentication
        - requesthash: string
          Request payload for hash validation
        - userId: integer
          userId
        
        
        """
        
        
        # Prepare query parameters
        params = {}
        if levelid is not None:
            params["levelId"] = levelid
            
        if numberschemeid is not None:
            params["numberSchemeId"] = numberschemeid
            
        if pagenum is not None:
            params["pageNum"] = pagenum
            
        if pagesize is not None:
            params["pageSize"] = pagesize
            
        
        
        # Replace path parameters in URL
        path = "/virtualAccountManagement/virtualAccount/levelValues/levelId/tabout"
        
        
        # Prepare headers
        headers = {}
        if accesstoken is not None:
            headers["Accesstoken"] = str(accesstoken)
        if channeltype is not None:
            headers["ChannelType"] = str(channeltype)
        if co_relationid is not None:
            headers["Co-Relationid"] = str(co_relationid)
        if initiatingsystem is not None:
            headers["InitiatingSystem"] = str(initiatingsystem)
        if servicemode is not None:
            headers["ServiceMode"] = str(servicemode)
        if uuidseqno is not None:
            headers["UUIDSeqNo"] = str(uuidseqno)
        if entity is not None:
            headers["entity"] = str(entity)
        if referenceid is not None:
            headers["referenceId"] = str(referenceid)
        if requesthash is not None:
            headers["requesthash"] = str(requesthash)
        if userid is not None:
            headers["userId"] = str(userid)
        
        
        return await make_api_request(
            "GET", 
            path, 
            
            params=params if params else None, 
            headers=headers if headers else None
        )
    
    
    
    @mcp.tool()
    async def vabt0049_modify_level_values_using_post(
        request_body:Dict[str, Any] ,  # ModifyLevelValues_Resource,
        accesstoken: Optional[str] = None,
        channeltype: Optional[int] = None,
        co_relationid: Optional[int] = None,
        initiatingsystem: Optional[str] = None,
        servicemode: Optional[int] = None,
        uuidseqno: Optional[int] = None,
        entity: Optional[str] = None,
        referenceid: Optional[str] = None,
        requesthash: Optional[str] = None,
        userid: Optional[int] = None
    ) -> Dict[str, Any]:
        """
        Modify Level Values
        
        Generated from: POST /virtualAccountManagement/virtualAccount/levelValues/modify
        Source: swagger_2_0
        Operation ID: VABT0049ModifyLevelValuesUsingPOST
        
        
        Authentication: Not required
        
        Parameters:
        - request_body: any (required)
          input
        
        
        
        Headers:
        - Accesstoken: string
          Authorization Token to validation the caller
        - ChannelType: integer
          Channel identifier from where the TXN has originated (Internet, Mobile, ATM, Branch Channel )
        - Co-Relationid: integer
          Unique ID for the service invoked, will be set by the TXN system
        - InitiatingSystem: string
          Indicating the initiated system
        - ServiceMode: integer
          Used for branch channel to indicate the type of customer
        - UUIDSeqNo: integer
          UUID Sequence Number
        - entity: string
          entity
        - referenceId: string
          Place holder for Token based authentication
        - requesthash: string
          Request payload for hash validation
        - userId: integer
          userId
        
        
        """
        
        
        # Prepare request data
        
        # Single body parameter - send directly
        data = request_body if request_body is not None else {}
        
        
        
        # Prepare query parameters
        params = {}
        
        
        # Replace path parameters in URL
        path = "/virtualAccountManagement/virtualAccount/levelValues/modify"
        
        
        # Prepare headers
        headers = {}
        if accesstoken is not None:
            headers["Accesstoken"] = str(accesstoken)
        if channeltype is not None:
            headers["ChannelType"] = str(channeltype)
        if co_relationid is not None:
            headers["Co-Relationid"] = str(co_relationid)
        if initiatingsystem is not None:
            headers["InitiatingSystem"] = str(initiatingsystem)
        if servicemode is not None:
            headers["ServiceMode"] = str(servicemode)
        if uuidseqno is not None:
            headers["UUIDSeqNo"] = str(uuidseqno)
        if entity is not None:
            headers["entity"] = str(entity)
        if referenceid is not None:
            headers["referenceId"] = str(referenceid)
        if requesthash is not None:
            headers["requesthash"] = str(requesthash)
        if userid is not None:
            headers["userId"] = str(userid)
        
        
        return await make_api_request(
            "POST", 
            path, 
            data=data, 
            params=params if params else None, 
            headers=headers if headers else None
        )
    
    
    
    @mcp.tool()
    async def vaet0051_fetch_level_values_list_using_get(
        virtualaccountnumber: int,
        pagenum: Optional[int] = None,
        pagesize: Optional[int] = None,
        accesstoken: Optional[str] = None,
        channeltype: Optional[int] = None,
        co_relationid: Optional[int] = None,
        initiatingsystem: Optional[str] = None,
        servicemode: Optional[int] = None,
        uuidseqno: Optional[int] = None,
        entity: Optional[str] = None,
        referenceid: Optional[str] = None,
        requesthash: Optional[str] = None,
        userid: Optional[int] = None
    ) -> Dict[str, Any]:
        """
        Fetch Level Values
        
        Generated from: GET /virtualAccountManagement/virtualAccount/levelValues/{virtualAccountNumber}/list
        Source: swagger_2_0
        Operation ID: VAET0051FetchLevelValuesListUsingGET
        
        
        Authentication: Not required
        
        Parameters:
        - pageNum: integer
          pageNum
        - pageSize: integer
          pageSize
        - virtualAccountNumber: integer (required)
          Enter Virtual Account Number
        
        
        
        Headers:
        - Accesstoken: string
          Authorization Token to validation the caller
        - ChannelType: integer
          Channel identifier from where the TXN has originated (Internet, Mobile, ATM, Branch Channel )
        - Co-Relationid: integer
          Unique ID for the service invoked, will be set by the TXN system
        - InitiatingSystem: string
          Indicating the initiated system
        - ServiceMode: integer
          Used for branch channel to indicate the type of customer
        - UUIDSeqNo: integer
          UUID Sequence Number
        - entity: string
          entity
        - referenceId: string
          Place holder for Token based authentication
        - requesthash: string
          Request payload for hash validation
        - userId: integer
          userId
        
        
        """
        
        
        # Prepare query parameters
        params = {}
        if pagenum is not None:
            params["pageNum"] = pagenum
            
        if pagesize is not None:
            params["pageSize"] = pagesize
            
        
        
        # Replace path parameters in URL
        path = "/virtualAccountManagement/virtualAccount/levelValues/{virtualAccountNumber}/list"
        if virtualaccountnumber is not None:
            path = path.replace("{virtualAccountNumber}", str(virtualaccountnumber))
        
        
        # Prepare headers
        headers = {}
        if accesstoken is not None:
            headers["Accesstoken"] = str(accesstoken)
        if channeltype is not None:
            headers["ChannelType"] = str(channeltype)
        if co_relationid is not None:
            headers["Co-Relationid"] = str(co_relationid)
        if initiatingsystem is not None:
            headers["InitiatingSystem"] = str(initiatingsystem)
        if servicemode is not None:
            headers["ServiceMode"] = str(servicemode)
        if uuidseqno is not None:
            headers["UUIDSeqNo"] = str(uuidseqno)
        if entity is not None:
            headers["entity"] = str(entity)
        if referenceid is not None:
            headers["referenceId"] = str(referenceid)
        if requesthash is not None:
            headers["requesthash"] = str(requesthash)
        if userid is not None:
            headers["userId"] = str(userid)
        
        
        return await make_api_request(
            "GET", 
            path, 
            
            params=params if params else None, 
            headers=headers if headers else None
        )
    
    
    
    @mcp.tool()
    async def vaet0046_fetch_virtual_account_list_using_get(
        accountbban: Optional[str] = None,
        accountiban: Optional[str] = None,
        accountmanager: Optional[str] = None,
        accountname: Optional[str] = None,
        accountusage: Optional[str] = None,
        corporateschemecode: Optional[str] = None,
        currency: Optional[str] = None,
        customerreference: Optional[str] = None,
        filereference: Optional[str] = None,
        hierarchyname: Optional[str] = None,
        openedondate: Optional[str] = None,
        openedontill: Optional[str] = None,
        pagenum: Optional[int] = None,
        pagesize: Optional[int] = None,
        parentaccountreference: Optional[str] = None,
        requestreference: Optional[str] = None,
        status: Optional[str] = None,
        virtualaccountnumber: Optional[str] = None,
        channeltype: Optional[int] = None,
        co_relationid: Optional[int] = None,
        initiatingsystem: Optional[str] = None,
        servicemode: Optional[int] = None,
        uuidseqno: Optional[int] = None,
        authorization: Optional[str] = None,
        entity: Optional[str] = None,
        referenceid: Optional[str] = None,
        requesthash: Optional[str] = None,
        userid: Optional[int] = None
    ) -> Dict[str, Any]:
        """
        Fetch Virtual Accounts
        
        Generated from: GET /virtualAccountManagement/virtualAccount/list
        Source: swagger_2_0
        Operation ID: VAET0046FetchVirtualAccountListUsingGET
        
        
        Authentication: Not required
        
        Parameters:
        - accountBban: string
          On the basis of account numbering scheme, the Virtual Account BBAN will be generated and shown in this field
        - accountIban: string
          On the basis of account numbering scheme, the Virtual Account IBAN will be generated and shown in this field
        - accountManager: string
          Enter Account Manager
        - accountName: string
          Enter Account Name
        - accountUsage: string
          Enter Account Usage
        - corporateSchemeCode: string
          Enter Corporate Scheme Code
        - currency: string
          Enter Currency
        - customerReference: string
          Enter Customer Reference
        - fileReference: string
          Unique Reference generated for each file uploaded
        - hierarchyName: string
          Enter Hierarchy Name
        - openedOnDate: string
          Enter Account Open Date
        - openedOntill: string
          Enter Account Open on till
        - pageNum: integer
          pageNum
        - pageSize: integer
          pageSize
        - parentAccountReference: string
          Enter Parent Account Reference
        - requestReference: string
          Unique Reference generated for Bulk Account creation request
        - status: string
          Enter Account Status
        - virtualAccountNumber: string
          Enter Virtual Account Number
        
        
        
        Headers:
        - ChannelType: integer
          Channel identifier from where the TXN has originated (Internet, Mobile, ATM, Branch Channel )
        - Co-Relationid: integer
          Unique ID for the service invoked, will be set by the TXN system
        - InitiatingSystem: string
          Indicating the initiated system
        - ServiceMode: integer
          Used for branch channel to indicate the type of customer
        - UUIDSeqNo: integer
          UUID Sequence Number
        - authorization: string
          Authorization Token to validation the caller
        - entity: string
          entity
        - referenceId: string
          Identified reference field for authorization
        - requesthash: string
          Request payload for hash validation
        - userId: integer
          userId
        
        
        """
        
        
        # Prepare query parameters
        params = {}
        if accountbban is not None:
            params["accountBban"] = accountbban
            
        if accountiban is not None:
            params["accountIban"] = accountiban
            
        if accountmanager is not None:
            params["accountManager"] = accountmanager
            
        if accountname is not None:
            params["accountName"] = accountname
            
        if accountusage is not None:
            params["accountUsage"] = accountusage
            
        if corporateschemecode is not None:
            params["corporateSchemeCode"] = corporateschemecode
            
        if currency is not None:
            params["currency"] = currency
            
        if customerreference is not None:
            params["customerReference"] = customerreference
            
        if filereference is not None:
            params["fileReference"] = filereference
            
        if hierarchyname is not None:
            params["hierarchyName"] = hierarchyname
            
        if openedondate is not None:
            params["openedOnDate"] = openedondate
            
        if openedontill is not None:
            params["openedOntill"] = openedontill
            
        if pagenum is not None:
            params["pageNum"] = pagenum
            
        if pagesize is not None:
            params["pageSize"] = pagesize
            
        if parentaccountreference is not None:
            params["parentAccountReference"] = parentaccountreference
            
        if requestreference is not None:
            params["requestReference"] = requestreference
            
        if status is not None:
            params["status"] = status
            
        if virtualaccountnumber is not None:
            params["virtualAccountNumber"] = virtualaccountnumber
            
        
        
        # Replace path parameters in URL
        path = "/virtualAccountManagement/virtualAccount/list"
        
        
        # Prepare headers
        headers = {}
        if channeltype is not None:
            headers["ChannelType"] = str(channeltype)
        if co_relationid is not None:
            headers["Co-Relationid"] = str(co_relationid)
        if initiatingsystem is not None:
            headers["InitiatingSystem"] = str(initiatingsystem)
        if servicemode is not None:
            headers["ServiceMode"] = str(servicemode)
        if uuidseqno is not None:
            headers["UUIDSeqNo"] = str(uuidseqno)
        if authorization is not None:
            headers["authorization"] = str(authorization)
        if entity is not None:
            headers["entity"] = str(entity)
        if referenceid is not None:
            headers["referenceId"] = str(referenceid)
        if requesthash is not None:
            headers["requesthash"] = str(requesthash)
        if userid is not None:
            headers["userId"] = str(userid)
        
        
        return await make_api_request(
            "GET", 
            path, 
            
            params=params if params else None, 
            headers=headers if headers else None
        )
    
    
    
    @mcp.tool()
    async def vabt0041_modify_virtual_account_using_post(
        request_body:Dict[str, Any] ,  # ModifyVirtualAccount_Resource,
        accesstoken: Optional[str] = None,
        channeltype: Optional[int] = None,
        co_relationid: Optional[int] = None,
        initiatingsystem: Optional[str] = None,
        servicemode: Optional[int] = None,
        uuidseqno: Optional[int] = None,
        entity: Optional[str] = None,
        referenceid: Optional[str] = None,
        requesthash: Optional[str] = None,
        userid: Optional[int] = None
    ) -> Dict[str, Any]:
        """
        Modify Virtual Account
        
        Generated from: POST /virtualAccountManagement/virtualAccount/modify
        Source: swagger_2_0
        Operation ID: VABT0041ModifyVirtualAccountUsingPOST
        
        
        Authentication: Not required
        
        Parameters:
        - request_body: any (required)
          input
        
        
        
        Headers:
        - Accesstoken: string
          Authorization Token to validation the caller
        - ChannelType: integer
          Channel identifier from where the TXN has originated (Internet, Mobile, ATM, Branch Channel )
        - Co-Relationid: integer
          Unique ID for the service invoked, will be set by the TXN system
        - InitiatingSystem: string
          Indicating the initiated system
        - ServiceMode: integer
          Used for branch channel to indicate the type of customer
        - UUIDSeqNo: integer
          UUID Sequence Number
        - entity: string
          entity
        - referenceId: string
          Place holder for Token based authentication
        - requesthash: string
          Request payload for hash validation
        - userId: integer
          userId
        
        
        """
        
        
        # Prepare request data
        
        # Single body parameter - send directly
        data = request_body if request_body is not None else {}
        
        
        
        # Prepare query parameters
        params = {}
        
        
        # Replace path parameters in URL
        path = "/virtualAccountManagement/virtualAccount/modify"
        
        
        # Prepare headers
        headers = {}
        if accesstoken is not None:
            headers["Accesstoken"] = str(accesstoken)
        if channeltype is not None:
            headers["ChannelType"] = str(channeltype)
        if co_relationid is not None:
            headers["Co-Relationid"] = str(co_relationid)
        if initiatingsystem is not None:
            headers["InitiatingSystem"] = str(initiatingsystem)
        if servicemode is not None:
            headers["ServiceMode"] = str(servicemode)
        if uuidseqno is not None:
            headers["UUIDSeqNo"] = str(uuidseqno)
        if entity is not None:
            headers["entity"] = str(entity)
        if referenceid is not None:
            headers["referenceId"] = str(referenceid)
        if requesthash is not None:
            headers["requesthash"] = str(requesthash)
        if userid is not None:
            headers["userId"] = str(userid)
        
        
        return await make_api_request(
            "POST", 
            path, 
            data=data, 
            params=params if params else None, 
            headers=headers if headers else None
        )
    
    
    
    @mcp.tool()
    async def vabt0042_modify_active_virtual_account_using_post(
        request_body:Dict[str, Any] ,  # ModifyActiveVirtualAccount_Resource,
        accesstoken: Optional[str] = None,
        channeltype: Optional[int] = None,
        co_relationid: Optional[int] = None,
        initiatingsystem: Optional[str] = None,
        servicemode: Optional[int] = None,
        uuidseqno: Optional[int] = None,
        entity: Optional[str] = None,
        referenceid: Optional[str] = None,
        requesthash: Optional[str] = None,
        userid: Optional[int] = None
    ) -> Dict[str, Any]:
        """
        Modify an active virtual account
        
        Generated from: POST /virtualAccountManagement/virtualAccount/modifyActive
        Source: swagger_2_0
        Operation ID: VABT0042ModifyActiveVirtualAccountUsingPOST
        
        
        Authentication: Not required
        
        Parameters:
        - request_body: any (required)
          input
        
        
        
        Headers:
        - Accesstoken: string
          Authorization Token to validation the caller
        - ChannelType: integer
          Channel identifier from where the TXN has originated (Internet, Mobile, ATM, Branch Channel )
        - Co-Relationid: integer
          Unique ID for the service invoked, will be set by the TXN system
        - InitiatingSystem: string
          Indicating the initiated system
        - ServiceMode: integer
          Used for branch channel to indicate the type of customer
        - UUIDSeqNo: integer
          UUID Sequence Number
        - entity: string
          entity
        - referenceId: string
          Place holder for Token based authentication
        - requesthash: string
          Request payload for hash validation
        - userId: integer
          userId
        
        
        """
        
        
        # Prepare request data
        
        # Single body parameter - send directly
        data = request_body if request_body is not None else {}
        
        
        
        # Prepare query parameters
        params = {}
        
        
        # Replace path parameters in URL
        path = "/virtualAccountManagement/virtualAccount/modifyActive"
        
        
        # Prepare headers
        headers = {}
        if accesstoken is not None:
            headers["Accesstoken"] = str(accesstoken)
        if channeltype is not None:
            headers["ChannelType"] = str(channeltype)
        if co_relationid is not None:
            headers["Co-Relationid"] = str(co_relationid)
        if initiatingsystem is not None:
            headers["InitiatingSystem"] = str(initiatingsystem)
        if servicemode is not None:
            headers["ServiceMode"] = str(servicemode)
        if uuidseqno is not None:
            headers["UUIDSeqNo"] = str(uuidseqno)
        if entity is not None:
            headers["entity"] = str(entity)
        if referenceid is not None:
            headers["referenceId"] = str(referenceid)
        if requesthash is not None:
            headers["requesthash"] = str(requesthash)
        if userid is not None:
            headers["userId"] = str(userid)
        
        
        return await make_api_request(
            "POST", 
            path, 
            data=data, 
            params=params if params else None, 
            headers=headers if headers else None
        )
    
    
    
    @mcp.tool()
    async def vabt0020_create_account_scheme_bank_defined_using_post(
        request_body:Dict[str, Any] ,  # CreateAccountSchemeBankDefined_Resource,
        accesstoken: Optional[str] = None,
        channeltype: Optional[int] = None,
        co_relationid: Optional[int] = None,
        initiatingsystem: Optional[str] = None,
        servicemode: Optional[int] = None,
        uuidseqno: Optional[int] = None,
        entity: Optional[str] = None,
        referenceid: Optional[str] = None,
        requesthash: Optional[str] = None,
        userid: Optional[int] = None
    ) -> Dict[str, Any]:
        """
        This service is used to Create Banked Defined Account Scheme
        
        Generated from: POST /virtualAccountManagement/virtualAccount/numberScheme/bank
        Source: swagger_2_0
        Operation ID: VABT0020CreateAccountSchemeBankDefinedUsingPOST
        
        
        Authentication: Not required
        
        Parameters:
        - request_body: any (required)
          input
        
        
        
        Headers:
        - Accesstoken: string
          Authorization Token to validation the caller
        - ChannelType: integer
          Channel identifier from where the TXN has originated (Internet, Mobile, ATM, Branch Channel )
        - Co-Relationid: integer
          Unique ID for the service invoked, will be set by the TXN system
        - InitiatingSystem: string
          Indicating the initiated system
        - ServiceMode: integer
          Used for branch channel to indicate the type of customer
        - UUIDSeqNo: integer
          UUID Sequence Number
        - entity: string
          entity
        - referenceId: string
          Place holder for Token based authentication
        - requesthash: string
          Request payload for hash validation
        - userId: integer
          userId
        
        
        """
        
        
        # Prepare request data
        
        # Single body parameter - send directly
        data = request_body if request_body is not None else {}
        
        
        
        # Prepare query parameters
        params = {}
        
        
        # Replace path parameters in URL
        path = "/virtualAccountManagement/virtualAccount/numberScheme/bank"
        
        
        # Prepare headers
        headers = {}
        if accesstoken is not None:
            headers["Accesstoken"] = str(accesstoken)
        if channeltype is not None:
            headers["ChannelType"] = str(channeltype)
        if co_relationid is not None:
            headers["Co-Relationid"] = str(co_relationid)
        if initiatingsystem is not None:
            headers["InitiatingSystem"] = str(initiatingsystem)
        if servicemode is not None:
            headers["ServiceMode"] = str(servicemode)
        if uuidseqno is not None:
            headers["UUIDSeqNo"] = str(uuidseqno)
        if entity is not None:
            headers["entity"] = str(entity)
        if referenceid is not None:
            headers["referenceId"] = str(referenceid)
        if requesthash is not None:
            headers["requesthash"] = str(requesthash)
        if userid is not None:
            headers["userId"] = str(userid)
        
        
        return await make_api_request(
            "POST", 
            path, 
            data=data, 
            params=params if params else None, 
            headers=headers if headers else None
        )
    
    
    
    @mcp.tool()
    async def vabt0024_create_scheme_detail_using_post(
        request_body:Dict[str, Any] ,  # CreateSchemeDetail_Resource,
        accesstoken: Optional[str] = None,
        channeltype: Optional[int] = None,
        co_relationid: Optional[int] = None,
        initiatingsystem: Optional[str] = None,
        servicemode: Optional[int] = None,
        uuidseqno: Optional[int] = None,
        entity: Optional[str] = None,
        referenceid: Optional[str] = None,
        requesthash: Optional[str] = None,
        userid: Optional[int] = None
    ) -> Dict[str, Any]:
        """
        This service will create component details for virtual account numbering scheme
        
        Generated from: POST /virtualAccountManagement/virtualAccount/numberScheme/componentData/create
        Source: swagger_2_0
        Operation ID: VABT0024CreateSchemeDetailUsingPOST
        
        
        Authentication: Not required
        
        Parameters:
        - request_body: any (required)
          input
        
        
        
        Headers:
        - Accesstoken: string
          Authorization Token to validation the caller
        - ChannelType: integer
          Channel identifier from where the TXN has originated (Internet, Mobile, ATM, Branch Channel )
        - Co-Relationid: integer
          Unique ID for the service invoked, will be set by the TXN system
        - InitiatingSystem: string
          Indicating the initiated system
        - ServiceMode: integer
          Used for branch channel to indicate the type of customer
        - UUIDSeqNo: integer
          UUID Sequence Number
        - entity: string
          entity
        - referenceId: string
          Place holder for Token based authentication
        - requesthash: string
          Request payload for hash validation
        - userId: integer
          userId
        
        
        """
        
        
        # Prepare request data
        
        # Single body parameter - send directly
        data = request_body if request_body is not None else {}
        
        
        
        # Prepare query parameters
        params = {}
        
        
        # Replace path parameters in URL
        path = "/virtualAccountManagement/virtualAccount/numberScheme/componentData/create"
        
        
        # Prepare headers
        headers = {}
        if accesstoken is not None:
            headers["Accesstoken"] = str(accesstoken)
        if channeltype is not None:
            headers["ChannelType"] = str(channeltype)
        if co_relationid is not None:
            headers["Co-Relationid"] = str(co_relationid)
        if initiatingsystem is not None:
            headers["InitiatingSystem"] = str(initiatingsystem)
        if servicemode is not None:
            headers["ServiceMode"] = str(servicemode)
        if uuidseqno is not None:
            headers["UUIDSeqNo"] = str(uuidseqno)
        if entity is not None:
            headers["entity"] = str(entity)
        if referenceid is not None:
            headers["referenceId"] = str(referenceid)
        if requesthash is not None:
            headers["requesthash"] = str(requesthash)
        if userid is not None:
            headers["userId"] = str(userid)
        
        
        return await make_api_request(
            "POST", 
            path, 
            data=data, 
            params=params if params else None, 
            headers=headers if headers else None
        )
    
    
    
    @mcp.tool()
    async def vabt0027_delete_scheme_detail_using_post(
        request_body:Dict[str, Any] ,  # DeleteSchemeDetail_Resource,
        accesstoken: Optional[str] = None,
        channeltype: Optional[int] = None,
        co_relationid: Optional[int] = None,
        initiatingsystem: Optional[str] = None,
        servicemode: Optional[int] = None,
        uuidseqno: Optional[int] = None,
        entity: Optional[str] = None,
        referenceid: Optional[str] = None,
        requesthash: Optional[str] = None,
        userid: Optional[int] = None
    ) -> Dict[str, Any]:
        """
        This service will delete component details for virtual account numbering scheme
        
        Generated from: POST /virtualAccountManagement/virtualAccount/numberScheme/componentData/delete
        Source: swagger_2_0
        Operation ID: VABT0027DeleteSchemeDetailUsingPOST
        
        
        Authentication: Not required
        
        Parameters:
        - request_body: any (required)
          input
        
        
        
        Headers:
        - Accesstoken: string
          Authorization Token to validation the caller
        - ChannelType: integer
          Channel identifier from where the TXN has originated (Internet, Mobile, ATM, Branch Channel )
        - Co-Relationid: integer
          Unique ID for the service invoked, will be set by the TXN system
        - InitiatingSystem: string
          Indicating the initiated system
        - ServiceMode: integer
          Used for branch channel to indicate the type of customer
        - UUIDSeqNo: integer
          UUID Sequence Number
        - entity: string
          entity
        - referenceId: string
          Place holder for Token based authentication
        - requesthash: string
          Request payload for hash validation
        - userId: integer
          userId
        
        
        """
        
        
        # Prepare request data
        
        # Single body parameter - send directly
        data = request_body if request_body is not None else {}
        
        
        
        # Prepare query parameters
        params = {}
        
        
        # Replace path parameters in URL
        path = "/virtualAccountManagement/virtualAccount/numberScheme/componentData/delete"
        
        
        # Prepare headers
        headers = {}
        if accesstoken is not None:
            headers["Accesstoken"] = str(accesstoken)
        if channeltype is not None:
            headers["ChannelType"] = str(channeltype)
        if co_relationid is not None:
            headers["Co-Relationid"] = str(co_relationid)
        if initiatingsystem is not None:
            headers["InitiatingSystem"] = str(initiatingsystem)
        if servicemode is not None:
            headers["ServiceMode"] = str(servicemode)
        if uuidseqno is not None:
            headers["UUIDSeqNo"] = str(uuidseqno)
        if entity is not None:
            headers["entity"] = str(entity)
        if referenceid is not None:
            headers["referenceId"] = str(referenceid)
        if requesthash is not None:
            headers["requesthash"] = str(requesthash)
        if userid is not None:
            headers["userId"] = str(userid)
        
        
        return await make_api_request(
            "POST", 
            path, 
            data=data, 
            params=params if params else None, 
            headers=headers if headers else None
        )
    
    
    
    @mcp.tool()
    async def vaet0034_view_scheme_detail_using_get(
        detailschemeid: Optional[int] = None,
        numberschemeid: Optional[int] = None,
        pagenum: Optional[int] = None,
        pagesize: Optional[int] = None,
        accesstoken: Optional[str] = None,
        channeltype: Optional[int] = None,
        co_relationid: Optional[int] = None,
        initiatingsystem: Optional[str] = None,
        servicemode: Optional[int] = None,
        uuidseqno: Optional[int] = None,
        entity: Optional[str] = None,
        referenceid: Optional[str] = None,
        requesthash: Optional[str] = None,
        userid: Optional[int] = None
    ) -> Dict[str, Any]:
        """
        This service will help in viewing component details for virtual account numbering scheme
        
        Generated from: GET /virtualAccountManagement/virtualAccount/numberScheme/componentData/details
        Source: swagger_2_0
        Operation ID: VAET0034ViewSchemeDetailUsingGET
        
        
        Authentication: Not required
        
        Parameters:
        - detailSchemeId: integer
          Unique Reference for the  Bankdefined/customer Defined numbering scheme
        - numberSchemeId: integer
          Unique Reference for the  Bankdefined/customer Defined numbering scheme
        - pageNum: integer
          pageNum
        - pageSize: integer
          pageSize
        
        
        
        Headers:
        - Accesstoken: string
          Authorization Token to validation the caller
        - ChannelType: integer
          Channel identifier from where the TXN has originated (Internet, Mobile, ATM, Branch Channel )
        - Co-Relationid: integer
          Unique ID for the service invoked, will be set by the TXN system
        - InitiatingSystem: string
          Indicating the initiated system
        - ServiceMode: integer
          Used for branch channel to indicate the type of customer
        - UUIDSeqNo: integer
          UUID Sequence Number
        - entity: string
          entity
        - referenceId: string
          Place holder for Token based authentication
        - requesthash: string
          Request payload for hash validation
        - userId: integer
          userId
        
        
        """
        
        
        # Prepare query parameters
        params = {}
        if detailschemeid is not None:
            params["detailSchemeId"] = detailschemeid
            
        if numberschemeid is not None:
            params["numberSchemeId"] = numberschemeid
            
        if pagenum is not None:
            params["pageNum"] = pagenum
            
        if pagesize is not None:
            params["pageSize"] = pagesize
            
        
        
        # Replace path parameters in URL
        path = "/virtualAccountManagement/virtualAccount/numberScheme/componentData/details"
        
        
        # Prepare headers
        headers = {}
        if accesstoken is not None:
            headers["Accesstoken"] = str(accesstoken)
        if channeltype is not None:
            headers["ChannelType"] = str(channeltype)
        if co_relationid is not None:
            headers["Co-Relationid"] = str(co_relationid)
        if initiatingsystem is not None:
            headers["InitiatingSystem"] = str(initiatingsystem)
        if servicemode is not None:
            headers["ServiceMode"] = str(servicemode)
        if uuidseqno is not None:
            headers["UUIDSeqNo"] = str(uuidseqno)
        if entity is not None:
            headers["entity"] = str(entity)
        if referenceid is not None:
            headers["referenceId"] = str(referenceid)
        if requesthash is not None:
            headers["requesthash"] = str(requesthash)
        if userid is not None:
            headers["userId"] = str(userid)
        
        
        return await make_api_request(
            "GET", 
            path, 
            
            params=params if params else None, 
            headers=headers if headers else None
        )
    
    
    
    @mcp.tool()
    async def vaet0035_get_level_values_details_using_get(
        corporateschemecode: Optional[str] = None,
        pagenum: Optional[int] = None,
        pagesize: Optional[int] = None,
        schemeid: Optional[int] = None,
        accesstoken: Optional[str] = None,
        channeltype: Optional[int] = None,
        co_relationid: Optional[int] = None,
        initiatingsystem: Optional[str] = None,
        servicemode: Optional[int] = None,
        uuidseqno: Optional[int] = None,
        entity: Optional[str] = None,
        referenceid: Optional[str] = None,
        requesthash: Optional[str] = None,
        userid: Optional[int] = None
    ) -> Dict[str, Any]:
        """
        This service is used to fetch Level Details 
        
        Generated from: GET /virtualAccountManagement/virtualAccount/numberScheme/componentData/levelData/details
        Source: swagger_2_0
        Operation ID: VAET0035GetLevelValuesDetailsUsingGET
        
        
        Authentication: Not required
        
        Parameters:
        - corporateSchemeCode: string
          Corporate Scheme Code uniquely identifies a registration for Virtual Account Management Service. Each of the Customer Registration will be with unique Corporate Scheme Code
        - pageNum: integer
          pageNum
        - pageSize: integer
          pageSize
        - schemeId: integer
          Reference for the Scheme Registration for unique Scheme Code and Customer Combination
        
        
        
        Headers:
        - Accesstoken: string
          Authorization Token to validation the caller
        - ChannelType: integer
          Channel identifier from where the TXN has originated (Internet, Mobile, ATM, Branch Channel )
        - Co-Relationid: integer
          Unique ID for the service invoked, will be set by the TXN system
        - InitiatingSystem: string
          Indicating the initiated system
        - ServiceMode: integer
          Used for branch channel to indicate the type of customer
        - UUIDSeqNo: integer
          UUID Sequence Number
        - entity: string
          entity
        - referenceId: string
          Place holder for Token based authentication
        - requesthash: string
          Request payload for hash validation
        - userId: integer
          userId
        
        
        """
        
        
        # Prepare query parameters
        params = {}
        if corporateschemecode is not None:
            params["corporateSchemeCode"] = corporateschemecode
            
        if pagenum is not None:
            params["pageNum"] = pagenum
            
        if pagesize is not None:
            params["pageSize"] = pagesize
            
        if schemeid is not None:
            params["schemeId"] = schemeid
            
        
        
        # Replace path parameters in URL
        path = "/virtualAccountManagement/virtualAccount/numberScheme/componentData/levelData/details"
        
        
        # Prepare headers
        headers = {}
        if accesstoken is not None:
            headers["Accesstoken"] = str(accesstoken)
        if channeltype is not None:
            headers["ChannelType"] = str(channeltype)
        if co_relationid is not None:
            headers["Co-Relationid"] = str(co_relationid)
        if initiatingsystem is not None:
            headers["InitiatingSystem"] = str(initiatingsystem)
        if servicemode is not None:
            headers["ServiceMode"] = str(servicemode)
        if uuidseqno is not None:
            headers["UUIDSeqNo"] = str(uuidseqno)
        if entity is not None:
            headers["entity"] = str(entity)
        if referenceid is not None:
            headers["referenceId"] = str(referenceid)
        if requesthash is not None:
            headers["requesthash"] = str(requesthash)
        if userid is not None:
            headers["userId"] = str(userid)
        
        
        return await make_api_request(
            "GET", 
            path, 
            
            params=params if params else None, 
            headers=headers if headers else None
        )
    
    
    
    @mcp.tool()
    async def vabt0026_modify_scheme_detail_using_post(
        request_body:Dict[str, Any] ,  # ModifySchemeDetail_Resource,
        accesstoken: Optional[str] = None,
        channeltype: Optional[int] = None,
        co_relationid: Optional[int] = None,
        initiatingsystem: Optional[str] = None,
        servicemode: Optional[int] = None,
        uuidseqno: Optional[int] = None,
        entity: Optional[str] = None,
        referenceid: Optional[str] = None,
        requesthash: Optional[str] = None,
        userid: Optional[int] = None
    ) -> Dict[str, Any]:
        """
        This service will modify component details for virtual account numbering scheme
        
        Generated from: POST /virtualAccountManagement/virtualAccount/numberScheme/componentData/modify
        Source: swagger_2_0
        Operation ID: VABT0026ModifySchemeDetailUsingPOST
        
        
        Authentication: Not required
        
        Parameters:
        - request_body: any (required)
          input
        
        
        
        Headers:
        - Accesstoken: string
          Authorization Token to validation the caller
        - ChannelType: integer
          Channel identifier from where the TXN has originated (Internet, Mobile, ATM, Branch Channel )
        - Co-Relationid: integer
          Unique ID for the service invoked, will be set by the TXN system
        - InitiatingSystem: string
          Indicating the initiated system
        - ServiceMode: integer
          Used for branch channel to indicate the type of customer
        - UUIDSeqNo: integer
          UUID Sequence Number
        - entity: string
          entity
        - referenceId: string
          Place holder for Token based authentication
        - requesthash: string
          Request payload for hash validation
        - userId: integer
          userId
        
        
        """
        
        
        # Prepare request data
        
        # Single body parameter - send directly
        data = request_body if request_body is not None else {}
        
        
        
        # Prepare query parameters
        params = {}
        
        
        # Replace path parameters in URL
        path = "/virtualAccountManagement/virtualAccount/numberScheme/componentData/modify"
        
        
        # Prepare headers
        headers = {}
        if accesstoken is not None:
            headers["Accesstoken"] = str(accesstoken)
        if channeltype is not None:
            headers["ChannelType"] = str(channeltype)
        if co_relationid is not None:
            headers["Co-Relationid"] = str(co_relationid)
        if initiatingsystem is not None:
            headers["InitiatingSystem"] = str(initiatingsystem)
        if servicemode is not None:
            headers["ServiceMode"] = str(servicemode)
        if uuidseqno is not None:
            headers["UUIDSeqNo"] = str(uuidseqno)
        if entity is not None:
            headers["entity"] = str(entity)
        if referenceid is not None:
            headers["referenceId"] = str(referenceid)
        if requesthash is not None:
            headers["requesthash"] = str(requesthash)
        if userid is not None:
            headers["userId"] = str(userid)
        
        
        return await make_api_request(
            "POST", 
            path, 
            data=data, 
            params=params if params else None, 
            headers=headers if headers else None
        )
    
    
    
    @mcp.tool()
    async def vaet0036_validate_scheme_detail_using_get(
        fieldreference: int,
        numberschemeid: int,
        pagenum: Optional[int] = None,
        pagesize: Optional[int] = None,
        startposition: Optional[int] = None,
        accesstoken: Optional[str] = None,
        channeltype: Optional[int] = None,
        co_relationid: Optional[int] = None,
        initiatingsystem: Optional[str] = None,
        servicemode: Optional[int] = None,
        uuidseqno: Optional[int] = None,
        entity: Optional[str] = None,
        referenceid: Optional[str] = None,
        requesthash: Optional[str] = None,
        userid: Optional[int] = None
    ) -> Dict[str, Any]:
        """
        This service will validate scheme detail based on Level detail records
        
        Generated from: GET /virtualAccountManagement/virtualAccount/numberScheme/componentData/validate
        Source: swagger_2_0
        Operation ID: VAET0036ValidateSchemeDetailUsingGET
        
        
        Authentication: Not required
        
        Parameters:
        - fieldReference: integer (required)
           Field Reference denotes the different Factors on which Virtual Account Schema will be defined. It will be part of Virtual Account Number Generated based on Schema Defined (1 - Level 1, 2 - Level 2, 3 - Level 3, 4 - Level 4, 5 - Level 5, 6 - Level 6, 7 - Level 7, 8 - Country Code, 9 - Check Digit, 10 - Bank Code, 11 - Branch Code, 12 - BIC, 13 - Sort Code, 14 - Corporate Scheme Code, 15 - National Check Digit, 16 - Currency, 17 - Account Type, 18 - Account Number Sequence)
        - numberSchemeId: integer (required)
          Unique Reference for the Account numbering which will happen for each Bankdefined/customer Defined schema provided for account number generation
        - pageNum: integer
          pageNum
        - pageSize: integer
          pageSize
        - startPosition: integer
          Denotes Start position of that part of virtual account number scheme as mentioned in Field Description
        
        
        
        Headers:
        - Accesstoken: string
          Authorization Token to validation the caller
        - ChannelType: integer
          Channel identifier from where the TXN has originated (Internet, Mobile, ATM, Branch Channel )
        - Co-Relationid: integer
          Unique ID for the service invoked, will be set by the TXN system
        - InitiatingSystem: string
          Indicating the initiated system
        - ServiceMode: integer
          Used for branch channel to indicate the type of customer
        - UUIDSeqNo: integer
          UUID Sequence Number
        - entity: string
          entity
        - referenceId: string
          Place holder for Token based authentication
        - requesthash: string
          Request payload for hash validation
        - userId: integer
          userId
        
        
        """
        
        
        # Prepare query parameters
        params = {}
        if fieldreference is not None:
            params["fieldReference"] = fieldreference
            
        if numberschemeid is not None:
            params["numberSchemeId"] = numberschemeid
            
        if pagenum is not None:
            params["pageNum"] = pagenum
            
        if pagesize is not None:
            params["pageSize"] = pagesize
            
        if startposition is not None:
            params["startPosition"] = startposition
            
        
        
        # Replace path parameters in URL
        path = "/virtualAccountManagement/virtualAccount/numberScheme/componentData/validate"
        
        
        # Prepare headers
        headers = {}
        if accesstoken is not None:
            headers["Accesstoken"] = str(accesstoken)
        if channeltype is not None:
            headers["ChannelType"] = str(channeltype)
        if co_relationid is not None:
            headers["Co-Relationid"] = str(co_relationid)
        if initiatingsystem is not None:
            headers["InitiatingSystem"] = str(initiatingsystem)
        if servicemode is not None:
            headers["ServiceMode"] = str(servicemode)
        if uuidseqno is not None:
            headers["UUIDSeqNo"] = str(uuidseqno)
        if entity is not None:
            headers["entity"] = str(entity)
        if referenceid is not None:
            headers["referenceId"] = str(referenceid)
        if requesthash is not None:
            headers["requesthash"] = str(requesthash)
        if userid is not None:
            headers["userId"] = str(userid)
        
        
        return await make_api_request(
            "GET", 
            path, 
            
            params=params if params else None, 
            headers=headers if headers else None
        )
    
    
    
    @mcp.tool()
    async def vaet0033_fetch_scheme_detail_list_using_get(
        numberschemeid: int,
        pagenum: Optional[int] = None,
        pagesize: Optional[int] = None,
        accesstoken: Optional[str] = None,
        channeltype: Optional[int] = None,
        co_relationid: Optional[int] = None,
        initiatingsystem: Optional[str] = None,
        servicemode: Optional[int] = None,
        uuidseqno: Optional[int] = None,
        entity: Optional[str] = None,
        referenceid: Optional[str] = None,
        requesthash: Optional[str] = None,
        userid: Optional[int] = None
    ) -> Dict[str, Any]:
        """
        This service will fetch component details for the virtual account numbering scheme
        
        Generated from: GET /virtualAccountManagement/virtualAccount/numberScheme/componentData/{numberSchemeId}/list
        Source: swagger_2_0
        Operation ID: VAET0033FetchSchemeDetailListUsingGET
        
        
        Authentication: Not required
        
        Parameters:
        - numberSchemeId: integer (required)
          Unique Reference for the  Bankdefined/customer Defined numbering scheme
        - pageNum: integer
          pageNum
        - pageSize: integer
          pageSize
        
        
        
        Headers:
        - Accesstoken: string
          Authorization Token to validation the caller
        - ChannelType: integer
          Channel identifier from where the TXN has originated (Internet, Mobile, ATM, Branch Channel )
        - Co-Relationid: integer
          Unique ID for the service invoked, will be set by the TXN system
        - InitiatingSystem: string
          Indicating the initiated system
        - ServiceMode: integer
          Used for branch channel to indicate the type of customer
        - UUIDSeqNo: integer
          UUID Sequence Number
        - entity: string
          entity
        - referenceId: string
          Place holder for Token based authentication
        - requesthash: string
          Request payload for hash validation
        - userId: integer
          userId
        
        
        """
        
        
        # Prepare query parameters
        params = {}
        if pagenum is not None:
            params["pageNum"] = pagenum
            
        if pagesize is not None:
            params["pageSize"] = pagesize
            
        
        
        # Replace path parameters in URL
        path = "/virtualAccountManagement/virtualAccount/numberScheme/componentData/{numberSchemeId}/list"
        if numberschemeid is not None:
            path = path.replace("{numberSchemeId}", str(numberschemeid))
        
        
        # Prepare headers
        headers = {}
        if accesstoken is not None:
            headers["Accesstoken"] = str(accesstoken)
        if channeltype is not None:
            headers["ChannelType"] = str(channeltype)
        if co_relationid is not None:
            headers["Co-Relationid"] = str(co_relationid)
        if initiatingsystem is not None:
            headers["InitiatingSystem"] = str(initiatingsystem)
        if servicemode is not None:
            headers["ServiceMode"] = str(servicemode)
        if uuidseqno is not None:
            headers["UUIDSeqNo"] = str(uuidseqno)
        if entity is not None:
            headers["entity"] = str(entity)
        if referenceid is not None:
            headers["referenceId"] = str(referenceid)
        if requesthash is not None:
            headers["requesthash"] = str(requesthash)
        if userid is not None:
            headers["userId"] = str(userid)
        
        
        return await make_api_request(
            "GET", 
            path, 
            
            params=params if params else None, 
            headers=headers if headers else None
        )
    
    
    
    @mcp.tool()
    async def vaet0039_fetch_corporate_scheme_using_get(
        corporateschemecode: Optional[str] = None,
        corporateschemename: Optional[str] = None,
        customerreference: Optional[str] = None,
        pagenum: Optional[int] = None,
        pagesize: Optional[int] = None,
        status: Optional[int] = None,
        accesstoken: Optional[str] = None,
        channeltype: Optional[int] = None,
        co_relationid: Optional[int] = None,
        initiatingsystem: Optional[str] = None,
        servicemode: Optional[int] = None,
        uuidseqno: Optional[int] = None,
        entity: Optional[str] = None,
        referenceid: Optional[str] = None,
        requesthash: Optional[str] = None,
        userid: Optional[int] = None
    ) -> Dict[str, Any]:
        """
        This is used to Fetch Corporate Scheme Codes
        
        Generated from: GET /virtualAccountManagement/virtualAccount/numberScheme/corporateSchemeCodes/list
        Source: swagger_2_0
        Operation ID: VAET0039FetchCorporateSchemeUsingGET
        
        
        Authentication: Not required
        
        Parameters:
        - corporateSchemeCode: string
          Corporate Scheme Code uniquely identifies a registration for Virtual Account Management Service. Each of the Customer Registration will be with unique Corporate Scheme Code
        - corporateSchemeName: string
          Name of the Scheme Code which denotes the Purpose for which Virtual Account Management registration is done
        - customerReference: string
          Business Partner Reference or equivalent identifier uniquely assigned to the customer
        - pageNum: integer
          pageNum
        - pageSize: integer
          pageSize
        - status: integer
          This Field denotes the WorkFlow Status of the Customer Registration created by User(1-Active,2-OnHold,3-ActivePndngAuth,4-Released,5-PndngCancelAuth,6-PendingCancel,7-Cancelled,8-Rejected,9-MOnHold)
        
        
        
        Headers:
        - Accesstoken: string
          Authorization Token to validation the caller
        - ChannelType: integer
          Channel identifier from where the TXN has originated (Internet, Mobile, ATM, Branch Channel )
        - Co-Relationid: integer
          Unique ID for the service invoked, will be set by the TXN system
        - InitiatingSystem: string
          Indicating the initiated system
        - ServiceMode: integer
          Used for branch channel to indicate the type of customer
        - UUIDSeqNo: integer
          UUID Sequence Number
        - entity: string
          entity
        - referenceId: string
          Place holder for Token based authentication
        - requesthash: string
          Request payload for hash validation
        - userId: integer
          userId
        
        
        """
        
        
        # Prepare query parameters
        params = {}
        if corporateschemecode is not None:
            params["corporateSchemeCode"] = corporateschemecode
            
        if corporateschemename is not None:
            params["corporateSchemeName"] = corporateschemename
            
        if customerreference is not None:
            params["customerReference"] = customerreference
            
        if pagenum is not None:
            params["pageNum"] = pagenum
            
        if pagesize is not None:
            params["pageSize"] = pagesize
            
        if status is not None:
            params["status"] = status
            
        
        
        # Replace path parameters in URL
        path = "/virtualAccountManagement/virtualAccount/numberScheme/corporateSchemeCodes/list"
        
        
        # Prepare headers
        headers = {}
        if accesstoken is not None:
            headers["Accesstoken"] = str(accesstoken)
        if channeltype is not None:
            headers["ChannelType"] = str(channeltype)
        if co_relationid is not None:
            headers["Co-Relationid"] = str(co_relationid)
        if initiatingsystem is not None:
            headers["InitiatingSystem"] = str(initiatingsystem)
        if servicemode is not None:
            headers["ServiceMode"] = str(servicemode)
        if uuidseqno is not None:
            headers["UUIDSeqNo"] = str(uuidseqno)
        if entity is not None:
            headers["entity"] = str(entity)
        if referenceid is not None:
            headers["referenceId"] = str(referenceid)
        if requesthash is not None:
            headers["requesthash"] = str(requesthash)
        if userid is not None:
            headers["userId"] = str(userid)
        
        
        return await make_api_request(
            "GET", 
            path, 
            
            params=params if params else None, 
            headers=headers if headers else None
        )
    
    
    
    @mcp.tool()
    async def vaet0037_populate_entity_country_using_get(
        accesstoken: Optional[str] = None,
        channeltype: Optional[int] = None,
        co_relationid: Optional[int] = None,
        initiatingsystem: Optional[str] = None,
        servicemode: Optional[int] = None,
        uuidseqno: Optional[int] = None,
        entity: Optional[str] = None,
        referenceid: Optional[str] = None,
        requesthash: Optional[str] = None,
        userid: Optional[int] = None
    ) -> Dict[str, Any]:
        """
        This service will populate the Country code details
        
        Generated from: GET /virtualAccountManagement/virtualAccount/numberScheme/countryCode
        Source: swagger_2_0
        Operation ID: VAET0037PopulateEntityCountryUsingGET
        
        
        Authentication: Not required
        
        Parameters:
        
        
        
        Headers:
        - Accesstoken: string
          Authorization Token to validation the caller
        - ChannelType: integer
          Channel identifier from where the TXN has originated (Internet, Mobile, ATM, Branch Channel )
        - Co-Relationid: integer
          Unique ID for the service invoked, will be set by the TXN system
        - InitiatingSystem: string
          Indicating the initiated system
        - ServiceMode: integer
          Used for branch channel to indicate the type of customer
        - UUIDSeqNo: integer
          UUID Sequence Number
        - entity: string
          entity
        - referenceId: string
          Place holder for Token based authentication
        - requesthash: string
          Request payload for hash validation
        - userId: integer
          userId
        
        
        """
        
        
        # Prepare query parameters
        params = {}
        
        
        # Replace path parameters in URL
        path = "/virtualAccountManagement/virtualAccount/numberScheme/countryCode"
        
        
        # Prepare headers
        headers = {}
        if accesstoken is not None:
            headers["Accesstoken"] = str(accesstoken)
        if channeltype is not None:
            headers["ChannelType"] = str(channeltype)
        if co_relationid is not None:
            headers["Co-Relationid"] = str(co_relationid)
        if initiatingsystem is not None:
            headers["InitiatingSystem"] = str(initiatingsystem)
        if servicemode is not None:
            headers["ServiceMode"] = str(servicemode)
        if uuidseqno is not None:
            headers["UUIDSeqNo"] = str(uuidseqno)
        if entity is not None:
            headers["entity"] = str(entity)
        if referenceid is not None:
            headers["referenceId"] = str(referenceid)
        if requesthash is not None:
            headers["requesthash"] = str(requesthash)
        if userid is not None:
            headers["userId"] = str(userid)
        
        
        return await make_api_request(
            "GET", 
            path, 
            
            params=params if params else None, 
            headers=headers if headers else None
        )
    
    
    
    @mcp.tool()
    async def vabt0021_create_account_scheme_customer_defined_using_post(
        request_body:Dict[str, Any] ,  # CreateAccountSchemeCustomerDefined_Resource,
        accesstoken: Optional[str] = None,
        channeltype: Optional[int] = None,
        co_relationid: Optional[int] = None,
        initiatingsystem: Optional[str] = None,
        servicemode: Optional[int] = None,
        uuidseqno: Optional[int] = None,
        entity: Optional[str] = None,
        referenceid: Optional[str] = None,
        requesthash: Optional[str] = None,
        userid: Optional[int] = None
    ) -> Dict[str, Any]:
        """
        This service is used to Create Customer Defined Account Scheme
        
        Generated from: POST /virtualAccountManagement/virtualAccount/numberScheme/customer
        Source: swagger_2_0
        Operation ID: VABT0021CreateAccountSchemeCustomerDefinedUsingPOST
        
        
        Authentication: Not required
        
        Parameters:
        - request_body: any (required)
          input
        
        
        
        Headers:
        - Accesstoken: string
          Authorization Token to validation the caller
        - ChannelType: integer
          Channel identifier from where the TXN has originated (Internet, Mobile, ATM, Branch Channel )
        - Co-Relationid: integer
          Unique ID for the service invoked, will be set by the TXN system
        - InitiatingSystem: string
          Indicating the initiated system
        - ServiceMode: integer
          Used for branch channel to indicate the type of customer
        - UUIDSeqNo: integer
          UUID Sequence Number
        - entity: string
          entity
        - referenceId: string
          Place holder for Token based authentication
        - requesthash: string
          Request payload for hash validation
        - userId: integer
          userId
        
        
        """
        
        
        # Prepare request data
        
        # Single body parameter - send directly
        data = request_body if request_body is not None else {}
        
        
        
        # Prepare query parameters
        params = {}
        
        
        # Replace path parameters in URL
        path = "/virtualAccountManagement/virtualAccount/numberScheme/customer"
        
        
        # Prepare headers
        headers = {}
        if accesstoken is not None:
            headers["Accesstoken"] = str(accesstoken)
        if channeltype is not None:
            headers["ChannelType"] = str(channeltype)
        if co_relationid is not None:
            headers["Co-Relationid"] = str(co_relationid)
        if initiatingsystem is not None:
            headers["InitiatingSystem"] = str(initiatingsystem)
        if servicemode is not None:
            headers["ServiceMode"] = str(servicemode)
        if uuidseqno is not None:
            headers["UUIDSeqNo"] = str(uuidseqno)
        if entity is not None:
            headers["entity"] = str(entity)
        if referenceid is not None:
            headers["referenceId"] = str(referenceid)
        if requesthash is not None:
            headers["requesthash"] = str(requesthash)
        if userid is not None:
            headers["userId"] = str(userid)
        
        
        return await make_api_request(
            "POST", 
            path, 
            data=data, 
            params=params if params else None, 
            headers=headers if headers else None
        )
    
    
    
    @mcp.tool()
    async def vaet0031_fetch_scheme_list_using_get(
        accountusage: Optional[str] = None,
        corporateschemecode: Optional[str] = None,
        formattype: Optional[str] = None,
        numberschemeid: Optional[str] = None,
        pagenum: Optional[int] = None,
        pagesize: Optional[int] = None,
        status: Optional[str] = None,
        accesstoken: Optional[str] = None,
        channeltype: Optional[int] = None,
        co_relationid: Optional[int] = None,
        initiatingsystem: Optional[str] = None,
        servicemode: Optional[int] = None,
        uuidseqno: Optional[int] = None,
        entity: Optional[str] = None,
        referenceid: Optional[str] = None,
        requesthash: Optional[str] = None,
        userid: Optional[int] = None
    ) -> Dict[str, Any]:
        """
        This service is used to Fetch Account Scheme List
        
        Generated from: GET /virtualAccountManagement/virtualAccount/numberScheme/list
        Source: swagger_2_0
        Operation ID: VAET0031FetchSchemeListUsingGET
        
        
        Authentication: Not required
        
        Parameters:
        - accountUsage: string
          It Provides flexibility to set up different schemes for different virtual account usages (1-VTA,2-Summary Account,3-VRN)
        - corporateSchemeCode: string
          Corporate Scheme Code uniquely identifies a registration for Virtual Account Management Service. Each of the Customer Registration will be with unique Corporate Scheme Code
        - formatType: string
          Captures the format for which account numbering scheme is being defined(1-IBAN,2-BBAN,3-Account Reference1,4- Account Reference2)
        - numberSchemeID: string
          Unique Reference for the Account numbering which will happen for each Bankdefined/customer Defined schema provided for account number generation
        - pageNum: integer
          pageNum
        - pageSize: integer
          pageSize
        - status: string
          This Field denotes the WorkFlow Status of the Account Numbering Scheme created by User(1-Active,2-OnHold,3-ActivePndngAuth,4-Released,5-PndngCancelAuth,6-PendingCancel,7-Cancelled,8-Rejected,9-MOnHold)
        
        
        
        Headers:
        - Accesstoken: string
          Authorization Token to validation the caller
        - ChannelType: integer
          Channel identifier from where the TXN has originated (Internet, Mobile, ATM, Branch Channel )
        - Co-Relationid: integer
          Unique ID for the service invoked, will be set by the TXN system
        - InitiatingSystem: string
          Indicating the initiated system
        - ServiceMode: integer
          Used for branch channel to indicate the type of customer
        - UUIDSeqNo: integer
          UUID Sequence Number
        - entity: string
          entity
        - referenceId: string
          Place holder for Token based authentication
        - requesthash: string
          Request payload for hash validation
        - userId: integer
          userId
        
        
        """
        
        
        # Prepare query parameters
        params = {}
        if accountusage is not None:
            params["accountUsage"] = accountusage
            
        if corporateschemecode is not None:
            params["corporateSchemeCode"] = corporateschemecode
            
        if formattype is not None:
            params["formatType"] = formattype
            
        if numberschemeid is not None:
            params["numberSchemeID"] = numberschemeid
            
        if pagenum is not None:
            params["pageNum"] = pagenum
            
        if pagesize is not None:
            params["pageSize"] = pagesize
            
        if status is not None:
            params["status"] = status
            
        
        
        # Replace path parameters in URL
        path = "/virtualAccountManagement/virtualAccount/numberScheme/list"
        
        
        # Prepare headers
        headers = {}
        if accesstoken is not None:
            headers["Accesstoken"] = str(accesstoken)
        if channeltype is not None:
            headers["ChannelType"] = str(channeltype)
        if co_relationid is not None:
            headers["Co-Relationid"] = str(co_relationid)
        if initiatingsystem is not None:
            headers["InitiatingSystem"] = str(initiatingsystem)
        if servicemode is not None:
            headers["ServiceMode"] = str(servicemode)
        if uuidseqno is not None:
            headers["UUIDSeqNo"] = str(uuidseqno)
        if entity is not None:
            headers["entity"] = str(entity)
        if referenceid is not None:
            headers["referenceId"] = str(referenceid)
        if requesthash is not None:
            headers["requesthash"] = str(requesthash)
        if userid is not None:
            headers["userId"] = str(userid)
        
        
        return await make_api_request(
            "GET", 
            path, 
            
            params=params if params else None, 
            headers=headers if headers else None
        )
    
    
    
    @mcp.tool()
    async def vabt0022_modify_account_scheme_using_post(
        request_body:Dict[str, Any] ,  # ModifyAccountScheme_Resourse,
        accesstoken: Optional[str] = None,
        channeltype: Optional[int] = None,
        co_relationid: Optional[int] = None,
        initiatingsystem: Optional[str] = None,
        servicemode: Optional[int] = None,
        uuidseqno: Optional[int] = None,
        entity: Optional[str] = None,
        referenceid: Optional[str] = None,
        requesthash: Optional[str] = None,
        userid: Optional[int] = None
    ) -> Dict[str, Any]:
        """
        This service is used to modify an account scheme
        
        Generated from: POST /virtualAccountManagement/virtualAccount/numberScheme/modify
        Source: swagger_2_0
        Operation ID: VABT0022ModifyAccountSchemeUsingPOST
        
        
        Authentication: Not required
        
        Parameters:
        - request_body: any (required)
          input
        
        
        
        Headers:
        - Accesstoken: string
          Authorization Token to validation the caller
        - ChannelType: integer
          Channel identifier from where the TXN has originated (Internet, Mobile, ATM, Branch Channel )
        - Co-Relationid: integer
          Unique ID for the service invoked, will be set by the TXN system
        - InitiatingSystem: string
          Indicating the initiated system
        - ServiceMode: integer
          Used for branch channel to indicate the type of customer
        - UUIDSeqNo: integer
          UUID Sequence Number
        - entity: string
          entity
        - referenceId: string
          Place holder for Token based authentication
        - requesthash: string
          Request payload for hash validation
        - userId: integer
          userId
        
        
        """
        
        
        # Prepare request data
        
        # Single body parameter - send directly
        data = request_body if request_body is not None else {}
        
        
        
        # Prepare query parameters
        params = {}
        
        
        # Replace path parameters in URL
        path = "/virtualAccountManagement/virtualAccount/numberScheme/modify"
        
        
        # Prepare headers
        headers = {}
        if accesstoken is not None:
            headers["Accesstoken"] = str(accesstoken)
        if channeltype is not None:
            headers["ChannelType"] = str(channeltype)
        if co_relationid is not None:
            headers["Co-Relationid"] = str(co_relationid)
        if initiatingsystem is not None:
            headers["InitiatingSystem"] = str(initiatingsystem)
        if servicemode is not None:
            headers["ServiceMode"] = str(servicemode)
        if uuidseqno is not None:
            headers["UUIDSeqNo"] = str(uuidseqno)
        if entity is not None:
            headers["entity"] = str(entity)
        if referenceid is not None:
            headers["referenceId"] = str(referenceid)
        if requesthash is not None:
            headers["requesthash"] = str(requesthash)
        if userid is not None:
            headers["userId"] = str(userid)
        
        
        return await make_api_request(
            "POST", 
            path, 
            data=data, 
            params=params if params else None, 
            headers=headers if headers else None
        )
    
    
    
    @mcp.tool()
    async def vaet0038_validate_corporate_scheme_using_get(
        corporateschemecode: str,
        pagenum: Optional[int] = None,
        pagesize: Optional[int] = None,
        accesstoken: Optional[str] = None,
        channeltype: Optional[int] = None,
        co_relationid: Optional[int] = None,
        initiatingsystem: Optional[str] = None,
        servicemode: Optional[int] = None,
        uuidseqno: Optional[int] = None,
        entity: Optional[str] = None,
        referenceid: Optional[str] = None,
        requesthash: Optional[str] = None,
        userid: Optional[int] = None
    ) -> Dict[str, Any]:
        """
        To Validate Corporate Scheme Code
        
        Generated from: GET /virtualAccountManagement/virtualAccount/numberScheme/{corporateSchemeCode}
        Source: swagger_2_0
        Operation ID: VAET0038ValidateCorporateSchemeUsingGET
        
        
        Authentication: Not required
        
        Parameters:
        - corporateSchemeCode: string (required)
          Corporate Scheme Code uniquely identifies a registration for Virtual Account Management Service. Each of the Customer Registration will be with unique Corporate Scheme Code
        - pageNum: integer
          pageNum
        - pageSize: integer
          pageSize
        
        
        
        Headers:
        - Accesstoken: string
          Authorization Token to validation the caller
        - ChannelType: integer
          Channel identifier from where the TXN has originated (Internet, Mobile, ATM, Branch Channel )
        - Co-Relationid: integer
          Unique ID for the service invoked, will be set by the TXN system
        - InitiatingSystem: string
          Indicating the initiated system
        - ServiceMode: integer
          Used for branch channel to indicate the type of customer
        - UUIDSeqNo: integer
          UUID Sequence Number
        - entity: string
          entity
        - referenceId: string
          Place holder for Token based authentication
        - requesthash: string
          Request payload for hash validation
        - userId: integer
          userId
        
        
        """
        
        
        # Prepare query parameters
        params = {}
        if pagenum is not None:
            params["pageNum"] = pagenum
            
        if pagesize is not None:
            params["pageSize"] = pagesize
            
        
        
        # Replace path parameters in URL
        path = "/virtualAccountManagement/virtualAccount/numberScheme/{corporateSchemeCode}"
        if corporateschemecode is not None:
            path = path.replace("{corporateSchemeCode}", str(corporateschemecode))
        
        
        # Prepare headers
        headers = {}
        if accesstoken is not None:
            headers["Accesstoken"] = str(accesstoken)
        if channeltype is not None:
            headers["ChannelType"] = str(channeltype)
        if co_relationid is not None:
            headers["Co-Relationid"] = str(co_relationid)
        if initiatingsystem is not None:
            headers["InitiatingSystem"] = str(initiatingsystem)
        if servicemode is not None:
            headers["ServiceMode"] = str(servicemode)
        if uuidseqno is not None:
            headers["UUIDSeqNo"] = str(uuidseqno)
        if entity is not None:
            headers["entity"] = str(entity)
        if referenceid is not None:
            headers["referenceId"] = str(referenceid)
        if requesthash is not None:
            headers["requesthash"] = str(requesthash)
        if userid is not None:
            headers["userId"] = str(userid)
        
        
        return await make_api_request(
            "GET", 
            path, 
            
            params=params if params else None, 
            headers=headers if headers else None
        )
    
    
    
    @mcp.tool()
    async def vabt0023_authorise_account_scheme_using_post(
        numberschemeid: str,
        request_body:Dict[str, Any] ,  # AuthoriseAccountScheme_Resourse,
        accesstoken: Optional[str] = None,
        channeltype: Optional[int] = None,
        co_relationid: Optional[int] = None,
        initiatingsystem: Optional[str] = None,
        servicemode: Optional[int] = None,
        uuidseqno: Optional[int] = None,
        entity: Optional[str] = None,
        referenceid: Optional[str] = None,
        requesthash: Optional[str] = None,
        userid: Optional[int] = None
    ) -> Dict[str, Any]:
        """
        This service is used to Authorise Account Scheme
        
        Generated from: POST /virtualAccountManagement/virtualAccount/numberScheme/{numberSchemeId}/authorise
        Source: swagger_2_0
        Operation ID: VABT0023AuthoriseAccountSchemeUsingPOST
        
        
        Authentication: Not required
        
        Parameters:
        - numberSchemeId: string (required)
          Path parameter numberSchemeId
        - request_body: any (required)
          input
        
        
        
        Headers:
        - Accesstoken: string
          Authorization Token to validation the caller
        - ChannelType: integer
          Channel identifier from where the TXN has originated (Internet, Mobile, ATM, Branch Channel )
        - Co-Relationid: integer
          Unique ID for the service invoked, will be set by the TXN system
        - InitiatingSystem: string
          Indicating the initiated system
        - ServiceMode: integer
          Used for branch channel to indicate the type of customer
        - UUIDSeqNo: integer
          UUID Sequence Number
        - entity: string
          entity
        - referenceId: string
          Place holder for Token based authentication
        - requesthash: string
          Request payload for hash validation
        - userId: integer
          userId
        
        
        """
        
        
        # Prepare request data
        
        # Single body parameter - send directly
        data = request_body if request_body is not None else {}
        
        
        
        # Prepare query parameters
        params = {}
        
        
        # Replace path parameters in URL
        path = "/virtualAccountManagement/virtualAccount/numberScheme/{numberSchemeId}/authorise"
        if numberschemeid is not None:
            path = path.replace("{numberSchemeId}", str(numberschemeid))
        
        
        # Prepare headers
        headers = {}
        if accesstoken is not None:
            headers["Accesstoken"] = str(accesstoken)
        if channeltype is not None:
            headers["ChannelType"] = str(channeltype)
        if co_relationid is not None:
            headers["Co-Relationid"] = str(co_relationid)
        if initiatingsystem is not None:
            headers["InitiatingSystem"] = str(initiatingsystem)
        if servicemode is not None:
            headers["ServiceMode"] = str(servicemode)
        if uuidseqno is not None:
            headers["UUIDSeqNo"] = str(uuidseqno)
        if entity is not None:
            headers["entity"] = str(entity)
        if referenceid is not None:
            headers["referenceId"] = str(referenceid)
        if requesthash is not None:
            headers["requesthash"] = str(requesthash)
        if userid is not None:
            headers["userId"] = str(userid)
        
        
        return await make_api_request(
            "POST", 
            path, 
            data=data, 
            params=params if params else None, 
            headers=headers if headers else None
        )
    
    
    
    @mcp.tool()
    async def vabt0029_cancel_account_scheme_using_post(
        numberschemeid: str,
        request_body:Dict[str, Any] ,  # CancelAccountScheme_Resource,
        accesstoken: Optional[str] = None,
        channeltype: Optional[int] = None,
        co_relationid: Optional[int] = None,
        initiatingsystem: Optional[str] = None,
        servicemode: Optional[int] = None,
        uuidseqno: Optional[int] = None,
        entity: Optional[str] = None,
        referenceid: Optional[str] = None,
        requesthash: Optional[str] = None,
        userid: Optional[int] = None
    ) -> Dict[str, Any]:
        """
        This service is used to Cancel Account Scheme
        
        Generated from: POST /virtualAccountManagement/virtualAccount/numberScheme/{numberSchemeId}/cancel
        Source: swagger_2_0
        Operation ID: VABT0029CancelAccountSchemeUsingPOST
        
        
        Authentication: Not required
        
        Parameters:
        - numberSchemeId: string (required)
          Path parameter numberSchemeId
        - request_body: any (required)
          input
        
        
        
        Headers:
        - Accesstoken: string
          Authorization Token to validation the caller
        - ChannelType: integer
          Channel identifier from where the TXN has originated (Internet, Mobile, ATM, Branch Channel )
        - Co-Relationid: integer
          Unique ID for the service invoked, will be set by the TXN system
        - InitiatingSystem: string
          Indicating the initiated system
        - ServiceMode: integer
          Used for branch channel to indicate the type of customer
        - UUIDSeqNo: integer
          UUID Sequence Number
        - entity: string
          entity
        - referenceId: string
          Place holder for Token based authentication
        - requesthash: string
          Request payload for hash validation
        - userId: integer
          userId
        
        
        """
        
        
        # Prepare request data
        
        # Single body parameter - send directly
        data = request_body if request_body is not None else {}
        
        
        
        # Prepare query parameters
        params = {}
        
        
        # Replace path parameters in URL
        path = "/virtualAccountManagement/virtualAccount/numberScheme/{numberSchemeId}/cancel"
        if numberschemeid is not None:
            path = path.replace("{numberSchemeId}", str(numberschemeid))
        
        
        # Prepare headers
        headers = {}
        if accesstoken is not None:
            headers["Accesstoken"] = str(accesstoken)
        if channeltype is not None:
            headers["ChannelType"] = str(channeltype)
        if co_relationid is not None:
            headers["Co-Relationid"] = str(co_relationid)
        if initiatingsystem is not None:
            headers["InitiatingSystem"] = str(initiatingsystem)
        if servicemode is not None:
            headers["ServiceMode"] = str(servicemode)
        if uuidseqno is not None:
            headers["UUIDSeqNo"] = str(uuidseqno)
        if entity is not None:
            headers["entity"] = str(entity)
        if referenceid is not None:
            headers["referenceId"] = str(referenceid)
        if requesthash is not None:
            headers["requesthash"] = str(requesthash)
        if userid is not None:
            headers["userId"] = str(userid)
        
        
        return await make_api_request(
            "POST", 
            path, 
            data=data, 
            params=params if params else None, 
            headers=headers if headers else None
        )
    
    
    
    @mcp.tool()
    async def vaet0032_view_scheme_using_get(
        numberschemeid: int,
        pagenum: Optional[int] = None,
        pagesize: Optional[int] = None,
        accesstoken: Optional[str] = None,
        channeltype: Optional[int] = None,
        co_relationid: Optional[int] = None,
        initiatingsystem: Optional[str] = None,
        servicemode: Optional[int] = None,
        uuidseqno: Optional[int] = None,
        entity: Optional[str] = None,
        referenceid: Optional[str] = None,
        requesthash: Optional[str] = None,
        userid: Optional[int] = None
    ) -> Dict[str, Any]:
        """
        This service is used to View the Account Scheme details
        
        Generated from: GET /virtualAccountManagement/virtualAccount/numberScheme/{numberSchemeId}/details
        Source: swagger_2_0
        Operation ID: VAET0032ViewSchemeUsingGET
        
        
        Authentication: Not required
        
        Parameters:
        - numberSchemeId: integer (required)
          Unique Reference for the Account numbering which will happen for each Bankdefined/customer Defined schema provided for account number generation
        - pageNum: integer
          pageNum
        - pageSize: integer
          pageSize
        
        
        
        Headers:
        - Accesstoken: string
          Authorization Token to validation the caller
        - ChannelType: integer
          Channel identifier from where the TXN has originated (Internet, Mobile, ATM, Branch Channel )
        - Co-Relationid: integer
          Unique ID for the service invoked, will be set by the TXN system
        - InitiatingSystem: string
          Indicating the initiated system
        - ServiceMode: integer
          Used for branch channel to indicate the type of customer
        - UUIDSeqNo: integer
          UUID Sequence Number
        - entity: string
          entity
        - referenceId: string
          Place holder for Token based authentication
        - requesthash: string
          Request payload for hash validation
        - userId: integer
          userId
        
        
        """
        
        
        # Prepare query parameters
        params = {}
        if pagenum is not None:
            params["pageNum"] = pagenum
            
        if pagesize is not None:
            params["pageSize"] = pagesize
            
        
        
        # Replace path parameters in URL
        path = "/virtualAccountManagement/virtualAccount/numberScheme/{numberSchemeId}/details"
        if numberschemeid is not None:
            path = path.replace("{numberSchemeId}", str(numberschemeid))
        
        
        # Prepare headers
        headers = {}
        if accesstoken is not None:
            headers["Accesstoken"] = str(accesstoken)
        if channeltype is not None:
            headers["ChannelType"] = str(channeltype)
        if co_relationid is not None:
            headers["Co-Relationid"] = str(co_relationid)
        if initiatingsystem is not None:
            headers["InitiatingSystem"] = str(initiatingsystem)
        if servicemode is not None:
            headers["ServiceMode"] = str(servicemode)
        if uuidseqno is not None:
            headers["UUIDSeqNo"] = str(uuidseqno)
        if entity is not None:
            headers["entity"] = str(entity)
        if referenceid is not None:
            headers["referenceId"] = str(referenceid)
        if requesthash is not None:
            headers["requesthash"] = str(requesthash)
        if userid is not None:
            headers["userId"] = str(userid)
        
        
        return await make_api_request(
            "GET", 
            path, 
            
            params=params if params else None, 
            headers=headers if headers else None
        )
    
    
    
    @mcp.tool()
    async def vabt0028_reject_account_scheme_using_post(
        numberschemeid: str,
        request_body:Dict[str, Any] ,  # RejectAccountScheme_Resource,
        accesstoken: Optional[str] = None,
        channeltype: Optional[int] = None,
        co_relationid: Optional[int] = None,
        initiatingsystem: Optional[str] = None,
        servicemode: Optional[int] = None,
        uuidseqno: Optional[int] = None,
        entity: Optional[str] = None,
        referenceid: Optional[str] = None,
        requesthash: Optional[str] = None,
        userid: Optional[int] = None
    ) -> Dict[str, Any]:
        """
        This service is used to Reject Account Scheme
        
        Generated from: POST /virtualAccountManagement/virtualAccount/numberScheme/{numberSchemeId}/reject
        Source: swagger_2_0
        Operation ID: VABT0028RejectAccountSchemeUsingPOST
        
        
        Authentication: Not required
        
        Parameters:
        - numberSchemeId: string (required)
          Path parameter numberSchemeId
        - request_body: any (required)
          input
        
        
        
        Headers:
        - Accesstoken: string
          Authorization Token to validation the caller
        - ChannelType: integer
          Channel identifier from where the TXN has originated (Internet, Mobile, ATM, Branch Channel )
        - Co-Relationid: integer
          Unique ID for the service invoked, will be set by the TXN system
        - InitiatingSystem: string
          Indicating the initiated system
        - ServiceMode: integer
          Used for branch channel to indicate the type of customer
        - UUIDSeqNo: integer
          UUID Sequence Number
        - entity: string
          entity
        - referenceId: string
          Place holder for Token based authentication
        - requesthash: string
          Request payload for hash validation
        - userId: integer
          userId
        
        
        """
        
        
        # Prepare request data
        
        # Single body parameter - send directly
        data = request_body if request_body is not None else {}
        
        
        
        # Prepare query parameters
        params = {}
        
        
        # Replace path parameters in URL
        path = "/virtualAccountManagement/virtualAccount/numberScheme/{numberSchemeId}/reject"
        if numberschemeid is not None:
            path = path.replace("{numberSchemeId}", str(numberschemeid))
        
        
        # Prepare headers
        headers = {}
        if accesstoken is not None:
            headers["Accesstoken"] = str(accesstoken)
        if channeltype is not None:
            headers["ChannelType"] = str(channeltype)
        if co_relationid is not None:
            headers["Co-Relationid"] = str(co_relationid)
        if initiatingsystem is not None:
            headers["InitiatingSystem"] = str(initiatingsystem)
        if servicemode is not None:
            headers["ServiceMode"] = str(servicemode)
        if uuidseqno is not None:
            headers["UUIDSeqNo"] = str(uuidseqno)
        if entity is not None:
            headers["entity"] = str(entity)
        if referenceid is not None:
            headers["referenceId"] = str(referenceid)
        if requesthash is not None:
            headers["requesthash"] = str(requesthash)
        if userid is not None:
            headers["userId"] = str(userid)
        
        
        return await make_api_request(
            "POST", 
            path, 
            data=data, 
            params=params if params else None, 
            headers=headers if headers else None
        )
    
    
    
    @mcp.tool()
    async def vabt0030_send_back_account_scheme_using_post(
        numberschemeid: str,
        request_body:Dict[str, Any] ,  # SendBackAccountScheme_Resource,
        accesstoken: Optional[str] = None,
        channeltype: Optional[int] = None,
        co_relationid: Optional[int] = None,
        initiatingsystem: Optional[str] = None,
        servicemode: Optional[int] = None,
        uuidseqno: Optional[int] = None,
        entity: Optional[str] = None,
        referenceid: Optional[str] = None,
        requesthash: Optional[str] = None,
        userid: Optional[int] = None
    ) -> Dict[str, Any]:
        """
        This service is used to SendBack Account Scheme 
        
        Generated from: POST /virtualAccountManagement/virtualAccount/numberScheme/{numberSchemeId}/sendback
        Source: swagger_2_0
        Operation ID: VABT0030SendBackAccountSchemeUsingPOST
        
        
        Authentication: Not required
        
        Parameters:
        - numberSchemeId: string (required)
          Path parameter numberSchemeId
        - request_body: any (required)
          input
        
        
        
        Headers:
        - Accesstoken: string
          Authorization Token to validation the caller
        - ChannelType: integer
          Channel identifier from where the TXN has originated (Internet, Mobile, ATM, Branch Channel )
        - Co-Relationid: integer
          Unique ID for the service invoked, will be set by the TXN system
        - InitiatingSystem: string
          Indicating the initiated system
        - ServiceMode: integer
          Used for branch channel to indicate the type of customer
        - UUIDSeqNo: integer
          UUID Sequence Number
        - entity: string
          entity
        - referenceId: string
          Place holder for Token based authentication
        - requesthash: string
          Request payload for hash validation
        - userId: integer
          userId
        
        
        """
        
        
        # Prepare request data
        
        # Single body parameter - send directly
        data = request_body if request_body is not None else {}
        
        
        
        # Prepare query parameters
        params = {}
        
        
        # Replace path parameters in URL
        path = "/virtualAccountManagement/virtualAccount/numberScheme/{numberSchemeId}/sendback"
        if numberschemeid is not None:
            path = path.replace("{numberSchemeId}", str(numberschemeid))
        
        
        # Prepare headers
        headers = {}
        if accesstoken is not None:
            headers["Accesstoken"] = str(accesstoken)
        if channeltype is not None:
            headers["ChannelType"] = str(channeltype)
        if co_relationid is not None:
            headers["Co-Relationid"] = str(co_relationid)
        if initiatingsystem is not None:
            headers["InitiatingSystem"] = str(initiatingsystem)
        if servicemode is not None:
            headers["ServiceMode"] = str(servicemode)
        if uuidseqno is not None:
            headers["UUIDSeqNo"] = str(uuidseqno)
        if entity is not None:
            headers["entity"] = str(entity)
        if referenceid is not None:
            headers["referenceId"] = str(referenceid)
        if requesthash is not None:
            headers["requesthash"] = str(requesthash)
        if userid is not None:
            headers["userId"] = str(userid)
        
        
        return await make_api_request(
            "POST", 
            path, 
            data=data, 
            params=params if params else None, 
            headers=headers if headers else None
        )
    
    
    
    @mcp.tool()
    async def vabt0076_maintain_virtual_acnt_postusing_post(
        request_body:Dict[str, Any] ,  # maintainVirtualAccountResource,
        accesstoken: Optional[str] = None,
        channeltype: Optional[int] = None,
        co_relationid: Optional[int] = None,
        initiatingsystem: Optional[str] = None,
        servicemode: Optional[int] = None,
        uuidseqno: Optional[int] = None,
        entity: Optional[str] = None,
        languagecode: Optional[int] = None,
        referenceid: Optional[str] = None,
        requesthash: Optional[str] = None,
        userid: Optional[int] = None
    ) -> Dict[str, Any]:
        """
        Maintain Virtual Account
        
        Generated from: POST /virtualAccountManagement/virtualAccount/unitary
        Source: swagger_2_0
        Operation ID: VABT0076MaintainVirtualAcnt_POSTUsingPOST
        
        
        Authentication: Not required
        
        Parameters:
        - request_body: any (required)
          input
        
        
        
        Headers:
        - Accesstoken: string
          Authorization Token to validation the caller
        - ChannelType: integer
          Channel identifier from where the TXN has originated (Internet, Mobile, ATM, Branch Channel )
        - Co-Relationid: integer
          Unique ID for the service invoked, will be set by the TXN system
        - InitiatingSystem: string
          Indicating the initiated system
        - ServiceMode: integer
          Used for branch channel to indicate the type of customer
        - UUIDSeqNo: integer
          UUID Sequence Number
        - entity: string
          entity
        - languageCode: integer
          languageCode
        - referenceId: string
          Place holder for Token based authentication
        - requesthash: string
          Request payload for hash validation
        - userId: integer
          userId
        
        
        """
        
        
        # Prepare request data
        
        # Single body parameter - send directly
        data = request_body if request_body is not None else {}
        
        
        
        # Prepare query parameters
        params = {}
        
        
        # Replace path parameters in URL
        path = "/virtualAccountManagement/virtualAccount/unitary"
        
        
        # Prepare headers
        headers = {}
        if accesstoken is not None:
            headers["Accesstoken"] = str(accesstoken)
        if channeltype is not None:
            headers["ChannelType"] = str(channeltype)
        if co_relationid is not None:
            headers["Co-Relationid"] = str(co_relationid)
        if initiatingsystem is not None:
            headers["InitiatingSystem"] = str(initiatingsystem)
        if servicemode is not None:
            headers["ServiceMode"] = str(servicemode)
        if uuidseqno is not None:
            headers["UUIDSeqNo"] = str(uuidseqno)
        if entity is not None:
            headers["entity"] = str(entity)
        if languagecode is not None:
            headers["languageCode"] = str(languagecode)
        if referenceid is not None:
            headers["referenceId"] = str(referenceid)
        if requesthash is not None:
            headers["requesthash"] = str(requesthash)
        if userid is not None:
            headers["userId"] = str(userid)
        
        
        return await make_api_request(
            "POST", 
            path, 
            data=data, 
            params=params if params else None, 
            headers=headers if headers else None
        )
    
    
    
    @mcp.tool()
    async def vaetvalidate_account_postusing_get(
        accountreference: str,
        transactioncurrency: str,
        transactionamount: Optional[str] = None,
        accesstoken: Optional[str] = None,
        channeltype: Optional[int] = None,
        co_relationid: Optional[int] = None,
        initiatingsystem: Optional[str] = None,
        servicemode: Optional[int] = None,
        uuidseqno: Optional[int] = None,
        entity: Optional[str] = None,
        languagecode: Optional[int] = None,
        referenceid: Optional[str] = None,
        userid: Optional[int] = None
    ) -> Dict[str, Any]:
        """
        This service is used to validate virtual account
        
        Generated from: GET /virtualAccountManagement/virtualAccount/validate
        Source: swagger_2_0
        Operation ID: VAETValidateAccount_POSTUsingGET
        
        
        Authentication: Not required
        
        Parameters:
        - accountReference: string (required)
          Account Number Received from External System in this Field will be validated against VAM Accounts
        - transactionAmount: string
          Transaction Amount received here will be used in Validation against VRN Usage Virtual Account
        - transactionCurrency: string (required)
          Currency of the Account Reference received will be validated against the Currency of Virtual Account existing(1-SAR,2-USD,3-EUR,4-INR,5-CHF,6-GBP,7-AUD,8-SEK Code name: d_VA_Currency_Code)
        
        
        
        Headers:
        - Accesstoken: string
          Authorization Token to validation the caller
        - ChannelType: integer
          Channel identifier from where the Transaction has originated (Internet, Mobile, ATM, Branch Channel )
        - Co-Relationid: integer
          Unique ID for the service invoked, will be set by the Transaction system
        - InitiatingSystem: string
          Indicating the initiated system
        - ServiceMode: integer
          Used for branch channel to indicate the type of customer
        - UUIDSeqNo: integer
          UUID Sequence Number
        - entity: string
          entity
        - languageCode: integer
          languageCode
        - referenceId: string
          Place holder for Token based authentication
        - userId: integer
          userId
        
        
        """
        
        
        # Prepare query parameters
        params = {}
        if accountreference is not None:
            params["accountReference"] = accountreference
            
        if transactionamount is not None:
            params["transactionAmount"] = transactionamount
            
        if transactioncurrency is not None:
            params["transactionCurrency"] = transactioncurrency
            
        
        
        # Replace path parameters in URL
        path = "/virtualAccountManagement/virtualAccount/validate"
        
        
        # Prepare headers
        headers = {}
        if accesstoken is not None:
            headers["Accesstoken"] = str(accesstoken)
        if channeltype is not None:
            headers["ChannelType"] = str(channeltype)
        if co_relationid is not None:
            headers["Co-Relationid"] = str(co_relationid)
        if initiatingsystem is not None:
            headers["InitiatingSystem"] = str(initiatingsystem)
        if servicemode is not None:
            headers["ServiceMode"] = str(servicemode)
        if uuidseqno is not None:
            headers["UUIDSeqNo"] = str(uuidseqno)
        if entity is not None:
            headers["entity"] = str(entity)
        if languagecode is not None:
            headers["languageCode"] = str(languagecode)
        if referenceid is not None:
            headers["referenceId"] = str(referenceid)
        if userid is not None:
            headers["userId"] = str(userid)
        
        
        return await make_api_request(
            "GET", 
            path, 
            
            params=params if params else None, 
            headers=headers if headers else None
        )
    
    
    
    @mcp.tool()
    async def vabt0043_authorise_virtual_account_using_post(
        virtualaccountnumber: str,
        request_body:Dict[str, Any] ,  # AuthorizeVirtualAccount_Resource,
        accesstoken: Optional[str] = None,
        channeltype: Optional[int] = None,
        co_relationid: Optional[int] = None,
        initiatingsystem: Optional[str] = None,
        servicemode: Optional[int] = None,
        uuidseqno: Optional[int] = None,
        entity: Optional[str] = None,
        referenceid: Optional[str] = None,
        requesthash: Optional[str] = None,
        userid: Optional[int] = None
    ) -> Dict[str, Any]:
        """
        Authorise Virtual Account
        
        Generated from: POST /virtualAccountManagement/virtualAccount/{virtualAccountNumber}/authorise
        Source: swagger_2_0
        Operation ID: VABT0043AuthoriseVirtualAccountUsingPOST
        
        
        Authentication: Not required
        
        Parameters:
        - virtualAccountNumber: string (required)
          Path parameter virtualAccountNumber
        - request_body: any (required)
          input
        
        
        
        Headers:
        - Accesstoken: string
          Authorization Token to validation the caller
        - ChannelType: integer
          Channel identifier from where the TXN has originated (Internet, Mobile, ATM, Branch Channel )
        - Co-Relationid: integer
          Unique ID for the service invoked, will be set by the TXN system
        - InitiatingSystem: string
          Indicating the initiated system
        - ServiceMode: integer
          Used for branch channel to indicate the type of customer
        - UUIDSeqNo: integer
          UUID Sequence Number
        - entity: string
          entity
        - referenceId: string
          Place holder for Token based authentication
        - requesthash: string
          Request payload for hash validation
        - userId: integer
          userId
        
        
        """
        
        
        # Prepare request data
        
        # Single body parameter - send directly
        data = request_body if request_body is not None else {}
        
        
        
        # Prepare query parameters
        params = {}
        
        
        # Replace path parameters in URL
        path = "/virtualAccountManagement/virtualAccount/{virtualAccountNumber}/authorise"
        if virtualaccountnumber is not None:
            path = path.replace("{virtualAccountNumber}", str(virtualaccountnumber))
        
        
        # Prepare headers
        headers = {}
        if accesstoken is not None:
            headers["Accesstoken"] = str(accesstoken)
        if channeltype is not None:
            headers["ChannelType"] = str(channeltype)
        if co_relationid is not None:
            headers["Co-Relationid"] = str(co_relationid)
        if initiatingsystem is not None:
            headers["InitiatingSystem"] = str(initiatingsystem)
        if servicemode is not None:
            headers["ServiceMode"] = str(servicemode)
        if uuidseqno is not None:
            headers["UUIDSeqNo"] = str(uuidseqno)
        if entity is not None:
            headers["entity"] = str(entity)
        if referenceid is not None:
            headers["referenceId"] = str(referenceid)
        if requesthash is not None:
            headers["requesthash"] = str(requesthash)
        if userid is not None:
            headers["userId"] = str(userid)
        
        
        return await make_api_request(
            "POST", 
            path, 
            data=data, 
            params=params if params else None, 
            headers=headers if headers else None
        )
    
    
    
    @mcp.tool()
    async def vabt0045_cancel_virtual_account_using_post(
        virtualaccountnumber: str,
        request_body:Dict[str, Any] ,  # CancelVirtualAccount_Resource,
        accesstoken: Optional[str] = None,
        channeltype: Optional[int] = None,
        co_relationid: Optional[int] = None,
        initiatingsystem: Optional[str] = None,
        servicemode: Optional[int] = None,
        uuidseqno: Optional[int] = None,
        entity: Optional[str] = None,
        referenceid: Optional[str] = None,
        requesthash: Optional[str] = None,
        userid: Optional[int] = None
    ) -> Dict[str, Any]:
        """
        Cancel Virtual Account
        
        Generated from: POST /virtualAccountManagement/virtualAccount/{virtualAccountNumber}/cancel
        Source: swagger_2_0
        Operation ID: VABT0045CancelVirtualAccountUsingPOST
        
        
        Authentication: Not required
        
        Parameters:
        - virtualAccountNumber: string (required)
          Path parameter virtualAccountNumber
        - request_body: any (required)
          input
        
        
        
        Headers:
        - Accesstoken: string
          Authorization Token to validation the caller
        - ChannelType: integer
          Channel identifier from where the TXN has originated (Internet, Mobile, ATM, Branch Channel )
        - Co-Relationid: integer
          Unique ID for the service invoked, will be set by the TXN system
        - InitiatingSystem: string
          Indicating the initiated system
        - ServiceMode: integer
          Used for branch channel to indicate the type of customer
        - UUIDSeqNo: integer
          UUID Sequence Number
        - entity: string
          entity
        - referenceId: string
          Place holder for Token based authentication
        - requesthash: string
          Request payload for hash validation
        - userId: integer
          userId
        
        
        """
        
        
        # Prepare request data
        
        # Single body parameter - send directly
        data = request_body if request_body is not None else {}
        
        
        
        # Prepare query parameters
        params = {}
        
        
        # Replace path parameters in URL
        path = "/virtualAccountManagement/virtualAccount/{virtualAccountNumber}/cancel"
        if virtualaccountnumber is not None:
            path = path.replace("{virtualAccountNumber}", str(virtualaccountnumber))
        
        
        # Prepare headers
        headers = {}
        if accesstoken is not None:
            headers["Accesstoken"] = str(accesstoken)
        if channeltype is not None:
            headers["ChannelType"] = str(channeltype)
        if co_relationid is not None:
            headers["Co-Relationid"] = str(co_relationid)
        if initiatingsystem is not None:
            headers["InitiatingSystem"] = str(initiatingsystem)
        if servicemode is not None:
            headers["ServiceMode"] = str(servicemode)
        if uuidseqno is not None:
            headers["UUIDSeqNo"] = str(uuidseqno)
        if entity is not None:
            headers["entity"] = str(entity)
        if referenceid is not None:
            headers["referenceId"] = str(referenceid)
        if requesthash is not None:
            headers["requesthash"] = str(requesthash)
        if userid is not None:
            headers["userId"] = str(userid)
        
        
        return await make_api_request(
            "POST", 
            path, 
            data=data, 
            params=params if params else None, 
            headers=headers if headers else None
        )
    
    
    
    @mcp.tool()
    async def vaet0047_view_virtual_account_using_get(
        virtualaccountnumber: int,
        pagenum: Optional[int] = None,
        pagesize: Optional[int] = None,
        accesstoken: Optional[str] = None,
        channeltype: Optional[int] = None,
        co_relationid: Optional[int] = None,
        initiatingsystem: Optional[str] = None,
        servicemode: Optional[int] = None,
        uuidseqno: Optional[int] = None,
        entity: Optional[str] = None,
        referenceid: Optional[str] = None,
        requesthash: Optional[str] = None,
        userid: Optional[int] = None
    ) -> Dict[str, Any]:
        """
        View Virtual Account
        
        Generated from: GET /virtualAccountManagement/virtualAccount/{virtualAccountNumber}/details
        Source: swagger_2_0
        Operation ID: VAET0047ViewVirtualAccountUsingGET
        
        
        Authentication: Not required
        
        Parameters:
        - pageNum: integer
          pageNum
        - pageSize: integer
          pageSize
        - virtualAccountNumber: integer (required)
          Enter the Virtual Account Number
        
        
        
        Headers:
        - Accesstoken: string
          Authorization Token to validation the caller
        - ChannelType: integer
          Channel identifier from where the TXN has originated (Internet, Mobile, ATM, Branch Channel )
        - Co-Relationid: integer
          Unique ID for the service invoked, will be set by the TXN system
        - InitiatingSystem: string
          Indicating the initiated system
        - ServiceMode: integer
          Used for branch channel to indicate the type of customer
        - UUIDSeqNo: integer
          UUID Sequence Number
        - entity: string
          entity
        - referenceId: string
          Place holder for Token based authentication
        - requesthash: string
          Request payload for hash validation
        - userId: integer
          userId
        
        
        """
        
        
        # Prepare query parameters
        params = {}
        if pagenum is not None:
            params["pageNum"] = pagenum
            
        if pagesize is not None:
            params["pageSize"] = pagesize
            
        
        
        # Replace path parameters in URL
        path = "/virtualAccountManagement/virtualAccount/{virtualAccountNumber}/details"
        if virtualaccountnumber is not None:
            path = path.replace("{virtualAccountNumber}", str(virtualaccountnumber))
        
        
        # Prepare headers
        headers = {}
        if accesstoken is not None:
            headers["Accesstoken"] = str(accesstoken)
        if channeltype is not None:
            headers["ChannelType"] = str(channeltype)
        if co_relationid is not None:
            headers["Co-Relationid"] = str(co_relationid)
        if initiatingsystem is not None:
            headers["InitiatingSystem"] = str(initiatingsystem)
        if servicemode is not None:
            headers["ServiceMode"] = str(servicemode)
        if uuidseqno is not None:
            headers["UUIDSeqNo"] = str(uuidseqno)
        if entity is not None:
            headers["entity"] = str(entity)
        if referenceid is not None:
            headers["referenceId"] = str(referenceid)
        if requesthash is not None:
            headers["requesthash"] = str(requesthash)
        if userid is not None:
            headers["userId"] = str(userid)
        
        
        return await make_api_request(
            "GET", 
            path, 
            
            params=params if params else None, 
            headers=headers if headers else None
        )
    
    
    
    @mcp.tool()
    async def vabt0044_reject_virtual_account_using_post(
        virtualaccountnumber: str,
        request_body:Dict[str, Any] ,  # RejectVirtualAccount_Resource,
        accesstoken: Optional[str] = None,
        channeltype: Optional[int] = None,
        co_relationid: Optional[int] = None,
        initiatingsystem: Optional[str] = None,
        servicemode: Optional[int] = None,
        uuidseqno: Optional[int] = None,
        entity: Optional[str] = None,
        referenceid: Optional[str] = None,
        requesthash: Optional[str] = None,
        userid: Optional[int] = None
    ) -> Dict[str, Any]:
        """
        Reject Virtual Account
        
        Generated from: POST /virtualAccountManagement/virtualAccount/{virtualAccountNumber}/reject
        Source: swagger_2_0
        Operation ID: VABT0044RejectVirtualAccountUsingPOST
        
        
        Authentication: Not required
        
        Parameters:
        - virtualAccountNumber: string (required)
          Path parameter virtualAccountNumber
        - request_body: any (required)
          input
        
        
        
        Headers:
        - Accesstoken: string
          Authorization Token to validation the caller
        - ChannelType: integer
          Channel identifier from where the TXN has originated (Internet, Mobile, ATM, Branch Channel )
        - Co-Relationid: integer
          Unique ID for the service invoked, will be set by the TXN system
        - InitiatingSystem: string
          Indicating the initiated system
        - ServiceMode: integer
          Used for branch channel to indicate the type of customer
        - UUIDSeqNo: integer
          UUID Sequence Number
        - entity: string
          entity
        - referenceId: string
          Place holder for Token based authentication
        - requesthash: string
          Request payload for hash validation
        - userId: integer
          userId
        
        
        """
        
        
        # Prepare request data
        
        # Single body parameter - send directly
        data = request_body if request_body is not None else {}
        
        
        
        # Prepare query parameters
        params = {}
        
        
        # Replace path parameters in URL
        path = "/virtualAccountManagement/virtualAccount/{virtualAccountNumber}/reject"
        if virtualaccountnumber is not None:
            path = path.replace("{virtualAccountNumber}", str(virtualaccountnumber))
        
        
        # Prepare headers
        headers = {}
        if accesstoken is not None:
            headers["Accesstoken"] = str(accesstoken)
        if channeltype is not None:
            headers["ChannelType"] = str(channeltype)
        if co_relationid is not None:
            headers["Co-Relationid"] = str(co_relationid)
        if initiatingsystem is not None:
            headers["InitiatingSystem"] = str(initiatingsystem)
        if servicemode is not None:
            headers["ServiceMode"] = str(servicemode)
        if uuidseqno is not None:
            headers["UUIDSeqNo"] = str(uuidseqno)
        if entity is not None:
            headers["entity"] = str(entity)
        if referenceid is not None:
            headers["referenceId"] = str(referenceid)
        if requesthash is not None:
            headers["requesthash"] = str(requesthash)
        if userid is not None:
            headers["userId"] = str(userid)
        
        
        return await make_api_request(
            "POST", 
            path, 
            data=data, 
            params=params if params else None, 
            headers=headers if headers else None
        )
    
    
    
    @mcp.tool()
    async def vabt0045_sendb_back_virtual_account_using_post(
        virtualaccountnumber: str,
        request_body:Dict[str, Any] ,  # SendbBackVirtualAccount_Resource,
        accesstoken: Optional[str] = None,
        channeltype: Optional[int] = None,
        co_relationid: Optional[int] = None,
        initiatingsystem: Optional[str] = None,
        servicemode: Optional[int] = None,
        uuidseqno: Optional[int] = None,
        entity: Optional[str] = None,
        referenceid: Optional[str] = None,
        requesthash: Optional[str] = None,
        userid: Optional[int] = None
    ) -> Dict[str, Any]:
        """
        Sendback Virtual Account
        
        Generated from: POST /virtualAccountManagement/virtualAccount/{virtualAccountNumber}/sendback
        Source: swagger_2_0
        Operation ID: VABT0045SendbBackVirtualAccountUsingPOST
        
        
        Authentication: Not required
        
        Parameters:
        - virtualAccountNumber: string (required)
          Path parameter virtualAccountNumber
        - request_body: any (required)
          input
        
        
        
        Headers:
        - Accesstoken: string
          Authorization Token to validation the caller
        - ChannelType: integer
          Channel identifier from where the TXN has originated (Internet, Mobile, ATM, Branch Channel )
        - Co-Relationid: integer
          Unique ID for the service invoked, will be set by the TXN system
        - InitiatingSystem: string
          Indicating the initiated system
        - ServiceMode: integer
          Used for branch channel to indicate the type of customer
        - UUIDSeqNo: integer
          UUID Sequence Number
        - entity: string
          entity
        - referenceId: string
          Place holder for Token based authentication
        - requesthash: string
          Request payload for hash validation
        - userId: integer
          userId
        
        
        """
        
        
        # Prepare request data
        
        # Single body parameter - send directly
        data = request_body if request_body is not None else {}
        
        
        
        # Prepare query parameters
        params = {}
        
        
        # Replace path parameters in URL
        path = "/virtualAccountManagement/virtualAccount/{virtualAccountNumber}/sendback"
        if virtualaccountnumber is not None:
            path = path.replace("{virtualAccountNumber}", str(virtualaccountnumber))
        
        
        # Prepare headers
        headers = {}
        if accesstoken is not None:
            headers["Accesstoken"] = str(accesstoken)
        if channeltype is not None:
            headers["ChannelType"] = str(channeltype)
        if co_relationid is not None:
            headers["Co-Relationid"] = str(co_relationid)
        if initiatingsystem is not None:
            headers["InitiatingSystem"] = str(initiatingsystem)
        if servicemode is not None:
            headers["ServiceMode"] = str(servicemode)
        if uuidseqno is not None:
            headers["UUIDSeqNo"] = str(uuidseqno)
        if entity is not None:
            headers["entity"] = str(entity)
        if referenceid is not None:
            headers["referenceId"] = str(referenceid)
        if requesthash is not None:
            headers["requesthash"] = str(requesthash)
        if userid is not None:
            headers["userId"] = str(userid)
        
        
        return await make_api_request(
            "POST", 
            path, 
            data=data, 
            params=params if params else None, 
            headers=headers if headers else None
        )
    
    
    
    logger.info("Registered 927 API tools")


# Tool summary for reference
TOOL_SUMMARY = {
    "total_tools": 927,
    "by_method": {
        "GET": 374,
        "POST": 410,
        "PUT": 132,
        "PATCH": 0,
        "DELETE": 11,
        "HEAD": 0,
        "OPTIONS": 0
        
    },
    "by_tag": {"AccountManagement": 73, "AssetInformation": 7, "BankStructure": 6, "CollateralManagement": 22, "COLLATERAL AUTH": 1, "Crypto": 27, "CustomerManagement": 102, "Deposits": 45, "DigitalSecurity": 4, "FinancialAccounting": 7, "InterfaceServices": 3, "LiquidityManagement": 7, "Loans": 105, "LOC": 6, "MarketInformation": 9, "PayableReceivable": 11, "Payments": 25, "PricingServices": 14, "ProductSetUp": 22, "ReferenceData": 16, "Reports": 1, "RetailServices": 46, "RiskManagement": 15, "ShareManagement": 11, "Syndication": 26, "TradeFinance": 225, "VirtualAccountManagement": 91},
    "by_source": {
        "swagger_2_0": 927
    }
}

if __name__ == "__main__":
    print("Tool Summary:")
    print(json.dumps(TOOL_SUMMARY, indent=2))